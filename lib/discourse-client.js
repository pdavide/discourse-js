(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("discourse-client", [], factory);
	else if(typeof exports === 'object')
		exports["discourse-client"] = factory();
	else
		root["discourse-client"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"discourse-client.js": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// The chunk loading function for additional chunks
/******/ 	// Since all referenced chunks are already included
/******/ 	// in this file, this function is empty here.
/******/ 	__webpack_require__.e = function requireEnsure() {
/******/ 		return Promise.resolve();
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonpdiscourse_client"] = window["webpackJsonpdiscourse_client"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/discourse.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@ungap/url-search-params/esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ungap/url-search-params/esm/index.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*! (c) Andrea Giammarchi - ISC */
var self = undefined || /* istanbul ignore next */ {};
try {
  (function (URLSearchParams, plus) {
    if (
      new URLSearchParams('q=%2B').get('q') !== plus ||
      new URLSearchParams({q: plus}).get('q') !== plus ||
      new URLSearchParams([['q', plus]]).get('q') !== plus ||
      new URLSearchParams('q=\n').toString() !== 'q=%0A' ||
      new URLSearchParams({q: ' &'}).toString() !== 'q=+%26'
    )
      throw URLSearchParams;
    self.URLSearchParams = URLSearchParams;
  }(URLSearchParams, '+'));
} catch(URLSearchParams) {
  (function (Object, String, isArray) {'use strict';
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var find = /[!'\(\)~]|%20|%00/g;
    var plus = /\+/g;
    var replace = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    var proto = {
      append: function (key, value) {
        appendTo(this._ungap, key, value);
      },
      delete: function (key) {
        delete this._ungap[key];
      },
      get: function (key) {
        return this.has(key) ? this._ungap[key][0] : null;
      },
      getAll: function (key) {
        return this.has(key) ? this._ungap[key].slice(0) : [];
      },
      has: function (key) {
        return key in this._ungap;
      },
      set: function (key, value) {
        this._ungap[key] = [String(value)];
      },
      forEach: function (callback, thisArg) {
        var self = this;
        for (var key in self._ungap)
          self._ungap[key].forEach(invoke, key);
        function invoke(value) {
          callback.call(thisArg, value, String(key), self);
        }
      },
      toJSON: function () {
        return {};
      },
      toString: function () {
        var query = [];
        for (var key in this._ungap) {
          var encoded = encode(key);
          for (var
            i = 0,
            value = this._ungap[key];
            i < value.length; i++
          ) {
            query.push(encoded + '=' + encode(value[i]));
          }
        }
        return query.join('&');
      }
    };
    for (var key in proto)
      defineProperty(URLSearchParams.prototype, key, {
        configurable: true,
        writable: true,
        value: proto[key]
      });
    self.URLSearchParams = URLSearchParams;
    function URLSearchParams(query) {
      var dict = create(null);
      defineProperty(this, '_ungap', {value: dict});
      switch (true) {
        case !query:
          break;
        case typeof query === 'string':
          if (query.charAt(0) === '?') {
            query = query.slice(1);
          }
          for (var
            pairs = query.split('&'),
            i = 0,
            length = pairs.length; i < length; i++
          ) {
            var value = pairs[i];
            var index = value.indexOf('=');
            if (-1 < index) {
              appendTo(
                dict,
                decode(value.slice(0, index)),
                decode(value.slice(index + 1))
              );
            } else if (value.length){
              appendTo(
                dict,
                decode(value),
                ''
              );
            }
          }
          break;
        case isArray(query):
          for (var
            i = 0,
            length = query.length; i < length; i++
          ) {
            var value = query[i];
            appendTo(dict, value[0], value[1]);
          }
          break;
        case 'forEach' in query:
          query.forEach(addEach, dict);
          break;
        default:
          for (var key in query)
            appendTo(dict, key, query[key]);
      }
    }

    function addEach(value, key) {
      appendTo(this, key, value);
    }
    
    function appendTo(dict, key, value) {
      var res = isArray(value) ? value.join(',') : value;
      if (key in dict)
        dict[key].push(res);
      else
        dict[key] = [res];
    }
    
    function decode(str) {
      return decodeURIComponent(str.replace(plus, ' '));
    }
    
    function encode(str) {
      return encodeURIComponent(str).replace(find, replacer);
    }

    function replacer(match) {
      return replace[match];
    }

  }(Object, String, Array.isArray));
}

(function (URLSearchParamsProto) {

  var iterable = false;
  try { iterable = !!Symbol.iterator; } catch (o_O) {}

  /* istanbul ignore else */
  if (!('forEach' in URLSearchParamsProto)) {
    URLSearchParamsProto.forEach = function forEach(callback, thisArg) {
      var self = this;
      var names = Object.create(null);
      this.toString()
          .replace(/=[\s\S]*?(?:&|$)/g, '=')
          .split('=')
          .forEach(function (name) {
            if (!name.length || name in names)
              return;
            (names[name] = self.getAll(name)).forEach(function(value) {
              callback.call(thisArg, value, name, self);
            });
          });
    };
  }

  /* istanbul ignore else */
  if (!('keys' in URLSearchParamsProto)) {
    URLSearchParamsProto.keys = function keys() {
      return iterator(this, function(value, key) { this.push(key); });
    };
  }

   /* istanbul ignore else */
  if (!('values' in URLSearchParamsProto)) {
    URLSearchParamsProto.values = function values() {
      return iterator(this, function(value, key) { this.push(value); });
    };
  }

  /* istanbul ignore else */
  if (!('entries' in URLSearchParamsProto)) {
    URLSearchParamsProto.entries = function entries() {
      return iterator(this, function(value, key) { this.push([key, value]); });
    };
  }

  /* istanbul ignore else */
  if (iterable && !(Symbol.iterator in URLSearchParamsProto)) {
    URLSearchParamsProto[Symbol.iterator] = URLSearchParamsProto.entries;
  }

  /* istanbul ignore else */
  if (!('sort' in URLSearchParamsProto)) {
    URLSearchParamsProto.sort = function sort() {
      var
        entries = this.entries(),
        entry = entries.next(),
        done = entry.done,
        keys = [],
        values = Object.create(null),
        i, key, value
      ;
      while (!done) {
        value = entry.value;
        key = value[0];
        keys.push(key);
        if (!(key in values)) {
          values[key] = [];
        }
        values[key].push(value[1]);
        entry = entries.next();
        done = entry.done;
      }
      // not the champion in efficiency
      // but these two bits just do the job
      keys.sort();
      for (i = 0; i < keys.length; i++) {
        this.delete(keys[i]);
      }
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        this.append(key, values[key].shift());
      }
    };
  }

  function iterator(self, callback) {
    var items = [];
    self.forEach(callback, items);
    return iterable ?
      items[Symbol.iterator]() :
      {
        next: function() {
          var value = items.shift();
          return {done: value === undefined, value: value};
        }
      };
  }

  /* istanbul ignore next */
  (function (Object) {
    var
      dP = Object.defineProperty,
      gOPD = Object.getOwnPropertyDescriptor,
      createSearchParamsPollute = function (search) {
        function append(name, value) {
          URLSearchParamsProto.append.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function del(name) {
          URLSearchParamsProto.delete.call(this, name);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        function set(name, value) {
          URLSearchParamsProto.set.call(this, name, value);
          name = this.toString();
          search.set.call(this._usp, name ? ('?' + name) : '');
        }
        return function (sp, value) {
          sp.append = append;
          sp.delete = del;
          sp.set = set;
          return dP(sp, '_usp', {
            configurable: true,
            writable: true,
            value: value
          });
        };
      },
      createSearchParamsCreate = function (polluteSearchParams) {
        return function (obj, sp) {
          dP(
            obj, '_searchParams', {
              configurable: true,
              writable: true,
              value: polluteSearchParams(sp, obj)
            }
          );
          return sp;
        };
      },
      updateSearchParams = function (sp) {
        var append = sp.append;
        sp.append = URLSearchParamsProto.append;
        URLSearchParams.call(sp, sp._usp.search.slice(1));
        sp.append = append;
      },
      verifySearchParams = function (obj, Class) {
        if (!(obj instanceof Class)) throw new TypeError(
          "'searchParams' accessed on an object that " +
          "does not implement interface " + Class.name
        );
      },
      upgradeClass = function (Class) {
        var
          ClassProto = Class.prototype,
          searchParams = gOPD(ClassProto, 'searchParams'),
          href = gOPD(ClassProto, 'href'),
          search = gOPD(ClassProto, 'search'),
          createSearchParams
        ;
        if (!searchParams && search && search.set) {
          createSearchParams = createSearchParamsCreate(
            createSearchParamsPollute(search)
          );
          Object.defineProperties(
            ClassProto,
            {
              href: {
                get: function () {
                  return href.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  href.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              search: {
                get: function () {
                  return search.get.call(this);
                },
                set: function (value) {
                  var sp = this._searchParams;
                  search.set.call(this, value);
                  if (sp) updateSearchParams(sp);
                }
              },
              searchParams: {
                get: function () {
                  verifySearchParams(this, Class);
                  return this._searchParams || createSearchParams(
                    this,
                    new URLSearchParams(this.search.slice(1))
                  );
                },
                set: function (sp) {
                  verifySearchParams(this, Class);
                  createSearchParams(this, sp);
                }
              }
            }
          );
        }
      }
    ;
    try {
      upgradeClass(HTMLAnchorElement);
      if (/^function|object$/.test(typeof URL) && URL.prototype)
        upgradeClass(URL);
    } catch (meh) {}
  }(Object));

}(self.URLSearchParams.prototype, Object));
/* harmony default export */ __webpack_exports__["default"] = (self.URLSearchParams);


/***/ }),

/***/ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cacheAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/* harmony import */ var _utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/isCacheLike */ "./node_modules/axios-extensions/esm/utils/isCacheLike.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */




var FIVE_MINUTES = 1000 * 60 * 5;
var CAPACITY = 100;
function cacheAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.enabledByDefault, enabledByDefault = _a === void 0 ? true : _a, _b = options.cacheFlag, cacheFlag = _b === void 0 ? 'cache' : _b, _c = options.defaultCache, defaultCache = _c === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ maxAge: FIVE_MINUTES, max: CAPACITY }) : _c;
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer, forceUpdate = config.forceUpdate;
        var useCache = (config[cacheFlag] !== void 0 && config[cacheFlag] !== null) ? config[cacheFlag] : enabledByDefault;
        if (method === 'get' && useCache) {
            // if had provide a specified cache, then use it instead
            var cache_1 = Object(_utils_isCacheLike__WEBPACK_IMPORTED_MODULE_3__["default"])(useCache) ? useCache : defaultCache;
            // build the index according to the url and params
            var index_1 = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
            var responsePromise = cache_1.get(index_1);
            if (!responsePromise || forceUpdate) {
                responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
                    var reason_1;
                    return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, adapter(config)];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                reason_1 = _a.sent();
                                cache_1.del(index_1);
                                throw reason_1;
                            case 3: return [2 /*return*/];
                        }
                    });
                }); })();
                // put the promise for the non-transformed response into cache as a placeholder
                cache_1.set(index_1, responsePromise);
                return responsePromise;
            }
            /* istanbul ignore next */
            if (process.env.LOGGER_LEVEL === 'info') {
                // eslint-disable-next-line no-console
                console.info("request cached by cache adapter: " + index_1);
            }
            return responsePromise;
        }
        return adapter(config);
    };
}
//# sourceMappingURL=cacheAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/axios-extensions/esm/index.js ***!
  \****************************************************/
/*! exports provided: Cache, cacheAdapterEnhancer, throttleAdapterEnhancer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return lru_cache__WEBPACK_IMPORTED_MODULE_0___default.a; });
/* harmony import */ var _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cacheAdapterEnhancer */ "./node_modules/axios-extensions/esm/cacheAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cacheAdapterEnhancer", function() { return _cacheAdapterEnhancer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./throttleAdapterEnhancer */ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "throttleAdapterEnhancer", function() { return _throttleAdapterEnhancer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-09-28
 */




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js":
/*!**********************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/throttleAdapterEnhancer.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return throttleAdapterEnhancer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buildSortedURL */ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js");
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-11
 */



function throttleAdapterEnhancer(adapter, options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    var _a = options.threshold, threshold = _a === void 0 ? 1000 : _a, _b = options.cache, cache = _b === void 0 ? new lru_cache__WEBPACK_IMPORTED_MODULE_1___default.a({ max: 10 }) : _b;
    var recordCacheWithRequest = function (index, config) {
        var responsePromise = (function () { return tslib__WEBPACK_IMPORTED_MODULE_0__["__awaiter"](_this, void 0, void 0, function () {
            var response, reason_1;
            return tslib__WEBPACK_IMPORTED_MODULE_0__["__generator"](this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, adapter(config)];
                    case 1:
                        response = _a.sent();
                        cache.set(index, {
                            timestamp: Date.now(),
                            value: Promise.resolve(response),
                        });
                        return [2 /*return*/, response];
                    case 2:
                        reason_1 = _a.sent();
                        cache.del(index);
                        throw reason_1;
                    case 3: return [2 /*return*/];
                }
            });
        }); })();
        cache.set(index, {
            timestamp: Date.now(),
            value: responsePromise,
        });
        return responsePromise;
    };
    return function (config) {
        var url = config.url, method = config.method, params = config.params, paramsSerializer = config.paramsSerializer;
        var index = Object(_utils_buildSortedURL__WEBPACK_IMPORTED_MODULE_2__["default"])(url, params, paramsSerializer);
        var now = Date.now();
        var cachedRecord = cache.get(index) || { timestamp: now };
        if (method === 'get') {
            if (now - cachedRecord.timestamp <= threshold) {
                var responsePromise = cachedRecord.value;
                if (responsePromise) {
                    /* istanbul ignore next */
                    if (process.env.LOGGER_LEVEL === 'info') {
                        // eslint-disable-next-line no-console
                        console.info("request cached by throttle adapter: " + index);
                    }
                    return responsePromise;
                }
            }
            return recordCacheWithRequest(index, config);
        }
        return adapter(config);
    };
}
//# sourceMappingURL=throttleAdapterEnhancer.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/buildSortedURL.js":
/*!*******************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/buildSortedURL.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return buildSortedURL; });
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios/lib/helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2017-10-12
 */

function buildSortedURL() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var builtURL = axios_lib_helpers_buildURL__WEBPACK_IMPORTED_MODULE_0___default.a.apply(void 0, args);
    var _a = builtURL.split('?'), urlPath = _a[0], queryString = _a[1];
    if (queryString) {
        var paramsPair = queryString.split('&');
        return urlPath + "?" + paramsPair.sort().join('&');
    }
    return builtURL;
}
//# sourceMappingURL=buildSortedURL.js.map

/***/ }),

/***/ "./node_modules/axios-extensions/esm/utils/isCacheLike.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios-extensions/esm/utils/isCacheLike.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isCacheLike; });
/**
 * @author Kuitos
 * @homepage https://github.com/kuitos/
 * @since 2018-03-19
 */
function isCacheLike(cache) {
    return !!(cache.set && cache.get && cache.del &&
        typeof cache.get === 'function' && typeof cache.set === 'function' && typeof cache.del === 'function');
}
//# sourceMappingURL=isCacheLike.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(/*! ./../helpers/btoa */ "./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ( true &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/btoa.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var UNSCOPABLES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('unscopables');
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  hide(ArrayPrototype, UNSCOPABLES, create(null));
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? codePointAt(S, index, true).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-view-core.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-view-core.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');
var TYPED_ARRAY_TAG = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js")('TYPED_ARRAY_TAG');

var DataView = global.DataView;
var DataViewPrototype = DataView && DataView.prototype;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var NATIVE_ARRAY_BUFFER = !!(global.ArrayBuffer && global.DataView);
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf;
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportProto = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportStatic = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    hide(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

// WebKit bug - the same parent prototype for typed arrays and data view
if (NATIVE_ARRAY_BUFFER && setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
  setPrototypeOf(DataViewPrototype, ObjectPrototype);
}

module.exports = {
  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportProto: exportProto,
  exportStatic: exportStatic,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER;
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndex = __webpack_require__(/*! ../internals/to-index */ "./node_modules/core-js/internals/to-index.js");
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var arrayFill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpackIEEE754 = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, NativeArrayBuffer[key]);
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/internals/array-copy-within.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/array-copy-within.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-fill.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-fill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativeForEach = [].forEach;
var internalForEach = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(0);

var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = SLOPPY_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return internalForEach(this, callbackfn, arguments[1]);
} : nativeForEach;


/***/ }),

/***/ "./node_modules/core-js/internals/array-from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var index = 0;
  var iteratorMethod = getIteratorMethod(O);
  var length, result, step, iterator;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    result = new C();
    for (;!(step = iterator.next()).done; index++) {
      createProperty(result, index, mapping
        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)
        : step.value
      );
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
// false -> Array#indexOf
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
// true  -> Array#includes
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-last-index-of.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/array-last-index-of.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var nativeLastIndexOf = [].lastIndexOf;

var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('lastIndexOf');

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = (NEGATIVE_ZERO || SLOPPY_METHOD) ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

module.exports = function (METHOD_NAME) {
  return !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-methods.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/array-methods.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
// 0 -> Array#forEach
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
// 1 -> Array#map
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// 2 -> Array#filter
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// 3 -> Array#some
// https://tc39.github.io/ecma262/#sec-array.prototype.some
// 4 -> Array#every
// https://tc39.github.io/ecma262/#sec-array.prototype.every
// 5 -> Array#find
// https://tc39.github.io/ecma262/#sec-array.prototype.find
// 6 -> Array#findIndex
// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
module.exports = function (TYPE, specificCreate) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = specificCreate || arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: target.push(value);       // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
module.exports = function (that, callbackfn, argumentsLength, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IndexedObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (argumentsLength < 2) while (true) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/bind-context.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/bind-context.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          hide(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    hide(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-well-known-symbol.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/wrapped-well-known-symbol */ "./node_modules/core-js/internals/wrapped-well-known-symbol.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var document = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").document;
// typeof document.createElement is 'object' in old IE
var exist = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return exist ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/enum-keys.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/enum-keys.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");

// all enumerable object keys, includes symbols
module.exports = function (it) {
  var result = objectKeys(it);
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  if (getOwnPropertySymbols) {
    var symbols = getOwnPropertySymbols(it);
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (propertyIsEnumerable.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      hide(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
    if (sham) hide(RegExp.prototype[SYMBOL], 'sham', true);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/function-to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('native-function-to-string', Function.toString);


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

module.exports = function (it) {
  var iteratorMethod = getIteratorMethod(it);
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  } return anObject(iteratorMethod.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports = typeof window == 'object' && window && window.Math == Math ? window
  : typeof self == 'object' && self && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();


/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/hide.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/hide.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js") ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/host-report-errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").document;

module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js") && !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js")('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var split = ''.split;

module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var WeakMap = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    hide(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var MATCH = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var BREAK = {};

var exports = module.exports = function (iterable, fn, that, ENTRIES, ITERATOR) {
  var boundFunction = bind(fn, that, ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, step;

  if (ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
        if (result === BREAK) return BREAK;
      } return;
    }
    iterator = iterFn.call(iterable);
  }

  while (!(step = iterator.next()).done) {
    if (callWithSafeIterationClosing(iterator, boundFunction, step.value, ENTRIES) === BREAK) return BREAK;
  }
};

exports.BREAK = BREAK;


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/microtask.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var macrotask = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !/(iPhone|iPod|iPad).*AppleWebKit/i.test(userAgent)) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Chrome 38 Symbol has incorrect toString conversion
module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-url.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/native-url.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');

module.exports = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  var url = new URL('b?e=1', 'http://a');
  var searchParams = url.searchParams;
  url.pathname = 'c%20d';
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?e=1'
    || searchParams.get('e') !== '1'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#').hash !== '#%D0%B1';
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");
var WeakMap = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/new-promise-capability.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-assign.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-assign.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var nativeAssign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !nativeAssign || __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (propertyIsEnumerable.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : nativeAssign;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var IE_PROTO = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js")('IE_PROTO');
var PROTOTYPE = 'prototype';
var Empty = function () { /* empty */ };

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

__webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js")[IE_PROTO] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var key;
  while (length > i) definePropertyModule.f(O, key = keys[i++], Properties[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var nativeDefineProperty = Object.defineProperty;

exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var hiddenKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IE_PROTO = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js")('IE_PROTO');
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");
var ObjectPrototype = Object.prototype;

module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var arrayIndexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(false);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = nativeGetOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = nativeGetOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var validateSetPrototypeOfArguments = __webpack_require__(/*! ../internals/validate-set-prototype-of-arguments */ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");

module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var correctSetter = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    correctSetter = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    validateSetPrototypeOfArguments(O, proto);
    if (correctSetter) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var Reflect = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Reflect;

// all object keys, includes non-enumerable and symbols
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/parse-float.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/parse-float.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeParseFloat = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").parseFloat;
var internalStringTrim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");
var FORCED = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;

module.exports = FORCED ? function parseFloat(str) {
  var string = internalStringTrim(String(str), 3);
  var result = nativeParseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat;


/***/ }),

/***/ "./node_modules/core-js/internals/parse-int.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/parse-int.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeParseInt = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").parseInt;
var internalStringTrim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");
var hex = /^[-+]?0[xX]/;
var FORCED = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;

module.exports = FORCED ? function parseInt(str, radix) {
  var string = internalStringTrim(String(str), 3);
  return nativeParseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : nativeParseInt;


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");


/***/ }),

/***/ "./node_modules/core-js/internals/perform.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/promise-resolve.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/internals/punycode-to-ascii.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/punycode-to-ascii.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[\u002E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        for (var k = base; /* no condition */; k += base) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) {
            break;
          }
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }
  return output.join('');
};

module.exports = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }
  return encoded.join('.');
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(nativeFunctionToString).split('toString');

__webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('inspectSource', function (it) {
  return nativeFunctionToString.call(it);
});

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else hide(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var regexpExec = __webpack_require__(/*! ./regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");

module.exports = function (key, value) {
  try {
    hide(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var C = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;
  if (DESCRIPTORS && C && !C[SPECIES]) defineProperty(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var TO_STRING_TAG = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('keys');
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.0.1',
  mode: __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js") ? 'pure' : 'global',
  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/internals/sloppy-array-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/sloppy-array-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/species-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-at.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/string-at.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
// CONVERT_TO_STRING: true  -> String#at
// CONVERT_TO_STRING: false -> String#codePointAt
module.exports = function (that, pos, CONVERT_TO_STRING) {
  var S = String(requireObjectCoercible(that));
  var position = toInteger(pos);
  var size = S.length;
  var first, second;
  if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
  first = S.charCodeAt(position);
  return first < 0xD800 || first > 0xDBFF || position + 1 === size
    || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
      ? CONVERT_TO_STRING ? S.charAt(position) : first
      : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-repeat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var whitespace = '[' + __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js") + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// 1 -> String#trimStart
// 2 -> String#trimEnd
// 3 -> String#trim
module.exports = function (string, TYPE) {
  string = String(requireObjectCoercible(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};


/***/ }),

/***/ "./node_modules/core-js/internals/task.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function (event) {
  run.call(event.data);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(bind(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(bind(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(bind(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-index.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/to-index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-offset.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-offset.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

module.exports = function (it, BYTES) {
  var offset = toInteger(it);
  if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/typed-array-constructor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-array-constructor.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js")) {
  var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
  var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
  var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(/*! ../internals/typed-arrays-constructors-requires-wrappers */ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js");
  var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
  var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
  var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
  var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
  var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
  var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
  var toIndex = __webpack_require__(/*! ../internals/to-index */ "./node_modules/core-js/internals/to-index.js");
  var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
  var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
  var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
  var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
  var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
  var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
  var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
  var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
  var typedArrayFrom = __webpack_require__(/*! ../internals/typed-array-from */ "./node_modules/core-js/internals/typed-array-from.js");
  var arrayForEach = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(0);
  var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
  var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
  var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
  var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
  var getInternalState = InternalStateModule.get;
  var setInternalState = InternalStateModule.set;
  var nativeDefineProperty = definePropertyModule.f;
  var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  var RangeError = global.RangeError;
  var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
  var DataView = ArrayBufferModule.DataView;
  var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
  var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
  var TypedArray = ArrayBufferViewCore.TypedArray;
  var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
  var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
  var isTypedArray = ArrayBufferViewCore.isTypedArray;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var WRONG_LENGTH = 'Wrong length';

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = new (aTypedArrayConstructor(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key) {
    nativeDefineProperty(it, key, { get: function () {
      return getInternalState(this)[key];
    } });
  };

  var isArrayBuffer = function (it) {
    var klass;
    return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
  };

  var isTypedArrayIndex = function (target, key) {
    return isTypedArray(target)
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };

  var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true))
      ? createPropertyDescriptor(2, target[key])
      : nativeGetOwnPropertyDescriptor(target, key);
  };

  var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true))
      && isObject(descriptor)
      && has(descriptor, 'value')
      && !has(descriptor, 'get')
      && !has(descriptor, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !descriptor.configurable
      && (!has(descriptor, 'writable') || descriptor.writable)
      && (!has(descriptor, 'enumerable') || descriptor.enumerable)
    ) {
      target[key] = descriptor.value;
      return target;
    } return nativeDefineProperty(target, key, descriptor);
  };

  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $export({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  // eslint-disable-next-line max-statements
  module.exports = function (TYPE, BYTES, wrapper, CLAMPED) {
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (that, data, typedArrayOffset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
        if (isArrayBuffer(data)) return $length !== undefined
          ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
          : typedArrayOffset !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
            : new NativeTypedArrayConstructor(data);
        if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
        return typedArrayFrom.call(TypedArrayConstructor, data);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      arrayForEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) hide(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      hide(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) hide(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $export({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      hide(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      hide(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/internals/typed-array-from.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-array-from.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var aTypedArrayConstructor = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    O = [];
    while (!(step = iterator.next()).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new */
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER_VIEWS;
var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari 11 bug
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + postfix).toString(36));
};


/***/ }),

/***/ "./node_modules/core-js/internals/user-agent.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/user-agent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),

/***/ "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

module.exports = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) {
    throw TypeError("Can't set " + String(proto) + ' as a prototype');
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js")('wks');
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var Symbol = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Symbol;
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

module.exports = function (name) {
  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]
    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/internals/wrapped-well-known-symbol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/wrapped-well-known-symbol.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.constructor.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js")[ARRAY_BUFFER];
var NativeArrayBuffer = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js")[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

__webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js")(ARRAY_BUFFER);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.slice.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.slice.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

var IS_CONCAT_SPREADABLE_SUPPORT = !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.filter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalFilter = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(2);

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return internalFilter(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: [].forEach != forEach }, { forEach: forEach });


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.index-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.index-of.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalIndexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(false);
var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : internalIndexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Array.isArray` method
// https://tc39.github.io/ecma262/#sec-array.isarray
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', stat: true }, { isArray: __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js") });


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.join.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.join.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeJoin = [].join;

var ES3_STRINGS = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js") != Object;
var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: ES3_STRINGS || SLOPPY_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalMap = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(1);

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return internalMap(this, callbackfn, arguments[1]);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var internalReduce = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js");

var SLOPPY_METHOD = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js")('reduce');

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: SLOPPY_METHOD }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return internalReduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.slice.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');
var nativeSlice = [].slice;
var max = Math.max;

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('slice');

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.splice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.splice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

var SPECIES_SUPPORT = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js")('splice');

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Array', proto: true, forced: !SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.data-view.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.data-view.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER;

// `DataView` constructor
// https://tc39.github.io/ecma262/#sec-dataview-constructor
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: !NATIVE_ARRAY_BUFFER }, {
  DataView: __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js").DataView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.now.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.now.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Date.now` method
// https://tc39.github.io/ecma262/#sec-date.now
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Date', stat: true }, {
  now: function now() {
    return new Date().getTime();
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-string.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime;

// `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js")(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.name.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.name.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.to-fixed.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.to-fixed.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
    }
  } return s;
};

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Number', proto: true, forced: nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
}) }, {
  toFixed: function toFixed(fractionDigits) {
    var x = thisNumberValue(this);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = '0';
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call('0', f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call('0', f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperty: __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FAILS_ON_PRIMITIVES = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var FAILS_ON_PRIMITIVES = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");
var ObjectPrototype = Object.prototype;

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (toString !== ObjectPrototype.toString) {
  __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js")(ObjectPrototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-float.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-float.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseFloatImplementation = __webpack_require__(/*! ../internals/parse-float */ "./node_modules/core-js/internals/parse-float.js");

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: parseFloat != parseFloatImplementation }, {
  parseFloat: parseFloatImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-int.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseIntImplementation = __webpack_require__(/*! ../internals/parse-int */ "./node_modules/core-js/internals/parse-int.js");

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: parseInt != parseIntImplementation }, {
  parseInt: parseIntImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PROMISE = 'Promise';
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;
var microtask = __webpack_require__(/*! ../internals/microtask */ "./node_modules/core-js/internals/microtask.js");
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ "./node_modules/core-js/internals/promise-resolve.js");
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ "./node_modules/core-js/internals/host-report-errors.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var SPECIES = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('species');
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = global[PROMISE];
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = global.fetch;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper;

var FORCED = isForced(PROMISE, function () {
  // correct subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var empty = function () { /* empty */ };
  var FakePromise = (promise.constructor = {})[SPECIES] = function (exec) {
    exec(empty, empty);
  };
  // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !((IS_NODE || typeof PromiseRejectionEvent == 'function')
    && (!IS_PURE || promise['finally'])
    && promise.then(empty) instanceof FakePromise
    // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0
    && userAgent.indexOf('Chrome/66') === -1);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js")(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  // wrap fetch result
  if (!IS_PURE && typeof $fetch == 'function') $export({ global: true, enumerable: true, forced: true }, {
    // eslint-disable-next-line no-unused-vars
    fetch: function fetch(input) {
      return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
    }
  });
}

$export({ global: true, wrap: true, forced: FORCED }, { Promise: PromiseConstructor });

__webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js")(PromiseConstructor, PROMISE, false, true);
__webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js")(PROMISE);

PromiseWrapper = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js")[PROMISE];

// statics
$export({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$export({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      iterate(iterable, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var MATCH = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('match');
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var getFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var FORCED = isForced('RegExp', DESCRIPTORS && (!CORRECT_NEW || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    return !thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined ? pattern
      : inheritIfRequired(CORRECT_NEW
        ? new NativeRegExp(patternIsRegExp && !flagsAreUndefined ? pattern.source : pattern, flags)
        : NativeRegExp((patternIsRegExp = pattern instanceof RegExpWrapper)
          ? pattern.source
          : pattern, patternIsRegExp && flagsAreUndefined ? getFlags.call(pattern) : flags)
      , thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var i = 0;
  while (i < keys.length) proxy(keys[i++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
__webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js")('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ target: 'RegExp', proto: true, forced: /./.exec !== regexpExec }, {
  exec: regexpExec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var flags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var TO_STRING = 'toString';
var nativeToString = /./[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js")(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? flags.call(R) : undefined);
  }, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = codePointAt(string, index, true);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.match.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.match.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@match logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'match',
  1,
  function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        if (!rx.global) return regExpExec(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regExpExec(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  }
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'replace',
  2,
  function (REPLACE, nativeReplace, maybeCallNative) {
    return [
      // `String.prototype.replace` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
        return replacer !== undefined
          ? replacer.call(searchValue, O, replaceValue)
          : nativeReplace.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        var functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = String(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;

          results.push(result);
          if (!global) break;

          var matchStr = String(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;
        for (var i = 0; i < results.length; i++) {
          result = results[i];

          var matched = String(result[0]);
          var position = max(min(toInteger(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
    function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== undefined) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return nativeReplace.call(replacement, symbols, function (match, ch) {
        var capture;
        switch (ch.charAt(0)) {
          case '$': return '$';
          case '&': return matched;
          case '`': return str.slice(0, position);
          case "'": return str.slice(tailPos);
          case '<':
            capture = namedCaptures[ch.slice(1, -1)];
            break;
          default: // \d\d?
            var n = +ch;
            if (n === 0) return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0) return match;
              if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === undefined ? '' : capture;
      });
    }
  }
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'search',
  1,
  function (SEARCH, nativeSearch, maybeCallNative) {
    return [
      // `String.prototype.search` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.search
      function search(regexp) {
        var O = requireObjectCoercible(this);
        var searcher = regexp == undefined ? undefined : regexp[SEARCH];
        return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
      },
      // `RegExp.prototype[@@search]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
      function (regexp) {
        var res = maybeCallNative(nativeSearch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        var previousLastIndex = rx.lastIndex;
        if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
        var result = regExpExec(rx, S);
        if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
        return result === null ? -1 : result.index;
      }
    ];
  }
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.split.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.split.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var callRegExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js")(
  'split',
  2,
  function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      'abbc'.split(/(b)*/)[1] == 'c' ||
      'test'.split(/(?:)/, -1).length != 4 ||
      'ab'.split(/(?:ab)*/).length != 2 ||
      '.'.split(/(.?)(.?)/).length != 4 ||
      '.'.split(/()()/).length > 1 ||
      ''.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = String(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegExp(separator)) {
          return nativeSplit.call(string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? 'i' : '') +
                    (separator.multiline ? 'm' : '') +
                    (separator.unicode ? 'u' : '') +
                    (separator.sticky ? 'y' : '');
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + 'g');
        var match, lastIndex, lastLength;
        while (match = regexpExec.call(separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !separatorCopy.test('')) output.push('');
        } else output.push(string.slice(lastLastIndex));
        return output.length > lim ? output.slice(0, lim) : output;
      };
    // Chakra, V8
    } else if ('0'.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = separator == undefined ? undefined : separator[SPLIT];
        return splitter !== undefined
          ? splitter.call(separator, O, limit)
          : internalSplit.call(String(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (regexp, limit) {
        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);
        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') +
                    (rx.multiline ? 'm' : '') +
                    (rx.unicode ? 'u' : '') +
                    (SUPPORTS_Y ? 'y' : 'g');

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.
        var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q < S.length) {
          splitter.lastIndex = SUPPORTS_Y ? q : 0;
          var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
          var e;
          if (
            z === null ||
            (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            A.push(S.slice(p, q));
            if (A.length === lim) return A;
            for (var i = 1; i <= z.length - 1; i++) {
              A.push(z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        A.push(S.slice(p));
        return A;
      }
    ];
  },
  !SUPPORTS_Y
);


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var NativeSymbol = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: true }, { Symbol: SymbolWrapper });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
__webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js")('iterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var $export = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/wrapped-well-known-symbol */ "./node_modules/core-js/internals/wrapped-well-known-symbol.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
var enumKeys = __webpack_require__(/*! ../internals/enum-keys */ "./node_modules/core-js/internals/enum-keys.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var HIDDEN = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js")('hidden');
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var SYMBOL = 'Symbol';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var $Symbol = global.Symbol;
var JSON = global.JSON;
var nativeJSONStringify = JSON && JSON.stringify;
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');
var ObjectPrototype = Object[PROTOTYPE];
var QObject = global.QObject;
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, key);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[key];
  nativeDefineProperty(it, key, D);
  if (ObjectPrototypeDescriptor && it !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, key, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = NATIVE_SYMBOL && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) nativeDefineProperty(it, HIDDEN, createPropertyDescriptor(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = nativeObjectCreate(D, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(it, key, D);
  } return nativeDefineProperty(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIndexedObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};

var $create = function create(it, P) {
  return P === undefined ? nativeObjectCreate(it) : $defineProperties(nativeObjectCreate(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = nativePropertyIsEnumerable.call(this, key = toPrimitive(key, true));
  if (this === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIndexedObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var D = nativeGetOwnPropertyDescriptor(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && !has(hiddenKeys, key)) result.push(key);
  } return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OP ? ObjectPrototypeSymbols : toIndexedObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectPrototype, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js").f = $getOwnPropertySymbols;

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

$export({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });

for (var wellKnownSymbols = objectKeys(WellKnownSymbolsStore), k = 0; wellKnownSymbols.length > k;) {
  defineWellKnownSymbol(wellKnownSymbols[k++]);
}

$export({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$export({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$export({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
JSON && $export({ target: 'JSON', stat: true, forced: !NATIVE_SYMBOL || fails(function () {
  var symbol = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  return nativeJSONStringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
}) }, {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON, args);
  }
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.copy-within.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.copy-within.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayCopyWithin = __webpack_require__(/*! ../internals/array-copy-within */ "./node_modules/core-js/internals/array-copy-within.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
ArrayBufferViewCore.exportProto('copyWithin', function copyWithin(target, start /* , end */) {
  return arrayCopyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.every.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.every.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayEvery = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(4);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
ArrayBufferViewCore.exportProto('every', function every(callbackfn /* , thisArg */) {
  return arrayEvery(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.fill.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.fill.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayFill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('fill', function fill(value /* , start, end */) {
  return arrayFill.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.filter.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.filter.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var arrayFilter = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(2);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
ArrayBufferViewCore.exportProto('filter', function filter(callbackfn /* , thisArg */) {
  var list = arrayFilter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.find-index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.find-index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayFindIndex = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(6);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
ArrayBufferViewCore.exportProto('findIndex', function findIndex(predicate /* , thisArg */) {
  return arrayFindIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.find.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.find.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayFind = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(5);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
ArrayBufferViewCore.exportProto('find', function find(predicate /* , thisArg */) {
  return arrayFind(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.for-each.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.for-each.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayForEach = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(0);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
ArrayBufferViewCore.exportProto('forEach', function forEach(callbackfn /* , thisArg */) {
  arrayForEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayIncludes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(true);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
ArrayBufferViewCore.exportProto('includes', function includes(searchElement /* , fromIndex */) {
  return arrayIncludes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayIndexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js")(false);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
ArrayBufferViewCore.exportProto('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return arrayIndexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.iterator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayIterators = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var Uint8Array = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Uint8Array;
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportProto = ArrayBufferViewCore.exportProto;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportProto('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportProto('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportProto('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportProto(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.join.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.join.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayJoin = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('join', function join(separator) {
  return arrayJoin.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.last-index-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.last-index-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayLastIndexOf = __webpack_require__(/*! ../internals/array-last-index-of */ "./node_modules/core-js/internals/array-last-index-of.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return arrayLastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

var internalTypedArrayMap = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(1, function (O, length) {
  return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
});

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
ArrayBufferViewCore.exportProto('map', function map(mapfn /* , thisArg */) {
  return internalTypedArrayMap(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reduce-right.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reduce-right.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayReduceRight = [].reduceRight;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return arrayReduceRight.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reduce.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reduce.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayReduce = [].reduce;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('reduce', function reduce(callbackfn /* , initialValue */) {
  return arrayReduce.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reverse.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reverse.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
ArrayBufferViewCore.exportProto('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = Math.floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.set.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.set.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

var FORCED = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
ArrayBufferViewCore.exportProto('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments[1], 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.slice.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.slice.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var arraySlice = [].slice;

var FORCED = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
ArrayBufferViewCore.exportProto('slice', function slice(start, end) {
  var list = arraySlice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.some.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.some.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arraySome = __webpack_require__(/*! ../internals/array-methods */ "./node_modules/core-js/internals/array-methods.js")(3);
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
ArrayBufferViewCore.exportProto('some', function some(callbackfn /* , thisArg */) {
  return arraySome(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.sort.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.sort.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arraySort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
ArrayBufferViewCore.exportProto('sort', function sort(comparefn) {
  return arraySort.call(aTypedArray(this), comparefn);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.subarray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.subarray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
ArrayBufferViewCore.exportProto('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-locale-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-locale-string.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Int8Array = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Int8Array;
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var arrayToLocaleString = [].toLocaleString;
var arraySlice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_BUG = !!Int8Array && fails(function () {
  arrayToLocaleString.call(new Int8Array(1));
});
var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
ArrayBufferViewCore.exportProto('toLocaleString', function toLocaleString() {
  return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-string.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Uint8Array = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype;
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var arrayToString = [].toString;
var arrayJoin = [].join;

if (__webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js")(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
ArrayBufferViewCore.exportProto('toString', arrayToString, (Uint8ArrayPrototype || {}).toString != arrayToString);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint16-array.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint16-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Uint16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
__webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint32-array.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint32-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Uint32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
__webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint8-array.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint8-array.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
__webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    hide(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      hide(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) hide(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        hide(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js");
var FORCED = !global.setImmediate || !global.clearImmediate;

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, bind: true, enumerable: true, forced: FORCED }, {
  setImmediate: task.set,
  clearImmediate: task.clear
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var slice = [].slice;

var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, bind: true, forced: MSIE }, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.url-search-params.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/web.url-search-params.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var hasOwn = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var ITERATOR = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js")('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;
  while (bytes) {
    result = result.replace(percentSequence(bytes--), percentDecode);
  }
  return result;
};

var find = /[!'()~]|%20/g;

var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replace[match];
};

var serialize = function (it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function (result, query) {
  if (query) {
    var attributes = query.split('&');
    var i = 0;
    var attribute, entry;
    while (i < attributes.length) {
      attribute = attributes[i++];
      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  } return result;
};

var updateSearchParams = function (query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
});

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, step, entryIterator, first, second, key;

  setInternalState(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: null,
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);
      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        while (!(step = iterator.next()).done) {
          entryIterator = getIterator(anObject(step.value));
          if (
            (first = entryIterator.next()).done ||
            (second = entryIterator.next()).done ||
            !entryIterator.next().done
          ) throw TypeError('Expected sequence with length 2');
          entries.push({ key: first.value + '', value: second.value + '' });
        }
      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({ key: name + '', value: value + '' });
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var i = 0;
    while (i < entries.length) {
      if (entries[i].key === key) entries.splice(i, 1);
      else i++;
    }
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var i = 0;
    for (; i < entries.length; i++) if (entries[i].key === key) return entries[i].value;
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var i = 0;
    for (; i < entries.length; i++) if (entries[i].key === key) result.push(entries[i].value);
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var i = 0;
    while (i < entries.length) if (entries[i++].key === key) return true;
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var i = 0;
    var entry;
    for (; i < entries.length; i++) {
      entry = entries[i];
      if (entry.key === key) {
        if (found) entries.splice(i--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) entries.push({ key: key, value: val });
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries;
    // Array#sort is not stable in some engines
    var slice = entries.slice();
    var entry, i, j;
    entries.length = 0;
    for (i = 0; i < slice.length; i++) {
      entry = slice[i];
      for (j = 0; j < i; j++) if (entries[j].key > entry.key) {
        entries.splice(j, 0, entry);
        break;
      }
      if (j === i) entries.push(entry);
    }
    if (state.updateURL) state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var i = 0;
    var entry;
    while (i < entries.length) {
      entry = entries[i++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var i = 0;
  var entry;
  while (i < entries.length) {
    entry = entries[i++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  } return result.join('&');
}, { enumerable: true });

__webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js")(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ "./node_modules/core-js/modules/web.url.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/web.url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(/*! ../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var NativeURL = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js").URL;
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");
var arrayFrom = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var codePointAt = __webpack_require__(/*! ../internals/string-at */ "./node_modules/core-js/internals/string-at.js");
var toASCII = __webpack_require__(/*! ../internals/punycode-to-ascii */ "./node_modules/core-js/internals/punycode-to-ascii.js");
var URLSearchParamsModule = __webpack_require__(/*! ../modules/web.url-search-params */ "./node_modules/core-js/modules/web.url-search-params.js");
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var pow = Math.pow;

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[a-zA-Z]/;
var ALPHANUMERIC = /[a-zA-Z0-9+\-.]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[0-9A-Fa-f]+$/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT = /\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/;
// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g;
// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE = /\u0009|\u000A|\u000D/g;
var EOF;

var parseHost = function (url, input) {
  var result, codePoints, i;
  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result;
  // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);
    for (i = 0; i < codePoints.length; i++) result += percentEncode(codePoints[i], C0ControlPercentEncodeSet);
    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function (input) {
  var parts = input.split('.');
  var partsLength, numbers, i, part, R, n, ipv4;
  if (parts[parts.length - 1] == '') {
    if (parts.length) parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (i = 0; i < partsLength; i++) {
    part = parts[i];
    if (part == '') return input;
    R = 10;
    if (part.length > 1 && part.charAt(0) == '0') {
      R = HEX_START.test(part) ? 16 : 8;
      part = part.slice(R == 8 ? 1 : 2);
    }
    if (part === '') {
      n = 0;
    } else {
      if (!(R == 10 ? DEC : R == 8 ? OCT : HEX).test(part)) return input;
      n = parseInt(part, R);
    }
    numbers.push(n);
  }
  for (i = 0; i < partsLength; i++) {
    n = numbers[i];
    if (i == partsLength - 1) {
      if (n >= pow(256, 5 - partsLength)) return null;
    } else if (n > 255) return null;
  }
  ipv4 = numbers.pop();
  for (i = 0; i < numbers.length; i++) {
    ipv4 += numbers[i] * pow(256, 3 - i);
  }
  return ipv4;
};

// eslint-disable-next-line max-statements
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var char = function () {
    return input.charAt(pointer);
  };

  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8) return;
    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!DIGIT.test(char())) return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var i = 0;
  for (; i < 8; i++) {
    if (ipv6[i] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = i;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

var serializeHost = function (host) {
  var result, i, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (i = 0; i < 4; i++) {
      result.unshift(host % 256);
      host = Math.floor(host / 256);
    } return result.join('.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (i = 0; i < 8; i++) {
      if (ignore0 && host[i] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === i) {
        result += i ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[i].toString(16);
        if (i < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (char, set) {
  var code = codePointAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function (url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function (url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function (url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0))
    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
};

var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
    string.length == 2 ||
    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

var shortenURLsPath = function (url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function (segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function (segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

// eslint-disable-next-line max-statements
var parseURL = function (url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');

  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;
        break;

      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride) {
            if (
              (isSpecial(url) != has(specialSchemes, buffer)) ||
              (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
              (url.scheme == 'file' && !url.host)
            ) return;
          }
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }
          buffer = '';
          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;
        break;

      case NO_SCHEME:
        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        } break;

      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        } break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        } break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        } break;

      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;
            else url.username += encodedCodePoints;
          }
          buffer = '';
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;
        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;
          else if (char == ']') seenBracket = false;
          buffer += char;
        } break;

      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url)) ||
          stateOverride
        ) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
            buffer = '';
          }
          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;
        break;

      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;
        else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        } break;

      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
          else url.host = base.host;
        }
        state = PATH;
        continue;

      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          } continue;
        } else buffer += char;
        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        } break;

      case PATH:
        if (
          char == EOF || char == '/' ||
          (char == '\\' && isSpecial(url)) ||
          (!stateOverride && (char == '?' || char == '#'))
        ) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }
            url.path.push(buffer);
          }
          buffer = '';
          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }
          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        } break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';
          else if (char == '#') url.query += '%23';
          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState(that, { type: 'URL' });
  var baseState, failure;
  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
    else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };
  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';
  if (host !== null) {
    output += '//';
    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }
    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';
  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function () {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function () {
  return getInternalURLState(this).username;
};

var getPassword = function () {
  return getInternalURLState(this).password;
};

var getHost = function () {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? ''
    : port === null ? serializeHost(host)
    : serializeHost(host) + ':' + port;
};

var getHostname = function () {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function () {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function () {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function () {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function () {
  return getInternalURLState(this).searchParams;
};

var getHash = function () {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function (getter, setter) {
  return { get: getter, set: setter, configurable: true, enumerable: true };
};

if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;
      else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == '') {
        url.fragment = null;
        return;
      }
      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

__webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js")(URLConstructor, 'URL');

__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/jsencrypt/bin/jsencrypt.js":
/*!*************************************************!*\
  !*** ./node_modules/jsencrypt/bin/jsencrypt.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(n) {
    return BI_RM.charAt(n);
}
//#region BIT_OPERATIONS
// (public) this & a
function op_and(x, y) {
    return x & y;
}
// (public) this | a
function op_or(x, y) {
    return x | y;
}
// (public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
// (public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) == 0) {
        ++r;
    }
    return r;
}
// return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}
//#endregion BIT_OPERATIONS

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(h) {
    var i;
    var c;
    var ret = "";
    for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
    }
    else if (i + 2 == h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
    }
    while ((ret.length & 3) > 0) {
        ret += b64pad;
    }
    return ret;
}
// convert a base64 string to hex
function b64tohex(s) {
    var ret = "";
    var i;
    var k = 0; // b64 state, 0-3
    var slop = 0;
    for (i = 0; i < s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        var v = b64map.indexOf(s.charAt(i));
        if (v < 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
        }
        else if (k == 1) {
            ret += int2char((slop << 2) | (v >> 4));
            slop = v & 0xf;
            k = 2;
        }
        else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
        }
        else {
            ret += int2char((slop << 2) | (v >> 4));
            ret += int2char(v & 0xf);
            k = 0;
        }
    }
    if (k == 1) {
        ret += int2char(slop << 2);
    }
    return ret;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

// Hex JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder;
var Hex = {
    decode: function (a) {
        var i;
        if (decoder === undefined) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r\t\u00A0\u2028\u2029";
            decoder = {};
            for (i = 0; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 4;
            }
        }
        if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
        }
        return out;
    }
};

// Base64 JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder$1;
var Base64 = {
    decode: function (a) {
        var i;
        if (decoder$1 === undefined) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r\t\u00A0\u2028\u2029";
            decoder$1 = Object.create(null);
            for (i = 0; i < 64; ++i) {
                decoder$1[b64.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder$1[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder$1[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                out[out.length] = bits & 0xFF;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
                out[out.length] = (bits >> 10);
                break;
            case 3:
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                break;
        }
        return out;
    },
    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
    unarmor: function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            }
            else if (m[2]) {
                a = m[2];
            }
            else {
                throw new Error("RegExp out of sync");
            }
        }
        return Base64.decode(a);
    }
};

// Big integer base-10 printing library
// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
var Int10 = /** @class */ (function () {
    function Int10(value) {
        this.buf = [+value || 0];
    }
    Int10.prototype.mulAdd = function (m, c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
                c = 0;
            }
            else {
                c = 0 | (t / max);
                t -= c * max;
            }
            b[i] = t;
        }
        if (c > 0) {
            b[i] = c;
        }
    };
    Int10.prototype.sub = function (c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
                t += max;
                c = 1;
            }
            else {
                c = 0;
            }
            b[i] = t;
        }
        while (b[b.length - 1] === 0) {
            b.pop();
        }
    };
    Int10.prototype.toString = function (base) {
        if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
        }
        var b = this.buf;
        var s = b[b.length - 1].toString();
        for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
        }
        return s;
    };
    Int10.prototype.valueOf = function () {
        var b = this.buf;
        var v = 0;
        for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
        }
        return v;
    };
    Int10.prototype.simplify = function () {
        var b = this.buf;
        return (b.length == 1) ? b[0] : this;
    };
    return Int10;
}());

// ASN.1 JavaScript decoder
var ellipsis = "\u2026";
var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(str, len) {
    if (str.length > len) {
        str = str.substring(0, len) + ellipsis;
    }
    return str;
}
var Stream = /** @class */ (function () {
    function Stream(enc, pos) {
        this.hexDigits = "0123456789ABCDEF";
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        }
        else {
            // enc should be an array or a binary string
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset " + pos + " on a stream of length " + this.enc.length);
        }
        return ("string" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];
    };
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i & 0xF) {
                    case 0x7:
                        s += "  ";
                        break;
                    case 0xF:
                        s += "\n";
                        break;
                    default:
                        s += " ";
                }
            }
        }
        return s;
    };
    Stream.prototype.isASCII = function (start, end) {
        for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
                return false;
            }
        }
        return true;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = "";
        for (var i = start; i < end;) {
            var c = this.get(i++);
            if (c < 128) {
                s += String.fromCharCode(c);
            }
            else if ((c > 191) && (c < 224)) {
                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
            }
            else {
                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = "";
        var hi;
        var lo;
        for (var i = start; i < end;) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode((hi << 8) | lo);
        }
        return str;
    };
    Stream.prototype.parseTime = function (start, end, shortYear) {
        var s = this.parseStringISO(start, end);
        var m = (shortYear ? reTimeS : reTimeL).exec(s);
        if (!m) {
            return "Unrecognized time: " + s;
        }
        if (shortYear) {
            // to avoid querying the timer, use the fixed range [1970, 2069]
            // it will conform with ITU X.400 [-10, +40] sliding window until 2030
            m[1] = +m[1];
            m[1] += (+m[1] < 70) ? 2000 : 1900;
        }
        s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
        if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
                s += ":" + m[6];
                if (m[7]) {
                    s += "." + m[7];
                }
            }
        }
        if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
                s += m[8];
                if (m[9]) {
                    s += ":" + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var v = this.get(start);
        var neg = (v > 127);
        var pad = neg ? 255 : 0;
        var len;
        var s = "";
        // skip unuseful bits (not allowed in DER)
        while (v == pad && ++start < end) {
            v = this.get(start);
        }
        len = end - start;
        if (len === 0) {
            return neg ? -1 : 0;
        }
        // show bit length of huge integers
        if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 0x80) == 0) {
                s = +s << 1;
                --len;
            }
            s = "(" + len + " bit)\n";
        }
        // decode the integer
        if (neg) {
            v = v - 256;
        }
        var n = new Int10(v);
        for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
        }
        return s + n.toString();
    };
    Stream.prototype.parseBitString = function (start, end, maxLength) {
        var unusedBit = this.get(start);
        var lenBit = ((end - start - 1) << 3) - unusedBit;
        var intro = "(" + lenBit + " bit)\n";
        var s = "";
        for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = (i == end - 1) ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
                s += (b >> j) & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
                return intro + stringCut(s, maxLength);
            }
        }
        return intro + s;
    };
    Stream.prototype.parseOctetString = function (start, end, maxLength) {
        if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
        }
        var len = end - start;
        var s = "(" + len + " byte)\n";
        maxLength /= 2; // we work in bytes
        if (len > maxLength) {
            end = start + maxLength;
        }
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len > maxLength) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end, maxLength) {
        var s = "";
        var n = new Int10();
        var bits = 0;
        for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 0x7F);
            bits += 7;
            if (!(v & 0x80)) { // finished
                if (s === "") {
                    n = n.simplify();
                    if (n instanceof Int10) {
                        n.sub(80);
                        s = "2." + n.toString();
                    }
                    else {
                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                        s = m + "." + (n - m * 40);
                    }
                }
                else {
                    s += "." + n.toString();
                }
                if (s.length > maxLength) {
                    return stringCut(s, maxLength);
                }
                n = new Int10();
                bits = 0;
            }
        }
        if (bits > 0) {
            s += ".incomplete";
        }
        return s;
    };
    return Stream;
}());
var ASN1 = /** @class */ (function () {
    function ASN1(stream, header, length, tag, sub) {
        if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
        }
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        switch (this.tag.tagClass) {
            case 0: // universal
                switch (this.tag.tagNumber) {
                    case 0x00:
                        return "EOC";
                    case 0x01:
                        return "BOOLEAN";
                    case 0x02:
                        return "INTEGER";
                    case 0x03:
                        return "BIT_STRING";
                    case 0x04:
                        return "OCTET_STRING";
                    case 0x05:
                        return "NULL";
                    case 0x06:
                        return "OBJECT_IDENTIFIER";
                    case 0x07:
                        return "ObjectDescriptor";
                    case 0x08:
                        return "EXTERNAL";
                    case 0x09:
                        return "REAL";
                    case 0x0A:
                        return "ENUMERATED";
                    case 0x0B:
                        return "EMBEDDED_PDV";
                    case 0x0C:
                        return "UTF8String";
                    case 0x10:
                        return "SEQUENCE";
                    case 0x11:
                        return "SET";
                    case 0x12:
                        return "NumericString";
                    case 0x13:
                        return "PrintableString"; // ASCII subset
                    case 0x14:
                        return "TeletexString"; // aka T61String
                    case 0x15:
                        return "VideotexString";
                    case 0x16:
                        return "IA5String"; // ASCII
                    case 0x17:
                        return "UTCTime";
                    case 0x18:
                        return "GeneralizedTime";
                    case 0x19:
                        return "GraphicString";
                    case 0x1A:
                        return "VisibleString"; // ASCII subset
                    case 0x1B:
                        return "GeneralString";
                    case 0x1C:
                        return "UniversalString";
                    case 0x1E:
                        return "BMPString";
                }
                return "Universal_" + this.tag.tagNumber.toString();
            case 1:
                return "Application_" + this.tag.tagNumber.toString();
            case 2:
                return "[" + this.tag.tagNumber.toString() + "]"; // Context
            case 3:
                return "Private_" + this.tag.tagNumber.toString();
        }
    };
    ASN1.prototype.content = function (maxLength) {
        if (this.tag === undefined) {
            return null;
        }
        if (maxLength === undefined) {
            maxLength = Infinity;
        }
        var content = this.posContent();
        var len = Math.abs(this.length);
        if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
        }
        switch (this.tag.tagNumber) {
            case 0x01: // BOOLEAN
                return (this.stream.get(content) === 0) ? "false" : "true";
            case 0x02: // INTEGER
                return this.stream.parseInteger(content, content + len);
            case 0x03: // BIT_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseBitString(content, content + len, maxLength);
            case 0x04: // OCTET_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseOctetString(content, content + len, maxLength);
            // case 0x05: // NULL
            case 0x06: // OBJECT_IDENTIFIER
                return this.stream.parseOID(content, content + len, maxLength);
            // case 0x07: // ObjectDescriptor
            // case 0x08: // EXTERNAL
            // case 0x09: // REAL
            // case 0x0A: // ENUMERATED
            // case 0x0B: // EMBEDDED_PDV
            case 0x10: // SEQUENCE
            case 0x11: // SET
                if (this.sub !== null) {
                    return "(" + this.sub.length + " elem)";
                }
                else {
                    return "(no elem)";
                }
            case 0x0C: // UTF8String
                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 0x12: // NumericString
            case 0x13: // PrintableString
            case 0x14: // TeletexString
            case 0x15: // VideotexString
            case 0x16: // IA5String
            // case 0x19: // GraphicString
            case 0x1A: // VisibleString
                // case 0x1B: // GeneralString
                // case 0x1C: // UniversalString
                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 0x1E: // BMPString
                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 0x17: // UTCTime
            case 0x18: // GeneralizedTime
                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? "null" : this.sub.length) + "]";
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = "";
        }
        var s = indent + this.typeName() + " @" + this.stream.pos;
        if (this.length >= 0) {
            s += "+";
        }
        s += this.length;
        if (this.tag.tagConstructed) {
            s += " (constructed)";
        }
        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {
            s += " (encapsulates)";
        }
        s += "\n";
        if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max = this.sub.length; i < max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.toHexString = function () {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get();
        var len = buf & 0x7F;
        if (len == buf) {
            return len;
        }
        // no reason to use Int10, as it would be a huge buffer anyways
        if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
        }
        if (len === 0) {
            return null;
        } // undefined
        buf = 0;
        for (var i = 0; i < len; ++i) {
            buf = (buf * 256) + stream.get();
        }
        return buf;
    };
    /**
     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
     * @returns {string}
     * @public
     */
    ASN1.prototype.getHexStringValue = function () {
        var hexString = this.toHexString();
        var offset = this.header * 2;
        var length = this.length * 2;
        return hexString.substr(offset, length);
    };
    ASN1.decode = function (str) {
        var stream;
        if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
        }
        else {
            stream = str;
        }
        var streamStart = new Stream(stream);
        var tag = new ASN1Tag(stream);
        var len = ASN1.decodeLength(stream);
        var start = stream.pos;
        var header = start - streamStart.pos;
        var sub = null;
        var getSub = function () {
            var ret = [];
            if (len !== null) {
                // definite length
                var end = start + len;
                while (stream.pos < end) {
                    ret[ret.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw new Error("Content size is not correct for container starting at offset " + start);
                }
            }
            else {
                // undefined length
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag.isEOC()) {
                            break;
                        }
                        ret[ret.length] = s;
                    }
                    len = start - stream.pos; // undefined lengths are represented as negative values
                }
                catch (e) {
                    throw new Error("Exception while decoding undefined length content: " + e);
                }
            }
            return ret;
        };
        if (tag.tagConstructed) {
            // must have valid content
            sub = getSub();
        }
        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {
            // sometimes BitString and OctetString are used to encapsulate ASN.1
            try {
                if (tag.tagNumber == 0x03) {
                    if (stream.get() != 0) {
                        throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                    }
                }
                sub = getSub();
                for (var i = 0; i < sub.length; ++i) {
                    if (sub[i].tag.isEOC()) {
                        throw new Error("EOC is not supposed to be actual content.");
                    }
                }
            }
            catch (e) {
                // but silently ignore when they don't
                sub = null;
            }
        }
        if (sub === null) {
            if (len === null) {
                throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    return ASN1;
}());
var ASN1Tag = /** @class */ (function () {
    function ASN1Tag(stream) {
        var buf = stream.get();
        this.tagClass = buf >> 6;
        this.tagConstructed = ((buf & 0x20) !== 0);
        this.tagNumber = buf & 0x1F;
        if (this.tagNumber == 0x1F) { // long tag
            var n = new Int10();
            do {
                buf = stream.get();
                n.mulAdd(128, buf & 0x7F);
            } while (buf & 0x80);
            this.tagNumber = n.simplify();
        }
    }
    ASN1Tag.prototype.isUniversal = function () {
        return this.tagClass === 0x00;
    };
    ASN1Tag.prototype.isEOC = function () {
        return this.tagClass === 0x00 && this.tagNumber === 0x00;
    };
    return ASN1Tag;
}());

// Copyright (c) 2005  Tom Wu
// Bits per digit
var dbits;
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);
//#region
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
//#endregion
// (public) Constructor
var BigInteger = /** @class */ (function () {
    function BigInteger(a, b, c) {
        if (a != null) {
            if ("number" == typeof a) {
                this.fromNumber(a, b, c);
            }
            else if (b == null && "string" != typeof a) {
                this.fromString(a, 256);
            }
            else {
                this.fromString(a, b);
            }
        }
    }
    //#region PUBLIC
    // BigInteger.prototype.toString = bnToString;
    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) {
            return "-" + this.negate().toString(b);
        }
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            return this.toRadix(b);
        }
        var km = (1 << k) - 1;
        var d;
        var m = false;
        var r = "";
        var i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
            }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if (d > 0) {
                    m = true;
                }
                if (m) {
                    r += int2char(d);
                }
            }
        }
        return m ? r : "0";
    };
    // BigInteger.prototype.negate = bnNegate;
    // (public) -this
    BigInteger.prototype.negate = function () {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
    };
    // BigInteger.prototype.abs = bnAbs;
    // (public) |this|
    BigInteger.prototype.abs = function () {
        return (this.s < 0) ? this.negate() : this;
    };
    // BigInteger.prototype.compareTo = bnCompareTo;
    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) {
            return r;
        }
        var i = this.t;
        r = i - a.t;
        if (r != 0) {
            return (this.s < 0) ? -r : r;
        }
        while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
                return r;
            }
        }
        return 0;
    };
    // BigInteger.prototype.bitLength = bnBitLength;
    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) {
            return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };
    // BigInteger.prototype.mod = bnMod;
    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
        }
        return r;
    };
    // BigInteger.prototype.modPowInt = bnModPowInt;
    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) {
            z = new Classic(m);
        }
        else {
            z = new Montgomery(m);
        }
        return this.exp(e, z);
    };
    // BigInteger.prototype.clone = bnClone;
    // (public)
    BigInteger.prototype.clone = function () {
        var r = nbi();
        this.copyTo(r);
        return r;
    };
    // BigInteger.prototype.intValue = bnIntValue;
    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) {
                return this[0] - this.DV;
            }
            else if (this.t == 0) {
                return -1;
            }
        }
        else if (this.t == 1) {
            return this[0];
        }
        else if (this.t == 0) {
            return 0;
        }
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };
    // BigInteger.prototype.byteValue = bnByteValue;
    // (public) return value as byte
    BigInteger.prototype.byteValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
    };
    // BigInteger.prototype.shortValue = bnShortValue;
    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
    };
    // BigInteger.prototype.signum = bnSigNum;
    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) {
            return -1;
        }
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
            return 0;
        }
        else {
            return 1;
        }
    };
    // BigInteger.prototype.toByteArray = bnToByteArray;
    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t;
        var r = [];
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8;
        var d;
        var k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                r[k++] = d | (this.s << (this.DB - p));
            }
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if ((d & 0x80) != 0) {
                    d |= -256;
                }
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                    ++k;
                }
                if (k > 0 || d != this.s) {
                    r[k++] = d;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.equals = function (a) {
        return (this.compareTo(a) == 0);
    };
    // BigInteger.prototype.min = bnMin;
    BigInteger.prototype.min = function (a) {
        return (this.compareTo(a) < 0) ? this : a;
    };
    // BigInteger.prototype.max = bnMax;
    BigInteger.prototype.max = function (a) {
        return (this.compareTo(a) > 0) ? this : a;
    };
    // BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.and = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
    };
    // BigInteger.prototype.or = bnOr;
    BigInteger.prototype.or = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
    };
    // BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.xor = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
    };
    // BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.andNot = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
    };
    // BigInteger.prototype.not = bnNot;
    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
        }
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };
    // BigInteger.prototype.shiftLeft = bnShiftLeft;
    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) {
            this.rShiftTo(-n, r);
        }
        else {
            this.lShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.shiftRight = bnShiftRight;
    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) {
            this.lShiftTo(-n, r);
        }
        else {
            this.rShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
                return i * this.DB + lbit(this[i]);
            }
        }
        if (this.s < 0) {
            return this.t * this.DB;
        }
        return -1;
    };
    // BigInteger.prototype.bitCount = bnBitCount;
    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0;
        var x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
        }
        return r;
    };
    // BigInteger.prototype.testBit = bnTestBit;
    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) {
            return (this.s != 0);
        }
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };
    // BigInteger.prototype.setBit = bnSetBit;
    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) {
        return this.changeBit(n, op_or);
    };
    // BigInteger.prototype.clearBit = bnClearBit;
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) {
        return this.changeBit(n, op_andnot);
    };
    // BigInteger.prototype.flipBit = bnFlipBit;
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) {
        return this.changeBit(n, op_xor);
    };
    // BigInteger.prototype.add = bnAdd;
    // (public) this + a
    BigInteger.prototype.add = function (a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
    };
    // BigInteger.prototype.subtract = bnSubtract;
    // (public) this - a
    BigInteger.prototype.subtract = function (a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
    };
    // BigInteger.prototype.multiply = bnMultiply;
    // (public) this * a
    BigInteger.prototype.multiply = function (a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
    };
    // BigInteger.prototype.divide = bnDivide;
    // (public) this / a
    BigInteger.prototype.divide = function (a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
    };
    // BigInteger.prototype.remainder = bnRemainder;
    // (public) this % a
    BigInteger.prototype.remainder = function (a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
    };
    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi();
        var r = nbi();
        this.divRemTo(a, q, r);
        return [q, r];
    };
    // BigInteger.prototype.modPow = bnModPow;
    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength();
        var k;
        var r = nbv(1);
        var z;
        if (i <= 0) {
            return r;
        }
        else if (i < 18) {
            k = 1;
        }
        else if (i < 48) {
            k = 3;
        }
        else if (i < 144) {
            k = 4;
        }
        else if (i < 768) {
            k = 5;
        }
        else {
            k = 6;
        }
        if (i < 8) {
            z = new Classic(m);
        }
        else if (m.isEven()) {
            z = new Barrett(m);
        }
        else {
            z = new Montgomery(m);
        }
        // precomputation
        var g = [];
        var n = 3;
        var k1 = k - 1;
        var km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }
        var j = e.t - 1;
        var w;
        var is1 = true;
        var r2 = nbi();
        var t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) {
                w = (e[j] >> (i - k1)) & km;
            }
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) {
                    w |= e[j - 1] >> (this.DB + i - k1);
                }
            }
            n = k;
            while ((w & 1) == 0) {
                w >>= 1;
                --n;
            }
            if ((i -= n) < 0) {
                i += this.DB;
                --j;
            }
            if (is1) { // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) {
                    z.sqrTo(r, r2);
                    z.sqrTo(r2, r);
                    n -= 2;
                }
                if (n > 0) {
                    z.sqrTo(r, r2);
                }
                else {
                    t = r;
                    r = r2;
                    r2 = t;
                }
                z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                    i = this.DB - 1;
                    --j;
                }
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.modInverse = bnModInverse;
    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) {
            return BigInteger.ZERO;
        }
        var u = m.clone();
        var v = this.clone();
        var a = nbv(1);
        var b = nbv(0);
        var c = nbv(0);
        var d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) {
                        a.addTo(this, a);
                        b.subTo(m, b);
                    }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) {
                    b.subTo(m, b);
                }
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) {
                        c.addTo(this, c);
                        d.subTo(m, d);
                    }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) {
                    d.subTo(m, d);
                }
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) {
                    a.subTo(c, a);
                }
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) {
                    c.subTo(a, c);
                }
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
        }
        if (d.compareTo(m) >= 0) {
            return d.subtract(m);
        }
        if (d.signum() < 0) {
            d.addTo(m, d);
        }
        else {
            return d;
        }
        if (d.signum() < 0) {
            return d.add(m);
        }
        else {
            return d;
        }
    };
    // BigInteger.prototype.pow = bnPow;
    // (public) this^e
    BigInteger.prototype.pow = function (e) {
        return this.exp(e, new NullExp());
    };
    // BigInteger.prototype.gcd = bnGCD;
    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            return x;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) {
            y.lShiftTo(g, y);
        }
        return y;
    };
    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i;
        var x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
                if (x[0] == lowprimes[i]) {
                    return true;
                }
            }
            return false;
        }
        if (x.isEven()) {
            return false;
        }
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
                m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
                if (m % lowprimes[i++] == 0) {
                    return false;
                }
            }
        }
        return x.millerRabin(t);
    };
    //#endregion PUBLIC
    //#region PROTECTED
    // BigInteger.prototype.copyTo = bnpCopyTo;
    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
        }
        r.t = this.t;
        r.s = this.s;
    };
    // BigInteger.prototype.fromInt = bnpFromInt;
    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) {
            this[0] = x;
        }
        else if (x < -1) {
            this[0] = x + this.DV;
        }
        else {
            this.t = 0;
        }
    };
    // BigInteger.prototype.fromString = bnpFromString;
    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 256) {
            k = 8;
            /* byte array */
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            this.fromRadix(s, b);
            return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length;
        var mi = false;
        var sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") {
                    mi = true;
                }
                continue;
            }
            mi = false;
            if (sh == 0) {
                this[this.t++] = x;
            }
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else {
                this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
                sh -= this.DB;
            }
        }
        if (k == 8 && ((+s[0]) & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) {
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
        }
        this.clamp();
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.clamp = bnpClamp;
    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
        }
    };
    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
        }
        for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r.t = this.t + n;
        r.s = this.s;
    };
    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
        }
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };
    // BigInteger.prototype.lShiftTo = bnpLShiftTo;
    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB);
        var c = (this.s << bs) & this.DM;
        for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };
    // BigInteger.prototype.rShiftTo = bnpRShiftTo;
    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
            r.t = 0;
            return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
        }
        r.t = this.t - ds;
        r.clamp();
    };
    // BigInteger.prototype.subTo = bnpSubTo;
    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) {
            r[i++] = this.DV + c;
        }
        else if (c > 0) {
            r[i++] = c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs();
        var y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        }
        r.s = 0;
        r.clamp();
        if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.squareTo = bnpSquareTo;
    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        }
        r.s = 0;
        r.clamp();
    };
    // BigInteger.prototype.divRemTo = bnpDivRemTo;
    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) {
            return;
        }
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) {
                q.fromInt(0);
            }
            if (r != null) {
                this.copyTo(r);
            }
            return;
        }
        if (r == null) {
            r = nbi();
        }
        var y = nbi();
        var ts = this.s;
        var ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
        }
        else {
            pm.copyTo(y);
            pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) {
            return;
        }
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt;
        var d2 = (1 << this.F1) / yt;
        var e = 1 << this.F2;
        var i = r.t;
        var j = i - ys;
        var t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) {
            y[y.t++] = 0;
        }
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) {
                    r.subTo(t, r);
                }
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
                BigInteger.ZERO.subTo(q, q);
            }
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) {
            r.rShiftTo(nsh, r);
        } // Denormalize remainder
        if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.invDigit = bnpInvDigit;
    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) {
            return 0;
        }
        var x = this[0];
        if ((x & 1) == 0) {
            return 0;
        }
        var y = x & 3; // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };
    // BigInteger.prototype.isEven = bnpIsEven;
    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () {
        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
    };
    // BigInteger.prototype.exp = bnpExp;
    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) {
            return BigInteger.ONE;
        }
        var r = nbi();
        var r2 = nbi();
        var g = z.convert(this);
        var i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) {
                z.mulTo(r2, g, r);
            }
            else {
                var t = r;
                r = r2;
                r2 = t;
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.chunkSize = bnpChunkSize;
    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
    };
    // BigInteger.prototype.toRadix = bnpToRadix;
    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) {
            b = 10;
        }
        if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
        }
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a);
        var y = nbi();
        var z = nbi();
        var r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };
    // BigInteger.prototype.fromRadix = bnpFromRadix;
    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) {
            b = 10;
        }
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs);
        var mi = false;
        var j = 0;
        var w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) {
                    mi = true;
                }
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.fromNumber = bnpFromNumber;
    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                } // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) {
                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i;
        var f;
        var m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
        }
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
                r[i] = op(this[i], f);
            }
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
                r[i] = op(f, a[i]);
            }
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };
    // BigInteger.prototype.changeBit = bnpChangeBit;
    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };
    // BigInteger.prototype.addTo = bnpAddTo;
    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) {
            r[i++] = c;
        }
        else if (c < -1) {
            r[i++] = this.DV + c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.dMultiply = bnpDMultiply;
    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    // BigInteger.prototype.dAddOffset = bnpDAddOffset;
    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) {
            return;
        }
        while (this.t <= w) {
            this[this.t++] = 0;
        }
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
                this[this.t++] = 0;
            }
            ++this[w];
        }
    };
    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) {
            r[--i] = 0;
        }
        for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        }
        for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
        }
        r.clamp();
    };
    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        }
        r.clamp();
        r.drShiftTo(1, r);
    };
    // BigInteger.prototype.modInt = bnpModInt;
    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) {
            return 0;
        }
        var d = this.DV % n;
        var r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0) {
            if (d == 0) {
                r = this[0] % n;
            }
            else {
                for (var i = this.t - 1; i >= 0; --i) {
                    r = (d * r + this[i]) % n;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.millerRabin = bnpMillerRabin;
    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) {
            return false;
        }
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) {
            t = lowprimes.length;
        }
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            // Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) {
                        return false;
                    }
                }
                if (y.compareTo(n1) != 0) {
                    return false;
                }
            }
        }
        return true;
    };
    // BigInteger.prototype.square = bnSquare;
    // (public) this^2
    BigInteger.prototype.square = function () {
        var r = nbi();
        this.squareTo(r);
        return r;
    };
    //#region ASYNC
    // Public API method
    BigInteger.prototype.gcda = function (a, callback) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            callback(x);
            return;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
        var gcda1 = function () {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
                if (g > 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () { callback(y); }, 0); // escape
            }
            else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    // (protected) alternate constructor
    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
        if ("number" == typeof b) {
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp_1 = this;
                var bnpfn1_1 = function () {
                    bnp_1.dAddOffset(2, 0);
                    if (bnp_1.bitLength() > a) {
                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                    }
                    if (bnp_1.isProbablePrime(b)) {
                        setTimeout(function () { callback(); }, 0); // escape
                    }
                    else {
                        setTimeout(bnpfn1_1, 0);
                    }
                };
                setTimeout(bnpfn1_1, 0);
            }
        }
        else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    return BigInteger;
}());
//#region REDUCERS
//#region NullExp
var NullExp = /** @class */ (function () {
    function NullExp() {
    }
    // NullExp.prototype.convert = nNop;
    NullExp.prototype.convert = function (x) {
        return x;
    };
    // NullExp.prototype.revert = nNop;
    NullExp.prototype.revert = function (x) {
        return x;
    };
    // NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
    };
    // NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
    };
    return NullExp;
}());
// Modular reduction using "classic" algorithm
var Classic = /** @class */ (function () {
    function Classic(m) {
        this.m = m;
    }
    // Classic.prototype.convert = cConvert;
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
        }
        else {
            return x;
        }
    };
    // Classic.prototype.revert = cRevert;
    Classic.prototype.revert = function (x) {
        return x;
    };
    // Classic.prototype.reduce = cReduce;
    Classic.prototype.reduce = function (x) {
        x.divRemTo(this.m, null, x);
    };
    // Classic.prototype.mulTo = cMulTo;
    Classic.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Classic.prototype.sqrTo = cSqrTo;
    Classic.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Classic;
}());
//#endregion
//#region Montgomery
// Montgomery reduction
var Montgomery = /** @class */ (function () {
    function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // Montgomery.prototype.convert = montConvert;
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
        }
        return r;
    };
    // Montgomery.prototype.revert = montRevert;
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // Montgomery.prototype.reduce = montReduce;
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) {
            // pad x so am has enough room later
            x[x.t++] = 0;
        }
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
            }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Montgomery.prototype.mulTo = montMulTo;
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Montgomery.prototype.sqrTo = montSqrTo;
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Montgomery;
}());
//#endregion Montgomery
//#region Barrett
// Barrett modular reduction
var Barrett = /** @class */ (function () {
    function Barrett(m) {
        this.m = m;
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
    }
    // Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
        }
        else if (x.compareTo(this.m) < 0) {
            return x;
        }
        else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    };
    // Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.revert = function (x) {
        return x;
    };
    // Barrett.prototype.reduce = barrettReduce;
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
        }
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Barrett.prototype.mulTo = barrettMulTo;
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Barrett.prototype.sqrTo = barrettSqrTo;
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Barrett;
}());
//#endregion
//#endregion REDUCERS
// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 0x4000000);
        w[j++] = v & 0x3ffffff;
    }
    return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
    var xl = x & 0x7fff;
    var xh = x >> 15;
    while (--n >= 0) {
        var l = this[i] & 0x7fff;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 0x3fffffff;
    }
    return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
    var xl = x & 0x3fff;
    var xh = x >> 14;
    while (--n >= 0) {
        var l = this[i] & 0x3fff;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 0xfffffff;
    }
    return c;
}
if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    BigInteger.prototype.am = am2;
    dbits = 30;
}
else if (j_lm && (navigator.appName != "Netscape")) {
    BigInteger.prototype.am = am1;
    dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
// Digit conversions
var BI_RC = [];
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}
// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
// returns bit length of the integer x
function nbits(x) {
    var r = 1;
    var t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// prng4.js - uses Arcfour as a PRNG
var Arcfour = /** @class */ (function () {
    function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = [];
    }
    // Arcfour.prototype.init = ARC4init;
    // Initialize arcfour context from key, an array of ints, each from [0..255]
    Arcfour.prototype.init = function (key) {
        var i;
        var j;
        var t;
        for (i = 0; i < 256; ++i) {
            this.S[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
    };
    // Arcfour.prototype.next = ARC4next;
    Arcfour.prototype.next = function () {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
    };
    return Arcfour;
}());
// Plug in your RNG constructor here
function prng_newstate() {
    return new Arcfour();
}
// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

// Random number generator - requires a PRNG backend, e.g. prng4.js
var rng_state;
var rng_pool = null;
var rng_pptr;
// Initialize the pool with junk if needed.
if (rng_pool == null) {
    rng_pool = [];
    rng_pptr = 0;
    var t = void 0;
    if (window.crypto && window.crypto.getRandomValues) {
        // Extract entropy (2048 bits) from RNG if available
        var z = new Uint32Array(256);
        window.crypto.getRandomValues(z);
        for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
        }
    }
    // Use mouse events for entropy, if we do not have enough entropy by the time
    // we need it, entropy will be generated by Math.random.
    var onMouseMoveListener_1 = function (ev) {
        this.count = this.count || 0;
        if (this.count >= 256 || rng_pptr >= rng_psize) {
            if (window.removeEventListener) {
                window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            }
            else if (window.detachEvent) {
                window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
        }
        try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            this.count += 1;
        }
        catch (e) {
            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
        }
    };
    if (window.addEventListener) {
        window.addEventListener("mousemove", onMouseMoveListener_1, false);
    }
    else if (window.attachEvent) {
        window.attachEvent("onmousemove", onMouseMoveListener_1);
    }
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_state = prng_newstate();
        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
        while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
        }
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    // TODO: allow reseeding after first request
    return rng_state.next();
}
var SecureRandom = /** @class */ (function () {
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = function (ba) {
        for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
        }
    };
    return SecureRandom;
}());

// Depends on jsbn.js and rng.js
// function linebrk(s,n) {
//   var ret = "";
//   var i = 0;
//   while(i + n < s.length) {
//     ret += s.substring(i,i+n) + "\n";
//     i += n;
//   }
//   return ret + s.substring(i,s.length);
// }
// function byte2Hex(b) {
//   if(b < 0x10)
//     return "0" + b.toString(16);
//   else
//     return b.toString(16);
// }
function pkcs1pad1(s, n) {
    if (n < s.length + 22) {
        console.error("Message too long for RSA");
        return null;
    }
    var len = n - s.length - 6;
    var filler = "";
    for (var f = 0; f < len; f += 2) {
        filler += "ff";
    }
    var m = "0001" + filler + "00" + s;
    return parseBigInt(m, 16);
}
// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
    if (n < s.length + 11) { // TODO: fix for utf-8
        console.error("Message too long for RSA");
        return null;
    }
    var ba = [];
    var i = s.length - 1;
    while (i >= 0 && n > 0) {
        var c = s.charCodeAt(i--);
        if (c < 128) { // encode using utf-8
            ba[--n] = c;
        }
        else if ((c > 127) && (c < 2048)) {
            ba[--n] = (c & 63) | 128;
            ba[--n] = (c >> 6) | 192;
        }
        else {
            ba[--n] = (c & 63) | 128;
            ba[--n] = ((c >> 6) & 63) | 128;
            ba[--n] = (c >> 12) | 224;
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = [];
    while (n > 2) { // random non-zero pad
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
// "empty" RSA key constructor
var RSAKey = /** @class */ (function () {
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }
    //#region PROTECTED
    // protected
    // RSAKey.prototype.doPublic = RSADoPublic;
    // Perform raw public operation on "x": return x^e (mod n)
    RSAKey.prototype.doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };
    // RSAKey.prototype.doPrivate = RSADoPrivate;
    // Perform raw private operation on "x": return x^d (mod n)
    RSAKey.prototype.doPrivate = function (x) {
        if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
        }
        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };
    //#endregion PROTECTED
    //#region PUBLIC
    // RSAKey.prototype.setPublic = RSASetPublic;
    // Set the public key fields N and e from hex strings
    RSAKey.prototype.setPublic = function (N, E) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
        }
        else {
            console.error("Invalid RSA public key");
        }
    };
    // RSAKey.prototype.encrypt = RSAEncrypt;
    // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
    RSAKey.prototype.encrypt = function (text) {
        var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
        if (m == null) {
            return null;
        }
        var c = this.doPublic(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    // RSAKey.prototype.setPrivate = RSASetPrivate;
    // Set the private key fields N, e, and d from hex strings
    RSAKey.prototype.setPrivate = function (N, E, D) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    // Set the private key fields N, e, d and CRT params from hex strings
    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.generate = RSAGenerate;
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generate = function (B, E) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        for (;;) {
            for (;;) {
                this.p = new BigInteger(B - qs, 1, rng);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                    break;
                }
            }
            for (;;) {
                this.q = new BigInteger(qs, 1, rng);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                    break;
                }
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                this.n = this.p.multiply(this.q);
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    };
    // RSAKey.prototype.decrypt = RSADecrypt;
    // Return the PKCS#1 RSA decryption of "ctext".
    // "ctext" is an even-length hex string and the output is a plain string.
    RSAKey.prototype.decrypt = function (ctext) {
        var c = parseBigInt(ctext, 16);
        var m = this.doPrivate(c);
        if (m == null) {
            return null;
        }
        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
    };
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generateAsync = function (B, E, callback) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        // These functions have non-descript names because they were originally for(;;) loops.
        // I don't know about cryptography to give them better names than loop1-4.
        var loop1 = function () {
            var loop4 = function () {
                if (rsa.p.compareTo(rsa.q) <= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () { callback(); }, 0); // escape
                }
                else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function () {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        }
                        else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function () {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        }
                        else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.sign = function (text, digestMethod, digestName) {
        var header = getDigestHeader(digestName);
        var digest = header + digestMethod(text).toString();
        var m = pkcs1pad1(digest, this.n.bitLength() / 4);
        if (m == null) {
            return null;
        }
        var c = this.doPrivate(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    RSAKey.prototype.verify = function (text, signature, digestMethod) {
        var c = parseBigInt(signature, 16);
        var m = this.doPublic(c);
        if (m == null) {
            return null;
        }
        var unpadded = m.toString(16).replace(/^1f+00/, "");
        var digest = removeDigestHeader(unpadded);
        return digest == digestMethod(text).toString();
    };
    return RSAKey;
}());
// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i < b.length && b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i >= b.length) {
            return null;
        }
    }
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
// https://tools.ietf.org/html/rfc3447#page-43
var DIGEST_HEADERS = {
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    ripemd160: "3021300906052b2403020105000414",
};
function getDigestHeader(name) {
    return DIGEST_HEADERS[name] || "";
}
function removeDigestHeader(str) {
    for (var name_1 in DIGEST_HEADERS) {
        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
            var header = DIGEST_HEADERS[name_1];
            var len = header.length;
            if (str.substr(0, len) == header) {
                return str.substr(len);
            }
        }
    }
    return str;
}
// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
// function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
// }
// public
// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function(subc, superc, overrides) {
        if (! superc || ! subc) {
            throw new Error("YAHOO.lang.extend failed, please check that " +
                "all dependencies are included.");
        }

        var F = function() {};
        F.prototype = superc.prototype;
        subc.prototype = new F();
        subc.prototype.constructor = subc;
        subc.superclass = superc.prototype;

        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor = superc;
        }

        if (overrides) {
            var i;
            for (i in overrides) {
                subc.prototype[i] = overrides[i];
            }

            /*
             * IE will not enumerate native functions in a derived object even if the
             * function was overridden.  This is a workaround for specific functions
             * we care about on the Object prototype.
             * @property _IEEnumFix
             * @param {Function} r  the object to receive the augmentation
             * @param {Function} s  the object that supplies the properties to augment
             * @static
             * @private
             */
            var _IEEnumFix = function() {},
                ADD = ["toString", "valueOf"];
            try {
                if (/MSIE/.test(navigator.userAgent)) {
                    _IEEnumFix = function(r, s) {
                        for (i = 0; i < ADD.length; i = i + 1) {
                            var fname = ADD[i], f = s[fname];
                            if (typeof f === 'function' && f != Object.prototype[fname]) {
                                r[fname] = f;
                            }
                        }
                    };
                }
            } catch (ex) {}            _IEEnumFix(subc.prototype, overrides);
        }
    }
};

/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */

/**
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
 * class and utilities</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
var KJUR = {};

/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to
 * org.bouncycastle.asn1 package of
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace.
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};

/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function() {
    this.integerToByteHex = function(i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1) h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function(bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            } else {
                if (! h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        } else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            } else {
                if (! h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function(dataHex, pemHeader) {
        return hextopem(dataHex, pemHeader);
    };

    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - DERBoolean</li>
     * <li>'int' - DERInteger</li>
     * <li>'bitstr' - DERBitString</li>
     * <li>'octstr' - DEROctetString</li>
     * <li>'null' - DERNull</li>
     * <li>'oid' - DERObjectIdentifier</li>
     * <li>'enum' - DEREnumerated</li>
     * <li>'utf8str' - DERUTF8String</li>
     * <li>'numstr' - DERNumericString</li>
     * <li>'prnstr' - DERPrintableString</li>
     * <li>'telstr' - DERTeletexString</li>
     * <li>'ia5str' - DERIA5String</li>
     * <li>'utctime' - DERUTCTime</li>
     * <li>'gentime' - DERGeneralizedTime</li>
     * <li>'seq' - DERSequence</li>
     * <li>'set' - DERSet</li>
     * <li>'tag' - DERTaggedObject</li>
     * </ul>
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1',
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3},
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function(param) {
        var _KJUR = KJUR,
            _KJUR_asn1 = _KJUR.asn1,
            _DERBoolean = _KJUR_asn1.DERBoolean,
            _DERInteger = _KJUR_asn1.DERInteger,
            _DERBitString = _KJUR_asn1.DERBitString,
            _DEROctetString = _KJUR_asn1.DEROctetString,
            _DERNull = _KJUR_asn1.DERNull,
            _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier,
            _DEREnumerated = _KJUR_asn1.DEREnumerated,
            _DERUTF8String = _KJUR_asn1.DERUTF8String,
            _DERNumericString = _KJUR_asn1.DERNumericString,
            _DERPrintableString = _KJUR_asn1.DERPrintableString,
            _DERTeletexString = _KJUR_asn1.DERTeletexString,
            _DERIA5String = _KJUR_asn1.DERIA5String,
            _DERUTCTime = _KJUR_asn1.DERUTCTime,
            _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime,
            _DERSequence = _KJUR_asn1.DERSequence,
            _DERSet = _KJUR_asn1.DERSet,
            _DERTaggedObject = _KJUR_asn1.DERTaggedObject,
            _newObject = _KJUR_asn1.ASN1Util.newObject;

        var keys = Object.keys(param);
        if (keys.length != 1)
            throw "key of param shall be only one.";
        var key = keys[0];

        if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw "undefined key: " + key;

        if (key == "bool")    return new _DERBoolean(param[key]);
        if (key == "int")     return new _DERInteger(param[key]);
        if (key == "bitstr")  return new _DERBitString(param[key]);
        if (key == "octstr")  return new _DEROctetString(param[key]);
        if (key == "null")    return new _DERNull(param[key]);
        if (key == "oid")     return new _DERObjectIdentifier(param[key]);
        if (key == "enum")    return new _DEREnumerated(param[key]);
        if (key == "utf8str") return new _DERUTF8String(param[key]);
        if (key == "numstr")  return new _DERNumericString(param[key]);
        if (key == "prnstr")  return new _DERPrintableString(param[key]);
        if (key == "telstr")  return new _DERTeletexString(param[key]);
        if (key == "ia5str")  return new _DERIA5String(param[key]);
        if (key == "utctime") return new _DERUTCTime(param[key]);
        if (key == "gentime") return new _DERGeneralizedTime(param[key]);

        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({'array': a});
        }

        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({'array': a});
        }

        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({tag: tagParam[0],
                    explicit: tagParam[1],
                    obj: obj});
            } else {
                var newParam = {};
                if (tagParam.explicit !== undefined)
                    newParam.explicit = tagParam.explicit;
                if (tagParam.tag !== undefined)
                    newParam.tag = tagParam.tag;
                if (tagParam.obj === undefined)
                    throw "obj shall be specified for 'tag'.";
                newParam.obj = _newObject(tagParam.obj);
                return new _DERTaggedObject(newParam);
            }
        }
    };

    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'});
     */
    this.jsonToASN1HEX = function(param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.getEncodedHex();
    };
};

/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function(hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;

    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
        var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(- 8);
        binbuf = binbuf + bin.substr(1, 7);
        if (bin.substr(0, 1) == "0") {
            var bi = new BigInteger(binbuf, 2);
            s = s + "." + bi.toString(10);
            binbuf = "";
        }
    }
    return s;
};

/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function(oidString) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };

    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    if (! oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};


// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************

// ********************************************************************

/**
 * base class for ASN.1 DER encoder object
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 * @description
 */
KJUR.asn1.ASN1Object = function() {
    var hV = '';

    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function() {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw "this.hV is null or undefined.";
        }
        if (this.hV.length % 2 == 1) {
            throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        } else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };

    /**
     * get hexadecimal string of ASN.1 TLV bytes
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     */
    this.getEncodedHex = function() {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };

    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function() {
        this.getEncodedHex();
        return this.hV;
    };

    this.getFreshValueHex = function() {
        return '';
    };
};

// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };

    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        } else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        } else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================

// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractTime = function(params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);

    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function(d) {
        utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };

    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function(dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc') year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };

    this.zeroPadding = function(s, len) {
        if (s.length >= len) return s;
        return new Array(len - s.length + 1).join('0') + s;
    };

    // --- PUBLIC METHODS --------------------
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     */
    this.getString = function() {
        return this.s;
    };

    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     */
    this.setString = function(newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(newS);
    };

    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function(year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================

// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function(params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);

    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function(asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };

    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function(asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };

    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);


// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************

// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERBoolean = function() {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function(params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['bigint'] != "undefined") {
            this.setByBigInteger(params['bigint']);
        } else if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DERBitString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = "00" + o.getEncodedHex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";

    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function(newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };

    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function(unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };

    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of
     * 'binaryValue'. <br/>
     * NOTE: Trailing zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray("01011");
     */
    this.setByBinaryString = function(binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8) unusedBits = 0;
        for (var i = 0; i <= unusedBits; i++) {
            binaryString += '0';
        }
        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1) x = '0' + x;
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };

    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function(booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            } else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };

    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function(nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        } else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        } else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DEROctetString = function(params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = o.getEncodedHex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function() {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERObjectIdentifier = function(params) {
    var itox = function(i) {
        var h = i.toString(16);
        if (h.length == 1) h = '0' + h;
        return h;
    };
    var roidtox = function(roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++) bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };

    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";

    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function(newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };

    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function(oidString) {
        if (! oidString.match(/^[0-9.]+$/)) {
            throw "malformed oid string: " + oidString;
        }
        var h = '';
        var a = oidString.split('.');
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };

    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function(oidName) {
        var oid = KJUR.asn1.x509.OID.name2oid(oidName);
        if (oid !== '') {
            this.setValueOidString(oid);
        } else {
            throw "DERObjectIdentifier oidName undefined: " + oidName;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (params !== undefined) {
        if (typeof params === "string") {
            if (params.match(/^[0-2].[0-9.]+$/)) {
                this.setValueOidString(params);
            } else {
                this.setValueName(params);
            }
        } else if (params.oid !== undefined) {
            this.setValueOidString(params.oid);
        } else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        } else if (params.name !== undefined) {
            this.setValueName(params.name);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function(params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";

    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function(bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };

    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function(intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };

    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function(newHexString) {
        this.hV = newHexString;
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        } else if (typeof params == "number") {
            this.setByInteger(params);
        } else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);

// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function(params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function(params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function(params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function(params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function(params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);

// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * <h4>EXAMPLES</h4>
 * @example
 * d1 = new KJUR.asn1.DERUTCTime();
 * d1.setString('130430125959Z');
 *
 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
 */
KJUR.asn1.DERUTCTime = function(params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";

    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERUTCTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31"));
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'utc');
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'utc');
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
 */
KJUR.asn1.DERGeneralizedTime = function(params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.withMillis = false;

    /**
     * set value by a Date object
     * @name setByDate
     * @memberOf KJUR.asn1.DERGeneralizedTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * When you specify UTC time, use 'Date.UTC' method like this:<br/>
     * o1 = new DERUTCTime();
     * o1.setByDate(date);
     *
     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
     */
    this.setByDate = function(dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'gen', this.withMillis);
        this.hV = stohex(this.s);
    };

    this.getFreshValueHex = function() {
        if (this.date === undefined && this.s === undefined) {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'gen', this.withMillis);
            this.hV = stohex(this.s);
        }
        return this.hV;
    };

    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        } else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
            this.setString(params);
        } else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        } else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
        if (params.millis === true) {
            this.withMillis = true;
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);

// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function(params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function() {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function(params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function() {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        if (this.sortFlag == true) a.sort();
        this.hV = a.join('');
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);

// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump,
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>explicit - specify true if this is explicit tag otherwise false
 *     (default is 'true').</li>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>obj - specify ASN1Object which is tagged</li>
 * </ul>
 * @example
 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.getEncodedHex();
 */
KJUR.asn1.DERTaggedObject = function(params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;

    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     */
    this.setASN1Object = function(isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        } else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };

    this.getFreshValueHex = function() {
        return this.hV;
    };

    if (typeof params != "undefined") {
        if (typeof params['tag'] != "undefined") {
            this.hT = params['tag'];
        }
        if (typeof params['explicit'] != "undefined") {
            this.isExplicit = params['explicit'];
        }
        if (typeof params['obj'] != "undefined") {
            this.asn1Object = params['obj'];
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

/**
 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
 * This object is just a decorator for parsing the key parameter
 * @param {string|Object} key - The key in string format, or an object containing
 * the parameters needed to build a RSAKey object.
 * @constructor
 */
var JSEncryptRSAKey = /** @class */ (function (_super) {
    __extends(JSEncryptRSAKey, _super);
    function JSEncryptRSAKey(key) {
        var _this = _super.call(this) || this;
        // Call the super constructor.
        //  RSAKey.call(this);
        // If a key key was provided.
        if (key) {
            // If this is a string...
            if (typeof key === "string") {
                _this.parseKey(key);
            }
            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||
                JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                // Set the values for the key.
                _this.parsePropertiesFrom(key);
            }
        }
        return _this;
    }
    /**
     * Method to parse a pem encoded string containing both a public or private key.
     * The method will translate the pem encoded string in a der encoded string and
     * will parse private key and public key parameters. This method accepts public key
     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
     *
     * @todo Check how many rsa formats use the same format of pkcs #1.
     *
     * The format is defined as:
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * it's possible to examine the structure of the keys obtained from openssl using
     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
     * @private
     */
    JSEncryptRSAKey.prototype.parseKey = function (pem) {
        try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            // Fixes a bug with OpenSSL 1.0+ private keys
            if (asn1.sub.length === 3) {
                asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
                // Parse the private key.
                modulus = asn1.sub[1].getHexStringValue(); // bigint
                this.n = parseBigInt(modulus, 16);
                public_exponent = asn1.sub[2].getHexStringValue(); // int
                this.e = parseInt(public_exponent, 16);
                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                this.d = parseBigInt(private_exponent, 16);
                var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                this.p = parseBigInt(prime1, 16);
                var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                this.q = parseBigInt(prime2, 16);
                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                this.dmp1 = parseBigInt(exponent1, 16);
                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                this.dmq1 = parseBigInt(exponent2, 16);
                var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                this.coeff = parseBigInt(coefficient, 16);
            }
            else if (asn1.sub.length === 2) {
                // Parse the public key.
                var bit_string = asn1.sub[1];
                var sequence = bit_string.sub[0];
                modulus = sequence.sub[0].getHexStringValue();
                this.n = parseBigInt(modulus, 16);
                public_exponent = sequence.sub[1].getHexStringValue();
                this.e = parseInt(public_exponent, 16);
            }
            else {
                return false;
            }
            return true;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa key.
     *
     * The translation follow the ASN.1 notation :
     * RSAPrivateKey ::= SEQUENCE {
     *   version           Version,
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER,  -- e
     *   privateExponent   INTEGER,  -- d
     *   prime1            INTEGER,  -- p
     *   prime2            INTEGER,  -- q
     *   exponent1         INTEGER,  -- d mod (p1)
     *   exponent2         INTEGER,  -- d mod (q-1)
     *   coefficient       INTEGER,  -- (inverse of q) mod p
     * }
     * @returns {string}  DER Encoded String representing the rsa private key
     * @private
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
        var options = {
            array: [
                new KJUR.asn1.DERInteger({ int: 0 }),
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
                new KJUR.asn1.DERInteger({ bigint: this.d }),
                new KJUR.asn1.DERInteger({ bigint: this.p }),
                new KJUR.asn1.DERInteger({ bigint: this.q }),
                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
                new KJUR.asn1.DERInteger({ bigint: this.coeff })
            ]
        };
        var seq = new KJUR.asn1.DERSequence(options);
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
        return hex2b64(this.getPrivateBaseKey());
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa public key.
     * The representation follow the ASN.1 notation :
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * @returns {string} DER Encoded String representing the rsa public key
     * @private
     */
    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
        var first_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
                new KJUR.asn1.DERNull()
            ]
        });
        var second_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e })
            ]
        });
        var bit_string = new KJUR.asn1.DERBitString({
            hex: "00" + second_sequence.getEncodedHex()
        });
        var seq = new KJUR.asn1.DERSequence({
            array: [
                first_sequence,
                bit_string
            ]
        });
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
        return hex2b64(this.getPublicBaseKey());
    };
    /**
     * wrap the string in block of width chars. The default value for rsa keys is 64
     * characters.
     * @param {string} str the pem encoded string without header and footer
     * @param {Number} [width=64] - the length the string has to be wrapped at
     * @returns {string}
     * @private
     */
    JSEncryptRSAKey.wordwrap = function (str, width) {
        width = width || 64;
        if (!str) {
            return str;
        }
        var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
        return str.match(RegExp(regex, "g")).join("\n");
    };
    /**
     * Retrieve the pem encoded private key
     * @returns {string} the pem encoded private key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateKey = function () {
        var key = "-----BEGIN RSA PRIVATE KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
        key += "-----END RSA PRIVATE KEY-----";
        return key;
    };
    /**
     * Retrieve the pem encoded public key
     * @returns {string} the pem encoded public key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicKey = function () {
        var key = "-----BEGIN PUBLIC KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
        key += "-----END PUBLIC KEY-----";
        return key;
    };
    /**
     * Check if the object contains the necessary parameters to populate the rsa modulus
     * and public exponent parameters.
     * @param {Object} [obj={}] - An object that may contain the two public key
     * parameters
     * @returns {boolean} true if the object contains both the modulus and the public exponent
     * properties (n and e)
     * @todo check for types of n and e. N should be a parseable bigInt object, E should
     * be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e"));
    };
    /**
     * Check if the object contains ALL the parameters of an RSA key.
     * @param {Object} [obj={}] - An object that may contain nine rsa key
     * parameters
     * @returns {boolean} true if the object contains all the parameters needed
     * @todo check for types of the parameters all the parameters but the public exponent
     * should be parseable bigint objects, the public exponent should be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e") &&
            obj.hasOwnProperty("d") &&
            obj.hasOwnProperty("p") &&
            obj.hasOwnProperty("q") &&
            obj.hasOwnProperty("dmp1") &&
            obj.hasOwnProperty("dmq1") &&
            obj.hasOwnProperty("coeff"));
    };
    /**
     * Parse the properties of obj in the current rsa object. Obj should AT LEAST
     * include the modulus and public exponent (n, e) parameters.
     * @param {Object} obj - the object containing rsa parameters
     * @private
     */
    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
        this.n = obj.n;
        this.e = obj.e;
        if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
        }
    };
    return JSEncryptRSAKey;
}(RSAKey));

/**
 *
 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
 * possible parameters are:
 * - default_key_size        {number}  default: 1024 the key size in bit
 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
 * - log                     {boolean} default: false whether log warn/error or not
 * @constructor
 */
var JSEncrypt = /** @class */ (function () {
    function JSEncrypt(options) {
        options = options || {};
        this.default_key_size = parseInt(options.default_key_size, 10) || 1024;
        this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
        this.log = options.log || false;
        // The private and public key.
        this.key = null;
    }
    /**
     * Method to set the rsa key parameter (one method is enough to set both the public
     * and the private key, since the private key contains the public key paramenters)
     * Log a warning if logs are enabled
     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
     * @public
     */
    JSEncrypt.prototype.setKey = function (key) {
        if (this.log && this.key) {
            console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPrivateKey = function (privkey) {
        // Create the key.
        this.setKey(privkey);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPublicKey = function (pubkey) {
        // Sets the public key.
        this.setKey(pubkey);
    };
    /**
     * Proxy method for RSAKey object's decrypt, decrypt the string using the private
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str base64 encoded crypted string to decrypt
     * @return {string} the decrypted string
     * @public
     */
    JSEncrypt.prototype.decrypt = function (str) {
        // Return the decrypted string.
        try {
            return this.getKey().decrypt(b64tohex(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's encrypt, encrypt the string using the public
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str the string to encrypt
     * @return {string} the encrypted string encoded in base64
     * @public
     */
    JSEncrypt.prototype.encrypt = function (str) {
        // Return the encrypted string.
        try {
            return hex2b64(this.getKey().encrypt(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's sign.
     * @param {string} str the string to sign
     * @param {function} digestMethod hash method
     * @param {string} digestName the name of the hash algorithm
     * @return {string} the signature encoded in base64
     * @public
     */
    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
        // return the RSA signature of 'str' in 'hex' format.
        try {
            return hex2b64(this.getKey().sign(str, digestMethod, digestName));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's verify.
     * @param {string} str the string to verify
     * @param {string} signature the signature encoded in base64 to compare the string to
     * @param {function} digestMethod hash method
     * @return {boolean} whether the data and signature match
     * @public
     */
    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
        // Return the decrypted 'digest' of the signature.
        try {
            return this.getKey().verify(str, b64tohex(signature), digestMethod);
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
     * will be created and returned
     * @param {callback} [cb] the callback to be called if we want the key to be generated
     * in an async fashion
     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
     * @public
     */
    JSEncrypt.prototype.getKey = function (cb) {
        // Only create new if it does not exist.
        if (!this.key) {
            // Get a new private key.
            this.key = new JSEncryptRSAKey();
            if (cb && {}.toString.call(cb) === "[object Function]") {
                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                return;
            }
            // Generate the key.
            this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateKey();
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateBaseKeyB64();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicKey();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicBaseKeyB64();
    };
    JSEncrypt.version = "3.0.0-rc.1";
    return JSEncrypt;
}());

window.JSEncrypt = JSEncrypt;

exports.JSEncrypt = JSEncrypt;
exports.default = JSEncrypt;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/promise-window/dist/promise-window.js":
/*!************************************************************!*\
  !*** ./node_modules/promise-window/dist/promise-window.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * PromiseWindow
 * https://github.com/amercier/promise-window
 * @ignore
 */
(function() {
  'use strict';

  var root = window,
      prototype,
      html = root.document.documentElement;

  /**
   * Merge the contents of two or more objects together into the first object.
   *
   *     merge( target [, object1 ] [, objectN ] )
   *
   * @param {Object} target  An object that will receive the new properties if
   *                         additional objects are passed in.
   * @param {Object} object1 An object containing additional properties to merge in.
   * @param {Object} objectN An object containing additional properties to merge in.
   * @return {Object} Returns the first object.
   * @ignore
   */
  function extend() {
    var extended = arguments[0], key, i;
    for (i = 1; i < arguments.length; i++) {
      for (key in arguments[i]) {
        if (arguments[i].hasOwnProperty(key)) {
          extended[key] = arguments[i][key];
        }
      }
    }
    return extended;
  }

  /**
   * Generates a pseudo-unique String
   *
   * @param  {String} prefix Optional.
   * @return {String} Returns a pseudo-unique string prefixed with the given prefix, if any.
   * @ignore
   */
  function generateUniqueString(prefix) {
    return prefix + new Date().getTime() + "-" + Math.floor(10e12 * Math.random());
  }

  /**
   * Create a new PromiseWindow object
   *
   * During the lifecycle of this object, popup windows can be opened, closed,
   * and reopened again. However, it'
   *
   * Instanciating this prototype does not immediately opens a new popup window.
   * To open the window, use `open()` on the created object.
   *
   * @param {String}   uri                    Destination URI
   * @param {Object}   config                 Configuration object. See description below.
   * @param {Number}   config.width           Width of the popup window. Defaults to the current document width.
   * @param {Number}   config.height          Height of the popup window. Defaults to the current document height.
   * @param {Function} config.promiseProvider Promise provider. Should return a plain object containing 3 fields:
   *                                          - `promise` {Promise}  a new Promise object
   *                                          - `resolve` {Function} the method to resolve the given Promise
   *                                          - `reject`  {Function} the method to reject the given Promise
   * @param {Function} config.onPostMessage   Handler for receiving a postMessage from the opened window. Default
   *                                          implementation resolves the promise with the data passed in the post
   *                                          message, except if this data contains an `error` field. In this case,
   *                                          it rejects the Promise with the value of that field. In all cases, closes
   *                                          the popup window.
   * @param {Function} config.onPostMessage.event Event The postMessage event
   * @param {Number}   config.watcherDelay    There is no programmatic way of knowing when a popup window is closed
   *                                          (either manually or programatically). For this reason, every time
   *                                          PromiseWindow opens a popup, a new watcher is created. The watcher checks
   *                                          regularly if the window is still open. This value defines at which
   *                                          interval this check is done. Defaults to 100ms.
   * @param {String}   config.windowName      Name to be ginven to the popup window. See `window.open` references for
   *                                          details. If `null`, a random name is generated.
   * @param {Object}   config.window          Object containing window configuration settings. Scrollbars are enabled
   *                                          by default. All `window.open` ptions are accepted, but please note that
   *                                          many of them have no effect in most modern browsers. See
   *                                          https://developer.mozilla.org/en-US/docs/Web/API/Window/open for more
   *                                          details.
   * @param {Function} config.onClose         Function being called whenever the popup is being closed (either after a
   *                                          post message has been received, or window has been closed by user, or
   *                                          `.close()` method has been called. Default implementation closes the
   *                                          popup window by calling `this._window.close()`).
   * @param {RegExp} config.originRegexp      Regular expression that matches the origin part of an URI. Defaults to
   *                                          `new RegExp('^[^:/?]+://[^/]*')`. If doesn't match (ex: relative URIs),
   *                                          use `location.origin`.
   * @constructor
   */
  function PromiseWindow(uri, config) {
    this.uri = uri;
    this.config = extend({}, this.constructor.defaultConfig, config);
    this.config.windowName = this.config.windowName || generateUniqueString('promise-window-');
    this._onPostMessage = this._onPostMessage.bind(this);
  }

  /**
   * Create a Promise provider from a Promise/A+ constructor to be used with
   * `config.promiseProvider`.
   *
   *     new PromiseWindow(..., {
   *       ...,
   *       promiseProvider: PromiseWindow.getAPlusPromiseProvider(MyCustomPromise)
   *     });
   *
   * @param  {Function} CustomPromise Promise/A+ contructor
   * @return {Function} Returns a promise provider
   * @static
   */
  PromiseWindow.getAPlusPromiseProvider = function getAPlusPromiseProvider(CustomPromise) {
    return function promiseProvider() {
      var module = {};
      module.promise = new CustomPromise(function(resolve, reject) {
        module.resolve = resolve;
        module.reject = reject;
      });
      return module;
    };
  };

  /**
   * Convenience method for:
   *
   *     new PromiseWindow(uri, config).open()
   *
   * Use this method only if you never need to close the window programatically.
   * If you do, please consider using the classic way:
   *
   *     var w = new PromiseWindow(uri, config)
   *     w.open();
   *     // ...
   *     w.close();
   *
   * @return {Promise} Returns a Promise equivalent to the one returned by `open()`
   * @static
   */
  PromiseWindow.open = function open(uri, config) {
    return new PromiseWindow(uri, config).open();
  };

  /**
   * Default configuration
   * @type {Object}
   */
  PromiseWindow.defaultConfig = {
    width: html.clientWidth,
    height: html.clientHeight,
    window: {
      scrollbars: true
    },
    watcherDelay: 100,
    promiseProvider: null,
    onPostMessage: function onPostMessage(event) {
      if (event.data.error) {
        this._reject(event.data.error);
      } else {
        this._resolve(event.data);
      }
      this.close();
    },
    windowName: null,
    onClose: function() {
      this._window.close();
    },
    originRegexp: new RegExp('^[^:/?]+://[^/]*')
  };

  // Configure default Promise provider from current invironment
  if (root.Promise) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Promise);
  }
  else if (root.RSVP) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.RSVP.Promise);
  }
  else if (root.Q) {
    PromiseWindow.defaultConfig.promiseProvider = PromiseWindow.getAPlusPromiseProvider(root.Q.Promise);
  }
  else if (root.jQuery) {
    PromiseWindow.defaultConfig.promiseProvider = function promiseProvider() {
      var deferred = root.jQuery.Deferred();
      return {
        promise: deferred.promise(),
        resolve: deferred.resolve,
        reject: deferred.reject
      };
    };
  }
  else {
    PromiseWindow.defaultConfig.promiseProvider = function() {
      throw new Error('Missing promiseProvider in PromiseWindow configuration');
    };
  }

  prototype = PromiseWindow.prototype;

  /**
   * Checks whether a value is a boolean
   * @param {*} value The value to check
   * @return {boolean} `true` if value is a boolean, `false` otherwise
   * @protected
   */
  prototype._isBoolean = function _isBoolean(value) {
    return value === true || value === false;
  };

  /**
   * Converts a config value into a value compatible with `window.open`.
   * If value is a boolean, convert it to 'yes' or 'no', otherwise simply
   * casts it into a string.
   * @param {*} value The value to convert
   * @return {string} The converted value
   * @protected
   */
  prototype._serializeFeatureValue = function _serializeFeatureValue(key, value) {
    if (this._isBoolean(value)) {
      return value ? 'yes' : 'no';
    }
    return '' + value;
  };

  /**
   * Get the left and top position in the screen for a rectangle, taking
   * dual-screen position into account
   * @param {Number} width Width of the rectangle
   * @param {Number} height Height of the rectangle
   * @return {Object} position A new object representing the position of the rectangle, centered
   * @return {Number} position.left The X coordinate of the centered rectangle
   * @return {Number} position.top The Y coordinate of the centered rectangle
   * @return {Number} position.width The width of the centered rectangle
   * @return {Number} position.height The height of the centered rectangle
   * @protected
   */
  prototype._getCenteredPosition = function _getCenteredPosition(width, height) {
    var dualScreenLeft = root.screenLeft !== undefined ? root.screenLeft : screen.left,
        dualScreenTop = root.screenTop !== undefined ? root.screenTop : screen.top,
        w = root.innerWidth || html.clientWidth || screen.width,
        h = root.innerHeight || html.clientHeight || screen.height;

    return {
      left: (w / 2) - (width / 2) + dualScreenLeft,
      top:  (h / 2) - (height / 2) + dualScreenTop,
      width: width,
      height: height
    };
  };

  /**
   * Generates window features based on the current configuration
   * @return {String} Returns window features compatible with `window.open`
   * @protected
   */
  prototype._getFeatures = function _getFeatures() {
    var config = this._getCenteredPosition(this.config.width, this.config.height);
    for (var key in this.config.window) {
      if (this.config.window.hasOwnProperty(key)) {
        config[key] = this.config.window[key];
      }
    }

    return Object.keys(config)
      .map(function(key) { return key + '=' + this._serializeFeatureValue(key, config[key]); }.bind(this))
      .join(',');
  };

  /**
   * Creates a new Promise, using `config.promiseProvider`, and save reject and
   * resolve methods for later.
   *
   * @return {Promise} Returns the new Promise object created by the configured
   *                   Promise Provider.
   * @protected
   */
  prototype._createPromise = function _createPromise() {
    var module = this.config.promiseProvider();
    this._resolve = module.resolve;
    this._reject = module.reject;
    return module.promise;
  };

  /**
   * Checks whether the window is alive or not
   * @return {Boolean} Returns `true` if the window is alive, `false` otherwise
   * @protected
   */
  prototype._isWindowAlive = function _isWindowAlive() {
    return this._window && !this._window.closed;
  };

  /**
   * Starts the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._startWatcher = function _startWatcher() {
    if (this._watcherRunning) {
      throw new Error('Watcher is already started');
    }
    this._watcher = root.setInterval(function () {
      if (this._watcherRunning && !this._isWindowAlive()) {
        this.close();
      }
    }.bind(this), this.config.watcherDelay);
    this._watcherRunning = true;
  };

  /**
   * Stops the popup window watcher.
   * @return {void}
   * @protected
   */
  prototype._stopWatcher = function _stopWatcher() {
    if (!this._watcherRunning) {
      throw new Error('Watcher is already stopped');
    }
    this._watcherRunning = false;
    root.clearInterval(this._watcher);
  };

  /**
   * Callback for post message events. If and only of the event has been
   * generated from the opened popup window, it propagates it to the configured
   * post message handler (`config.onPostMessage`).
   *
   * @param {Event} event The postMessage event
   * @return {void}
   * @protected
   */
  prototype._onPostMessage = function _onPostMessage(event) {
    var expectedOriginMatches = this.config.originRegexp.exec(this.uri);
    var expectedOrigin = expectedOriginMatches && expectedOriginMatches[0] || location.origin;
    if (this._window === event.source && event.origin === expectedOrigin) {
      this.config.onPostMessage.call(this, event);
    }
  };

  /**
   * Changes the URI
   * @param {String} uri The new URI
   * @throws {Error} If the window is open
   * @return {PromiseWindow} Returns this object to allow chaining
   */
  prototype.setURI = function setURI(uri) {
    if (this.isOpen()) {
      throw new Error('Cannot change the URI while the window is open');
    }
    this.uri = uri;
    return this;
  };

  /**
   * Opens a new popup window.
   *
   * @return {Promise} Returns a new `Promise` object. This promise will be:
   *                   - rejected with `"blocked"` message if the popup window
   *                     does not open for any reason (popup blocker, etc...)
   *                   - rejected with `"closed"` if closed either manually by
   *                     the user, or programatically
   *                   - rejected with the given error if the web page opened in
   *                     the popup sends a post message with a `error` data field.
   *                   - resolved with the given data if the web page opened in
   *                     the popup sends a post message without a `error` data
   *                     field.
   */
  prototype.open = function open() {
    if (this.isOpen()) {
      throw new Error('Window is already open');
    }

    this._windowOpen = true;
    var promise = this._createPromise();
    this._window = root.open(
      this.uri,
      this.config.windowName,
      this._getFeatures()
    );
    if (!this._window) {
      this._reject("blocked");
    }
    else {
      root.addEventListener("message", this._onPostMessage, true);
      this._startWatcher();
    }
    return promise;
  };

  /**
   * Closes the popup window.
   *
   * @return {void}
   */
  prototype.close = function close() {
    if (!this.isOpen()) {
      throw new Error('Window is already closed');
    }
    this._stopWatcher();
    root.removeEventListener("message", this._onPostMessage);
    if (this._isWindowAlive()) {
      this.config.onClose.call(this);
    }
    this._reject("closed");
    this._window = null;
    this._windowOpen = false;
  };

  /**
   * Checks whether the window is open or not
   * @return {Boolean} Returns `true` if the window is opened, `false` otherwise.
   */
  prototype.isOpen = function isOpen() {
    return this._windowOpen;
  };

  // Exports PromiseWindow to the global scope
  /* jshint ignore:start */
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() { return PromiseWindow }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
  /* jshint ignore:end */

})();


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./src/discourse.js":
/*!**************************!*\
  !*** ./src/discourse.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");

__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");

__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");

__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");

__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");

__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");

__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js");

__webpack_require__(/*! core-js/modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.constructor */ "./node_modules/core-js/modules/es.regexp.constructor.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");

__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");

__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _discourseAuth = _interopRequireDefault(__webpack_require__(/*! ./discourseAuth */ "./src/discourseAuth.js"));

var _discourseClient = _interopRequireDefault(__webpack_require__(/*! ./discourseClient */ "./src/discourseClient.js"));

var _promiseWindow = _interopRequireDefault(__webpack_require__(/*! promise-window */ "./node_modules/promise-window/dist/promise-window.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Discourse =
/*#__PURE__*/
function () {
  function Discourse(options) {
    _classCallCheck(this, Discourse);

    this._requireOptions(options);

    this.options = this._formatOptions(options);
    this.auth = new _discourseAuth["default"](this.options);
    this.client = new _discourseClient["default"](this.options.apiBaseUrl);
  }

  _createClass(Discourse, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.auth.init();

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_requireOptions",
    value: function _requireOptions(options) {
      options && _typeof(options) === 'object' || function (e) {
        throw e;
      }(new Error('Options must be an object'));
      typeof options.appName === 'string' && options.appName.length > 0 || function (e) {
        throw e;
      }(new Error('options.appName must be a non-empty string'));
      typeof options.apiBaseUrl === 'string' && options.apiBaseUrl.length > 0 || function (e) {
        throw e;
      }(new Error('Options.apiBaseUrl must be a non-empty string'));
      options.scopes instanceof Array && options.scopes.length > 0 || function (e) {
        throw e;
      }(new Error('Options.scopes must be a non-empty array'));
    }
  }, {
    key: "_formatOptions",
    value: function _formatOptions(options) {
      var formattedOptions = _objectSpread({}, options); // remove trailing slash


      formattedOptions.apiBaseUrl = options.apiBaseUrl.replace(/\/$/, '');
      formattedOptions.scopes = options.scopes.join(',');
      return formattedOptions;
    }
  }, {
    key: "getApiBaseUrl",
    value: function getApiBaseUrl() {
      return this.options.apiBaseUrl;
    }
  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.isLoggedIn();

              case 2:
                if (!_context3.sent) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return");

              case 4:
                _context3.t0 = _promiseWindow["default"];
                _context3.next = 7;
                return this.auth._getLoginUrl();

              case 7:
                _context3.t1 = _context3.sent;
                _context3.t2 = {
                  width: 700,
                  height: 650,
                  originRegexp: new RegExp('^' + location.origin)
                };

                _context3.t3 =
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee2(data) {
                    return regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.client._setUserApiKey(data.result.key);

                          case 2:
                            _context2.next = 4;
                            return _this._refreshCurrentUser();

                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x) {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context3.t4 = // Error
                function (error) {
                  switch (error) {
                    case 'closed':
                      dispatchEvent(new Event('discourseLoginCanceled'));
                      throw new Error('Authentication popup window closed by the user');

                    case 'blocked':
                      dispatchEvent(new Event('discourseLoginBlocked'));
                      throw new Error('Authentication popup window blocked by the browser');

                    default:
                      throw new Error('Authentication popup window returned an error: ', error);
                  }
                };

                _context3.t5 = function () {
                  return dispatchEvent(new Event('discourseLoggedIn'));
                };

                _context3.next = 14;
                return _context3.t0.open.call(_context3.t0, _context3.t1, _context3.t2).then(_context3.t3, _context3.t4).then(_context3.t5);

              case 14:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function login() {
        return _login.apply(this, arguments);
      }

      return login;
    }()
  }, {
    key: "logout",
    value: function () {
      var _logout = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.client._doLogout(this.getCurrentUserName());

              case 2:
                this.auth._clearAuthData();

                dispatchEvent(new Event('discourseLoggedOut'));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }, {
    key: "getCurrentSessionUser",
    value: function () {
      var _getCurrentSessionUser = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.client._getCallResult('/session/current.json', 'current_user', true);

              case 2:
                return _context5.abrupt("return", _context5.sent);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getCurrentSessionUser() {
        return _getCurrentSessionUser.apply(this, arguments);
      }

      return getCurrentSessionUser;
    }()
  }, {
    key: "isLoggedIn",
    value: function () {
      var _isLoggedIn = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this.auth._hasUserApiKey()) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return", false);

              case 2:
                _context6.prev = 2;
                _context6.next = 5;
                return this._refreshCurrentUser();

              case 5:
                return _context6.abrupt("return", true);

              case 8:
                _context6.prev = 8;
                _context6.t0 = _context6["catch"](2);
                return _context6.abrupt("return", false);

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[2, 8]]);
      }));

      function isLoggedIn() {
        return _isLoggedIn.apply(this, arguments);
      }

      return isLoggedIn;
    }()
  }, {
    key: "getCurrentUser",
    value: function getCurrentUser() {
      return JSON.parse(localStorage.getItem('currentUser'));
    }
  }, {
    key: "getCurrentUserName",
    value: function getCurrentUserName() {
      return this.getCurrentUser() && this.getCurrentUser()['username'];
    }
  }, {
    key: "getCurrentUserId",
    value: function getCurrentUserId() {
      return this.getCurrentUser() && this.getCurrentUser()['id'];
    }
  }, {
    key: "getCurrentUserDisplayName",
    value: function getCurrentUserDisplayName() {
      return this.getCurrentUser() && this.getCurrentUser()['name'];
    }
  }, {
    key: "isCurrentUserSilenced",
    value: function isCurrentUserSilenced() {
      return this.getCurrentUser() && !this.getCurrentUser()['can_create_topic'];
    }
  }, {
    key: "getCurrentUserAvatarUrl",
    value: function getCurrentUserAvatarUrl(size) {
      return this.getCurrentUser() && [this.options.apiBaseUrl, this.getCurrentUser()['avatar_template'].replace('{size}', size || 110)].join('/');
    }
  }, {
    key: "getCurrentUserNotificationsUrl",
    value: function getCurrentUserNotificationsUrl() {
      return this.getCurrentUser() && [this.options.apiBaseUrl, 'u', this.getCurrentUserName(), 'notifications'].join('/');
    }
  }, {
    key: "_refreshCurrentUser",
    value: function () {
      var _refreshCurrentUser2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.prev = 0;
                _context7.t0 = localStorage;
                _context7.t1 = JSON;
                _context7.next = 5;
                return this.getCurrentSessionUser();

              case 5:
                _context7.t2 = _context7.sent;
                _context7.t3 = _context7.t1.stringify.call(_context7.t1, _context7.t2);

                _context7.t0.setItem.call(_context7.t0, 'currentUser', _context7.t3);

                _context7.next = 15;
                break;

              case 10:
                _context7.prev = 10;
                _context7.t4 = _context7["catch"](0);
                _context7.next = 14;
                return this.logout();

              case 14:
                throw new Error('Not logged in.');

              case 15:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[0, 10]]);
      }));

      function _refreshCurrentUser() {
        return _refreshCurrentUser2.apply(this, arguments);
      }

      return _refreshCurrentUser;
    }()
  }, {
    key: "getLatestPosts",
    value: function () {
      var _getLatestPosts = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(descending) {
        var posts;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.prev = 0;
                _context8.next = 3;
                return this.client._getCallResult('/posts.json', 'latest_posts');

              case 3:
                posts = _context8.sent;
                _context8.next = 9;
                break;

              case 6:
                _context8.prev = 6;
                _context8.t0 = _context8["catch"](0);
                throw new Error(_context8.t0);

              case 9:
                if (descending) {
                  posts = posts.reverse();
                }

                return _context8.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[0, 6]]);
      }));

      function getLatestPosts(_x2) {
        return _getLatestPosts.apply(this, arguments);
      }

      return getLatestPosts;
    }()
  }, {
    key: "getPostsInTopic",
    value: function () {
      var _getPostsInTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(topicId, descending) {
        var nocache,
            posts,
            _args9 = arguments;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                nocache = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : false;
                _context9.next = 3;
                return this.client._getCallResult('/t/' + topicId + '/posts.json?include_raw=true', 'post_stream.posts', nocache);

              case 3:
                posts = _context9.sent;

                if (descending) {
                  posts = posts.reverse();
                }

                return _context9.abrupt("return", posts.filter(function (post) {
                  return post.post_type === 1;
                }));

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getPostsInTopic(_x3, _x4) {
        return _getPostsInTopic.apply(this, arguments);
      }

      return getPostsInTopic;
    }()
  }, {
    key: "getTopic",
    value: function () {
      var _getTopic = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(topicId, descending) {
        var nocache,
            topic,
            _args10 = arguments;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                nocache = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : false;
                _context10.next = 3;
                return this.client._getCallResult('/t/' + topicId + '.json?include_raw=true', false, nocache);

              case 3:
                topic = _context10.sent;
                topic.post_stream.posts = topic.post_stream.posts.filter(function (post) {
                  return post.post_type === 1;
                });

                if (descending) {
                  topic.post_stream.posts = topic.post_stream.posts.reverse();
                }

                return _context10.abrupt("return", topic);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getTopic(_x5, _x6) {
        return _getTopic.apply(this, arguments);
      }

      return getTopic;
    }()
  }, {
    key: "getPublicUserFields",
    value: function () {
      var _getPublicUserFields = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(username) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.client._getCallResult('/u/' + username + '.json?stats=false', 'user.user_fields');

              case 2:
                return _context11.abrupt("return", _context11.sent);

              case 3:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getPublicUserFields(_x7) {
        return _getPublicUserFields.apply(this, arguments);
      }

      return getPublicUserFields;
    }()
  }, {
    key: "getPublicUserField",
    value: function () {
      var _getPublicUserField = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(username, field) {
        var userFields;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.getPublicUserFields(username);

              case 2:
                userFields = _context12.sent;
                return _context12.abrupt("return", userFields && userFields[field]);

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getPublicUserField(_x8, _x9) {
        return _getPublicUserField.apply(this, arguments);
      }

      return getPublicUserField;
    }()
  }, {
    key: "postMessage",
    value: function () {
      var _postMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(topicId, message) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.client._checkUserApiKey();

                _context13.next = 3;
                return this.client._postCallResult('/posts.json', {
                  /* eslint-disable camelcase */
                  topic_id: topicId,
                  raw: message
                  /* eslint-enable camelcase */

                }).then(function (response) {
                  response.hidden && Promise.reject(response.hidden_reason_id);
                  return response;
                })["catch"](function (error) {
                  return Promise.reject(error.response.data.errors);
                });

              case 3:
                return _context13.abrupt("return", _context13.sent);

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function postMessage(_x10, _x11) {
        return _postMessage.apply(this, arguments);
      }

      return postMessage;
    }()
  }, {
    key: "likePost",
    value: function () {
      var _likePost = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(postId) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this.client._checkUserApiKey();

                _context14.next = 3;
                return this.client._postCallResult('/post_actions', {
                  /* eslint-disable camelcase */
                  id: postId,
                  post_action_type_id: 2
                  /* eslint-enable camelcase */

                }).then(function (response) {
                  return response;
                })["catch"](function (error) {
                  return Promise.reject(error.response.data.errors);
                });

              case 3:
                return _context14.abrupt("return", _context14.sent);

              case 4:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function likePost(_x12) {
        return _likePost.apply(this, arguments);
      }

      return likePost;
    }()
  }, {
    key: "undoLikePost",
    value: function () {
      var _undoLikePost = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee15(postId) {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                this.client._checkUserApiKey();

                _context15.next = 3;
                return this.client.instance["delete"]('/post_actions/' + postId, {
                  data: {
                    /* eslint-disable camelcase */
                    post_action_type_id: '2'
                    /* eslint-enable camelcase */

                  }
                });

              case 3:
                return _context15.abrupt("return", _context15.sent.data);

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function undoLikePost(_x13) {
        return _undoLikePost.apply(this, arguments);
      }

      return undoLikePost;
    }()
  }]);

  return Discourse;
}();

exports["default"] = Discourse;
window.Discourse = Discourse;

/***/ }),

/***/ "./src/discourseAuth.js":
/*!******************************!*\
  !*** ./src/discourseAuth.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");

__webpack_require__(/*! core-js/modules/es.array.map */ "./node_modules/core-js/modules/es.array.map.js");

__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");

__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");

__webpack_require__(/*! core-js/modules/es.string.search */ "./node_modules/core-js/modules/es.string.search.js");

__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _keyManager = _interopRequireDefault(__webpack_require__(/*! ./keyManager */ "./src/keyManager.js"));

var _urlSearchParams = _interopRequireDefault(__webpack_require__(/*! @ungap/url-search-params */ "./node_modules/@ungap/url-search-params/esm/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// polyfill
// import MobileDetect from 'mobile-detect';
var DiscourseAuth =
/*#__PURE__*/
function () {
  function DiscourseAuth(options) {
    _classCallCheck(this, DiscourseAuth);

    this.appId = this._slugify(options.appName);
    this.km = new _keyManager["default"](this.appId);
    this.options = options;
  }

  _createClass(DiscourseAuth, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.km.getKeys();

              case 2:
                this._hasUserApiKey() || this._managePayload();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_hasUserApiKey",
    value: function _hasUserApiKey() {
      return localStorage.getItem('user_api_key') !== null;
    }
  }, {
    key: "_getLoginUrl",
    value: function () {
      var _getLoginUrl2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var params;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.options.appName;
                _context2.next = 3;
                return this.km.getPublicKey();

              case 3:
                _context2.t1 = _context2.sent;
                _context2.t2 = this._generateStoredRandom('nonce');
                _context2.t3 = this._getStoredRandom('clientId') || this._generateStoredRandom('clientId');
                _context2.t4 = location.href;
                _context2.t5 = this.options.scopes;
                params = {
                  application_name: _context2.t0,
                  public_key: _context2.t1,
                  nonce: _context2.t2,
                  client_id: _context2.t3,
                  auth_redirect: _context2.t4,
                  scopes: _context2.t5
                };
                return _context2.abrupt("return", this.options.apiBaseUrl + '/user-api-key/new?' + this._serializeParams(params));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getLoginUrl() {
        return _getLoginUrl2.apply(this, arguments);
      }

      return _getLoginUrl;
    }()
  }, {
    key: "_serializeParams",
    value: function _serializeParams(params) {
      return Object.keys(params).map(function (k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
      }).join('&');
    }
  }, {
    key: "_generateStoredRandom",
    value: function _generateStoredRandom(name) {
      var storedRandom = Math.random().toString(16).substr(2);
      localStorage.setItem(this.appId + '_' + name, storedRandom);
      return storedRandom;
    }
  }, {
    key: "_getStoredRandom",
    value: function _getStoredRandom(name) {
      var storedRandom = localStorage.getItem(this.appId + '_' + name);
      return storedRandom;
    }
  }, {
    key: "_removeStoredRandom",
    value: function _removeStoredRandom(name) {
      localStorage.removeItem(this.appId + '_' + name);
    }
  }, {
    key: "_getUserApiKey",
    value: function _getUserApiKey() {
      return localStorage.getItem('user_api_key');
    }
  }, {
    key: "_clearAuthData",
    value: function _clearAuthData() {
      localStorage.removeItem('user_api_key');
      localStorage.removeItem('currentUser');

      this._removeStoredRandom('clientId');
    }
  }, {
    key: "_managePayload",
    value: function _managePayload() {
      var _this = this;

      var url = new _urlSearchParams["default"](window.location.search || window.location.hash.split('?')[1]);

      if (url.has('payload') && opener) {
        this.km.decryptPayload(url.get('payload')).then(function (payloadObject) {
          payloadObject.nonce === _this._getStoredRandom('nonce') || function (e) {
            throw e;
          }(new Error('The returned payload is invalid.'));
          payloadObject.api === 4 || function (e) {
            throw e;
          }(new Error('Wrong API version: ' + payloadObject.api + '. Discourse-js works with API version 3.'));
          localStorage.setItem('user_api_key', payloadObject.key);

          _this._removeStoredRandom('nonce');

          opener.postMessage({
            result: payloadObject
          }, location.origin);
        });
      } // var md = new MobileDetect(window.navigator.userAgent);

    }
  }, {
    key: "_slugify",
    value: function _slugify(text) {
      return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    }
  }]);

  return DiscourseAuth;
}();

exports["default"] = DiscourseAuth;

/***/ }),

/***/ "./src/discourseClient.js":
/*!********************************!*\
  !*** ./src/discourseClient.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");

__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _axios = _interopRequireDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));

var _axiosExtensions = __webpack_require__(/*! axios-extensions */ "./node_modules/axios-extensions/esm/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DiscourseClient =
/*#__PURE__*/
function () {
  function DiscourseClient(apiBaseUrl) {
    _classCallCheck(this, DiscourseClient);

    this.apiBaseUrl = apiBaseUrl;
    this.instance = _axios["default"].create({
      baseURL: this.apiBaseUrl,
      headers: {
        'X-Requested-With': 'XMLHttpRequest',
        'Cache-Control': 'no-cache',
        'Content-Type': 'application/json'
      },
      adapter: (0, _axiosExtensions.throttleAdapterEnhancer)((0, _axiosExtensions.cacheAdapterEnhancer)(_axios["default"].defaults.adapter), {
        threshold: 500 // 120 reqs/min

      })
    });

    this._setUserApiKey(localStorage.getItem('user_api_key'));
  }

  _createClass(DiscourseClient, [{
    key: "_getCallResult",
    value: function () {
      var _getCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(endpoint, prop) {
        var nocache,
            response,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                nocache = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;
                _context.prev = 1;
                _context.next = 4;
                return this.instance.get(endpoint, {
                  forceUpdate: nocache
                });

              case 4:
                response = _context.sent.data;
                _context.next = 10;
                break;

              case 7:
                _context.prev = 7;
                _context.t0 = _context["catch"](1);
                throw new Error(_context.t0);

              case 10:
                if (prop) {
                  response = prop.split('.').reduce(function (returnedResponse, currentProp) {
                    return returnedResponse[currentProp];
                  }, response);
                }

                return _context.abrupt("return", response);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[1, 7]]);
      }));

      function _getCallResult(_x, _x2) {
        return _getCallResult2.apply(this, arguments);
      }

      return _getCallResult;
    }()
  }, {
    key: "_postCallResult",
    value: function () {
      var _postCallResult2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(endpoint, payload) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.instance.post(endpoint, payload);

              case 2:
                return _context2.abrupt("return", _context2.sent.data);

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _postCallResult(_x3, _x4) {
        return _postCallResult2.apply(this, arguments);
      }

      return _postCallResult;
    }()
  }, {
    key: "_setUserApiKey",
    value: function () {
      var _setUserApiKey2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(userApiKey) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (userApiKey) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return");

              case 2:
                this.instance.defaults.headers.common['User-Api-Key'] = userApiKey;
                _context3.next = 5;
                return this._setCsrfToken();

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _setUserApiKey(_x5) {
        return _setUserApiKey2.apply(this, arguments);
      }

      return _setUserApiKey;
    }()
  }, {
    key: "_setCsrfToken",
    value: function () {
      var _setCsrfToken2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._getCallResult('/session/csrf.json', 'csrf');

              case 2:
                this.instance.defaults.headers.common['X-CSRF-Token'] = _context4.sent;

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _setCsrfToken() {
        return _setCsrfToken2.apply(this, arguments);
      }

      return _setCsrfToken;
    }()
  }, {
    key: "_checkUserApiKey",
    value: function _checkUserApiKey() {
      this.instance.defaults.headers.common['User-Api-Key'] || function (e) {
        throw e;
      }(new Error('User API key not set'));
    }
  }, {
    key: "_doLogout",
    value: function () {
      var _doLogout2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(username) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._checkUserApiKey();

                _context5.next = 3;
                return this.instance["delete"]('/session/' + username);

              case 3:
                _context5.next = 5;
                return this.instance.post('/user-api-key/revoke');

              case 5:
                delete this.instance.defaults.headers.common['User-Api-Key'];
                delete this.instance.defaults.headers.common['X-CSRF-Token'];

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _doLogout(_x6) {
        return _doLogout2.apply(this, arguments);
      }

      return _doLogout;
    }()
  }]);

  return DiscourseClient;
}();

exports["default"] = DiscourseClient;

/***/ }),

/***/ "./src/keyGenerator.js":
/*!*****************************!*\
  !*** ./src/keyGenerator.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");

__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var forge = __webpack_require__(/*! ./vendor/forge-pki */ "./src/vendor/forge-pki.js");

var _default = function () {
  var generate = function generate(appId) {
    return new Promise(function (resolve, reject) {
      forge.rsa.generateKeyPair({
        workerScript: '/prime-worker.min.js'
      }, function (error, generatedKeypair) {
        generatedKeypair ? function () {
          var keypair = {
            "public": forge.pki.publicKeyToPem(generatedKeypair.publicKey, 72).replace(/\r/g, ''),
            "private": forge.pki.privateKeyToPem(generatedKeypair.privateKey, 72).replace(/\r/g, '')
          };
          localStorage.setItem(appId + '_publicKey', keypair["public"]);
          localStorage.setItem(appId + '_privateKey', keypair["private"]);
          resolve(keypair);
        }() : reject(error);
      });
    });
  };

  return {
    generate: generate
  };
}();

exports["default"] = _default;

/***/ }),

/***/ "./src/keyManager.js":
/*!***************************!*\
  !*** ./src/keyManager.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");

__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");

__webpack_require__(/*! core-js/modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var KeyManager =
/*#__PURE__*/
function () {
  function KeyManager(appId) {
    _classCallCheck(this, KeyManager);

    this.appId = appId;
  }

  _createClass(KeyManager, [{
    key: "generateNewKeypair",
    value: function () {
      var _generateNewKeypair = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve(/*! import() | keyGenerator */).then(__webpack_require__.t.bind(null, /*! ./keyGenerator */ "./src/keyGenerator.js", 7)).then(function (_ref) {
                  var keyGenerator = _ref["default"];
                  return keyGenerator.generate(_this.appId).then(function (keypair) {
                    return keypair;
                  });
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function generateNewKeypair() {
        return _generateNewKeypair.apply(this, arguments);
      }

      return generateNewKeypair;
    }()
  }, {
    key: "getKeys",
    value: function () {
      var _getKeys = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = this.readKeysFromStorage();

                if (_context2.t0) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return this.generateNewKeypair();

              case 4:
                _context2.t0 = _context2.sent;

              case 5:
                return _context2.abrupt("return", _context2.t0);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getKeys() {
        return _getKeys.apply(this, arguments);
      }

      return getKeys;
    }()
  }, {
    key: "readKeysFromStorage",
    value: function readKeysFromStorage() {
      var publicKey = localStorage.getItem(this.appId + '_publicKey');
      var privateKey = localStorage.getItem(this.appId + '_privateKey');
      return publicKey && privateKey ? {
        "public": publicKey,
        "private": privateKey
      } : null;
    }
  }, {
    key: "getPublicKey",
    value: function () {
      var _getPublicKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getKeys();

              case 2:
                return _context3.abrupt("return", _context3.sent['public']);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getPublicKey() {
        return _getPublicKey.apply(this, arguments);
      }

      return getPublicKey;
    }()
  }, {
    key: "getPrivateKey",
    value: function () {
      var _getPrivateKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getKeys();

              case 2:
                return _context4.abrupt("return", _context4.sent['private']);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getPrivateKey() {
        return _getPrivateKey.apply(this, arguments);
      }

      return getPrivateKey;
    }()
  }, {
    key: "decryptPayload",
    value: function () {
      var _decryptPayload = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(payload) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.getPrivateKey().then(function (privateKey) {
                  return Promise.resolve(/*! import() | jsencrypt */).then(__webpack_require__.t.bind(null, /*! jsencrypt */ "./node_modules/jsencrypt/bin/jsencrypt.js", 7)).then(function (_ref2) {
                    var Jsencrypt = _ref2["default"];
                    var jsencrypt = new Jsencrypt();
                    jsencrypt.setPrivateKey(privateKey);
                    return JSON.parse(jsencrypt.decrypt(payload));
                  });
                }));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function decryptPayload(_x) {
        return _decryptPayload.apply(this, arguments);
      }

      return decryptPayload;
    }()
  }]);

  return KeyManager;
}();

exports["default"] = KeyManager;
;

/***/ }),

/***/ "./src/vendor/forge-pki.js":
/*!*********************************!*\
  !*** ./src/vendor/forge-pki.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, Buffer, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;__webpack_require__(/*! core-js/modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");__webpack_require__(/*! core-js/modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");__webpack_require__(/*! core-js/modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");__webpack_require__(/*! core-js/modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");__webpack_require__(/*! core-js/modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");__webpack_require__(/*! core-js/modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");__webpack_require__(/*! core-js/modules/es.array.index-of */ "./node_modules/core-js/modules/es.array.index-of.js");__webpack_require__(/*! core-js/modules/es.array.is-array */ "./node_modules/core-js/modules/es.array.is-array.js");__webpack_require__(/*! core-js/modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");__webpack_require__(/*! core-js/modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");__webpack_require__(/*! core-js/modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");__webpack_require__(/*! core-js/modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");__webpack_require__(/*! core-js/modules/es.array.splice */ "./node_modules/core-js/modules/es.array.splice.js");__webpack_require__(/*! core-js/modules/es.array-buffer.constructor */ "./node_modules/core-js/modules/es.array-buffer.constructor.js");__webpack_require__(/*! core-js/modules/es.array-buffer.slice */ "./node_modules/core-js/modules/es.array-buffer.slice.js");__webpack_require__(/*! core-js/modules/es.data-view */ "./node_modules/core-js/modules/es.data-view.js");__webpack_require__(/*! core-js/modules/es.date.now */ "./node_modules/core-js/modules/es.date.now.js");__webpack_require__(/*! core-js/modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");__webpack_require__(/*! core-js/modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");__webpack_require__(/*! core-js/modules/es.number.to-fixed */ "./node_modules/core-js/modules/es.number.to-fixed.js");__webpack_require__(/*! core-js/modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");__webpack_require__(/*! core-js/modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");__webpack_require__(/*! core-js/modules/es.parse-float */ "./node_modules/core-js/modules/es.parse-float.js");__webpack_require__(/*! core-js/modules/es.parse-int */ "./node_modules/core-js/modules/es.parse-int.js");__webpack_require__(/*! core-js/modules/es.regexp.constructor */ "./node_modules/core-js/modules/es.regexp.constructor.js");__webpack_require__(/*! core-js/modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");__webpack_require__(/*! core-js/modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");__webpack_require__(/*! core-js/modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");__webpack_require__(/*! core-js/modules/es.string.match */ "./node_modules/core-js/modules/es.string.match.js");__webpack_require__(/*! core-js/modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");__webpack_require__(/*! core-js/modules/es.string.search */ "./node_modules/core-js/modules/es.string.search.js");__webpack_require__(/*! core-js/modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");__webpack_require__(/*! core-js/modules/es.typed-array.uint8-array */ "./node_modules/core-js/modules/es.typed-array.uint8-array.js");__webpack_require__(/*! core-js/modules/es.typed-array.uint16-array */ "./node_modules/core-js/modules/es.typed-array.uint16-array.js");__webpack_require__(/*! core-js/modules/es.typed-array.uint32-array */ "./node_modules/core-js/modules/es.typed-array.uint32-array.js");__webpack_require__(/*! core-js/modules/es.typed-array.copy-within */ "./node_modules/core-js/modules/es.typed-array.copy-within.js");__webpack_require__(/*! core-js/modules/es.typed-array.every */ "./node_modules/core-js/modules/es.typed-array.every.js");__webpack_require__(/*! core-js/modules/es.typed-array.fill */ "./node_modules/core-js/modules/es.typed-array.fill.js");__webpack_require__(/*! core-js/modules/es.typed-array.filter */ "./node_modules/core-js/modules/es.typed-array.filter.js");__webpack_require__(/*! core-js/modules/es.typed-array.find */ "./node_modules/core-js/modules/es.typed-array.find.js");__webpack_require__(/*! core-js/modules/es.typed-array.find-index */ "./node_modules/core-js/modules/es.typed-array.find-index.js");__webpack_require__(/*! core-js/modules/es.typed-array.for-each */ "./node_modules/core-js/modules/es.typed-array.for-each.js");__webpack_require__(/*! core-js/modules/es.typed-array.includes */ "./node_modules/core-js/modules/es.typed-array.includes.js");__webpack_require__(/*! core-js/modules/es.typed-array.index-of */ "./node_modules/core-js/modules/es.typed-array.index-of.js");__webpack_require__(/*! core-js/modules/es.typed-array.iterator */ "./node_modules/core-js/modules/es.typed-array.iterator.js");__webpack_require__(/*! core-js/modules/es.typed-array.join */ "./node_modules/core-js/modules/es.typed-array.join.js");__webpack_require__(/*! core-js/modules/es.typed-array.last-index-of */ "./node_modules/core-js/modules/es.typed-array.last-index-of.js");__webpack_require__(/*! core-js/modules/es.typed-array.map */ "./node_modules/core-js/modules/es.typed-array.map.js");__webpack_require__(/*! core-js/modules/es.typed-array.reduce */ "./node_modules/core-js/modules/es.typed-array.reduce.js");__webpack_require__(/*! core-js/modules/es.typed-array.reduce-right */ "./node_modules/core-js/modules/es.typed-array.reduce-right.js");__webpack_require__(/*! core-js/modules/es.typed-array.reverse */ "./node_modules/core-js/modules/es.typed-array.reverse.js");__webpack_require__(/*! core-js/modules/es.typed-array.set */ "./node_modules/core-js/modules/es.typed-array.set.js");__webpack_require__(/*! core-js/modules/es.typed-array.slice */ "./node_modules/core-js/modules/es.typed-array.slice.js");__webpack_require__(/*! core-js/modules/es.typed-array.some */ "./node_modules/core-js/modules/es.typed-array.some.js");__webpack_require__(/*! core-js/modules/es.typed-array.sort */ "./node_modules/core-js/modules/es.typed-array.sort.js");__webpack_require__(/*! core-js/modules/es.typed-array.subarray */ "./node_modules/core-js/modules/es.typed-array.subarray.js");__webpack_require__(/*! core-js/modules/es.typed-array.to-locale-string */ "./node_modules/core-js/modules/es.typed-array.to-locale-string.js");__webpack_require__(/*! core-js/modules/es.typed-array.to-string */ "./node_modules/core-js/modules/es.typed-array.to-string.js");__webpack_require__(/*! core-js/modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");__webpack_require__(/*! core-js/modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");__webpack_require__(/*! core-js/modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");__webpack_require__(/*! core-js/modules/web.url */ "./node_modules/core-js/modules/web.url.js");function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}(function webpackUniversalModuleDefinition(root,factory){if(( false?undefined:_typeof(exports))==='object'&&( false?undefined:_typeof(module))==='object')module.exports=factory();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(typeof self!=='undefined'?self:void 0,function(){return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};/******/ /******/ // The require function
/******/function __webpack_require__(moduleId){/******/ /******/ // Check if module is in cache
/******/if(installedModules[moduleId]){/******/return installedModules[moduleId].exports;/******/}/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={/******/i:moduleId,/******/l:false,/******/exports:{}/******/};/******/ /******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);/******/ /******/ // Flag the module as loaded
/******/module.l=true;/******/ /******/ // Return the exports of the module
/******/return module.exports;/******/}/******/ /******/ /******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;/******/ /******/ // expose the module cache
/******/__webpack_require__.c=installedModules;/******/ /******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){/******/if(!__webpack_require__.o(exports,name)){/******/Object.defineProperty(exports,name,{/******/configurable:false,/******/enumerable:true,/******/get:getter/******/});/******/}/******/};/******/ /******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){/******/var getter=module&&module.__esModule?/******/function getDefault(){return module['default'];}:/******/function getModuleExports(){return module;};/******/__webpack_require__.d(getter,'a',getter);/******/return getter;/******/};/******/ /******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};/******/ /******/ // __webpack_public_path__
/******/__webpack_require__.p="";/******/ /******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s=20);/******/}(/************************************************************************/ /******/[/* 0 */ /***/function(module,exports){/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */module.exports={// default options
options:{usePureJavaScript:false}};/***/},/* 1 */ /***/function(module,exports,__webpack_require__){/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);var baseN=__webpack_require__(22);/* Utilities API */var util=module.exports=forge.util=forge.util||{};// define setImmediate and nextTick
(function(){// use native nextTick (unless we're in webpack)
// webpack (or better node-libs-browser polyfill) sets process.browser.
// this way we can detect webpack properly
if(typeof process!=='undefined'&&process.nextTick&&!process.browser){util.nextTick=process.nextTick;if(typeof setImmediate==='function'){util.setImmediate=setImmediate;}else{// polyfill setImmediate with nextTick, older versions of node
// (those w/o setImmediate) won't totally starve IO
util.setImmediate=util.nextTick;}return;}// polyfill nextTick with native setImmediate
if(typeof setImmediate==='function'){util.setImmediate=function(){return setImmediate.apply(undefined,arguments);};util.nextTick=function(callback){return setImmediate(callback);};return;}/* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */ // polyfill with setTimeout
util.setImmediate=function(callback){setTimeout(callback,0);};// upgrade polyfill to use postMessage
if(typeof window!=='undefined'&&typeof window.postMessage==='function'){var handler=function handler(event){if(event.source===window&&event.data===msg){event.stopPropagation();var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}};var msg='forge.setImmediate';var callbacks=[];util.setImmediate=function(callback){callbacks.push(callback);// only send message when one hasn't been sent in
// the current turn of the event loop
if(callbacks.length===1){window.postMessage(msg,'*');}};window.addEventListener('message',handler,true);}// upgrade polyfill to use MutationObserver
if(typeof MutationObserver!=='undefined'){// polyfill with MutationObserver
var now=Date.now();var attr=true;var div=document.createElement('div');var callbacks=[];new MutationObserver(function(){var copy=callbacks.slice();callbacks.length=0;copy.forEach(function(callback){callback();});}).observe(div,{attributes:true});var oldSetImmediate=util.setImmediate;util.setImmediate=function(callback){if(Date.now()-now>15){now=Date.now();oldSetImmediate(callback);}else{callbacks.push(callback);// only trigger observer when it hasn't been triggered in
// the current turn of the event loop
if(callbacks.length===1){div.setAttribute('a',attr=!attr);}}};}util.nextTick=util.setImmediate;})();// check if running under Node.js
util.isNodejs=typeof process!=='undefined'&&process.versions&&process.versions.node;// define isArray
util.isArray=Array.isArray||function(x){return Object.prototype.toString.call(x)==='[object Array]';};// define isArrayBuffer
util.isArrayBuffer=function(x){return typeof ArrayBuffer!=='undefined'&&x instanceof ArrayBuffer;};// define isArrayBufferView
util.isArrayBufferView=function(x){return x&&util.isArrayBuffer(x.buffer)&&x.byteLength!==undefined;};/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */function _checkBitsParam(n){if(!(n===8||n===16||n===24||n===32)){throw new Error('Only 8, 16, 24, or 32 bits supported: '+n);}}// TODO: set ByteBuffer to best available backing
util.ByteBuffer=ByteStringBuffer;/** Buffer w/BinaryString backing */ /**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */function ByteStringBuffer(b){// TODO: update to match DataBuffer API
// the data in this buffer
this.data='';// the pointer for reading from this buffer
this.read=0;if(typeof b==='string'){this.data=b;}else if(util.isArrayBuffer(b)||util.isArrayBufferView(b)){if(typeof Buffer!=='undefined'&&b instanceof Buffer){this.data=b.toString('binary');}else{// convert native buffer to forge buffer
// FIXME: support native buffers internally instead
var arr=new Uint8Array(b);try{this.data=String.fromCharCode.apply(null,arr);}catch(e){for(var i=0;i<arr.length;++i){this.putByte(arr[i]);}}}}else if(b instanceof ByteStringBuffer||_typeof(b)==='object'&&typeof b.data==='string'&&typeof b.read==='number'){// copy existing buffer
this.data=b.data;this.read=b.read;}// used for v8 optimization
this._constructedStringLength=0;}util.ByteStringBuffer=ByteStringBuffer;/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */var _MAX_CONSTRUCTED_STRING_LENGTH=4096;util.ByteStringBuffer.prototype._optimizeConstructedString=function(x){this._constructedStringLength+=x;if(this._constructedStringLength>_MAX_CONSTRUCTED_STRING_LENGTH){// this substr() should cause the constructed string to join
this.data.substr(0,1);this._constructedStringLength=0;}};/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putByte=function(b){return this.putBytes(String.fromCharCode(b));};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.fillWithByte=function(b,n){b=String.fromCharCode(b);var d=this.data;while(n>0){if(n&1){d+=b;}n>>>=1;if(n>0){b+=b;}}this.data=d;this._optimizeConstructedString(n);return this;};/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a UTF-8 encoded string) to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBytes=function(bytes){this.data+=bytes;this._optimizeConstructedString(bytes.length);return this;};/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putString=function(str){return this.putBytes(util.encodeUtf8(str));};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16=function(i){return this.putBytes(String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24=function(i){return this.putBytes(String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32=function(i){return this.putBytes(String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF));};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt16Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF));};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt24Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF));};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt32Le=function(i){return this.putBytes(String.fromCharCode(i&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>24&0xFF));};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);var bytes='';do{n-=8;bytes+=String.fromCharCode(i>>n&0xFF);}while(n>0);return this.putBytes(bytes);};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putSignedInt=function(i,n){// putInt checks n
if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.putBuffer=function(buffer){return this.putBytes(buffer.getBytes());};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16=function(){var rval=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24=function(){var rval=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32=function(){var rval=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.ByteStringBuffer.prototype.getInt16Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.ByteStringBuffer.prototype.getInt24Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.ByteStringBuffer.prototype.getInt32Le=function(){var rval=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.charCodeAt(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.ByteStringBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.ByteStringBuffer.prototype.getBytes=function(count){var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.ByteStringBuffer.prototype.bytes=function(count){return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.ByteStringBuffer.prototype.at=function(i){return this.data.charCodeAt(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.setAt=function(i,b){this.data=this.data.substr(0,this.read+i)+String.fromCharCode(b)+this.data.substr(this.read+i+1);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.ByteStringBuffer.prototype.copy=function(){var c=util.createBuffer(this.data);c.read=this.read;return c;};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.compact=function(){if(this.read>0){this.data=this.data.slice(this.read);this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.clear=function(){this.data='';this.read=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.ByteStringBuffer.prototype.truncate=function(count){var len=Math.max(0,this.length()-count);this.data=this.data.substr(this.read,len);this.read=0;return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.ByteStringBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.length;++i){var b=this.data.charCodeAt(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */util.ByteStringBuffer.prototype.toString=function(){return util.decodeUtf8(this.bytes());};/** End Buffer w/BinaryString backing */ /** Buffer w/UInt8Array backing */ /**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */function DataBuffer(b,options){// default options
options=options||{};// pointers for read from/write to buffer
this.read=options.readOffset||0;this.growSize=options.growSize||1024;var isArrayBuffer=util.isArrayBuffer(b);var isArrayBufferView=util.isArrayBufferView(b);if(isArrayBuffer||isArrayBufferView){// use ArrayBuffer directly
if(isArrayBuffer){this.data=new DataView(b);}else{// TODO: adjust read/write offset based on the type of view
// or specify that this must be done in the options ... that the
// offsets are byte-based
this.data=new DataView(b.buffer,b.byteOffset,b.byteLength);}this.write='writeOffset'in options?options.writeOffset:this.data.byteLength;return;}// initialize to empty array buffer and add any given bytes using putBytes
this.data=new DataView(new ArrayBuffer(0));this.write=0;if(b!==null&&b!==undefined){this.putBytes(b);}if('writeOffset'in options){this.write=options.writeOffset;}}util.DataBuffer=DataBuffer;/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */util.DataBuffer.prototype.length=function(){return this.write-this.read;};/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */util.DataBuffer.prototype.isEmpty=function(){return this.length()<=0;};/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */util.DataBuffer.prototype.accommodate=function(amount,growSize){if(this.length()>=amount){return this;}growSize=Math.max(growSize||this.growSize,amount);// grow buffer
var src=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength);var dst=new Uint8Array(this.length()+growSize);dst.set(src);this.data=new DataView(dst.buffer);return this;};/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putByte=function(b){this.accommodate(1);this.data.setUint8(this.write++,b);return this;};/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.fillWithByte=function(b,n){this.accommodate(n);for(var i=0;i<n;++i){this.data.setUint8(b);}return this;};/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBytes=function(bytes,encoding){if(util.isArrayBufferView(bytes)){var src=new Uint8Array(bytes.buffer,bytes.byteOffset,bytes.byteLength);var len=src.byteLength-src.byteOffset;this.accommodate(len);var dst=new Uint8Array(this.data.buffer,this.write);dst.set(src);this.write+=len;return this;}if(util.isArrayBuffer(bytes)){var src=new Uint8Array(bytes);this.accommodate(src.byteLength);var dst=new Uint8Array(this.data.buffer);dst.set(src,this.write);this.write+=src.byteLength;return this;}// bytes is a util.DataBuffer or equivalent
if(bytes instanceof util.DataBuffer||_typeof(bytes)==='object'&&typeof bytes.read==='number'&&typeof bytes.write==='number'&&util.isArrayBufferView(bytes.data)){var src=new Uint8Array(bytes.data.byteLength,bytes.read,bytes.length());this.accommodate(src.byteLength);var dst=new Uint8Array(bytes.data.byteLength,this.write);dst.set(src);this.write+=src.byteLength;return this;}if(bytes instanceof util.ByteStringBuffer){// copy binary string and process as the same as a string parameter below
bytes=bytes.data;encoding='binary';}// string conversion
encoding=encoding||'binary';if(typeof bytes==='string'){var view;// decode from string
if(encoding==='hex'){this.accommodate(Math.ceil(bytes.length/2));view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.hex.decode(bytes,view,this.write);return this;}if(encoding==='base64'){this.accommodate(Math.ceil(bytes.length/4)*3);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.base64.decode(bytes,view,this.write);return this;}// encode text as UTF-8 bytes
if(encoding==='utf8'){// encode as UTF-8 then decode string as raw binary
bytes=util.encodeUtf8(bytes);encoding='binary';}// decode string as raw binary
if(encoding==='binary'||encoding==='raw'){// one byte per character
this.accommodate(bytes.length);view=new Uint8Array(this.data.buffer,this.write);this.write+=util.binary.raw.decode(view);return this;}// encode text as UTF-16 bytes
if(encoding==='utf16'){// two bytes per character
this.accommodate(bytes.length*2);view=new Uint16Array(this.data.buffer,this.write);this.write+=util.text.utf16.encode(view);return this;}throw new Error('Invalid encoding: '+encoding);}throw Error('Invalid parameter: '+bytes);};/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putBuffer=function(buffer){this.putBytes(buffer);buffer.clear();return this;};/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putString=function(str){return this.putBytes(str,'utf16');};/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16=function(i){this.accommodate(2);this.data.setInt16(this.write,i);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24=function(i){this.accommodate(3);this.data.setInt16(this.write,i>>8&0xFFFF);this.data.setInt8(this.write,i>>16&0xFF);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32=function(i){this.accommodate(4);this.data.setInt32(this.write,i);this.write+=4;return this;};/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt16Le=function(i){this.accommodate(2);this.data.setInt16(this.write,i,true);this.write+=2;return this;};/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt24Le=function(i){this.accommodate(3);this.data.setInt8(this.write,i>>16&0xFF);this.data.setInt16(this.write,i>>8&0xFFFF,true);this.write+=3;return this;};/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt32Le=function(i){this.accommodate(4);this.data.setInt32(this.write,i,true);this.write+=4;return this;};/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);do{n-=8;this.data.setInt8(this.write++,i>>n&0xFF);}while(n>0);return this;};/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.putSignedInt=function(i,n){_checkBitsParam(n);this.accommodate(n/8);if(i<0){i+=2<<n-1;}return this.putInt(i,n);};/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */util.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++);};/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16=function(){var rval=this.data.getInt16(this.read);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24=function(){var rval=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32=function(){var rval=this.data.getInt32(this.read);this.read+=4;return rval;};/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */util.DataBuffer.prototype.getInt16Le=function(){var rval=this.data.getInt16(this.read,true);this.read+=2;return rval;};/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */util.DataBuffer.prototype.getInt24Le=function(){var rval=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,true)<<8;this.read+=3;return rval;};/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */util.DataBuffer.prototype.getInt32Le=function(){var rval=this.data.getInt32(this.read,true);this.read+=4;return rval;};/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getInt=function(n){_checkBitsParam(n);var rval=0;do{// TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
rval=(rval<<8)+this.data.getInt8(this.read++);n-=8;}while(n>0);return rval;};/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */util.DataBuffer.prototype.getSignedInt=function(n){// getInt checks n
var x=this.getInt(n);var max=2<<n-2;if(x>=max){x-=max<<1;}return x;};/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */util.DataBuffer.prototype.getBytes=function(count){// TODO: deprecate this method, it is poorly named and
// this.toString('binary') replaces it
// add a toTypedArray()/toArrayBuffer() function
var rval;if(count){// read count bytes
count=Math.min(this.length(),count);rval=this.data.slice(this.read,this.read+count);this.read+=count;}else if(count===0){rval='';}else{// read all bytes, optimize to only copy when needed
rval=this.read===0?this.data:this.data.slice(this.read);this.clear();}return rval;};/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */util.DataBuffer.prototype.bytes=function(count){// TODO: deprecate this method, it is poorly named, add "getString()"
return typeof count==='undefined'?this.data.slice(this.read):this.data.slice(this.read,this.read+count);};/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */util.DataBuffer.prototype.at=function(i){return this.data.getUint8(this.read+i);};/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.setAt=function(i,b){this.data.setUint8(i,b);return this;};/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */util.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1);};/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */util.DataBuffer.prototype.copy=function(){return new util.DataBuffer(this);};/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.compact=function(){if(this.read>0){var src=new Uint8Array(this.data.buffer,this.read);var dst=new Uint8Array(src.byteLength);dst.set(src);this.data=new DataView(dst);this.write-=this.read;this.read=0;}return this;};/**
 * Clears this buffer.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.clear=function(){this.data=new DataView(new ArrayBuffer(0));this.read=this.write=0;return this;};/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */util.DataBuffer.prototype.truncate=function(count){this.write=Math.max(0,this.length()-count);this.read=Math.min(this.read,this.write);return this;};/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */util.DataBuffer.prototype.toHex=function(){var rval='';for(var i=this.read;i<this.data.byteLength;++i){var b=this.data.getUint8(i);if(b<16){rval+='0';}rval+=b.toString(16);}return rval;};/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */util.DataBuffer.prototype.toString=function(encoding){var view=new Uint8Array(this.data,this.read,this.length());encoding=encoding||'utf8';// encode to string
if(encoding==='binary'||encoding==='raw'){return util.binary.raw.encode(view);}if(encoding==='hex'){return util.binary.hex.encode(view);}if(encoding==='base64'){return util.binary.base64.encode(view);}// decode to text
if(encoding==='utf8'){return util.text.utf8.decode(view);}if(encoding==='utf16'){return util.text.utf16.decode(view);}throw new Error('Invalid encoding: '+encoding);};/** End Buffer w/UInt8Array backing */ /**
 * Creates a buffer that stores bytes. A value may be given to put into the
 * buffer that is either a string of bytes or a UTF-16 string that will
 * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).
 *
 * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode
 *          as UTF-8.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */util.createBuffer=function(input,encoding){// TODO: deprecate, use new ByteBuffer() instead
encoding=encoding||'raw';if(input!==undefined&&encoding==='utf8'){input=util.encodeUtf8(input);}return new util.ByteBuffer(input);};/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */util.fillString=function(c,n){var s='';while(n>0){if(n&1){s+=c;}n>>>=1;if(n>0){c+=c;}}return s;};/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */util.xorBytes=function(s1,s2,n){var s3='';var b='';var t='';var i=0;var c=0;for(;n>0;--n,++i){b=s1.charCodeAt(i)^s2.charCodeAt(i);if(c>=10){s3+=t;t='';c=0;}t+=String.fromCharCode(b);++c;}s3+=t;return s3;};/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */util.hexToBytes=function(hex){// TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
var rval='';var i=0;if(hex.length&1==1){// odd number of characters, convert first character alone
i=1;rval+=String.fromCharCode(parseInt(hex[0],16));}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){rval+=String.fromCharCode(parseInt(hex.substr(i,2),16));}return rval;};/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */util.bytesToHex=function(bytes){// TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
return util.createBuffer(bytes).toHex();};/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */util.int32ToBytes=function(i){return String.fromCharCode(i>>24&0xFF)+String.fromCharCode(i>>16&0xFF)+String.fromCharCode(i>>8&0xFF)+String.fromCharCode(i&0xFF);};// base64 characters, reverse mapping
var _base64='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';var _base64Idx=[/*43 -43 = 0*/ /*'+',  1,  2,  3,'/' */62,-1,-1,-1,63,/*'0','1','2','3','4','5','6','7','8','9' */52,53,54,55,56,57,58,59,60,61,/*15, 16, 17,'=', 19, 20, 21 */-1,-1,-1,64,-1,-1,-1,/*65 - 43 = 22*/ /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */0,1,2,3,4,5,6,7,8,9,10,11,12,/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */13,14,15,16,17,18,19,20,21,22,23,24,25,/*91 - 43 = 48 */ /*48, 49, 50, 51, 52, 53 */-1,-1,-1,-1,-1,-1,/*97 - 43 = 54*/ /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */26,27,28,29,30,31,32,33,34,35,36,37,38,/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */39,40,41,42,43,44,45,46,47,48,49,50,51];// base58 characters (Bitcoin alphabet)
var _base58='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */util.encode64=function(input,maxline){// TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.length){chr1=input.charCodeAt(i++);chr2=input.charCodeAt(i++);chr3=input.charCodeAt(i++);// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */util.decode64=function(input){// TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."
// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');var output='';var enc1,enc2,enc3,enc4;var i=0;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];output+=String.fromCharCode(enc1<<2|enc2>>4);if(enc3!==64){// decoded at least 2 bytes
output+=String.fromCharCode((enc2&15)<<4|enc3>>2);if(enc4!==64){// decoded 3 bytes
output+=String.fromCharCode((enc3&3)<<6|enc4);}}}return output;};/**
 * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript
 * string). Non-ASCII characters will be encoded as multiple bytes according
 * to UTF-8.
 *
 * @param str the string to encode.
 *
 * @return the UTF-8 encoded string.
 */util.encodeUtf8=function(str){return unescape(encodeURIComponent(str));};/**
 * Decodes a UTF-8 encoded string into a UTF-16 string.
 *
 * @param str the string to decode.
 *
 * @return the UTF-16 encoded string (standard JavaScript string).
 */util.decodeUtf8=function(str){return decodeURIComponent(escape(str));};// binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:baseN.encode,decode:baseN.decode}};/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */util.binary.raw.encode=function(bytes){return String.fromCharCode.apply(null,bytes);};/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.raw.decode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */util.binary.hex.encode=util.bytesToHex;/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.hex.decode=function(hex,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(hex.length/2));}offset=offset||0;var i=0,j=offset;if(hex.length&1){// odd number of characters, convert first character alone
i=1;out[j++]=parseInt(hex[0],16);}// convert 2 characters (1 byte) at a time
for(;i<hex.length;i+=2){out[j++]=parseInt(hex.substr(i,2),16);}return output?j-offset:out;};/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */util.binary.base64.encode=function(input,maxline){var line='';var output='';var chr1,chr2,chr3;var i=0;while(i<input.byteLength){chr1=input[i++];chr2=input[i++];chr3=input[i++];// encode 4 character group
line+=_base64.charAt(chr1>>2);line+=_base64.charAt((chr1&3)<<4|chr2>>4);if(isNaN(chr2)){line+='==';}else{line+=_base64.charAt((chr2&15)<<2|chr3>>6);line+=isNaN(chr3)?'=':_base64.charAt(chr3&63);}if(maxline&&line.length>maxline){output+=line.substr(0,maxline)+'\r\n';line=line.substr(maxline);}}output+=line;return output;};/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.binary.base64.decode=function(input,output,offset){var out=output;if(!out){out=new Uint8Array(Math.ceil(input.length/4)*3);}// remove all non-base64 characters
input=input.replace(/[^A-Za-z0-9\+\/\=]/g,'');offset=offset||0;var enc1,enc2,enc3,enc4;var i=0,j=offset;while(i<input.length){enc1=_base64Idx[input.charCodeAt(i++)-43];enc2=_base64Idx[input.charCodeAt(i++)-43];enc3=_base64Idx[input.charCodeAt(i++)-43];enc4=_base64Idx[input.charCodeAt(i++)-43];out[j++]=enc1<<2|enc2>>4;if(enc3!==64){// decoded at least 2 bytes
out[j++]=(enc2&15)<<4|enc3>>2;if(enc4!==64){// decoded 3 bytes
out[j++]=(enc3&3)<<6|enc4;}}}// make sure result is the exact decoded length
return output?j-offset:out.subarray(0,j);};// add support for base58 encoding/decoding with Bitcoin alphabet
util.binary.base58.encode=function(input,maxline){return util.binary.baseN.encode(input,_base58,maxline);};util.binary.base58.decode=function(input,maxline){return util.binary.baseN.decode(input,_base58,maxline);};// text encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.text={utf8:{},utf16:{}};/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf8.encode=function(str,output,offset){str=util.encodeUtf8(str);var out=output;if(!out){out=new Uint8Array(str.length);}offset=offset||0;var j=offset;for(var i=0;i<str.length;++i){out[j++]=str.charCodeAt(i);}return output?j-offset:out;};/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf8.decode=function(bytes){return util.decodeUtf8(String.fromCharCode.apply(null,bytes));};/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */util.text.utf16.encode=function(str,output,offset){var out=output;if(!out){out=new Uint8Array(str.length*2);}var view=new Uint16Array(out.buffer);offset=offset||0;var j=offset;var k=offset;for(var i=0;i<str.length;++i){view[k++]=str.charCodeAt(i);j+=2;}return output?j-offset:out;};/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */util.text.utf16.decode=function(bytes){return String.fromCharCode.apply(null,new Uint16Array(bytes.buffer));};/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */util.deflate=function(api,bytes,raw){bytes=util.decode64(api.deflate(util.encode64(bytes)).rval);// strip zlib header and trailer if necessary
if(raw){// zlib header is 2 bytes (CMF,FLG) where FLG indicates that
// there is a 4-byte DICT (alder-32) block before the data if
// its 5th bit is set
var start=2;var flg=bytes.charCodeAt(1);if(flg&0x20){start=6;}// zlib trailer is 4 bytes of adler-32
bytes=bytes.substring(start,bytes.length-4);}return bytes;};/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */util.inflate=function(api,bytes,raw){// TODO: add zlib header and trailer if necessary/possible
var rval=api.inflate(util.encode64(bytes)).rval;return rval===null?null:util.decode64(rval);};/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */var _setStorageObject=function _setStorageObject(api,id,obj){if(!api){throw new Error('WebStorage not available.');}var rval;if(obj===null){rval=api.removeItem(id);}else{// json-encode and base64-encode object
obj=util.encode64(JSON.stringify(obj));rval=api.setItem(id,obj);}// handle potential flash error
if(typeof rval!=='undefined'&&rval.rval!==true){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}};/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */var _getStorageObject=function _getStorageObject(api,id){if(!api){throw new Error('WebStorage not available.');}// get the existing entry
var rval=api.getItem(id);/* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */ // flash returns item wrapped in an object, handle special case
if(api.init){if(rval.rval===null){if(rval.error){var error=new Error(rval.error.message);error.id=rval.error.id;error.name=rval.error.name;throw error;}// no error, but also no item
rval=null;}else{rval=rval.rval;}}// handle decoding
if(rval!==null){// base64-decode and json-decode data
rval=JSON.parse(util.decode64(rval));}return rval;};/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */var _setItem=function _setItem(api,id,key,data){// get storage object
var obj=_getStorageObject(api,id);if(obj===null){// create a new storage object
obj={};}// update key
obj[key]=data;// set storage object
_setStorageObject(api,id,obj);};/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */var _getItem=function _getItem(api,id,key){// get storage object
var rval=_getStorageObject(api,id);if(rval!==null){// return data at key
rval=key in rval?rval[key]:null;}return rval;};/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */var _removeItem=function _removeItem(api,id,key){// get storage object
var obj=_getStorageObject(api,id);if(obj!==null&&key in obj){// remove key
delete obj[key];// see if entry has no keys remaining
var empty=true;for(var prop in obj){empty=false;break;}if(empty){// remove entry entirely if no keys are left
obj=null;}// set storage object
_setStorageObject(api,id,obj);}};/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */var _clearItems=function _clearItems(api,id){_setStorageObject(api,id,null);};/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */var _callStorageFunction=function _callStorageFunction(func,args,location){var rval=null;// default storage types
if(typeof location==='undefined'){location=['web','flash'];}// apply storage types in order of preference
var type;var done=false;var exception=null;for(var idx in location){type=location[idx];try{if(type==='flash'||type==='both'){if(args[0]===null){throw new Error('Flash local storage not available.');}rval=func.apply(this,args);done=type==='flash';}if(type==='web'||type==='both'){args[0]=localStorage;rval=func.apply(this,args);done=true;}}catch(ex){exception=ex;}if(done){break;}}if(!done){throw exception;}return rval;};/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */util.setItem=function(api,id,key,data,location){_callStorageFunction(_setItem,arguments,location);};/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */util.getItem=function(api,id,key,location){return _callStorageFunction(_getItem,arguments,location);};/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */util.removeItem=function(api,id,key,location){_callStorageFunction(_removeItem,arguments,location);};/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */util.clearItems=function(api,id,location){_callStorageFunction(_clearItems,arguments,location);};/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */util.parseUrl=function(str){// FIXME: this regex looks a bit broken
var regex=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;regex.lastIndex=0;var m=regex.exec(str);var url=m===null?null:{full:str,scheme:m[1],host:m[2],port:m[3],path:m[4]};if(url){url.fullHost=url.host;if(url.port){if(url.port!==80&&url.scheme==='http'){url.fullHost+=':'+url.port;}else if(url.port!==443&&url.scheme==='https'){url.fullHost+=':'+url.port;}}else if(url.scheme==='http'){url.port=80;}else if(url.scheme==='https'){url.port=443;}url.full=url.scheme+'://'+url.fullHost;}return url;};/* Storage for query variables */var _queryVariables=null;/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */util.getQueryVariables=function(query){var parse=function parse(q){var rval={};var kvpairs=q.split('&');for(var i=0;i<kvpairs.length;i++){var pos=kvpairs[i].indexOf('=');var key;var val;if(pos>0){key=kvpairs[i].substring(0,pos);val=kvpairs[i].substring(pos+1);}else{key=kvpairs[i];val=null;}if(!(key in rval)){rval[key]=[];}// disallow overriding object prototype keys
if(!(key in Object.prototype)&&val!==null){rval[key].push(unescape(val));}}return rval;};var rval;if(typeof query==='undefined'){// set cached variables if needed
if(_queryVariables===null){if(typeof window!=='undefined'&&window.location&&window.location.search){// parse window search query
_queryVariables=parse(window.location.search.substring(1));}else{// no query variables available
_queryVariables={};}}rval=_queryVariables;}else{// parse given query
rval=parse(query);}return rval;};/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */util.parseFragment=function(fragment){// default to whole fragment
var fp=fragment;var fq='';// split into path and query if possible at the first '?'
var pos=fragment.indexOf('?');if(pos>0){fp=fragment.substring(0,pos);fq=fragment.substring(pos+1);}// split path based on '/' and ignore first element if empty
var path=fp.split('/');if(path.length>0&&path[0]===''){path.shift();}// convert query into object
var query=fq===''?{}:util.getQueryVariables(fq);return{pathString:fp,queryString:fq,path:path,query:query};};/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */util.makeRequest=function(reqString){var frag=util.parseFragment(reqString);var req={// full path string
path:frag.pathString,// full query string
query:frag.queryString,/**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */getPath:function getPath(i){return typeof i==='undefined'?frag.path:frag.path[i];},/**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */getQuery:function getQuery(k,i){var rval;if(typeof k==='undefined'){rval=frag.query;}else{rval=frag.query[k];if(rval&&typeof i!=='undefined'){rval=rval[i];}}return rval;},getQueryLast:function getQueryLast(k,_default){var rval;var vals=req.getQuery(k);if(vals){rval=vals[vals.length-1];}else{rval=_default;}return rval;}};return req;};/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */util.makeLink=function(path,query,fragment){// join path parts if needed
path=jQuery.isArray(path)?path.join('/'):path;var qstr=jQuery.param(query||{});fragment=fragment||'';return path+(qstr.length>0?'?'+qstr:'')+(fragment.length>0?'#'+fragment:'');};/**
 * Follows a path of keys deep into an object hierarchy and set a value.
 * If a key does not exist or it's value is not an object, create an
 * object in it's place. This can be destructive to a object tree if
 * leaf nodes are given as non-final path keys.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param value the value to set.
 */util.setPath=function(object,keys,value){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
object[next]=value;}else{// more
var hasNext=next in object;if(!hasNext||hasNext&&_typeof(object[next])!=='object'||hasNext&&object[next]===null){object[next]={};}object=object[next];}}}};/**
 * Follows a path of keys deep into an object hierarchy and return a value.
 * If a key does not exist, create an object in it's place.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param _default value to return if path not found.
 *
 * @return the value at the path if found, else default if given, else
 *         undefined.
 */util.getPath=function(object,keys,_default){var i=0;var len=keys.length;var hasNext=true;while(hasNext&&i<len&&_typeof(object)==='object'&&object!==null){var next=keys[i++];hasNext=next in object;if(hasNext){object=object[next];}}return hasNext?object:_default;};/**
 * Follow a path of keys deep into an object hierarchy and delete the
 * last one. If a key does not exist, do nothing.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 */util.deletePath=function(object,keys){// need to start at an object
if(_typeof(object)==='object'&&object!==null){var i=0;var len=keys.length;while(i<len){var next=keys[i++];if(i==len){// last
delete object[next];}else{// more
if(!(next in object)||_typeof(object[next])!=='object'||object[next]===null){break;}object=object[next];}}}};/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */util.isEmpty=function(obj){for(var prop in obj){if(obj.hasOwnProperty(prop)){return false;}}return true;};/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */util.format=function(format){var re=/%./g;// current match
var match;// current part
var part;// current arg index
var argi=0;// collected parts to recombine later
var parts=[];// last index found
var last=0;// loop while matches remain
while(match=re.exec(format)){part=format.substring(last,re.lastIndex-2);// don't add empty strings (ie, parts between %s%s)
if(part.length>0){parts.push(part);}last=re.lastIndex;// switch on % code
var code=match[0][1];switch(code){case's':case'o':// check if enough arguments were given
if(argi<arguments.length){parts.push(arguments[argi++ +1]);}else{parts.push('<?>');}break;// FIXME: do proper formating for numbers, etc
//case 'f':
//case 'd':
case'%':parts.push('%');break;default:parts.push('<%'+code+'?>');}}// add trailing part of format string
parts.push(format.substring(last));return parts.join('');};/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */util.formatNumber=function(number,decimals,dec_point,thousands_sep){// http://kevin.vanzonneveld.net
// +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
// +     bugfix by: Michael White (http://crestidg.com)
// +     bugfix by: Benjamin Lupton
// +     bugfix by: Allan Jensen (http://www.winternet.no)
// +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
// *     example 1: number_format(1234.5678, 2, '.', '');
// *     returns 1: 1234.57
var n=number,c=isNaN(decimals=Math.abs(decimals))?2:decimals;var d=dec_point===undefined?',':dec_point;var t=thousands_sep===undefined?'.':thousands_sep,s=n<0?'-':'';var i=parseInt(n=Math.abs(+n||0).toFixed(c),10)+'';var j=i.length>3?i.length%3:0;return s+(j?i.substr(0,j)+t:'')+i.substr(j).replace(/(\d{3})(?=\d)/g,'$1'+t)+(c?d+Math.abs(n-i).toFixed(c).slice(2):'');};/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */util.formatSize=function(size){if(size>=1073741824){size=util.formatNumber(size/1073741824,2,'.','')+' GiB';}else if(size>=1048576){size=util.formatNumber(size/1048576,2,'.','')+' MiB';}else if(size>=1024){size=util.formatNumber(size/1024,0)+' KiB';}else{size=util.formatNumber(size,0)+' bytes';}return size;};/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */util.bytesFromIP=function(ip){if(ip.indexOf('.')!==-1){return util.bytesFromIPv4(ip);}if(ip.indexOf(':')!==-1){return util.bytesFromIPv6(ip);}return null;};/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */util.bytesFromIPv4=function(ip){ip=ip.split('.');if(ip.length!==4){return null;}var b=util.createBuffer();for(var i=0;i<ip.length;++i){var num=parseInt(ip[i],10);if(isNaN(num)){return null;}b.putByte(num);}return b.getBytes();};/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */util.bytesFromIPv6=function(ip){var blanks=0;ip=ip.split(':').filter(function(e){if(e.length===0)++blanks;return true;});var zeros=(8-ip.length+blanks)*2;var b=util.createBuffer();for(var i=0;i<8;++i){if(!ip[i]||ip[i].length===0){b.fillWithByte(0,zeros);zeros=0;continue;}var bytes=util.hexToBytes(ip[i]);if(bytes.length<2){b.putByte(0);}b.putBytes(bytes);}return b.getBytes();};/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */util.bytesToIP=function(bytes){if(bytes.length===4){return util.bytesToIPv4(bytes);}if(bytes.length===16){return util.bytesToIPv6(bytes);}return null;};/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */util.bytesToIPv4=function(bytes){if(bytes.length!==4){return null;}var ip=[];for(var i=0;i<bytes.length;++i){ip.push(bytes.charCodeAt(i));}return ip.join('.');};/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */util.bytesToIPv6=function(bytes){if(bytes.length!==16){return null;}var ip=[];var zeroGroups=[];var zeroMaxGroup=0;for(var i=0;i<bytes.length;i+=2){var hex=util.bytesToHex(bytes[i]+bytes[i+1]);// canonicalize zero representation
while(hex[0]==='0'&&hex!=='0'){hex=hex.substr(1);}if(hex==='0'){var last=zeroGroups[zeroGroups.length-1];var idx=ip.length;if(!last||idx!==last.end+1){zeroGroups.push({start:idx,end:idx});}else{last.end=idx;if(last.end-last.start>zeroGroups[zeroMaxGroup].end-zeroGroups[zeroMaxGroup].start){zeroMaxGroup=zeroGroups.length-1;}}}ip.push(hex);}if(zeroGroups.length>0){var group=zeroGroups[zeroMaxGroup];// only shorten group of length > 0
if(group.end-group.start>0){ip.splice(group.start,group.end-group.start+1,'');if(group.start===0){ip.unshift('');}if(group.end===7){ip.push('');}}}return ip.join(':');};/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */util.estimateCores=function(options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};if('cores'in util&&!options.update){return callback(null,util.cores);}if(typeof navigator!=='undefined'&&'hardwareConcurrency'in navigator&&navigator.hardwareConcurrency>0){util.cores=navigator.hardwareConcurrency;return callback(null,util.cores);}if(typeof Worker==='undefined'){// workers not available
util.cores=1;return callback(null,util.cores);}if(typeof Blob==='undefined'){// can't estimate, default to 2
util.cores=2;return callback(null,util.cores);}// create worker concurrency estimation code as blob
var blobUrl=URL.createObjectURL(new Blob(['(',function(){self.addEventListener('message',function(e){// run worker for 4 ms
var st=Date.now();var et=st+4;while(Date.now()<et){;}self.postMessage({st:st,et:et});});}.toString(),')()'],{type:'application/javascript'}));// take 5 samples using 16 workers
sample([],5,16);function sample(max,samples,numWorkers){if(samples===0){// get overlap average
var avg=Math.floor(max.reduce(function(avg,x){return avg+x;},0)/max.length);util.cores=Math.max(1,avg);URL.revokeObjectURL(blobUrl);return callback(null,util.cores);}map(numWorkers,function(err,results){max.push(reduce(numWorkers,results));sample(max,samples-1,numWorkers);});}function map(numWorkers,callback){var workers=[];var results=[];for(var i=0;i<numWorkers;++i){var worker=new Worker(blobUrl);worker.addEventListener('message',function(e){results.push(e.data);if(results.length===numWorkers){for(var i=0;i<numWorkers;++i){workers[i].terminate();}callback(null,results);}});workers.push(worker);}for(var i=0;i<numWorkers;++i){workers[i].postMessage(i);}}function reduce(numWorkers,results){// find overlapping time windows
var overlaps=[];for(var n=0;n<numWorkers;++n){var r1=results[n];var overlap=overlaps[n]=[];for(var i=0;i<numWorkers;++i){if(n===i){continue;}var r2=results[i];if(r1.st>r2.st&&r1.st<r2.et||r2.st>r1.st&&r2.st<r1.et){overlap.push(i);}}}// get maximum overlaps ... don't include overlapping worker itself
// as the main JS process was also being scheduled during the work and
// would have to be subtracted from the estimate anyway
return overlaps.reduce(function(max,overlap){return Math.max(max,overlap.length);},0);}};/***/},/* 2 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(3);/* ASN.1 API */var asn1=module.exports=forge.asn1=forge.asn1||{};/**
 * ASN.1 classes.
 */asn1.Class={UNIVERSAL:0x00,APPLICATION:0x40,CONTEXT_SPECIFIC:0x80,PRIVATE:0xC0};/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */asn1.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30};/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */asn1.create=function(tagClass,type,constructed,value,options){/* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */ // remove undefined values
if(forge.util.isArray(value)){var tmp=[];for(var i=0;i<value.length;++i){if(value[i]!==undefined){tmp.push(value[i]);}}value=tmp;}var obj={tagClass:tagClass,type:type,constructed:constructed,composed:constructed||forge.util.isArray(value),value:value};if(options&&'bitStringContents'in options){// TODO: copy byte buffer if it's a buffer not a string
obj.bitStringContents=options.bitStringContents;// TODO: add readonly flag to avoid this overhead
// save copy to detect changes
obj.original=asn1.copy(obj);}return obj;};/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */asn1.copy=function(obj,options){var copy;if(forge.util.isArray(obj)){copy=[];for(var i=0;i<obj.length;++i){copy.push(asn1.copy(obj[i],options));}return copy;}if(typeof obj==='string'){// TODO: copy byte buffer if it's a buffer not a string
return obj;}copy={tagClass:obj.tagClass,type:obj.type,constructed:obj.constructed,composed:obj.composed,value:asn1.copy(obj.value,options)};if(options&&!options.excludeBitStringContents){// TODO: copy byte buffer if it's a buffer not a string
copy.bitStringContents=obj.bitStringContents;}return copy;};/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */asn1.equals=function(obj1,obj2,options){if(forge.util.isArray(obj1)){if(!forge.util.isArray(obj2)){return false;}if(obj1.length!==obj2.length){return false;}for(var i=0;i<obj1.length;++i){if(!asn1.equals(obj1[i],obj2[i])){return false;}}return true;}if(_typeof(obj1)!==_typeof(obj2)){return false;}if(typeof obj1==='string'){return obj1===obj2;}var equal=obj1.tagClass===obj2.tagClass&&obj1.type===obj2.type&&obj1.constructed===obj2.constructed&&obj1.composed===obj2.composed&&asn1.equals(obj1.value,obj2.value);if(options&&options.includeBitStringContents){equal=equal&&obj1.bitStringContents===obj2.bitStringContents;}return equal;};/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */asn1.getBerValueLength=function(b){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
var b2=b.getByte();if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
length=b.getInt((b2&0x7F)<<3);}return length;};/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */function _checkBufferLength(bytes,remaining,n){if(n>remaining){var error=new Error('Too few bytes to parse DER.');error.available=bytes.length();error.remaining=remaining;error.requested=n;throw error;}}/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */var _getValueLength=function _getValueLength(bytes,remaining){// TODO: move this function and related DER/BER functions to a der.js
// file; better abstract ASN.1 away from der/ber.
// fromDer already checked that this byte exists
var b2=bytes.getByte();remaining--;if(b2===0x80){return undefined;}// see if the length is "short form" or "long form" (bit 8 set)
var length;var longForm=b2&0x80;if(!longForm){// length is just the first byte
length=b2;}else{// the number of bytes the length is specified in bits 7 through 1
// and each length byte is in big-endian base-256
var longFormBytes=b2&0x7F;_checkBufferLength(bytes,remaining,longFormBytes);length=bytes.getInt(longFormBytes<<3);}// FIXME: this will only happen for 32 bit getInt with high bit set
if(length<0){throw new Error('Negative length: '+length);}return length;};/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */asn1.fromDer=function(bytes,options){if(options===undefined){options={strict:true,decodeBitStrings:true};}if(typeof options==='boolean'){options={strict:options,decodeBitStrings:true};}if(!('strict'in options)){options.strict=true;}if(!('decodeBitStrings'in options)){options.decodeBitStrings=true;}// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}return _fromDer(bytes,bytes.length(),0,options);};/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */function _fromDer(bytes,remaining,depth,options){// temporary storage for consumption calculations
var start;// minimum length for ASN.1 DER structure is 2
_checkBufferLength(bytes,remaining,2);// get the first byte
var b1=bytes.getByte();// consumed one byte
remaining--;// get the tag class
var tagClass=b1&0xC0;// get the type (bits 1-5)
var type=b1&0x1F;// get the variable value length and adjust remaining bytes
start=bytes.length();var length=_getValueLength(bytes,remaining);remaining-=start-bytes.length();// ensure there are enough bytes to get the value
if(length!==undefined&&length>remaining){if(options.strict){var error=new Error('Too few bytes to read ASN.1 value.');error.available=bytes.length();error.remaining=remaining;error.requested=length;throw error;}// Note: be lenient with truncated values and use remaining state bytes
length=remaining;}// value storage
var value;// possible BIT STRING contents storage
var bitStringContents;// constructed flag is bit 6 (32 = 0x20) of the first byte
var constructed=(b1&0x20)===0x20;if(constructed){// parse child asn1 objects from the value
value=[];if(length===undefined){// asn1 object of indefinite length, read until end tag
for(;;){_checkBufferLength(bytes,remaining,2);if(bytes.bytes(2)===String.fromCharCode(0,0)){bytes.getBytes(2);remaining-=2;break;}start=bytes.length();value.push(_fromDer(bytes,remaining,depth+1,options));remaining-=start-bytes.length();}}else{// parsing asn1 object of definite length
while(length>0){start=bytes.length();value.push(_fromDer(bytes,length,depth+1,options));remaining-=start-bytes.length();length-=start-bytes.length();}}}// if a BIT STRING, save the contents including padding
if(value===undefined&&tagClass===asn1.Class.UNIVERSAL&&type===asn1.Type.BITSTRING){bitStringContents=bytes.bytes(length);}// determine if a non-constructed value should be decoded as a composed
// value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
// can be used this way.
if(value===undefined&&options.decodeBitStrings&&tagClass===asn1.Class.UNIVERSAL&&// FIXME: OCTET STRINGs not yet supported here
// .. other parts of forge expect to decode OCTET STRINGs manually
type===asn1.Type.BITSTRING/*|| type === asn1.Type.OCTETSTRING*/&&length>1){// save read position
var savedRead=bytes.read;var savedRemaining=remaining;var unused=0;if(type===asn1.Type.BITSTRING){/* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").

        The second and following octets give the value of the bit string
        converted to an octet string. */_checkBufferLength(bytes,remaining,1);unused=bytes.getByte();remaining--;}// if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs
if(unused===0){try{// attempt to parse child asn1 object from the value
// (stored in array to signal composed value)
start=bytes.length();var subOptions={// enforce strict mode to avoid parsing ASN.1 from plain data
verbose:options.verbose,strict:true,decodeBitStrings:true};var composed=_fromDer(bytes,remaining,depth+1,subOptions);var used=start-bytes.length();remaining-=used;if(type==asn1.Type.BITSTRING){used++;}// if the data all decoded and the class indicates UNIVERSAL or
// CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object
var tc=composed.tagClass;if(used===length&&(tc===asn1.Class.UNIVERSAL||tc===asn1.Class.CONTEXT_SPECIFIC)){value=[composed];}}catch(ex){}}if(value===undefined){// restore read position
bytes.read=savedRead;remaining=savedRemaining;}}if(value===undefined){// asn1 not constructed or composed, get raw value
// TODO: do DER to OID conversion and vice-versa in .toDer?
if(length===undefined){if(options.strict){throw new Error('Non-constructed ASN.1 object of indefinite length.');}// be lenient and use remaining state bytes
length=remaining;}if(type===asn1.Type.BMPSTRING){value='';for(;length>0;length-=2){_checkBufferLength(bytes,remaining,2);value+=String.fromCharCode(bytes.getInt16());remaining-=2;}}else{value=bytes.getBytes(length);}}// add BIT STRING contents if available
var asn1Options=bitStringContents===undefined?null:{bitStringContents:bitStringContents};// create and return asn1 object
return asn1.create(tagClass,type,constructed,value,asn1Options);}/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */asn1.toDer=function(obj){var bytes=forge.util.createBuffer();// build the first byte
var b1=obj.tagClass|obj.type;// for storing the ASN.1 value
var value=forge.util.createBuffer();// use BIT STRING contents if available and data not changed
var useBitStringContents=false;if('bitStringContents'in obj){useBitStringContents=true;if(obj.original){useBitStringContents=asn1.equals(obj,obj.original);}}if(useBitStringContents){value.putBytes(obj.bitStringContents);}else if(obj.composed){// if composed, use each child asn1 object's DER bytes as value
// turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
// from other asn1 objects
if(obj.constructed){b1|=0x20;}else{// type is a bit string, add unused bits of 0x00
value.putByte(0x00);}// add all of the child DER bytes together
for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){value.putBuffer(asn1.toDer(obj.value[i]));}}}else{// use asn1.value directly
if(obj.type===asn1.Type.BMPSTRING){for(var i=0;i<obj.value.length;++i){value.putInt16(obj.value.charCodeAt(i));}}else{// ensure integer is minimally-encoded
// TODO: should all leading bytes be stripped vs just one?
// .. ex '00 00 01' => '01'?
if(obj.type===asn1.Type.INTEGER&&obj.value.length>1&&(// leading 0x00 for positive integer
obj.value.charCodeAt(0)===0&&(obj.value.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
obj.value.charCodeAt(0)===0xFF&&(obj.value.charCodeAt(1)&0x80)===0x80)){value.putBytes(obj.value.substr(1));}else{value.putBytes(obj.value);}}}// add tag byte
bytes.putByte(b1);// use "short form" encoding
if(value.length()<=127){// one byte describes the length
// bit 8 = 0 and bits 7-1 = length
bytes.putByte(value.length()&0x7F);}else{// use "long form" encoding
// 2 to 127 bytes describe the length
// first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
// other bytes: length in base 256, big-endian
var len=value.length();var lenBytes='';do{lenBytes+=String.fromCharCode(len&0xFF);len=len>>>8;}while(len>0);// set first byte to # bytes used to store the length and turn on
// bit 8 to indicate long-form length is used
bytes.putByte(lenBytes.length|0x80);// concatenate length bytes in reverse since they were generated
// little endian and we need big endian
for(var i=lenBytes.length-1;i>=0;--i){bytes.putByte(lenBytes.charCodeAt(i));}}// concatenate value bytes
bytes.putBuffer(value);return bytes;};/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */asn1.oidToDer=function(oid){// split OID into individual values
var values=oid.split('.');var bytes=forge.util.createBuffer();// first byte is 40 * value1 + value2
bytes.putByte(40*parseInt(values[0],10)+parseInt(values[1],10));// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var last,valueBytes,value,b;for(var i=2;i<values.length;++i){// produce value bytes in reverse because we don't know how many
// bytes it will take to store the value
last=true;valueBytes=[];value=parseInt(values[i],10);do{b=value&0x7F;value=value>>>7;// if value is not last, then turn on 8th bit
if(!last){b|=0x80;}valueBytes.push(b);last=false;}while(value>0);// add value bytes in reverse (needs to be in big endian)
for(var n=valueBytes.length-1;n>=0;--n){bytes.putByte(valueBytes[n]);}}return bytes;};/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */asn1.derToOid=function(bytes){var oid;// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}// first byte is 40 * value1 + value2
var b=bytes.getByte();oid=Math.floor(b/40)+'.'+b%40;// other bytes are each value in base 128 with 8th bit set except for
// the last byte for each value
var value=0;while(bytes.length()>0){b=bytes.getByte();value=value<<7;// not the last byte for the value
if(b&0x80){value+=b&0x7F;}else{// last byte
oid+='.'+(value+b);value=0;}}return oid;};/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */asn1.utcTimeToDate=function(utc){/* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();// if YY >= 50 use 19xx, if YY < 50 use 20xx
var year=parseInt(utc.substr(0,2),10);year=year>=50?1900+year:2000+year;var MM=parseInt(utc.substr(2,2),10)-1;// use 0-11 for month
var DD=parseInt(utc.substr(4,2),10);var hh=parseInt(utc.substr(6,2),10);var mm=parseInt(utc.substr(8,2),10);var ss=0;// not just YYMMDDhhmmZ
if(utc.length>11){// get character after minutes
var c=utc.charAt(10);var end=10;// see if seconds are present
if(c!=='+'&&c!=='-'){// get seconds
ss=parseInt(utc.substr(10,2),10);end+=2;}}// update date
date.setUTCFullYear(year,MM,DD);date.setUTCHours(hh,mm,ss,0);if(end){// get +/- after end of time
c=utc.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(utc.substr(end+1,2),10);var mmoffset=parseInt(utc.substr(end+4,2),10);// calculate offset in milliseconds
var offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){date.setTime(+date-offset);}else{date.setTime(+date+offset);}}}return date;};/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */asn1.generalizedTimeToDate=function(gentime){/* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */var date=new Date();var YYYY=parseInt(gentime.substr(0,4),10);var MM=parseInt(gentime.substr(4,2),10)-1;// use 0-11 for month
var DD=parseInt(gentime.substr(6,2),10);var hh=parseInt(gentime.substr(8,2),10);var mm=parseInt(gentime.substr(10,2),10);var ss=parseInt(gentime.substr(12,2),10);var fff=0;var offset=0;var isUTC=false;if(gentime.charAt(gentime.length-1)==='Z'){isUTC=true;}var end=gentime.length-5,c=gentime.charAt(end);if(c==='+'||c==='-'){// get hours+minutes offset
var hhoffset=parseInt(gentime.substr(end+1,2),10);var mmoffset=parseInt(gentime.substr(end+4,2),10);// calculate offset in milliseconds
offset=hhoffset*60+mmoffset;offset*=60000;// apply offset
if(c==='+'){offset*=-1;}isUTC=true;}// check for second fraction
if(gentime.charAt(14)==='.'){fff=parseFloat(gentime.substr(14),10)*1000;}if(isUTC){date.setUTCFullYear(YYYY,MM,DD);date.setUTCHours(hh,mm,ss,fff);// apply offset
date.setTime(+date+offset);}else{date.setFullYear(YYYY,MM,DD);date.setHours(hh,mm,ss,fff);}return date;};/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */asn1.dateToUtcTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYMMDDhhmmssZ
var format=[];format.push((''+date.getUTCFullYear()).substr(2));format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */asn1.dateToGeneralizedTime=function(date){// TODO: validate; currently assumes proper format
if(typeof date==='string'){return date;}var rval='';// create format YYYYMMDDHHMMSSZ
var format=[];format.push(''+date.getUTCFullYear());format.push(''+(date.getUTCMonth()+1));format.push(''+date.getUTCDate());format.push(''+date.getUTCHours());format.push(''+date.getUTCMinutes());format.push(''+date.getUTCSeconds());// ensure 2 digits are used for each format entry
for(var i=0;i<format.length;++i){if(format[i].length<2){rval+='0';}rval+=format[i];}rval+='Z';return rval;};/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */asn1.integerToDer=function(x){var rval=forge.util.createBuffer();if(x>=-0x80&&x<0x80){return rval.putSignedInt(x,8);}if(x>=-0x8000&&x<0x8000){return rval.putSignedInt(x,16);}if(x>=-0x800000&&x<0x800000){return rval.putSignedInt(x,24);}if(x>=-0x80000000&&x<0x80000000){return rval.putSignedInt(x,32);}var error=new Error('Integer too large; max is 32-bits.');error.integer=x;throw error;};/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */asn1.derToInteger=function(bytes){// wrap in buffer if needed
if(typeof bytes==='string'){bytes=forge.util.createBuffer(bytes);}var n=bytes.length()*8;if(n>32){throw new Error('Integer too large; max is 32-bits.');}return bytes.getSignedInt(n);};/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */asn1.validate=function(obj,v,capture,errors){var rval=false;// ensure tag class and type are the same if specified
if((obj.tagClass===v.tagClass||typeof v.tagClass==='undefined')&&(obj.type===v.type||typeof v.type==='undefined')){// ensure constructed flag is the same if specified
if(obj.constructed===v.constructed||typeof v.constructed==='undefined'){rval=true;// handle sub values
if(v.value&&forge.util.isArray(v.value)){var j=0;for(var i=0;rval&&i<v.value.length;++i){rval=v.value[i].optional||false;if(obj.value[j]){rval=asn1.validate(obj.value[j],v.value[i],capture,errors);if(rval){++j;}else if(v.value[i].optional){rval=true;}}if(!rval&&errors){errors.push('['+v.name+'] '+'Tag class "'+v.tagClass+'", type "'+v.type+'" expected value length "'+v.value.length+'", got "'+obj.value.length+'"');}}}if(rval&&capture){if(v.capture){capture[v.capture]=obj.value;}if(v.captureAsn1){capture[v.captureAsn1]=obj;}if(v.captureBitStringContents&&'bitStringContents'in obj){capture[v.captureBitStringContents]=obj.bitStringContents;}if(v.captureBitStringValue&&'bitStringContents'in obj){var value;if(obj.bitStringContents.length<2){capture[v.captureBitStringValue]='';}else{// FIXME: support unused bits with data shifting
var unused=obj.bitStringContents.charCodeAt(0);if(unused!==0){throw new Error('captureBitStringValue only supported for zero unused bits');}capture[v.captureBitStringValue]=obj.bitStringContents.slice(1);}}}}else if(errors){errors.push('['+v.name+'] '+'Expected constructed "'+v.constructed+'", got "'+obj.constructed+'"');}}else if(errors){if(obj.tagClass!==v.tagClass){errors.push('['+v.name+'] '+'Expected tag class "'+v.tagClass+'", got "'+obj.tagClass+'"');}if(obj.type!==v.type){errors.push('['+v.name+'] '+'Expected type "'+v.type+'", got "'+obj.type+'"');}}return rval;};// regex for testing for non-latin characters
var _nonLatinRegex=/[^\\u0000-\\u00ff]/;/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */asn1.prettyPrint=function(obj,level,indentation){var rval='';// set default level and indentation
level=level||0;indentation=indentation||2;// start new line for deep levels
if(level>0){rval+='\n';}// create indent
var indent='';for(var i=0;i<level*indentation;++i){indent+=' ';}// print class:type
rval+=indent+'Tag: ';switch(obj.tagClass){case asn1.Class.UNIVERSAL:rval+='Universal:';break;case asn1.Class.APPLICATION:rval+='Application:';break;case asn1.Class.CONTEXT_SPECIFIC:rval+='Context-Specific:';break;case asn1.Class.PRIVATE:rval+='Private:';break;}if(obj.tagClass===asn1.Class.UNIVERSAL){rval+=obj.type;// known types
switch(obj.type){case asn1.Type.NONE:rval+=' (None)';break;case asn1.Type.BOOLEAN:rval+=' (Boolean)';break;case asn1.Type.INTEGER:rval+=' (Integer)';break;case asn1.Type.BITSTRING:rval+=' (Bit string)';break;case asn1.Type.OCTETSTRING:rval+=' (Octet string)';break;case asn1.Type.NULL:rval+=' (Null)';break;case asn1.Type.OID:rval+=' (Object Identifier)';break;case asn1.Type.ODESC:rval+=' (Object Descriptor)';break;case asn1.Type.EXTERNAL:rval+=' (External or Instance of)';break;case asn1.Type.REAL:rval+=' (Real)';break;case asn1.Type.ENUMERATED:rval+=' (Enumerated)';break;case asn1.Type.EMBEDDED:rval+=' (Embedded PDV)';break;case asn1.Type.UTF8:rval+=' (UTF8)';break;case asn1.Type.ROID:rval+=' (Relative Object Identifier)';break;case asn1.Type.SEQUENCE:rval+=' (Sequence)';break;case asn1.Type.SET:rval+=' (Set)';break;case asn1.Type.PRINTABLESTRING:rval+=' (Printable String)';break;case asn1.Type.IA5String:rval+=' (IA5String (ASCII))';break;case asn1.Type.UTCTIME:rval+=' (UTC time)';break;case asn1.Type.GENERALIZEDTIME:rval+=' (Generalized time)';break;case asn1.Type.BMPSTRING:rval+=' (BMP String)';break;}}else{rval+=obj.type;}rval+='\n';rval+=indent+'Constructed: '+obj.constructed+'\n';if(obj.composed){var subvalues=0;var sub='';for(var i=0;i<obj.value.length;++i){if(obj.value[i]!==undefined){subvalues+=1;sub+=asn1.prettyPrint(obj.value[i],level+1,indentation);if(i+1<obj.value.length){sub+=',';}}}rval+=indent+'Sub values: '+subvalues+sub;}else{rval+=indent+'Value: ';if(obj.type===asn1.Type.OID){var oid=asn1.derToOid(obj.value);rval+=oid;if(forge.pki&&forge.pki.oids){if(oid in forge.pki.oids){rval+=' ('+forge.pki.oids[oid]+') ';}}}if(obj.type===asn1.Type.INTEGER){try{rval+=asn1.derToInteger(obj.value);}catch(ex){rval+='0x'+forge.util.bytesToHex(obj.value);}}else if(obj.type===asn1.Type.BITSTRING){// TODO: shift bits as needed to display without padding
if(obj.value.length>1){// remove unused bits field
rval+='0x'+forge.util.bytesToHex(obj.value.slice(1));}else{rval+='(none)';}// show unused bit count
if(obj.value.length>0){var unused=obj.value.charCodeAt(0);if(unused==1){rval+=' (1 unused bit shown)';}else if(unused>1){rval+=' ('+unused+' unused bits shown)';}}}else if(obj.type===asn1.Type.OCTETSTRING){if(!_nonLatinRegex.test(obj.value)){rval+='('+obj.value+') ';}rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.type===asn1.Type.UTF8){rval+=forge.util.decodeUtf8(obj.value);}else if(obj.type===asn1.Type.PRINTABLESTRING||obj.type===asn1.Type.IA5String){rval+=obj.value;}else if(_nonLatinRegex.test(obj.value)){rval+='0x'+forge.util.bytesToHex(obj.value);}else if(obj.value.length===0){rval+='[null]';}else{rval+=obj.value;}}return rval;};/***/},/* 3 */ /***/function(module,exports,__webpack_require__){/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);forge.pki=forge.pki||{};var oids=module.exports=forge.pki.oids=forge.oids=forge.oids||{};// set id to name mapping and name to id mapping
function _IN(id,name){oids[id]=name;oids[name]=id;}// set id to name mapping only
function _I_(id,name){oids[id]=name;}// algorithm OIDs
_IN('1.2.840.113549.1.1.1','rsaEncryption');// Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
_IN('1.2.840.113549.1.1.4','md5WithRSAEncryption');_IN('1.2.840.113549.1.1.5','sha1WithRSAEncryption');_IN('1.2.840.113549.1.1.7','RSAES-OAEP');_IN('1.2.840.113549.1.1.8','mgf1');_IN('1.2.840.113549.1.1.9','pSpecified');_IN('1.2.840.113549.1.1.10','RSASSA-PSS');_IN('1.2.840.113549.1.1.11','sha256WithRSAEncryption');_IN('1.2.840.113549.1.1.12','sha384WithRSAEncryption');_IN('1.2.840.113549.1.1.13','sha512WithRSAEncryption');_IN('1.2.840.10040.4.3','dsa-with-sha1');_IN('1.3.14.3.2.7','desCBC');_IN('1.3.14.3.2.26','sha1');_IN('2.16.840.1.101.3.4.2.1','sha256');_IN('2.16.840.1.101.3.4.2.2','sha384');_IN('2.16.840.1.101.3.4.2.3','sha512');_IN('1.2.840.113549.2.5','md5');// pkcs#7 content types
_IN('1.2.840.113549.1.7.1','data');_IN('1.2.840.113549.1.7.2','signedData');_IN('1.2.840.113549.1.7.3','envelopedData');_IN('1.2.840.113549.1.7.4','signedAndEnvelopedData');_IN('1.2.840.113549.1.7.5','digestedData');_IN('1.2.840.113549.1.7.6','encryptedData');// pkcs#9 oids
_IN('1.2.840.113549.1.9.1','emailAddress');_IN('1.2.840.113549.1.9.2','unstructuredName');_IN('1.2.840.113549.1.9.3','contentType');_IN('1.2.840.113549.1.9.4','messageDigest');_IN('1.2.840.113549.1.9.5','signingTime');_IN('1.2.840.113549.1.9.6','counterSignature');_IN('1.2.840.113549.1.9.7','challengePassword');_IN('1.2.840.113549.1.9.8','unstructuredAddress');_IN('1.2.840.113549.1.9.14','extensionRequest');_IN('1.2.840.113549.1.9.20','friendlyName');_IN('1.2.840.113549.1.9.21','localKeyId');_IN('1.2.840.113549.1.9.22.1','x509Certificate');// pkcs#12 safe bags
_IN('1.2.840.113549.1.12.10.1.1','keyBag');_IN('1.2.840.113549.1.12.10.1.2','pkcs8ShroudedKeyBag');_IN('1.2.840.113549.1.12.10.1.3','certBag');_IN('1.2.840.113549.1.12.10.1.4','crlBag');_IN('1.2.840.113549.1.12.10.1.5','secretBag');_IN('1.2.840.113549.1.12.10.1.6','safeContentsBag');// password-based-encryption for pkcs#12
_IN('1.2.840.113549.1.5.13','pkcs5PBES2');_IN('1.2.840.113549.1.5.12','pkcs5PBKDF2');_IN('1.2.840.113549.1.12.1.1','pbeWithSHAAnd128BitRC4');_IN('1.2.840.113549.1.12.1.2','pbeWithSHAAnd40BitRC4');_IN('1.2.840.113549.1.12.1.3','pbeWithSHAAnd3-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.4','pbeWithSHAAnd2-KeyTripleDES-CBC');_IN('1.2.840.113549.1.12.1.5','pbeWithSHAAnd128BitRC2-CBC');_IN('1.2.840.113549.1.12.1.6','pbewithSHAAnd40BitRC2-CBC');// hmac OIDs
_IN('1.2.840.113549.2.7','hmacWithSHA1');_IN('1.2.840.113549.2.8','hmacWithSHA224');_IN('1.2.840.113549.2.9','hmacWithSHA256');_IN('1.2.840.113549.2.10','hmacWithSHA384');_IN('1.2.840.113549.2.11','hmacWithSHA512');// symmetric key algorithm oids
_IN('1.2.840.113549.3.7','des-EDE3-CBC');_IN('2.16.840.1.101.3.4.1.2','aes128-CBC');_IN('2.16.840.1.101.3.4.1.22','aes192-CBC');_IN('2.16.840.1.101.3.4.1.42','aes256-CBC');// certificate issuer/subject OIDs
_IN('2.5.4.3','commonName');_IN('2.5.4.5','serialName');_IN('2.5.4.6','countryName');_IN('2.5.4.7','localityName');_IN('2.5.4.8','stateOrProvinceName');_IN('2.5.4.10','organizationName');_IN('2.5.4.11','organizationalUnitName');_IN('2.5.4.13','description');// X.509 extension OIDs
_IN('2.16.840.1.113730.1.1','nsCertType');_I_('2.5.29.1','authorityKeyIdentifier');// deprecated, use .35
_I_('2.5.29.2','keyAttributes');// obsolete use .37 or .15
_I_('2.5.29.3','certificatePolicies');// deprecated, use .32
_I_('2.5.29.4','keyUsageRestriction');// obsolete use .37 or .15
_I_('2.5.29.5','policyMapping');// deprecated use .33
_I_('2.5.29.6','subtreesConstraint');// obsolete use .30
_I_('2.5.29.7','subjectAltName');// deprecated use .17
_I_('2.5.29.8','issuerAltName');// deprecated use .18
_I_('2.5.29.9','subjectDirectoryAttributes');_I_('2.5.29.10','basicConstraints');// deprecated use .19
_I_('2.5.29.11','nameConstraints');// deprecated use .30
_I_('2.5.29.12','policyConstraints');// deprecated use .36
_I_('2.5.29.13','basicConstraints');// deprecated use .19
_IN('2.5.29.14','subjectKeyIdentifier');_IN('2.5.29.15','keyUsage');_I_('2.5.29.16','privateKeyUsagePeriod');_IN('2.5.29.17','subjectAltName');_IN('2.5.29.18','issuerAltName');_IN('2.5.29.19','basicConstraints');_I_('2.5.29.20','cRLNumber');_I_('2.5.29.21','cRLReason');_I_('2.5.29.22','expirationDate');_I_('2.5.29.23','instructionCode');_I_('2.5.29.24','invalidityDate');_I_('2.5.29.25','cRLDistributionPoints');// deprecated use .31
_I_('2.5.29.26','issuingDistributionPoint');// deprecated use .28
_I_('2.5.29.27','deltaCRLIndicator');_I_('2.5.29.28','issuingDistributionPoint');_I_('2.5.29.29','certificateIssuer');_I_('2.5.29.30','nameConstraints');_IN('2.5.29.31','cRLDistributionPoints');_IN('2.5.29.32','certificatePolicies');_I_('2.5.29.33','policyMappings');_I_('2.5.29.34','policyConstraints');// deprecated use .36
_IN('2.5.29.35','authorityKeyIdentifier');_I_('2.5.29.36','policyConstraints');_IN('2.5.29.37','extKeyUsage');_I_('2.5.29.46','freshestCRL');_I_('2.5.29.54','inhibitAnyPolicy');// extKeyUsage purposes
_IN('1.3.6.1.4.1.11129.2.4.2','timestampList');_IN('1.3.6.1.5.5.7.1.1','authorityInfoAccess');_IN('1.3.6.1.5.5.7.3.1','serverAuth');_IN('1.3.6.1.5.5.7.3.2','clientAuth');_IN('1.3.6.1.5.5.7.3.3','codeSigning');_IN('1.3.6.1.5.5.7.3.4','emailProtection');_IN('1.3.6.1.5.5.7.3.8','timeStamping');/***/},/* 4 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);module.exports=forge.md=forge.md||{};forge.md.algorithms=forge.md.algorithms||{};/***/},/* 5 */ /***/function(module,exports,__webpack_require__){/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(23);__webpack_require__(24);__webpack_require__(1);(function(){// forge.random already defined
if(forge.random&&forge.random.getBytes){module.exports=forge.random;return;}(function(jQuery){// the default prng plugin, uses AES-128
var prng_aes={};var _prng_aes_output=new Array(4);var _prng_aes_buffer=forge.util.createBuffer();prng_aes.formatKey=function(key){// convert the key into 32-bit integers
var tmp=forge.util.createBuffer(key);key=new Array(4);key[0]=tmp.getInt32();key[1]=tmp.getInt32();key[2]=tmp.getInt32();key[3]=tmp.getInt32();// return the expanded key
return forge.aes._expandKey(key,false);};prng_aes.formatSeed=function(seed){// convert seed into 32-bit integers
var tmp=forge.util.createBuffer(seed);seed=new Array(4);seed[0]=tmp.getInt32();seed[1]=tmp.getInt32();seed[2]=tmp.getInt32();seed[3]=tmp.getInt32();return seed;};prng_aes.cipher=function(key,seed){forge.aes._updateBlock(key,seed,_prng_aes_output,false);_prng_aes_buffer.putInt32(_prng_aes_output[0]);_prng_aes_buffer.putInt32(_prng_aes_output[1]);_prng_aes_buffer.putInt32(_prng_aes_output[2]);_prng_aes_buffer.putInt32(_prng_aes_output[3]);return _prng_aes_buffer.getBytes();};prng_aes.increment=function(seed){// FIXME: do we care about carry or signed issues?
++seed[3];return seed;};prng_aes.md=forge.md.sha256;/**
 * Creates a new PRNG.
 */function spawnPrng(){var ctx=forge.prng.create(prng_aes);/**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */ctx.getBytes=function(count,callback){return ctx.generate(count,callback);};/**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */ctx.getBytesSync=function(count){return ctx.generate(count);};return ctx;}// create default prng context
var _ctx=spawnPrng();// add other sources of entropy only if window.crypto.getRandomValues is not
// available -- otherwise this source will be automatically used by the prng
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}if(forge.options.usePureJavaScript||!forge.util.isNodejs&&!getRandomValues){// if this is a web worker, do not use weak entropy, instead register to
// receive strong entropy asynchronously from the main thread
if(typeof window==='undefined'||window.document===undefined){}// FIXME:
// get load time entropy
_ctx.collectInt(+new Date(),32);// add some entropy from navigator object
if(typeof navigator!=='undefined'){var _navBytes='';for(var key in navigator){try{if(typeof navigator[key]=='string'){_navBytes+=navigator[key];}}catch(e){/* Some navigator keys might not be accessible, e.g. the geolocation
          attribute throws an exception if touched in Mozilla chrome://
          context.

          Silently ignore this and just don't use this as a source of
          entropy. */}}_ctx.collect(_navBytes);_navBytes=null;}// add mouse and keyboard collectors if jquery is available
if(jQuery){// set up mouse entropy capture
jQuery().mousemove(function(e){// add mouse coords
_ctx.collectInt(e.clientX,16);_ctx.collectInt(e.clientY,16);});// set up keyboard entropy capture
jQuery().keypress(function(e){_ctx.collectInt(e.charCode,8);});}}/* Random API */if(!forge.random){forge.random=_ctx;}else{// extend forge.random with _ctx
for(var key in _ctx){forge.random[key]=_ctx[key];}}// expose spawn PRNG
forge.random.createInstance=spawnPrng;module.exports=forge.random;})(typeof jQuery!=='undefined'?jQuery:null);})();/***/},/* 6 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(16);__webpack_require__(3);__webpack_require__(26);__webpack_require__(27);__webpack_require__(5);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/*
 * RSA encryption and decryption, see RFC 2313.
 */forge.pki=forge.pki||{};module.exports=forge.pki.rsa=forge.rsa=forge.rsa||{};var pki=forge.pki;// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];// validator for a PrivateKeyInfo structure
var privateKeyValidator={// PrivateKeyInfo
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'PrivateKeyInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// privateKeyAlgorithm
name:'PrivateKeyInfo.privateKeyAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'privateKeyOid'}]},{// PrivateKey
name:'PrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'privateKey'}]};// validator for an RSA private key
var rsaPrivateKeyValidator={// RSAPrivateKey
name:'RSAPrivateKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// Version (INTEGER)
name:'RSAPrivateKey.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyVersion'},{// modulus (n)
name:'RSAPrivateKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyModulus'},{// publicExponent (e)
name:'RSAPrivateKey.publicExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPublicExponent'},{// privateExponent (d)
name:'RSAPrivateKey.privateExponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrivateExponent'},{// prime1 (p)
name:'RSAPrivateKey.prime1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime1'},{// prime2 (q)
name:'RSAPrivateKey.prime2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyPrime2'},{// exponent1 (d mod (p-1))
name:'RSAPrivateKey.exponent1',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent1'},{// exponent2 (d mod (q-1))
name:'RSAPrivateKey.exponent2',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyExponent2'},{// coefficient ((inverse of q) mod p)
name:'RSAPrivateKey.coefficient',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'privateKeyCoefficient'}]};// validator for an RSA public key
var rsaPublicKeyValidator={// RSAPublicKey
name:'RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// modulus (n)
name:'RSAPublicKey.modulus',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyModulus'},{// publicExponent (e)
name:'RSAPublicKey.exponent',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'publicKeyExponent'}]};// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator={name:'SubjectPublicKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'subjectPublicKeyInfo',value:[{name:'SubjectPublicKeyInfo.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'publicKeyOid'}]},{// subjectPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,value:[{// RSAPublicKey
name:'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'rsaPublicKey'}]}]};/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */var emsaPkcs1v15encode=function emsaPkcs1v15encode(md){// get the oid for the algorithm
var oid;if(md.algorithm in pki.oids){oid=pki.oids[md.algorithm];}else{var error=new Error('Unknown message digest algorithm.');error.algorithm=md.algorithm;throw error;}var oidBytes=asn1.oidToDer(oid).getBytes();// create the digest info
var digestInfo=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var digestAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,oidBytes));digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,''));var digest=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,md.digest().getBytes());digestInfo.value.push(digestAlgorithm);digestInfo.value.push(digest);// encode digest info
return asn1.toDer(digestInfo).getBytes();};/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */var _modPow=function _modPow(x,key,pub){if(pub){return x.modPow(key.e,key.n);}if(!key.p||!key.q){// allow calculation without CRT params (slow)
return x.modPow(key.d,key.n);}// pre-compute dP, dQ, and qInv if necessary
if(!key.dP){key.dP=key.d.mod(key.p.subtract(BigInteger.ONE));}if(!key.dQ){key.dQ=key.d.mod(key.q.subtract(BigInteger.ONE));}if(!key.qInv){key.qInv=key.q.modInverse(key.p);}/* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */ // cryptographic blinding
var r;do{r=new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength()/8)),16);}while(r.compareTo(key.n)>=0||!r.gcd(key.n).equals(BigInteger.ONE));x=x.multiply(r.modPow(key.e,key.n)).mod(key.n);// calculate xp and xq
var xp=x.mod(key.p).modPow(key.dP,key.p);var xq=x.mod(key.q).modPow(key.dQ,key.q);// xp must be larger than xq to avoid signed bit usage
while(xp.compareTo(xq)<0){xp=xp.add(key.p);}// do last step
var y=xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);// remove effect of random for cryptographic blinding
y=y.multiply(r.modInverse(key.n)).mod(key.n);return y;};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */pki.rsa.encrypt=function(m,key,bt){var pub=bt;var eb;// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);if(bt!==false&&bt!==true){// legacy, default to PKCS#1 v1.5 padding
pub=bt===0x02;eb=_encodePkcs1_v1_5(m,key,bt);}else{eb=forge.util.createBuffer();eb.putBytes(m);}// load encryption block as big integer 'x'
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var x=new BigInteger(eb.toHex(),16);// do RSA encryption
var y=_modPow(x,key,pub);// convert y into the encrypted data byte string, if y is shorter in
// bytes than k, then prepend zero bytes to fill up ed
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var yhex=y.toString(16);var ed=forge.util.createBuffer();var zeros=k-Math.ceil(yhex.length/2);while(zeros>0){ed.putByte(0x00);--zeros;}ed.putBytes(forge.util.hexToBytes(yhex));return ed.getBytes();};/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */pki.rsa.decrypt=function(ed,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);// error if the length of the encrypted data ED is not k
if(ed.length!==k){var error=new Error('Encrypted message length is invalid.');error.length=ed.length;error.expected=k;throw error;}// convert encrypted data into a big integer
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var y=new BigInteger(forge.util.createBuffer(ed).toHex(),16);// y must be less than the modulus or it wasn't the result of
// a previous mod operation (encryption) using that modulus
if(y.compareTo(key.n)>=0){throw new Error('Encrypted message is invalid.');}// do RSA decryption
var x=_modPow(y,key,pub);// create the encryption block, if x is shorter in bytes than k, then
// prepend zero bytes to fill up eb
// FIXME: hex conversion inefficient, get BigInteger w/byte strings
var xhex=x.toString(16);var eb=forge.util.createBuffer();var zeros=k-Math.ceil(xhex.length/2);while(zeros>0){eb.putByte(0x00);--zeros;}eb.putBytes(forge.util.hexToBytes(xhex));if(ml!==false){// legacy, default to PKCS#1 v1.5 padding
return _decodePkcs1_v1_5(eb.getBytes(),key,pub);}// return message
return eb.getBytes();};/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */pki.rsa.createKeyPairGenerationState=function(bits,e,options){// TODO: migrate step-based prime generation code to forge.prime
// set default bits
if(typeof bits==='string'){bits=parseInt(bits,10);}bits=bits||2048;// create prng with api that matches BigInteger secure random
options=options||{};var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};var algorithm=options.algorithm||'PRIMEINC';// create PRIMEINC algorithm state
var rval;if(algorithm==='PRIMEINC'){rval={algorithm:algorithm,state:0,bits:bits,rng:rng,eInt:e||65537,e:new BigInteger(null),p:null,q:null,qBits:bits>>1,pBits:bits-(bits>>1),pqState:0,num:null,keys:null};rval.e.fromInt(rval.eInt);}else{throw new Error('Invalid key generation algorithm: '+algorithm);}return rval;};/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */pki.rsa.stepKeyPairGenerationState=function(state,n){// set default algorithm if not set
if(!('algorithm'in state)){state.algorithm='PRIMEINC';}// TODO: migrate step-based prime generation code to forge.prime
// TODO: abstract as PRIMEINC algorithm
// do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
// with some minor optimizations and designed to run in steps
// local state vars
var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var deltaIdx=0;var op_or=function op_or(x,y){return x|y;};// keep stepping until time limit is reached or done
var t1=+new Date();var t2;var total=0;while(state.keys===null&&(n<=0||total<n)){// generate p or q
if(state.state===0){/* Note: All primes are of the form:

        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */var bits=state.p===null?state.pBits:state.qBits;var bits1=bits-1;// get a random number
if(state.pqState===0){state.num=new BigInteger(bits,state.rng);// force MSB set
if(!state.num.testBit(bits1)){state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,state.num);}// align number on 30k+1 boundary
state.num.dAddOffset(31-state.num.mod(THIRTY).byteValue(),0);deltaIdx=0;++state.pqState;}else if(state.pqState===1){// try to make the number a prime
if(state.num.bitLength()>bits){// overflow, try again
state.pqState=0;// do primality test
}else if(state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))){++state.pqState;}else{// get next potential prime
state.num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}}else if(state.pqState===2){// ensure number is coprime with e
state.pqState=state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)===0?3:0;}else if(state.pqState===3){// store p or q
state.pqState=0;if(state.p===null){state.p=state.num;}else{state.q=state.num;}// advance state if both p and q are ready
if(state.p!==null&&state.q!==null){++state.state;}state.num=null;}}else if(state.state===1){// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){state.num=state.p;state.p=state.q;state.q=state.num;}++state.state;}else if(state.state===2){// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);++state.state;}else if(state.state===3){// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)===0){// phi and e are coprime, advance
++state.state;}else{// phi and e aren't coprime, so generate a new p and q
state.p=null;state.q=null;state.state=0;}}else if(state.state===4){// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);// ensure n is right number of bits
if(state.n.bitLength()===state.bits){// success, advance
++state.state;}else{// failed, get new q
state.q=null;state.state=0;}}else if(state.state===5){// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};}// update timing
t2=+new Date();total+=t2-t1;t1=t2;}return state.keys!==null;};/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *          and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */pki.rsa.generateKeyPair=function(bits,e,options,callback){// (bits), (options), (callback)
if(arguments.length===1){if(_typeof(bits)==='object'){options=bits;bits=undefined;}else if(typeof bits==='function'){callback=bits;bits=undefined;}}else if(arguments.length===2){// (bits, e), (bits, options), (bits, callback), (options, callback)
if(typeof bits==='number'){if(typeof e==='function'){callback=e;e=undefined;}else if(typeof e!=='number'){options=e;e=undefined;}}else{options=bits;callback=e;bits=undefined;e=undefined;}}else if(arguments.length===3){// (bits, e, options), (bits, e, callback), (bits, options, callback)
if(typeof e==='number'){if(typeof options==='function'){callback=options;options=undefined;}}else{callback=options;options=e;e=undefined;}}options=options||{};if(bits===undefined){bits=options.bits||2048;}if(e===undefined){e=options.e||0x10001;}// if native code is permitted and a callback is given, use native
// key generation code if available and if parameters are acceptable
if(!forge.options.usePureJavaScript&&callback&&bits>=256&&bits<=16384&&(e===0x10001||e===3)){if(_detectSubtleCrypto('generateKey')&&_detectSubtleCrypto('exportKey')){// use standard native generateKey
return window.crypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']).then(function(pair){return window.crypto.subtle.exportKey('pkcs8',pair.privateKey);// avoiding catch(function(err) {...}) to support IE <= 8
}).then(undefined,function(err){callback(err);}).then(function(pkcs8){if(pkcs8){var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});}});}if(_detectSubtleMsCrypto('generateKey')&&_detectSubtleMsCrypto('exportKey')){var genOp=window.msCrypto.subtle.generateKey({name:'RSASSA-PKCS1-v1_5',modulusLength:bits,publicExponent:_intToUint8Array(e),hash:{name:'SHA-256'}},true/* key can be exported*/,['sign','verify']);genOp.oncomplete=function(e){var pair=e.target.result;var exportOp=window.msCrypto.subtle.exportKey('pkcs8',pair.privateKey);exportOp.oncomplete=function(e){var pkcs8=e.target.result;var privateKey=pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));callback(null,{privateKey:privateKey,publicKey:pki.setRsaPublicKey(privateKey.n,privateKey.e)});};exportOp.onerror=function(err){callback(err);};};genOp.onerror=function(err){callback(err);};return;}}// use JavaScript implementation
var state=pki.rsa.createKeyPairGenerationState(bits,e,options);if(!callback){pki.rsa.stepKeyPairGenerationState(state,0);return state.keys;}_generateKeyPair(state,options,callback);};/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */pki.setRsaPublicKey=pki.rsa.setPublicKey=function(n,e){var key={n:n,e:e};/**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */key.encrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}if(scheme==='RSAES-PKCS1-V1_5'){scheme={encode:function encode(m,key,pub){return _encodePkcs1_v1_5(m,key,0x02).getBytes();}};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={encode:function encode(m,key){return forge.pkcs1.encode_rsa_oaep(key,m,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={encode:function encode(e){return e;}};}else if(typeof scheme==='string'){throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// do scheme-based encoding then rsa encryption
var e=scheme.encode(data,key,true);return pki.rsa.encrypt(e,key,true);};/**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */key.verify=function(digest,signature,scheme){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSASSA-PKCS1-V1_5';}if(scheme==='RSASSA-PKCS1-V1_5'){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);// d is ASN.1 BER-encoded DigestInfo
var obj=asn1.fromDer(d);// compare the given digest to the decrypted one
return digest===obj.value[1].value;}};}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={verify:function verify(digest,d){// remove padding
d=_decodePkcs1_v1_5(d,key,true);return digest===d;}};}// do rsa decryption w/o any decoding, then verify -- which does decoding
var d=pki.rsa.decrypt(signature,key,true,false);return scheme.verify(digest,d,key.n.bitLength());};return key;};/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */pki.setRsaPrivateKey=pki.rsa.setPrivateKey=function(n,e,d,p,q,dP,dQ,qInv){var key={n:n,e:e,d:d,p:p,q:q,dP:dP,dQ:dQ,qInv:qInv};/**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */key.decrypt=function(data,scheme,schemeOptions){if(typeof scheme==='string'){scheme=scheme.toUpperCase();}else if(scheme===undefined){scheme='RSAES-PKCS1-V1_5';}// do rsa decryption w/o any decoding
var d=pki.rsa.decrypt(data,key,false,false);if(scheme==='RSAES-PKCS1-V1_5'){scheme={decode:_decodePkcs1_v1_5};}else if(scheme==='RSA-OAEP'||scheme==='RSAES-OAEP'){scheme={decode:function decode(d,key){return forge.pkcs1.decode_rsa_oaep(key,d,schemeOptions);}};}else if(['RAW','NONE','NULL',null].indexOf(scheme)!==-1){scheme={decode:function decode(d){return d;}};}else{throw new Error('Unsupported encryption scheme: "'+scheme+'".');}// decode according to scheme
return scheme.decode(d,key,false);};/**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */key.sign=function(md,scheme){/* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */ // private key operation
var bt=false;if(typeof scheme==='string'){scheme=scheme.toUpperCase();}if(scheme===undefined||scheme==='RSASSA-PKCS1-V1_5'){scheme={encode:emsaPkcs1v15encode};bt=0x01;}else if(scheme==='NONE'||scheme==='NULL'||scheme===null){scheme={encode:function encode(){return md;}};bt=0x01;}// encode and then encrypt
var d=scheme.encode(md,key.n.bitLength());return pki.rsa.encrypt(d,key,bt);};return key;};/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */pki.wrapRsaPrivateKey=function(rsaKey){// PrivateKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// privateKeyAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// PrivateKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(rsaKey).getBytes())]);};/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */pki.privateKeyFromAsn1=function(obj){// get PrivateKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,privateKeyValidator,capture,errors)){obj=asn1.fromDer(forge.util.createBuffer(capture.privateKey));}// get RSAPrivateKey
capture={};errors=[];if(!asn1.validate(obj,rsaPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read private key. '+'ASN.1 object does not contain an RSAPrivateKey.');error.errors=errors;throw error;}// Note: Version is currently ignored.
// capture.privateKeyVersion
// FIXME: inefficient, get a BigInteger that uses byte strings
var n,e,d,p,q,dP,dQ,qInv;n=forge.util.createBuffer(capture.privateKeyModulus).toHex();e=forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();d=forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();p=forge.util.createBuffer(capture.privateKeyPrime1).toHex();q=forge.util.createBuffer(capture.privateKeyPrime2).toHex();dP=forge.util.createBuffer(capture.privateKeyExponent1).toHex();dQ=forge.util.createBuffer(capture.privateKeyExponent2).toHex();qInv=forge.util.createBuffer(capture.privateKeyCoefficient).toHex();// set private key
return pki.setRsaPrivateKey(new BigInteger(n,16),new BigInteger(e,16),new BigInteger(d,16),new BigInteger(p,16),new BigInteger(q,16),new BigInteger(dP,16),new BigInteger(dQ,16),new BigInteger(qInv,16));};/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */pki.privateKeyToAsn1=pki.privateKeyToRSAPrivateKey=function(key){// RSAPrivateKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (0 = only 2 primes, 1 multiple primes)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(0).getBytes()),// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e)),// privateExponent (d)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.d)),// privateKeyPrime1 (p)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.p)),// privateKeyPrime2 (q)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.q)),// privateKeyExponent1 (dP)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dP)),// privateKeyExponent2 (dQ)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.dQ)),// coefficient (qInv)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.qInv))]);};/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */pki.publicKeyFromAsn1=function(obj){// get SubjectPublicKeyInfo
var capture={};var errors=[];if(asn1.validate(obj,publicKeyValidator,capture,errors)){// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){var error=new Error('Cannot read public key. Unknown OID.');error.oid=oid;throw error;}obj=capture.rsaPublicKey;}// get RSA params
errors=[];if(!asn1.validate(obj,rsaPublicKeyValidator,capture,errors)){var error=new Error('Cannot read public key. '+'ASN.1 object does not contain an RSAPublicKey.');error.errors=errors;throw error;}// FIXME: inefficient, get a BigInteger that uses byte strings
var n=forge.util.createBuffer(capture.publicKeyModulus).toHex();var e=forge.util.createBuffer(capture.publicKeyExponent).toHex();// set public key
return pki.setRsaPublicKey(new BigInteger(n,16),new BigInteger(e,16));};/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */pki.publicKeyToAsn1=pki.publicKeyToSubjectPublicKeyInfo=function(key){// SubjectPublicKeyInfo
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// subjectPublicKey
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,[pki.publicKeyToRSAPublicKey(key)])]);};/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */pki.publicKeyToRSAPublicKey=function(key){// RSAPublicKey
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// modulus (n)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.n)),// publicExponent (e)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,_bnToBytes(key.e))]);};/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */function _encodePkcs1_v1_5(m,key,bt){var eb=forge.util.createBuffer();// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* use PKCS#1 v1.5 padding */if(m.length>k-11){var error=new Error('Message is too long for PKCS#1 v1.5 padding.');error.length=m.length;error.max=k-11;throw error;}/* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:

    EB = 00 || BT || PS || 00 || D

    The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.

    The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */ // build the encryption block
eb.putByte(0x00);eb.putByte(bt);// create the padding
var padNum=k-3-m.length;var padByte;// private key op
if(bt===0x00||bt===0x01){padByte=bt===0x00?0x00:0xFF;for(var i=0;i<padNum;++i){eb.putByte(padByte);}}else{// public key op
// pad with random non-zero values
while(padNum>0){var numZeros=0;var padBytes=forge.random.getBytes(padNum);for(var i=0;i<padNum;++i){padByte=padBytes.charCodeAt(i);if(padByte===0){++numZeros;}else{eb.putByte(padByte);}}padNum=numZeros;}}// zero followed by message
eb.putByte(0x00);eb.putBytes(m);return eb;}/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */function _decodePkcs1_v1_5(em,key,pub,ml){// get the length of the modulus in bytes
var k=Math.ceil(key.n.bitLength()/8);/* It is an error if any of the following conditions occurs:

    1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */ // parse the encryption block
var eb=forge.util.createBuffer(em);var first=eb.getByte();var bt=eb.getByte();if(first!==0x00||pub&&bt!==0x00&&bt!==0x01||!pub&&bt!=0x02||pub&&bt===0x00&&typeof ml==='undefined'){throw new Error('Encryption block is invalid.');}var padNum=0;if(bt===0x00){// check all padding bytes for 0x00
padNum=k-3-ml;for(var i=0;i<padNum;++i){if(eb.getByte()!==0x00){throw new Error('Encryption block is invalid.');}}}else if(bt===0x01){// find the first byte that isn't 0xFF, should be after all padding
padNum=0;while(eb.length()>1){if(eb.getByte()!==0xFF){--eb.read;break;}++padNum;}}else if(bt===0x02){// look for 0x00 byte
padNum=0;while(eb.length()>1){if(eb.getByte()===0x00){--eb.read;break;}++padNum;}}// zero must be 0x00 and padNum must be (k - 3 - message length)
var zero=eb.getByte();if(zero!==0x00||padNum!==k-3-eb.length()){throw new Error('Encryption block is invalid.');}return eb.getBytes();}/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */function _generateKeyPair(state,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};var opts={algorithm:{name:options.algorithm||'PRIMEINC',options:{workers:options.workers||2,workLoad:options.workLoad||100,workerScript:options.workerScript}}};if('prng'in options){opts.prng=options.prng;}generate();function generate(){// find p and then q (done in series to simplify)
getPrime(state.pBits,function(err,num){if(err){return callback(err);}state.p=num;if(state.q!==null){return finish(err,state.q);}getPrime(state.qBits,finish);});}function getPrime(bits,callback){forge.prime.generateProbablePrime(bits,opts,callback);}function finish(err,num){if(err){return callback(err);}// set q
state.q=num;// ensure p is larger than q (swap them if not)
if(state.p.compareTo(state.q)<0){var tmp=state.p;state.p=state.q;state.q=tmp;}// ensure p is coprime with e
if(state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.p=null;generate();return;}// ensure q is coprime with e
if(state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE)!==0){state.q=null;getPrime(state.qBits,finish);return;}// compute phi: (p - 1)(q - 1) (Euler's totient function)
state.p1=state.p.subtract(BigInteger.ONE);state.q1=state.q.subtract(BigInteger.ONE);state.phi=state.p1.multiply(state.q1);// ensure e and phi are coprime
if(state.phi.gcd(state.e).compareTo(BigInteger.ONE)!==0){// phi and e aren't coprime, so generate a new p and q
state.p=state.q=null;generate();return;}// create n, ensure n is has the right number of bits
state.n=state.p.multiply(state.q);if(state.n.bitLength()!==state.bits){// failed, get new q
state.q=null;getPrime(state.qBits,finish);return;}// set keys
var d=state.e.modInverse(state.phi);state.keys={privateKey:pki.rsa.setPrivateKey(state.n,state.e,d,state.p,state.q,d.mod(state.p1),d.mod(state.q1),state.q.modInverse(state.p)),publicKey:pki.rsa.setPublicKey(state.n,state.e)};callback(null,state.keys);}}/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */function _bnToBytes(b){// prepend 0x00 if first byte >= 0x80
var hex=b.toString(16);if(hex[0]>='8'){hex='00'+hex;}var bytes=forge.util.hexToBytes(hex);// ensure integer is minimally-encoded
if(bytes.length>1&&(// leading 0x00 for positive integer
bytes.charCodeAt(0)===0&&(bytes.charCodeAt(1)&0x80)===0||// leading 0xFF for negative integer
bytes.charCodeAt(0)===0xFF&&(bytes.charCodeAt(1)&0x80)===0x80)){return bytes.substr(1);}return bytes;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function _getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleCrypto(fn){return typeof window!=='undefined'&&_typeof(window.crypto)==='object'&&_typeof(window.crypto.subtle)==='object'&&typeof window.crypto.subtle[fn]==='function';}/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */function _detectSubtleMsCrypto(fn){return typeof window!=='undefined'&&_typeof(window.msCrypto)==='object'&&_typeof(window.msCrypto.subtle)==='object'&&typeof window.msCrypto.subtle[fn]==='function';}function _intToUint8Array(x){var bytes=forge.util.hexToBytes(x.toString(16));var buffer=new Uint8Array(bytes.length);for(var i=0;i<bytes.length;++i){buffer[i]=bytes.charCodeAt(i);}return buffer;}function _privateKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Unsupported key algorithm "'+jwk.kty+'"; algorithm must be "RSA".');}return pki.setRsaPrivateKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e),_base64ToBigInt(jwk.d),_base64ToBigInt(jwk.p),_base64ToBigInt(jwk.q),_base64ToBigInt(jwk.dp),_base64ToBigInt(jwk.dq),_base64ToBigInt(jwk.qi));}function _publicKeyFromJwk(jwk){if(jwk.kty!=='RSA'){throw new Error('Key algorithm must be "RSA".');}return pki.setRsaPublicKey(_base64ToBigInt(jwk.n),_base64ToBigInt(jwk.e));}function _base64ToBigInt(b64){return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)),16);}/***/},/* 7 */ /***/function(module,exports,__webpack_require__){/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* AES API */module.exports=forge.aes=forge.aes||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.aes.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */forge.aes.Algorithm=function(name,mode){if(!init){initialize();}var self=this;self.name=name;self.mode=new mode({blockSize:16,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._w,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.aes.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=options.key;var tmp;/* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */if(typeof key==='string'&&(key.length===16||key.length===24||key.length===32)){// convert key string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)&&(key.length===16||key.length===24||key.length===32)){// convert key integer array into byte buffer
tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// convert key byte buffer into 32-bit integer array
if(!forge.util.isArray(key)){tmp=key;key=[];// key lengths of 16, 24, 32 bytes allowed
var len=tmp.length();if(len===16||len===24||len===32){len=len>>>2;for(var i=0;i<len;++i){key.push(tmp.getInt32());}}}// key must be an array of 32-bit integers by now
if(!forge.util.isArray(key)||!(key.length===4||key.length===6||key.length===8)){throw new Error('Invalid key parameter.');}// encryption operation is always used for these modes
var mode=this.mode.name;var encryptOp=['CFB','OFB','CTR','GCM'].indexOf(mode)!==-1;// do key expansion
this._w=_expandKey(key,options.decrypt&&!encryptOp);this._init=true;};/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */forge.aes._expandKey=function(key,decrypt){if(!init){initialize();}return _expandKey(key,decrypt);};/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */forge.aes._updateBlock=_updateBlock;/** Register AES algorithms **/registerAlgorithm('AES-ECB',forge.cipher.modes.ecb);registerAlgorithm('AES-CBC',forge.cipher.modes.cbc);registerAlgorithm('AES-CFB',forge.cipher.modes.cfb);registerAlgorithm('AES-OFB',forge.cipher.modes.ofb);registerAlgorithm('AES-CTR',forge.cipher.modes.ctr);registerAlgorithm('AES-GCM',forge.cipher.modes.gcm);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.aes.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** AES implementation **/var init=false;// not yet initialized
var Nb=4;// number of words comprising the state (AES = 4)
var sbox;// non-linear substitution table used in key expansion
var isbox;// inversion of sbox
var rcon;// round constant word array
var mix;// mix-columns table
var imix;// inverse mix-columns table
/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */function initialize(){init=true;/* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.

    rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36

    We only store the first byte because it is the only one used.
  */rcon=[0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36];// compute xtime table which maps i onto GF(i, 0x02)
var xtime=new Array(256);for(var i=0;i<128;++i){xtime[i]=i<<1;xtime[i+128]=i+128<<1^0x11B;}// compute all other tables
sbox=new Array(256);isbox=new Array(256);mix=new Array(4);imix=new Array(4);for(var i=0;i<4;++i){mix[i]=new Array(256);imix[i]=new Array(256);}var e=0,ei=0,e2,e4,e8,sx,sx2,me,ime;for(var i=0;i<256;++i){/* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:

      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.

      It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.

      On each iteration we can determine the multiplicative inverse for
      the current element.

      Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.

      In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:

      s = 01000001
      x = 01000001

      iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63

      This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.

      At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */ // apply affine transformation
sx=ei^ei<<1^ei<<2^ei<<3^ei<<4;sx=sx>>8^sx&255^0x63;// update tables
sbox[e]=sx;isbox[sx]=e;/* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:

      [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]

      r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:

      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c

      As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */ // calculate mix and imix table values
sx2=xtime[sx];e2=xtime[e];e4=xtime[e2];e8=xtime[e4];me=sx2<<24^// 2
sx<<16^// 1
sx<<8^(// 1
sx^sx2);// 3
ime=(e2^e4^e8)<<24^// E (14)
(e^e8)<<16^// 9
(e^e4^e8)<<8^(// D (13)
e^e2^e8);// B (11)
// produce each of the mix tables by rotating the 2,1,1,3 value
for(var n=0;n<4;++n){mix[n][e]=me;imix[n][sx]=ime;// cycle the right most byte to the left most position
// ie: 2,1,1,3 becomes 3,2,1,1
me=me<<24|me>>>8;ime=ime<<24|ime>>>8;}// get next element and inverse
if(e===0){// 1 is the inverse of 1
e=ei=1;}else{// e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
// ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
e=e2^xtime[xtime[xtime[e2^e8]]];ei^=xtime[xtime[ei]];}}}/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0  i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */function _expandKey(key,decrypt){// copy the key's words to initialize the key schedule
var w=key.slice(0);/* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */ // go through the rounds expanding the key
var temp,iNk=1;var Nk=w.length;var Nr1=Nk+6+1;var end=Nb*Nr1;for(var i=Nk;i<end;++i){temp=w[i-1];if(i%Nk===0){// temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
temp=sbox[temp>>>16&255]<<24^sbox[temp>>>8&255]<<16^sbox[temp&255]<<8^sbox[temp>>>24]^rcon[iNk]<<24;iNk++;}else if(Nk>6&&i%Nk===4){// temp = SubWord(temp)
temp=sbox[temp>>>24]<<24^sbox[temp>>>16&255]<<16^sbox[temp>>>8&255]<<8^sbox[temp&255];}w[i]=w[i-Nk]^temp;}/* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */if(decrypt){var tmp;var m0=imix[0];var m1=imix[1];var m2=imix[2];var m3=imix[3];var wnew=w.slice(0);end=w.length;for(var i=0,wi=end-Nb;i<end;i+=Nb,wi-=Nb){// do not sub the first or last round key (round keys are Nb
// words) as no column mixing is performed before they are added,
// but do change the key order
if(i===0||i===end-Nb){wnew[i]=w[wi];wnew[i+1]=w[wi+3];wnew[i+2]=w[wi+2];wnew[i+3]=w[wi+1];}else{// substitute each round key byte because the inverse-mix
// table will inverse-substitute it (effectively cancel the
// substitution because round key bytes aren't sub'd in
// decryption mode) and swap indexes 3 and 1
for(var n=0;n<Nb;++n){tmp=w[wi+n];wnew[i+(3&-n)]=m0[sbox[tmp>>>24]]^m1[sbox[tmp>>>16&255]]^m2[sbox[tmp>>>8&255]]^m3[sbox[tmp&255]];}}}w=wnew;}return w;}/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(w,input,output,decrypt){/*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */ // Encrypt: AddRoundKey(state, w[0, Nb-1])
// Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
var Nr=w.length/4-1;var m0,m1,m2,m3,sub;if(decrypt){m0=imix[0];m1=imix[1];m2=imix[2];m3=imix[3];sub=isbox;}else{m0=mix[0];m1=mix[1];m2=mix[2];m3=mix[3];sub=sbox;}var a,b,c,d,a2,b2,c2;a=input[0]^w[0];b=input[decrypt?3:1]^w[1];c=input[2]^w[2];d=input[decrypt?1:3]^w[3];var i=3;/* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */for(var round=1;round<Nr;++round){/* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */a2=m0[a>>>24]^m1[b>>>16&255]^m2[c>>>8&255]^m3[d&255]^w[++i];b2=m0[b>>>24]^m1[c>>>16&255]^m2[d>>>8&255]^m3[a&255]^w[++i];c2=m0[c>>>24]^m1[d>>>16&255]^m2[a>>>8&255]^m3[b&255]^w[++i];d=m0[d>>>24]^m1[a>>>16&255]^m2[b>>>8&255]^m3[c&255]^w[++i];a=a2;b=b2;c=c2;}/*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */ // Note: rows are shifted inline
output[0]=sub[a>>>24]<<24^sub[b>>>16&255]<<16^sub[c>>>8&255]<<8^sub[d&255]^w[++i];output[decrypt?3:1]=sub[b>>>24]<<24^sub[c>>>16&255]<<16^sub[d>>>8&255]<<8^sub[a&255]^w[++i];output[2]=sub[c>>>24]<<24^sub[d>>>16&255]<<16^sub[a>>>8&255]<<8^sub[b&255]^w[++i];output[decrypt?1:3]=sub[d>>>24]<<24^sub[a>>>16&255]<<16^sub[b>>>8&255]<<8^sub[c&255]^w[++i];}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='AES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 8 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */var forge=__webpack_require__(0);__webpack_require__(1);// shortcut for pem API
var pem=module.exports=forge.pem=forge.pem||{};/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */pem.encode=function(msg,options){options=options||{};var rval='-----BEGIN '+msg.type+'-----\r\n';// encode special headers
var header;if(msg.procType){header={name:'Proc-Type',values:[String(msg.procType.version),msg.procType.type]};rval+=foldHeader(header);}if(msg.contentDomain){header={name:'Content-Domain',values:[msg.contentDomain]};rval+=foldHeader(header);}if(msg.dekInfo){header={name:'DEK-Info',values:[msg.dekInfo.algorithm]};if(msg.dekInfo.parameters){header.values.push(msg.dekInfo.parameters);}rval+=foldHeader(header);}if(msg.headers){// encode all other headers
for(var i=0;i<msg.headers.length;++i){rval+=foldHeader(msg.headers[i]);}}// terminate header
if(msg.procType){rval+='\r\n';}// add body
rval+=forge.util.encode64(msg.body,options.maxline||64)+'\r\n';rval+='-----END '+msg.type+'-----\r\n';return rval;};/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */pem.decode=function(str){var rval=[];// split string into PEM messages (be lenient w/EOF on BEGIN line)
var rMessage=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;var rHeader=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;var rCRLF=/\r?\n/;var match;while(true){match=rMessage.exec(str);if(!match){break;}var msg={type:match[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:forge.util.decode64(match[3])};rval.push(msg);// no headers
if(!match[2]){continue;}// parse headers
var lines=match[2].split(rCRLF);var li=0;while(match&&li<lines.length){// get line, trim any rhs whitespace
var line=lines[li].replace(/\s+$/,'');// RFC2822 unfold any following folded lines
for(var nl=li+1;nl<lines.length;++nl){var next=lines[nl];if(!/\s/.test(next[0])){break;}line+=next;li=nl;}// parse header
match=line.match(rHeader);if(match){var header={name:match[1],values:[]};var values=match[2].split(',');for(var vi=0;vi<values.length;++vi){header.values.push(ltrim(values[vi]));}// Proc-Type must be the first header
if(!msg.procType){if(header.name!=='Proc-Type'){throw new Error('Invalid PEM formatted message. The first '+'encapsulated header must be "Proc-Type".');}else if(header.values.length!==2){throw new Error('Invalid PEM formatted message. The "Proc-Type" '+'header must have two subfields.');}msg.procType={version:values[0],type:values[1]};}else if(!msg.contentDomain&&header.name==='Content-Domain'){// special-case Content-Domain
msg.contentDomain=values[0]||'';}else if(!msg.dekInfo&&header.name==='DEK-Info'){// special-case DEK-Info
if(header.values.length===0){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must have at least one subfield.');}msg.dekInfo={algorithm:values[0],parameters:values[1]||null};}else{msg.headers.push(header);}}++li;}if(msg.procType==='ENCRYPTED'&&!msg.dekInfo){throw new Error('Invalid PEM formatted message. The "DEK-Info" '+'header must be present if "Proc-Type" is "ENCRYPTED".');}}if(rval.length===0){throw new Error('Invalid PEM formatted message.');}return rval;};function foldHeader(header){var rval=header.name+': ';// ensure values with CRLF are folded
var values=[];var insertSpace=function insertSpace(match,$1){return' '+$1;};for(var i=0;i<header.values.length;++i){values.push(header.values[i].replace(/^(\S+\r\n)/,insertSpace));}rval+=values.join(',')+'\r\n';// do folding
var length=0;var candidate=-1;for(var i=0;i<rval.length;++i,++length){if(length>65&&candidate!==-1){var insert=rval[candidate];if(insert===','){++candidate;rval=rval.substr(0,candidate)+'\r\n '+rval.substr(candidate);}else{rval=rval.substr(0,candidate)+'\r\n'+insert+rval.substr(candidate+1);}length=i-candidate-1;candidate=-1;++i;}else if(rval[i]===' '||rval[i]==='\t'||rval[i]===','){candidate=i;}}return rval;}function ltrim(str){return str.replace(/^\s+/,'');}/***/},/* 9 */ /***/function(module,exports,__webpack_require__){/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(3);__webpack_require__(13);__webpack_require__(8);__webpack_require__(5);__webpack_require__(25);__webpack_require__(6);__webpack_require__(1);if(typeof BigInteger==='undefined'){var BigInteger=forge.jsbn.BigInteger;}// shortcut for asn.1 API
var asn1=forge.asn1;/* Password-based encryption implementation. */var pki=forge.pki=forge.pki||{};module.exports=pki.pbe=forge.pbe=forge.pbe||{};var oids=pki.oids;// validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params
var encryptedPrivateKeyValidator={name:'EncryptedPrivateKeyInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedPrivateKeyInfo.encryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encryptionOid'},{name:'AlgorithmIdentifier.parameters',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'encryptionParams'}]},{// encryptedData
name:'EncryptedPrivateKeyInfo.encryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encryptedData'}]};// validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes
var PBES2AlgorithmsValidator={name:'PBES2Algorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.keyDerivationFunc.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'kdfOid'},{name:'PBES2Algorithms.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.params.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'kdfSalt'},{name:'PBES2Algorithms.params.iterationCount',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'kdfIterationCount'},{name:'PBES2Algorithms.params.keyLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'keyLength'},{// prf
name:'PBES2Algorithms.params.prf',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,value:[{name:'PBES2Algorithms.params.prf.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'prfOid'}]}]}]},{name:'PBES2Algorithms.encryptionScheme',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PBES2Algorithms.encryptionScheme.oid',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encOid'},{name:'PBES2Algorithms.encryptionScheme.iv',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encIv'}]}]};var pkcs12PbeParamsValidator={name:'pkcs-12PbeParams',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'pkcs-12PbeParams.salt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'salt'},{name:'pkcs-12PbeParams.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'iterations'}]};/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptPrivateKeyInfo=function(obj,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||'aes128';options.prfAlgorithm=options.prfAlgorithm||'sha1';// generate PBE params
var salt=forge.random.getBytesSync(options.saltSize);var count=options.count;var countBytes=asn1.integerToDer(count);var dkLen;var encryptionAlgorithm;var encryptedData;if(options.algorithm.indexOf('aes')===0||options.algorithm==='des'){// do PBES2
var ivLen,encOid,cipherFn;switch(options.algorithm){case'aes128':dkLen=16;ivLen=16;encOid=oids['aes128-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':dkLen=24;ivLen=16;encOid=oids['aes192-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':dkLen=32;ivLen=16;encOid=oids['aes256-CBC'];cipherFn=forge.aes.createEncryptionCipher;break;case'des':dkLen=8;ivLen=8;encOid=oids['desCBC'];cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// get PRF message digest
var prfAlgorithm='hmacWith'+options.prfAlgorithm.toUpperCase();var md=prfAlgorithmToMessageDigest(prfAlgorithm);// encrypt private key using pbe SHA-1 and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=forge.random.getBytesSync(ivLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();// get PBKDF2-params
var params=createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm);encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// keyDerivationFunc
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),// PBKDF2-params
params]),// encryptionScheme
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(encOid).getBytes()),// iv
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,iv)])])]);}else if(options.algorithm==='3des'){// Do PKCS12 PBE
dkLen=24;var saltBytes=new forge.util.ByteBuffer(salt);var dk=pki.pbe.generatePkcs12Key(password,saltBytes,1,count,dkLen);var iv=pki.pbe.generatePkcs12Key(password,saltBytes,2,count,dkLen);var cipher=forge.des.createEncryptionCipher(dk);cipher.start(iv);cipher.update(asn1.toDer(obj));cipher.finish();encryptedData=cipher.output.getBytes();encryptionAlgorithm=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),// pkcs-12PbeParams
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())])]);}else{var error=new Error('Cannot encrypt private key. Unknown encryption algorithm.');error.algorithm=options.algorithm;throw error;}// EncryptedPrivateKeyInfo
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// encryptionAlgorithm
encryptionAlgorithm,// encryptedData
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,encryptedData)]);return rval;};/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */pki.decryptPrivateKeyInfo=function(obj,password){var rval=null;// get PBE params
var capture={};var errors=[];if(!asn1.validate(obj,encryptedPrivateKeyValidator,capture,errors)){var error=new Error('Cannot read encrypted private key. '+'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// get cipher
var oid=asn1.derToOid(capture.encryptionOid);var cipher=pki.pbe.getCipher(oid,capture.encryptionParams,password);// get encrypted data
var encrypted=forge.util.createBuffer(capture.encryptedData);cipher.update(encrypted);if(cipher.finish()){rval=asn1.fromDer(cipher.output);}return rval;};/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */pki.encryptedPrivateKeyToPem=function(epki,maxline){// convert to DER, then PEM-encode
var msg={type:'ENCRYPTED PRIVATE KEY',body:asn1.toDer(epki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptedPrivateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'){var error=new Error('Could not convert encrypted private key from PEM; '+'PEM header type is "ENCRYPTED PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert encrypted private key from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
return asn1.fromDer(msg.body);};/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */pki.encryptRsaPrivateKey=function(rsaKey,password,options){// standard PKCS#8
options=options||{};if(!options.legacy){// encrypt PrivateKeyInfo
var rval=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));rval=pki.encryptPrivateKeyInfo(rval,password,options);return pki.encryptedPrivateKeyToPem(rval);}// legacy non-PKCS#8
var algorithm;var iv;var dkLen;var cipherFn;switch(options.algorithm){case'aes128':algorithm='AES-128-CBC';dkLen=16;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes192':algorithm='AES-192-CBC';dkLen=24;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'aes256':algorithm='AES-256-CBC';dkLen=32;iv=forge.random.getBytesSync(16);cipherFn=forge.aes.createEncryptionCipher;break;case'3des':algorithm='DES-EDE3-CBC';dkLen=24;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;case'des':algorithm='DES-CBC';dkLen=8;iv=forge.random.getBytesSync(8);cipherFn=forge.des.createEncryptionCipher;break;default:var error=new Error('Could not encrypt RSA private key; unsupported '+'encryption algorithm "'+options.algorithm+'".');error.algorithm=options.algorithm;throw error;}// encrypt private key using OpenSSL legacy key derivation
var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));cipher.finish();var msg={type:'RSA PRIVATE KEY',procType:{version:'4',type:'ENCRYPTED'},dekInfo:{algorithm:algorithm,parameters:forge.util.bytesToHex(iv).toUpperCase()},body:cipher.output.getBytes()};return forge.pem.encode(msg);};/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */pki.decryptRsaPrivateKey=function(pem,password){var rval=null;var msg=forge.pem.decode(pem)[0];if(msg.type!=='ENCRYPTED PRIVATE KEY'&&msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM header type '+'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');error.headerType=error;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){var dkLen;var cipherFn;switch(msg.dekInfo.algorithm){case'DES-CBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;case'DES-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'AES-128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'AES-256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'RC2-40-CBC':dkLen=5;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,40);};break;case'RC2-64-CBC':dkLen=8;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,64);};break;case'RC2-128-CBC':dkLen=16;cipherFn=function cipherFn(key){return forge.rc2.createDecryptionCipher(key,128);};break;default:var error=new Error('Could not decrypt private key; unsupported '+'encryption algorithm "'+msg.dekInfo.algorithm+'".');error.algorithm=msg.dekInfo.algorithm;throw error;}// use OpenSSL legacy key derivation
var iv=forge.util.hexToBytes(msg.dekInfo.parameters);var dk=forge.pbe.opensslDeriveBytes(password,iv.substr(0,8),dkLen);var cipher=cipherFn(dk);cipher.start(iv);cipher.update(forge.util.createBuffer(msg.body));if(cipher.finish()){rval=cipher.output.getBytes();}else{return rval;}}else{rval=msg.body;}if(msg.type==='ENCRYPTED PRIVATE KEY'){rval=pki.decryptPrivateKeyInfo(asn1.fromDer(rval),password);}else{// decryption already performed above
rval=asn1.fromDer(rval);}if(rval!==null){rval=pki.privateKeyFromAsn1(rval);}return rval;};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */pki.pbe.generatePkcs12Key=function(password,salt,id,iter,n,md){var j,l;if(typeof md==='undefined'||md===null){if(!('sha1'in forge.md)){throw new Error('"sha1" hash algorithm unavailable.');}md=forge.md.sha1.create();}var u=md.digestLength;var v=md.blockLength;var result=new forge.util.ByteBuffer();/* Convert password to Unicode byte buffer + trailing 0-byte. */var passBuf=new forge.util.ByteBuffer();if(password!==null&&password!==undefined){for(l=0;l<password.length;l++){passBuf.putInt16(password.charCodeAt(l));}passBuf.putInt16(0);}/* Length of salt and password in BYTES. */var p=passBuf.length();var s=salt.length();/* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */var D=new forge.util.ByteBuffer();D.fillWithByte(id,v);/* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */var Slen=v*Math.ceil(s/v);var S=new forge.util.ByteBuffer();for(l=0;l<Slen;l++){S.putByte(salt.at(l%s));}/* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */var Plen=v*Math.ceil(p/v);var P=new forge.util.ByteBuffer();for(l=0;l<Plen;l++){P.putByte(passBuf.at(l%p));}/* 4. Set I=S||P to be the concatenation of S and P. */var I=S;I.putBuffer(P);/* 5. Set c=ceil(n / u). */var c=Math.ceil(n/u);/* 6. For i=1, 2, ..., c, do the following: */for(var i=1;i<=c;i++){/* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */var buf=new forge.util.ByteBuffer();buf.putBytes(D.bytes());buf.putBytes(I.bytes());for(var round=0;round<iter;round++){md.start();md.update(buf.getBytes());buf=md.digest();}/* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */var B=new forge.util.ByteBuffer();for(l=0;l<v;l++){B.putByte(buf.at(l%u));}/* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */var k=Math.ceil(s/v)+Math.ceil(p/v);var Inew=new forge.util.ByteBuffer();for(j=0;j<k;j++){var chunk=new forge.util.ByteBuffer(I.getBytes(v));var x=0x1ff;for(l=B.length()-1;l>=0;l--){x=x>>8;x+=B.at(l)+chunk.at(l);chunk.setAt(l,x&0xff);}Inew.putBuffer(chunk);}I=Inew;/* Add Ai to A. */result.putBuffer(buf);}result.truncate(result.length()-n);return result;};/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipher=function(oid,params,password){switch(oid){case pki.oids['pkcs5PBES2']:return pki.pbe.getCipherForPBES2(oid,params,password);case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:case pki.oids['pbewithSHAAnd40BitRC2-CBC']:return pki.pbe.getCipherForPKCS12PBE(oid,params,password);default:var error=new Error('Cannot read encrypted PBE data block. Unsupported OID.');error.oid=oid;error.supportedOids=['pkcs5PBES2','pbeWithSHAAnd3-KeyTripleDES-CBC','pbewithSHAAnd40BitRC2-CBC'];throw error;}};/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */pki.pbe.getCipherForPBES2=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,PBES2AlgorithmsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}// check oids
oid=asn1.derToOid(capture.kdfOid);if(oid!==pki.oids['pkcs5PBKDF2']){var error=new Error('Cannot read encrypted private key. '+'Unsupported key derivation function OID.');error.oid=oid;error.supportedOids=['pkcs5PBKDF2'];throw error;}oid=asn1.derToOid(capture.encOid);if(oid!==pki.oids['aes128-CBC']&&oid!==pki.oids['aes192-CBC']&&oid!==pki.oids['aes256-CBC']&&oid!==pki.oids['des-EDE3-CBC']&&oid!==pki.oids['desCBC']){var error=new Error('Cannot read encrypted private key. '+'Unsupported encryption scheme OID.');error.oid=oid;error.supportedOids=['aes128-CBC','aes192-CBC','aes256-CBC','des-EDE3-CBC','desCBC'];throw error;}// set PBE params
var salt=capture.kdfSalt;var count=forge.util.createBuffer(capture.kdfIterationCount);count=count.getInt(count.length()<<3);var dkLen;var cipherFn;switch(pki.oids[oid]){case'aes128-CBC':dkLen=16;cipherFn=forge.aes.createDecryptionCipher;break;case'aes192-CBC':dkLen=24;cipherFn=forge.aes.createDecryptionCipher;break;case'aes256-CBC':dkLen=32;cipherFn=forge.aes.createDecryptionCipher;break;case'des-EDE3-CBC':dkLen=24;cipherFn=forge.des.createDecryptionCipher;break;case'desCBC':dkLen=8;cipherFn=forge.des.createDecryptionCipher;break;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);// decrypt private key using pbe with chosen PRF and AES/DES
var dk=forge.pkcs5.pbkdf2(password,salt,count,dkLen,md);var iv=capture.encIv;var cipher=cipherFn(dk);cipher.start(iv);return cipher;};/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */pki.pbe.getCipherForPKCS12PBE=function(oid,params,password){// get PBE params
var capture={};var errors=[];if(!asn1.validate(params,pkcs12PbeParamsValidator,capture,errors)){var error=new Error('Cannot read password-based-encryption algorithm '+'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');error.errors=errors;throw error;}var salt=forge.util.createBuffer(capture.salt);var count=forge.util.createBuffer(capture.iterations);count=count.getInt(count.length()<<3);var dkLen,dIvLen,cipherFn;switch(oid){case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:dkLen=24;dIvLen=8;cipherFn=forge.des.startDecrypting;break;case pki.oids['pbewithSHAAnd40BitRC2-CBC']:dkLen=5;dIvLen=8;cipherFn=function cipherFn(key,iv){var cipher=forge.rc2.createDecryptionCipher(key,40);cipher.start(iv,null);return cipher;};break;default:var error=new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');error.oid=oid;throw error;}// get PRF message digest
var md=prfOidToMessageDigest(capture.prfOid);var key=pki.pbe.generatePkcs12Key(password,salt,1,count,dkLen,md);md.start();var iv=pki.pbe.generatePkcs12Key(password,salt,2,count,dIvLen,md);return cipherFn(key,iv);};/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */pki.pbe.opensslDeriveBytes=function(password,salt,dkLen,md){if(typeof md==='undefined'||md===null){if(!('md5'in forge.md)){throw new Error('"md5" hash algorithm unavailable.');}md=forge.md.md5.create();}if(salt===null){salt='';}var digests=[hash(md,password+salt)];for(var length=16,i=1;length<dkLen;++i,length+=16){digests.push(hash(md,digests[i-1]+password+salt));}return digests.join('').substr(0,dkLen);};function hash(md,bytes){return md.start().update(bytes).digest().getBytes();}function prfOidToMessageDigest(prfOid){// get PRF algorithm, default to SHA-1
var prfAlgorithm;if(!prfOid){prfAlgorithm='hmacWithSHA1';}else{prfAlgorithm=pki.oids[asn1.derToOid(prfOid)];if(!prfAlgorithm){var error=new Error('Unsupported PRF OID.');error.oid=prfOid;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}}return prfAlgorithmToMessageDigest(prfAlgorithm);}function prfAlgorithmToMessageDigest(prfAlgorithm){var factory=forge.md;switch(prfAlgorithm){case'hmacWithSHA224':factory=forge.md.sha512;case'hmacWithSHA1':case'hmacWithSHA256':case'hmacWithSHA384':case'hmacWithSHA512':prfAlgorithm=prfAlgorithm.substr(8).toLowerCase();break;default:var error=new Error('Unsupported PRF algorithm.');error.algorithm=prfAlgorithm;error.supported=['hmacWithSHA1','hmacWithSHA224','hmacWithSHA256','hmacWithSHA384','hmacWithSHA512'];throw error;}if(!factory||!(prfAlgorithm in factory)){throw new Error('Unknown hash algorithm: '+prfAlgorithm);}return factory[prfAlgorithm].create();}function createPbkdf2Params(salt,countBytes,dkLen,prfAlgorithm){var params=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// salt
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,salt),// iteration count
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,countBytes.getBytes())]);// when PRF algorithm is not SHA-1 default, add key length and PRF algorithm
if(prfAlgorithm!=='hmacWithSHA1'){params.value.push(// key length
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(dkLen.toString(16))),// AlgorithmIdentifier
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),// parameters (null)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]));}return params;}/***/},/* 10 */ /***/function(module,exports,__webpack_require__){/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);module.exports=forge.cipher=forge.cipher||{};// registered algorithms
forge.cipher.algorithms=forge.cipher.algorithms||{};/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createCipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:false});};/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */forge.cipher.createDecipher=function(algorithm,key){var api=algorithm;if(typeof api==='string'){api=forge.cipher.getAlgorithm(api);if(api){api=api();}}if(!api){throw new Error('Unsupported algorithm: '+algorithm);}// assume block cipher
return new forge.cipher.BlockCipher({algorithm:api,key:key,decrypt:true});};/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */forge.cipher.registerAlgorithm=function(name,algorithm){name=name.toUpperCase();forge.cipher.algorithms[name]=algorithm;};/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */forge.cipher.getAlgorithm=function(name){name=name.toUpperCase();if(name in forge.cipher.algorithms){return forge.cipher.algorithms[name];}return null;};var BlockCipher=forge.cipher.BlockCipher=function(options){this.algorithm=options.algorithm;this.mode=this.algorithm.mode;this.blockSize=this.mode.blockSize;this._finish=false;this._input=null;this.output=null;this._op=options.decrypt?this.mode.decrypt:this.mode.encrypt;this._decrypt=options.decrypt;this.algorithm.initialize(options);};/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */BlockCipher.prototype.start=function(options){options=options||{};var opts={};for(var key in options){opts[key]=options[key];}opts.decrypt=this._decrypt;this._finish=false;this._input=forge.util.createBuffer();this.output=options.output||forge.util.createBuffer();this.mode.start(opts);};/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */BlockCipher.prototype.update=function(input){if(input){// input given, so empty it into the input buffer
this._input.putBuffer(input);}// do cipher operation until it needs more input and not finished
while(!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish){}// free consumed memory from input buffer
this._input.compact();};/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */BlockCipher.prototype.finish=function(pad){// backwards-compatibility w/deprecated padding API
// Note: will overwrite padding functions even after another start() call
if(pad&&(this.mode.name==='ECB'||this.mode.name==='CBC')){this.mode.pad=function(input){return pad(this.blockSize,input,false);};this.mode.unpad=function(output){return pad(this.blockSize,output,true);};}// build options for padding and afterFinish functions
var options={};options.decrypt=this._decrypt;// get # of bytes that won't fill a block
options.overflow=this._input.length()%this.blockSize;if(!this._decrypt&&this.mode.pad){if(!this.mode.pad(this._input,options)){return false;}}// do final update
this._finish=true;this.update();if(this._decrypt&&this.mode.unpad){if(!this.mode.unpad(this.output,options)){return false;}}if(this.mode.afterFinish){if(!this.mode.afterFinish(this.output,options)){return false;}}return true;};/***/},/* 11 */ /***/function(module,exports,__webpack_require__){/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.cipher=forge.cipher||{};// supported cipher modes
var modes=module.exports=forge.cipher.modes=forge.cipher.modes||{};/** Electronic codebook (ECB) (Don't use this; it's not secure) **/modes.ecb=function(options){options=options||{};this.name='ECB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.ecb.prototype.start=function(options){};modes.ecb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}};modes.ecb.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.ecb.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher-block Chaining (CBC) **/modes.cbc=function(options){options=options||{};this.name='CBC';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);};modes.cbc.prototype.start=function(options){// Note: legacy support for using IV residue (has security flaws)
// if IV is null, reuse block from previous processing
if(options.iv===null){// must have a previous block
if(!this._prev){throw new Error('Invalid IV parameter.');}this._iv=this._prev.slice(0);}else if(!('iv'in options)){throw new Error('Invalid IV parameter.');}else{// save IV as "previous" block
this._iv=transformIV(options.iv);this._prev=this._iv.slice(0);}};modes.cbc.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
// CBC XOR's IV (or previous block) with plaintext
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._prev[i]^input.getInt32();}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// write output, save previous block
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]);}this._prev=this._outBlock;};modes.cbc.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
if(input.length()<this.blockSize&&!(finish&&input.length()>0)){return true;}// get next block
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();}// decrypt block
this.cipher.decrypt(this._inBlock,this._outBlock);// write output, save previous ciphered block
// CBC XOR's IV (or previous block) with ciphertext
for(var i=0;i<this._ints;++i){output.putInt32(this._prev[i]^this._outBlock[i]);}this._prev=this._inBlock.slice(0);};modes.cbc.prototype.pad=function(input,options){// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=input.length()===this.blockSize?this.blockSize:this.blockSize-input.length();input.fillWithByte(padding,padding);return true;};modes.cbc.prototype.unpad=function(output,options){// check for error: input data not a multiple of blockSize
if(options.overflow>0){return false;}// ensure padding byte count is valid
var len=output.length();var count=output.at(len-1);if(count>this.blockSize<<2){return false;}// trim off padding bytes
output.truncate(count);return true;};/** Cipher feedback (CFB) **/modes.cfb=function(options){options=options||{};this.name='CFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.cfb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.cfb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32()^this._outBlock[i];output.putInt32(this._inBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32()^this._outBlock[i];this._partialOutput.putInt32(this._partialBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.cfb.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output, write input as output
for(var i=0;i<this._ints;++i){this._inBlock[i]=input.getInt32();output.putInt32(this._inBlock[i]^this._outBlock[i]);}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output, write input as partial output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialBlock[i]=input.getInt32();this._partialOutput.putInt32(this._partialBlock[i]^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._partialBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};/** Output feedback (OFB) **/modes.ofb=function(options){options=options||{};this.name='OFB';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ofb.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ofb.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(input.length()===0){return true;}// encrypt block (OFB always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output and update next input
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);this._inBlock[i]=this._outBlock[i];}return;}// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}else{// block complete, update input block
for(var i=0;i<this._ints;++i){this._inBlock[i]=this._outBlock[i];}}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;};modes.ofb.prototype.decrypt=modes.ofb.prototype.encrypt;/** Counter (CTR) **/modes.ctr=function(options){options=options||{};this.name='CTR';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=null;this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;};modes.ctr.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// use IV as first input
this._iv=transformIV(options.iv);this._inBlock=this._iv.slice(0);this._partialBytes=0;};modes.ctr.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block (CTR always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(input.getInt32()^this._outBlock[i]);}}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes>0){// block still incomplete, restore input buffer
input.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// block complete, increment counter (input block)
inc32(this._inBlock);};modes.ctr.prototype.decrypt=modes.ctr.prototype.encrypt;/** Galois/Counter Mode (GCM) **/modes.gcm=function(options){options=options||{};this.name='GCM';this.cipher=options.cipher;this.blockSize=options.blockSize||16;this._ints=this.blockSize/4;this._inBlock=new Array(this._ints);this._outBlock=new Array(this._ints);this._partialOutput=forge.util.createBuffer();this._partialBytes=0;// R is actually this value concatenated with 120 more zero bits, but
// we only XOR against R so the other zeros have no effect -- we just
// apply this value to the first integer in a block
this._R=0xE1000000;};modes.gcm.prototype.start=function(options){if(!('iv'in options)){throw new Error('Invalid IV parameter.');}// ensure IV is a byte buffer
var iv=forge.util.createBuffer(options.iv);// no ciphered data processed yet
this._cipherLength=0;// default additional data is none
var additionalData;if('additionalData'in options){additionalData=forge.util.createBuffer(options.additionalData);}else{additionalData=forge.util.createBuffer();}// default tag length is 128 bits
if('tagLength'in options){this._tagLength=options.tagLength;}else{this._tagLength=128;}// if tag is given, ensure tag matches tag length
this._tag=null;if(options.decrypt){// save tag to check later
this._tag=forge.util.createBuffer(options.tag).getBytes();if(this._tag.length!==this._tagLength/8){throw new Error('Authentication tag does not match tag length.');}}// create tmp storage for hash calculation
this._hashBlock=new Array(this._ints);// no tag generated yet
this.tag=null;// generate hash subkey
// (apply block cipher to "zero" block)
this._hashSubkey=new Array(this._ints);this.cipher.encrypt([0,0,0,0],this._hashSubkey);// generate table M
// use 4-bit tables (32 component decomposition of a 16 byte value)
// 8-bit tables take more space and are known to have security
// vulnerabilities (in native implementations)
this.componentBits=4;this._m=this.generateHashTable(this._hashSubkey,this.componentBits);// Note: support IV length different from 96 bits? (only supporting
// 96 bits is recommended by NIST SP-800-38D)
// generate J_0
var ivLength=iv.length();if(ivLength===12){// 96-bit IV
this._j0=[iv.getInt32(),iv.getInt32(),iv.getInt32(),1];}else{// IV is NOT 96-bits
this._j0=[0,0,0,0];while(iv.length()>0){this._j0=this.ghash(this._hashSubkey,this._j0,[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()]);}this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(from64To32(ivLength*8)));}// generate ICB (initial counter block)
this._inBlock=this._j0.slice(0);inc32(this._inBlock);this._partialBytes=0;// consume authentication data
additionalData=forge.util.createBuffer(additionalData);// save additional data length as a BE 64-bit number
this._aDataLength=from64To32(additionalData.length()*8);// pad additional data to 128 bit (16 byte) block size
var overflow=additionalData.length()%this.blockSize;if(overflow){additionalData.fillWithByte(0,this.blockSize-overflow);}this._s=[0,0,0,0];while(additionalData.length()>0){this._s=this.ghash(this._hashSubkey,this._s,[additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32(),additionalData.getInt32()]);}};modes.gcm.prototype.encrypt=function(input,output,finish){// not enough input to encrypt
var inputLength=input.length();if(inputLength===0){return true;}// encrypt block
this.cipher.encrypt(this._inBlock,this._outBlock);// handle full block
if(this._partialBytes===0&&inputLength>=this.blockSize){// XOR input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^=input.getInt32());}this._cipherLength+=this.blockSize;}else{// handle partial block
var partialBytes=(this.blockSize-inputLength)%this.blockSize;if(partialBytes>0){partialBytes=this.blockSize-partialBytes;}// XOR input with output
this._partialOutput.clear();for(var i=0;i<this._ints;++i){this._partialOutput.putInt32(input.getInt32()^this._outBlock[i]);}if(partialBytes===0||finish){// handle overflow prior to hashing
if(finish){// get block overflow
var overflow=inputLength%this.blockSize;this._cipherLength+=overflow;// truncate for hash function
this._partialOutput.truncate(this.blockSize-overflow);}else{this._cipherLength+=this.blockSize;}// get output block for hashing
for(var i=0;i<this._ints;++i){this._outBlock[i]=this._partialOutput.getInt32();}this._partialOutput.read-=this.blockSize;}// skip any previous partial bytes
if(this._partialBytes>0){this._partialOutput.getBytes(this._partialBytes);}if(partialBytes>0&&!finish){// block still incomplete, restore input buffer, get partial output,
// and return early
input.read-=this.blockSize;output.putBytes(this._partialOutput.getBytes(partialBytes-this._partialBytes));this._partialBytes=partialBytes;return true;}output.putBytes(this._partialOutput.getBytes(inputLength-this._partialBytes));this._partialBytes=0;}// update hash block S
this._s=this.ghash(this._hashSubkey,this._s,this._outBlock);// increment counter (input block)
inc32(this._inBlock);};modes.gcm.prototype.decrypt=function(input,output,finish){// not enough input to decrypt
var inputLength=input.length();if(inputLength<this.blockSize&&!(finish&&inputLength>0)){return true;}// encrypt block (GCM always uses encryption mode)
this.cipher.encrypt(this._inBlock,this._outBlock);// increment counter (input block)
inc32(this._inBlock);// update hash block S
this._hashBlock[0]=input.getInt32();this._hashBlock[1]=input.getInt32();this._hashBlock[2]=input.getInt32();this._hashBlock[3]=input.getInt32();this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);// XOR hash input with output
for(var i=0;i<this._ints;++i){output.putInt32(this._outBlock[i]^this._hashBlock[i]);}// increment cipher data length
if(inputLength<this.blockSize){this._cipherLength+=inputLength%this.blockSize;}else{this._cipherLength+=this.blockSize;}};modes.gcm.prototype.afterFinish=function(output,options){var rval=true;// handle overflow
if(options.decrypt&&options.overflow){output.truncate(this.blockSize-options.overflow);}// handle authentication tag
this.tag=forge.util.createBuffer();// concatenate additional data length with cipher length
var lengths=this._aDataLength.concat(from64To32(this._cipherLength*8));// include lengths in hash
this._s=this.ghash(this._hashSubkey,this._s,lengths);// do GCTR(J_0, S)
var tag=[];this.cipher.encrypt(this._j0,tag);for(var i=0;i<this._ints;++i){this.tag.putInt32(this._s[i]^tag[i]);}// trim tag to length
this.tag.truncate(this.tag.length()%(this._tagLength/8));// check authentication tag
if(options.decrypt&&this.tag.bytes()!==this._tag){rval=false;}return rval;};/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */modes.gcm.prototype.multiply=function(x,y){var z_i=[0,0,0,0];var v_i=y.slice(0);// calculate Z_128 (block has 128 bits)
for(var i=0;i<128;++i){// if x_i is 0, Z_{i+1} = Z_i (unchanged)
// else Z_{i+1} = Z_i ^ V_i
// get x_i by finding 32-bit int position, then left shift 1 by remainder
var x_i=x[i/32|0]&1<<31-i%32;if(x_i){z_i[0]^=v_i[0];z_i[1]^=v_i[1];z_i[2]^=v_i[2];z_i[3]^=v_i[3];}// if LSB(V_i) is 1, V_i = V_i >> 1
// else V_i = (V_i >> 1) ^ R
this.pow(v_i,v_i);}return z_i;};modes.gcm.prototype.pow=function(x,out){// if LSB(x) is 1, x = x >>> 1
// else x = (x >>> 1) ^ R
var lsb=x[3]&1;// always do x >>> 1:
// starting with the rightmost integer, shift each integer to the right
// one bit, pulling in the bit from the integer to the left as its top
// most bit (do this for the last 3 integers)
for(var i=3;i>0;--i){out[i]=x[i]>>>1|(x[i-1]&1)<<31;}// shift the first integer normally
out[0]=x[0]>>>1;// if lsb was not set, then polynomial had a degree of 127 and doesn't
// need to divided; otherwise, XOR with R to find the remainder; we only
// need to XOR the first integer since R technically ends w/120 zero bits
if(lsb){out[0]^=this._R;}};modes.gcm.prototype.tableMultiply=function(x){// assumes 4-bit tables are used
var z=[0,0,0,0];for(var i=0;i<32;++i){var idx=i/8|0;var x_i=x[idx]>>>(7-i%8)*4&0xF;var ah=this._m[i][x_i];z[0]^=ah[0];z[1]^=ah[1];z[2]^=ah[2];z[3]^=ah[3];}return z;};/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */modes.gcm.prototype.ghash=function(h,y,x){y[0]^=x[0];y[1]^=x[1];y[2]^=x[2];y[3]^=x[3];return this.tableMultiply(y);//return this.multiply(y, h);
};/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateHashTable=function(h,bits){// TODO: There are further optimizations that would use only the
// first table M_0 (or some variant) along with a remainder table;
// this can be explored in the future
var multiplier=8/bits;var perInt=4*multiplier;var size=16*multiplier;var m=new Array(size);for(var i=0;i<size;++i){var tmp=[0,0,0,0];var idx=i/perInt|0;var shft=(perInt-1-i%perInt)*bits;tmp[idx]=1<<bits-1<<shft;m[i]=this.generateSubHashTable(this.multiply(tmp,h),bits);}return m;};/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */modes.gcm.prototype.generateSubHashTable=function(mid,bits){// compute the table quickly by minimizing the number of
// POW operations -- they only need to be performed for powers of 2,
// all other entries can be composed from those powers using XOR
var size=1<<bits;var half=size>>>1;var m=new Array(size);m[half]=mid.slice(0);var i=half>>>1;while(i>0){// raise m0[2 * i] and store in m0[i]
this.pow(m[2*i],m[i]=[]);i>>=1;}i=2;while(i<half){for(var j=1;j<i;++j){var m_i=m[i];var m_j=m[j];m[i+j]=[m_i[0]^m_j[0],m_i[1]^m_j[1],m_i[2]^m_j[2],m_i[3]^m_j[3]];}i*=2;}m[0]=[0,0,0,0];/* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */for(i=half+1;i<size;++i){var c=m[i^half];m[i]=[mid[0]^c[0],mid[1]^c[1],mid[2]^c[2],mid[3]^c[3]];}return m;};/** Utility functions */function transformIV(iv){if(typeof iv==='string'){// convert iv string into byte buffer
iv=forge.util.createBuffer(iv);}if(forge.util.isArray(iv)&&iv.length>4){// convert iv byte array into byte buffer
var tmp=iv;iv=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){iv.putByte(tmp[i]);}}if(!forge.util.isArray(iv)){// convert iv byte buffer into 32-bit integer array
iv=[iv.getInt32(),iv.getInt32(),iv.getInt32(),iv.getInt32()];}return iv;}function inc32(block){// increment last 32 bits of block only
block[block.length-1]=block[block.length-1]+1&0xFFFFFFFF;}function from64To32(num){// convert 64-bit number to two BE Int32s
return[num/0x100000000|0,num&0xFFFFFFFF];}/***/},/* 12 */ /***/function(module,exports,__webpack_require__){/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(10);__webpack_require__(11);__webpack_require__(1);/* DES API */module.exports=forge.des=forge.des||{};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startEncrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:false,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createEncryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:false,mode:mode});};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */forge.des.startDecrypting=function(key,iv,output,mode){var cipher=_createCipher({key:key,output:output,decrypt:true,mode:mode||(iv===null?'ECB':'CBC')});cipher.start(iv);return cipher;};/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */forge.des.createDecryptionCipher=function(key,mode){return _createCipher({key:key,output:null,decrypt:true,mode:mode});};/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */forge.des.Algorithm=function(name,mode){var self=this;self.name=name;self.mode=new mode({blockSize:8,cipher:{encrypt:function encrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,false);},decrypt:function decrypt(inBlock,outBlock){return _updateBlock(self._keys,inBlock,outBlock,true);}}});self._init=false;};/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */forge.des.Algorithm.prototype.initialize=function(options){if(this._init){return;}var key=forge.util.createBuffer(options.key);if(this.name.indexOf('3DES')===0){if(key.length()!==24){throw new Error('Invalid Triple-DES key size: '+key.length()*8);}}// do key expansion to 16 or 48 subkeys (single or triple DES)
this._keys=_createKeys(key);this._init=true;};/** Register DES algorithms **/registerAlgorithm('DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('DES-CTR',forge.cipher.modes.ctr);registerAlgorithm('3DES-ECB',forge.cipher.modes.ecb);registerAlgorithm('3DES-CBC',forge.cipher.modes.cbc);registerAlgorithm('3DES-CFB',forge.cipher.modes.cfb);registerAlgorithm('3DES-OFB',forge.cipher.modes.ofb);registerAlgorithm('3DES-CTR',forge.cipher.modes.ctr);function registerAlgorithm(name,mode){var factory=function factory(){return new forge.des.Algorithm(name,mode);};forge.cipher.registerAlgorithm(name,factory);}/** DES implementation **/var spfunction1=[0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];var spfunction2=[-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];var spfunction3=[0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];var spfunction4=[0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];var spfunction5=[0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];var spfunction6=[0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];var spfunction7=[0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];var spfunction8=[0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */function _createKeys(key){var pc2bytes0=[0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],pc2bytes1=[0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],pc2bytes2=[0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],pc2bytes3=[0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],pc2bytes4=[0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],pc2bytes5=[0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],pc2bytes6=[0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],pc2bytes7=[0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],pc2bytes8=[0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],pc2bytes9=[0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],pc2bytes10=[0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],pc2bytes11=[0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],pc2bytes12=[0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],pc2bytes13=[0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];// how many iterations (1 for des, 3 for triple des)
// changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
var iterations=key.length()>8?3:1;// stores the return keys
var keys=[];// now define the left shifts which need to be done
var shifts=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0];var n=0,tmp;for(var j=0;j<iterations;j++){var left=key.getInt32();var right=key.getInt32();tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>2^right)&0x33333333;right^=tmp;left^=tmp<<2;tmp=(right>>>-16^left)&0x0000ffff;left^=tmp;right^=tmp<<-16;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// right needs to be shifted and OR'd with last four bits of left
tmp=left<<8|right>>>20&0x000000f0;// left needs to be put upside down
left=right<<24|right<<8&0xff0000|right>>>8&0xff00|right>>>24&0xf0;right=tmp;// now go through and perform these shifts on the left and right keys
for(var i=0;i<shifts.length;++i){//shift the keys either one or two bits to the left
if(shifts[i]){left=left<<2|left>>>26;right=right<<2|right>>>26;}else{left=left<<1|left>>>27;right=right<<1|right>>>27;}left&=-0xf;right&=-0xf;// now apply PC-2, in such a way that E is easier when encrypting or
// decrypting this conversion will look like PC-2 except only the last 6
// bits of each byte are used rather than 48 consecutive bits and the
// order of lines will be according to how the S selection functions will
// be applied: S2, S4, S6, S8, S1, S3, S5, S7
var lefttmp=pc2bytes0[left>>>28]|pc2bytes1[left>>>24&0xf]|pc2bytes2[left>>>20&0xf]|pc2bytes3[left>>>16&0xf]|pc2bytes4[left>>>12&0xf]|pc2bytes5[left>>>8&0xf]|pc2bytes6[left>>>4&0xf];var righttmp=pc2bytes7[right>>>28]|pc2bytes8[right>>>24&0xf]|pc2bytes9[right>>>20&0xf]|pc2bytes10[right>>>16&0xf]|pc2bytes11[right>>>12&0xf]|pc2bytes12[right>>>8&0xf]|pc2bytes13[right>>>4&0xf];tmp=(righttmp>>>16^lefttmp)&0x0000ffff;keys[n++]=lefttmp^tmp;keys[n++]=righttmp^tmp<<16;}}return keys;}/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */function _updateBlock(keys,input,output,decrypt){// set up loops for single or triple DES
var iterations=keys.length===32?3:9;var looping;if(iterations===3){looping=decrypt?[30,-2,-2]:[0,32,2];}else{looping=decrypt?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];}var tmp;var left=input[0];var right=input[1];// first each 64 bit chunk of the message must be permuted according to IP
tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;// rotate left 1 bit
left=left<<1|left>>>31;right=right<<1|right>>>31;for(var j=0;j<iterations;j+=3){var endloop=looping[j+1];var loopinc=looping[j+2];// now go through and perform the encryption or decryption
for(var i=looping[j];i!=endloop;i+=loopinc){var right1=right^keys[i];var right2=(right>>>4|right<<28)^keys[i+1];// passing these bytes through the S selection functions
tmp=left;left=right;right=tmp^(spfunction2[right1>>>24&0x3f]|spfunction4[right1>>>16&0x3f]|spfunction6[right1>>>8&0x3f]|spfunction8[right1&0x3f]|spfunction1[right2>>>24&0x3f]|spfunction3[right2>>>16&0x3f]|spfunction5[right2>>>8&0x3f]|spfunction7[right2&0x3f]);}// unreverse left and right
tmp=left;left=right;right=tmp;}// rotate right 1 bit
left=left>>>1|left<<31;right=right>>>1|right<<31;// now perform IP-1, which is IP in the opposite direction
tmp=(left>>>1^right)&0x55555555;right^=tmp;left^=tmp<<1;tmp=(right>>>8^left)&0x00ff00ff;left^=tmp;right^=tmp<<8;tmp=(right>>>2^left)&0x33333333;left^=tmp;right^=tmp<<2;tmp=(left>>>16^right)&0x0000ffff;right^=tmp;left^=tmp<<16;tmp=(left>>>4^right)&0x0f0f0f0f;right^=tmp;left^=tmp<<4;output[0]=left;output[1]=right;}/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */function _createCipher(options){options=options||{};var mode=(options.mode||'CBC').toUpperCase();var algorithm='DES-'+mode;var cipher;if(options.decrypt){cipher=forge.cipher.createDecipher(algorithm,options.key);}else{cipher=forge.cipher.createCipher(algorithm,options.key);}// backwards compatible start API
var start=cipher.start;cipher.start=function(iv,options){// backwards compatibility: support second arg as output buffer
var output=null;if(options instanceof forge.util.ByteBuffer){output=options;options={};}options=options||{};options.output=output;options.iv=iv;start.call(cipher,options);};return cipher;}/***/},/* 13 */ /***/function(module,exports,__webpack_require__){/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(14);__webpack_require__(4);__webpack_require__(1);var pkcs5=forge.pkcs5=forge.pkcs5||{};var crypto;if(forge.util.isNodejs&&!forge.options.usePureJavaScript){crypto=__webpack_require__(15);}/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */module.exports=forge.pbkdf2=pkcs5.pbkdf2=function(p,s,c,dkLen,md,callback){if(typeof md==='function'){callback=md;md=null;}// use native implementation if possible and not disabled, note that
// some node versions only support SHA-1, others allow digest to be changed
if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&crypto.pbkdf2&&(md===null||_typeof(md)!=='object')&&(crypto.pbkdf2Sync.length>4||!md||md==='sha1')){if(typeof md!=='string'){// default prf to SHA-1
md='sha1';}p=new Buffer(p,'binary');s=new Buffer(s,'binary');if(!callback){if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2Sync(p,s,c,dkLen).toString('binary');}return crypto.pbkdf2Sync(p,s,c,dkLen,md).toString('binary');}if(crypto.pbkdf2Sync.length===4){return crypto.pbkdf2(p,s,c,dkLen,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}return crypto.pbkdf2(p,s,c,dkLen,md,function(err,key){if(err){return callback(err);}callback(null,key.toString('binary'));});}if(typeof md==='undefined'||md===null){// default prf to SHA-1
md='sha1';}if(typeof md==='string'){if(!(md in forge.md.algorithms)){throw new Error('Unknown hash algorithm: '+md);}md=forge.md[md].create();}var hLen=md.digestLength;/* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */if(dkLen>0xFFFFFFFF*hLen){var err=new Error('Derived key is too long.');if(callback){return callback(err);}throw err;}/* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */var len=Math.ceil(dkLen/hLen);var r=dkLen-(len-1)*hLen;/* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */var prf=forge.hmac.create();prf.start(md,p);var dk='';var xor,u_c,u_c1;// sync version
if(!callback){for(var i=1;i<=len;++i){// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
for(var j=2;j<=c;++j){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;}/* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);}/* 5. Output the derived key DK. */return dk;}// async version
var i=1,j;function outer(){if(i>len){// done
return callback(null,dk);}// PRF(P, S || INT(i)) (first iteration)
prf.start(null,null);prf.update(s);prf.update(forge.util.int32ToBytes(i));xor=u_c1=prf.digest().getBytes();// PRF(P, u_{c-1}) (other iterations)
j=2;inner();}function inner(){if(j<=c){prf.start(null,null);prf.update(u_c1);u_c=prf.digest().getBytes();// F(p, s, c, i)
xor=forge.util.xorBytes(xor,u_c,hLen);u_c1=u_c;++j;return forge.util.setImmediate(inner);}/* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:

      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */dk+=i<len?xor:xor.substr(0,r);++i;outer();}outer();};/***/},/* 14 */ /***/function(module,exports,__webpack_require__){/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);/* HMAC API */var hmac=module.exports=forge.hmac=forge.hmac||{};/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */hmac.create=function(){// the hmac key to use
var _key=null;// the message digest to use
var _md=null;// the inner padding
var _ipadding=null;// the outer padding
var _opadding=null;// hmac context
var ctx={};/**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */ctx.start=function(md,key){if(md!==null){if(typeof md==='string'){// create builtin message digest
md=md.toLowerCase();if(md in forge.md.algorithms){_md=forge.md.algorithms[md].create();}else{throw new Error('Unknown hash algorithm "'+md+'"');}}else{// store message digest
_md=md;}}if(key===null){// reuse previous key
key=_key;}else{if(typeof key==='string'){// convert string into byte buffer
key=forge.util.createBuffer(key);}else if(forge.util.isArray(key)){// convert byte array into byte buffer
var tmp=key;key=forge.util.createBuffer();for(var i=0;i<tmp.length;++i){key.putByte(tmp[i]);}}// if key is longer than blocksize, hash it
var keylen=key.length();if(keylen>_md.blockLength){_md.start();_md.update(key.bytes());key=_md.digest();}// mix key into inner and outer padding
// ipadding = [0x36 * blocksize] ^ key
// opadding = [0x5C * blocksize] ^ key
_ipadding=forge.util.createBuffer();_opadding=forge.util.createBuffer();keylen=key.length();for(var i=0;i<keylen;++i){var tmp=key.at(i);_ipadding.putByte(0x36^tmp);_opadding.putByte(0x5C^tmp);}// if key is shorter than blocksize, add additional padding
if(keylen<_md.blockLength){var tmp=_md.blockLength-keylen;for(var i=0;i<tmp;++i){_ipadding.putByte(0x36);_opadding.putByte(0x5C);}}_key=key;_ipadding=_ipadding.bytes();_opadding=_opadding.bytes();}// digest is done like so: hash(opadding | hash(ipadding | message))
// prepare to do inner hash
// hash(ipadding | message)
_md.start();_md.update(_ipadding);};/**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */ctx.update=function(bytes){_md.update(bytes);};/**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */ctx.getMac=function(){// digest is done like so: hash(opadding | hash(ipadding | message))
// here we do the outer hashing
var inner=_md.digest().bytes();_md.start();_md.update(_opadding);_md.update(inner);return _md.digest();};// alias for getMac
ctx.digest=ctx.getMac;return ctx;};/***/},/* 15 */ /***/function(module,exports){/* (ignored) */ /***/},/* 16 */ /***/function(module,exports,__webpack_require__){// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.
// Basic JavaScript BN library - subset useful for RSA encryption.
/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/ /*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */ /*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/var forge=__webpack_require__(0);module.exports=forge.jsbn=forge.jsbn||{};// Bits per digit
var dbits;// JavaScript engine analysis
var canary=0xdeadbeefcafe;var j_lm=(canary&0xffffff)==0xefcafe;// (public) Constructor
function BigInteger(a,b,c){this.data=[];if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b);}forge.jsbn.BigInteger=BigInteger;// return new, unset BigInteger
function nbi(){return new BigInteger(null);}// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this.data[i++]+w.data[j]+c;c=Math.floor(v/0x4000000);w.data[j++]=v&0x3ffffff;}return c;}// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n){var xl=x&0x7fff,xh=x>>15;while(--n>=0){var l=this.data[i]&0x7fff;var h=this.data[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);w.data[j++]=l&0x3fffffff;}return c;}// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n){var xl=x&0x3fff,xh=x>>14;while(--n>=0){var l=this.data[i]&0x3fff;var h=this.data[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&0x3fff)<<14)+w.data[j]+c;c=(l>>28)+(m>>14)+xh*h;w.data[j++]=l&0xfffffff;}return c;}// node.js (no browser)
if(typeof navigator==='undefined'){BigInteger.prototype.am=am3;dbits=28;}else if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30;}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26;}else{// Mozilla/Netscape seems to prefer am3
BigInteger.prototype.am=am3;dbits=28;}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;// Digit conversions
var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv;}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv;}function int2char(n){return BI_RM.charAt(n);}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];return c==null?-1:c;}// (protected) copy this to r
function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i){r.data[i]=this.data[i];}r.t=this.t;r.s=this.s;}// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this.data[0]=x;else if(x<-1)this.data[0]=x+this.DV;else this.t=0;}// return bigint initialized to value
function nbv(i){var r=nbi();r.fromInt(i);return r;}// (protected) set from string and radix
function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;// byte array
else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return;}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&0xff:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue;}mi=false;if(sh==0)this.data[this.t++]=x;else if(sh+k>this.DB){this.data[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this.data[this.t++]=x>>this.DB-sh;}else this.data[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB;}if(k==8&&(s[0]&0x80)!=0){this.s=-1;if(sh>0)this.data[this.t-1]|=(1<<this.DB-sh)-1<<sh;}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this);}// (protected) clamp off excess high words
function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this.data[this.t-1]==c){--this.t;}}// (public) return string representation in given radix
function bnToString(b){if(this.s<0)return"-"+this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)>0){m=true;r=int2char(d);}while(i>=0){if(p<k){d=(this.data[i]&(1<<p)-1)<<k-p;d|=this.data[--i]>>(p+=this.DB-k);}else{d=this.data[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i;}}if(d>0)m=true;if(m)r+=int2char(d);}}return m?r:"0";}// (public) -this
function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,r);return r;}// (public) |this|
function bnAbs(){return this.s<0?this.negate():this;}// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0){if((r=this.data[i]-a.data[i])!=0)return r;}return 0;}// returns bit length of the integer x
function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16;}if((t=x>>8)!=0){x=t;r+=8;}if((t=x>>4)!=0){x=t;r+=4;}if((t=x>>2)!=0){x=t;r+=2;}if((t=x>>1)!=0){x=t;r+=1;}return r;}// (public) return the number of bits in "this"
function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this.data[this.t-1]^this.s&this.DM);}// (protected) r = this << n*DB
function bnpDLShiftTo(n,r){var i;for(i=this.t-1;i>=0;--i){r.data[i+n]=this.data[i];}for(i=n-1;i>=0;--i){r.data[i]=0;}r.t=this.t+n;r.s=this.s;}// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i){r.data[i-n]=this.data[i];}r.t=Math.max(this.t-n,0);r.s=this.s;}// (protected) r = this << n
function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r.data[i+ds+1]=this.data[i]>>cbs|c;c=(this.data[i]&bm)<<bs;}for(i=ds-1;i>=0;--i){r.data[i]=0;}r.data[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp();}// (protected) r = this >> n
function bnpRShiftTo(n,r){r.s=this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return;}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r.data[0]=this.data[ds]>>bs;for(var i=ds+1;i<this.t;++i){r.data[i-ds-1]|=(this.data[i]&bm)<<cbs;r.data[i-ds]=this.data[i]>>bs;}if(bs>0)r.data[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp();}// (protected) r = this - a
function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]-a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c-=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c-=a.s;}r.s=c<0?-1:0;if(c<-1)r.data[i++]=this.DV+c;else if(c>0)r.data[i++]=c;r.t=i;r.clamp();}// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0){r.data[i]=0;}for(i=0;i<y.t;++i){r.data[i+x.t]=x.am(0,y.data[i],r,i,0,x.t);}r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r);}// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0){r.data[i]=0;}for(i=0;i<x.t-1;++i){var c=x.am(i,x.data[i],r,2*i,0,1);if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1))>=x.DV){r.data[i+x.t]-=x.DV;r.data[i+x.t+1]=1;}}if(r.t>0)r.data[r.t-1]+=x.am(i,x.data[i],r,2*i,0,1);r.s=0;r.clamp();}// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return;}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm.data[pm.t-1]);// normalize modulus
if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r);}else{pm.copyTo(y);pt.copyTo(r);}var ys=y.t;var y0=y.data[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y.data[ys-2]>>this.F2:0);var d1=this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r.data[r.t++]=1;r.subTo(t,r);}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);// "negative" y so we can replace sub with am later
while(y.t<ys){y.data[y.t++]=0;}while(--j>=0){// Estimate quotient digit
var qd=r.data[--i]==y0?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);if((r.data[i]+=y.am(0,qd,r,j,0,ys))<qd){// Try it out
y.dlShiftTo(j,t);r.subTo(t,r);while(r.data[i]<--qd){r.subTo(t,r);}}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q);}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);// Denormalize remainder
if(ts<0)BigInteger.ZERO.subTo(r,r);}// (public) this mod a
function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r;}// Modular reduction using "classic" algorithm
function Classic(m){this.m=m;}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x;}function cRevert(x){return x;}function cReduce(x){x.divRemTo(this.m,null,x);}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}function cSqrTo(x,r){x.squareTo(r);this.reduce(r);}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit(){if(this.t<1)return 0;var x=this.data[0];if((x&1)==0)return 0;var y=x&3;// y == 1/x mod 2^2
y=y*(2-(x&0xf)*y)&0xf;// y == 1/x mod 2^4
y=y*(2-(x&0xff)*y)&0xff;// y == 1/x mod 2^8
y=y*(2-((x&0xffff)*y&0xffff))&0xffff;// y == 1/x mod 2^16
// last step - calculate inverse mod DV directly;
// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
y=y*(2-x*y%this.DV)%this.DV;// y == 1/x mod 2^dbits
// we really want the negative inverse, and -DV < y < DV
return y>0?this.DV-y:-y;}// Montgomery reduction
function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&0x7fff;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t;}// xR mod m
function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r;}// x/R mod m
function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r;}// x = x/R mod m (HAC 14.32)
function montReduce(x){while(x.t<=this.mt2){// pad x so am has enough room later
x.data[x.t++]=0;}for(var i=0;i<this.m.t;++i){// faster way of calculating u0 = x.data[i]*mp mod DV
var j=x.data[i]&0x7fff;var u0=j*this.mpl+((j*this.mph+(x.data[i]>>15)*this.mpl&this.um)<<15)&x.DM;// use am to combine the multiply-shift-add into one call
j=i+this.m.t;x.data[j]+=this.m.am(0,u0,x,i,0,this.m.t);// propagate carry
while(x.data[j]>=x.DV){x.data[j]-=x.DV;x.data[++j]++;}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x);}// r = "x^2/R mod m"; x != r
function montSqrTo(x,r){x.squareTo(r);this.reduce(r);}// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;// (protected) true iff this is even
function bnpIsEven(){return(this.t>0?this.data[0]&1:this.s)==0;}// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z){if(e>0xffffffff||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t;}}return z.revert(r);}// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z);}// protected
BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;// public
BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;// "constants"
BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);// jsbn2 lib
//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).
//Extended JavaScript BN functions, required for RSA private ops.
//Version 1.1: new BigInteger("0", 10) returns "proper" zero
//(public)
function bnClone(){var r=nbi();this.copyTo(r);return r;}//(public) return value as integer
function bnIntValue(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;else if(this.t==0)return-1;}else if(this.t==1)return this.data[0];else if(this.t==0)return 0;// assumes 16 < DB < 32
return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0];}//(public) return value as byte
function bnByteValue(){return this.t==0?this.s:this.data[0]<<24>>24;}//(public) return value as short (assumes DB>=16)
function bnShortValue(){return this.t==0?this.s:this.data[0]<<16>>16;}//(protected) return x s.t. r^x < DV
function bnpChunkSize(r){return Math.floor(Math.LN2*this.DB/Math.log(r));}//(public) 0 if this == 0, 1 if this > 0
function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this.data[0]<=0)return 0;else return 1;}//(protected) convert to radix string
function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z);}return z.intValue().toString(b)+r;}//(protected) convert from radix string
function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue;}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0;}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0);}if(mi)BigInteger.ZERO.subTo(this,this);}//(protected) alternate constructor
function bnpFromNumber(a,b,c){if("number"==typeof b){// new BigInteger(int,int,RNG)
if(a<2)this.fromInt(1);else{this.fromNumber(a,c);if(!this.testBit(a-1))// force MSB set
this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);if(this.isEven())this.dAddOffset(1,0);// force odd
while(!this.isProbablePrime(b)){this.dAddOffset(2,0);if(this.bitLength()>a)this.subTo(BigInteger.ONE.shiftLeft(a-1),this);}}}else{// new BigInteger(int,RNG)
var x=new Array(),t=a&7;x.length=(a>>3)+1;b.nextBytes(x);if(t>0)x[0]&=(1<<t)-1;else x[0]=0;this.fromString(x,256);}}//(public) convert to bigendian byte array
function bnToByteArray(){var i=this.t,r=new Array();r[0]=this.s;var p=this.DB-i*this.DB%8,d,k=0;if(i-->0){if(p<this.DB&&(d=this.data[i]>>p)!=(this.s&this.DM)>>p)r[k++]=d|this.s<<this.DB-p;while(i>=0){if(p<8){d=(this.data[i]&(1<<p)-1)<<8-p;d|=this.data[--i]>>(p+=this.DB-8);}else{d=this.data[i]>>(p-=8)&0xff;if(p<=0){p+=this.DB;--i;}}if((d&0x80)!=0)d|=-256;if(k==0&&(this.s&0x80)!=(d&0x80))++k;if(k>0||d!=this.s)r[k++]=d;}}return r;}function bnEquals(a){return this.compareTo(a)==0;}function bnMin(a){return this.compareTo(a)<0?this:a;}function bnMax(a){return this.compareTo(a)>0?this:a;}//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r){var i,f,m=Math.min(a.t,this.t);for(i=0;i<m;++i){r.data[i]=op(this.data[i],a.data[i]);}if(a.t<this.t){f=a.s&this.DM;for(i=m;i<this.t;++i){r.data[i]=op(this.data[i],f);}r.t=this.t;}else{f=this.s&this.DM;for(i=m;i<a.t;++i){r.data[i]=op(f,a.data[i]);}r.t=a.t;}r.s=op(this.s,a.s);r.clamp();}//(public) this & a
function op_and(x,y){return x&y;}function bnAnd(a){var r=nbi();this.bitwiseTo(a,op_and,r);return r;}//(public) this | a
function op_or(x,y){return x|y;}function bnOr(a){var r=nbi();this.bitwiseTo(a,op_or,r);return r;}//(public) this ^ a
function op_xor(x,y){return x^y;}function bnXor(a){var r=nbi();this.bitwiseTo(a,op_xor,r);return r;}//(public) this & ~a
function op_andnot(x,y){return x&~y;}function bnAndNot(a){var r=nbi();this.bitwiseTo(a,op_andnot,r);return r;}//(public) ~this
function bnNot(){var r=nbi();for(var i=0;i<this.t;++i){r.data[i]=this.DM&~this.data[i];}r.t=this.t;r.s=~this.s;return r;}//(public) this << n
function bnShiftLeft(n){var r=nbi();if(n<0)this.rShiftTo(-n,r);else this.lShiftTo(n,r);return r;}//(public) this >> n
function bnShiftRight(n){var r=nbi();if(n<0)this.lShiftTo(-n,r);else this.rShiftTo(n,r);return r;}//return index of lowest 1-bit in x, x < 2^31
function lbit(x){if(x==0)return-1;var r=0;if((x&0xffff)==0){x>>=16;r+=16;}if((x&0xff)==0){x>>=8;r+=8;}if((x&0xf)==0){x>>=4;r+=4;}if((x&3)==0){x>>=2;r+=2;}if((x&1)==0)++r;return r;}//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit(){for(var i=0;i<this.t;++i){if(this.data[i]!=0)return i*this.DB+lbit(this.data[i]);}if(this.s<0)return this.t*this.DB;return-1;}//return number of 1 bits in x
function cbit(x){var r=0;while(x!=0){x&=x-1;++r;}return r;}//(public) return number of set bits
function bnBitCount(){var r=0,x=this.s&this.DM;for(var i=0;i<this.t;++i){r+=cbit(this.data[i]^x);}return r;}//(public) true iff nth bit is set
function bnTestBit(n){var j=Math.floor(n/this.DB);if(j>=this.t)return this.s!=0;return(this.data[j]&1<<n%this.DB)!=0;}//(protected) this op (1<<n)
function bnpChangeBit(n,op){var r=BigInteger.ONE.shiftLeft(n);this.bitwiseTo(r,op,r);return r;}//(public) this | (1<<n)
function bnSetBit(n){return this.changeBit(n,op_or);}//(public) this & ~(1<<n)
function bnClearBit(n){return this.changeBit(n,op_andnot);}//(public) this ^ (1<<n)
function bnFlipBit(n){return this.changeBit(n,op_xor);}//(protected) r = this + a
function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this.data[i]+a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}if(a.t<this.t){c+=a.s;while(i<this.t){c+=this.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=this.s;}else{c+=this.s;while(i<a.t){c+=a.data[i];r.data[i++]=c&this.DM;c>>=this.DB;}c+=a.s;}r.s=c<0?-1:0;if(c>0)r.data[i++]=c;else if(c<-1)r.data[i++]=this.DV+c;r.t=i;r.clamp();}//(public) this + a
function bnAdd(a){var r=nbi();this.addTo(a,r);return r;}//(public) this - a
function bnSubtract(a){var r=nbi();this.subTo(a,r);return r;}//(public) this * a
function bnMultiply(a){var r=nbi();this.multiplyTo(a,r);return r;}//(public) this / a
function bnDivide(a){var r=nbi();this.divRemTo(a,r,null);return r;}//(public) this % a
function bnRemainder(a){var r=nbi();this.divRemTo(a,null,r);return r;}//(public) [this/a,this%a]
function bnDivideAndRemainder(a){var q=nbi(),r=nbi();this.divRemTo(a,q,r);return new Array(q,r);}//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n){this.data[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp();}//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w){this.data[this.t++]=0;}this.data[w]+=n;while(this.data[w]>=this.DV){this.data[w]-=this.DV;if(++w>=this.t)this.data[this.t++]=0;++this.data[w];}}//A "null" reducer
function NullExp(){}function nNop(x){return x;}function nMulTo(x,y,r){x.multiplyTo(y,r);}function nSqrTo(x,r){x.squareTo(r);}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;//(public) this^e
function bnPow(e){return this.exp(e,new NullExp());}//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r){var i=Math.min(this.t+a.t,n);r.s=0;// assumes a,this >= 0
r.t=i;while(i>0){r.data[--i]=0;}var j;for(j=r.t-this.t;i<j;++i){r.data[i+this.t]=this.am(0,a.data[i],r,i,0,this.t);}for(j=Math.min(a.t,n);i<j;++i){this.am(0,a.data[i],r,i,0,n-i);}r.clamp();}//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r){--n;var i=r.t=this.t+a.t-n;r.s=0;// assumes a,this >= 0
while(--i>=0){r.data[i]=0;}for(i=Math.max(n-this.t,0);i<a.t;++i){r.data[this.t+i-n]=this.am(n-i,a.data[i],r,0,0,this.t+i-n);}r.clamp();r.drShiftTo(1,r);}//Barrett modular reduction
function Barrett(m){// setup Barrett
this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*m.t,this.r2);this.mu=this.r2.divide(m);this.m=m;}function barrettConvert(x){if(x.s<0||x.t>2*this.m.t)return x.mod(this.m);else if(x.compareTo(this.m)<0)return x;else{var r=nbi();x.copyTo(r);this.reduce(r);return r;}}function barrettRevert(x){return x;}//x = x mod m (HAC 14.42)
function barrettReduce(x){x.drShiftTo(this.m.t-1,this.r2);if(x.t>this.m.t+1){x.t=this.m.t+1;x.clamp();}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(x.compareTo(this.r2)<0){x.dAddOffset(1,this.m.t+1);}x.subTo(this.r2,x);while(x.compareTo(this.m)>=0){x.subTo(this.m,x);}}//r = x^2 mod m; x != r
function barrettSqrTo(x,r){x.squareTo(r);this.reduce(r);}//r = x*y mod m; x,y != r
function barrettMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r);}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;//(public) this^e % m (HAC 14.85)
function bnModPow(e,m){var i=e.bitLength(),k,r=nbv(1),z;if(i<=0)return r;else if(i<18)k=1;else if(i<48)k=3;else if(i<144)k=4;else if(i<768)k=5;else k=6;if(i<8)z=new Classic(m);else if(m.isEven())z=new Barrett(m);else z=new Montgomery(m);// precomputation
var g=new Array(),n=3,k1=k-1,km=(1<<k)-1;g[1]=z.convert(this);if(k>1){var g2=nbi();z.sqrTo(g[1],g2);while(n<=km){g[n]=nbi();z.mulTo(g2,g[n-2],g[n]);n+=2;}}var j=e.t-1,w,is1=true,r2=nbi(),t;i=nbits(e.data[j])-1;while(j>=0){if(i>=k1)w=e.data[j]>>i-k1&km;else{w=(e.data[j]&(1<<i+1)-1)<<k1-i;if(j>0)w|=e.data[j-1]>>this.DB+i-k1;}n=k;while((w&1)==0){w>>=1;--n;}if((i-=n)<0){i+=this.DB;--j;}if(is1){// ret == 1, don't bother squaring or multiplying it
g[w].copyTo(r);is1=false;}else{while(n>1){z.sqrTo(r,r2);z.sqrTo(r2,r);n-=2;}if(n>0)z.sqrTo(r,r2);else{t=r;r=r2;r2=t;}z.mulTo(r2,g[w],r);}while(j>=0&&(e.data[j]&1<<i)==0){z.sqrTo(r,r2);t=r;r=r2;r2=t;if(--i<0){i=this.DB-1;--j;}}}return z.revert(r);}//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a){var x=this.s<0?this.negate():this.clone();var y=a.s<0?a.negate():a.clone();if(x.compareTo(y)<0){var t=x;x=y;y=t;}var i=x.getLowestSetBit(),g=y.getLowestSetBit();if(g<0)return x;if(i<g)g=i;if(g>0){x.rShiftTo(g,x);y.rShiftTo(g,y);}while(x.signum()>0){if((i=x.getLowestSetBit())>0)x.rShiftTo(i,x);if((i=y.getLowestSetBit())>0)y.rShiftTo(i,y);if(x.compareTo(y)>=0){x.subTo(y,x);x.rShiftTo(1,x);}else{y.subTo(x,y);y.rShiftTo(1,y);}}if(g>0)y.lShiftTo(g,y);return y;}//(protected) this % n, n < 2^26
function bnpModInt(n){if(n<=0)return 0;var d=this.DV%n,r=this.s<0?n-1:0;if(this.t>0)if(d==0)r=this.data[0]%n;else for(var i=this.t-1;i>=0;--i){r=(d*r+this.data[i])%n;}return r;}//(public) 1/this % m (HAC 14.61)
function bnModInverse(m){var ac=m.isEven();if(this.isEven()&&ac||m.signum()==0)return BigInteger.ZERO;var u=m.clone(),v=this.clone();var a=nbv(1),b=nbv(0),c=nbv(0),d=nbv(1);while(u.signum()!=0){while(u.isEven()){u.rShiftTo(1,u);if(ac){if(!a.isEven()||!b.isEven()){a.addTo(this,a);b.subTo(m,b);}a.rShiftTo(1,a);}else if(!b.isEven())b.subTo(m,b);b.rShiftTo(1,b);}while(v.isEven()){v.rShiftTo(1,v);if(ac){if(!c.isEven()||!d.isEven()){c.addTo(this,c);d.subTo(m,d);}c.rShiftTo(1,c);}else if(!d.isEven())d.subTo(m,d);d.rShiftTo(1,d);}if(u.compareTo(v)>=0){u.subTo(v,u);if(ac)a.subTo(c,a);b.subTo(d,b);}else{v.subTo(u,v);if(ac)c.subTo(a,c);d.subTo(b,d);}}if(v.compareTo(BigInteger.ONE)!=0)return BigInteger.ZERO;if(d.compareTo(m)>=0)return d.subtract(m);if(d.signum()<0)d.addTo(m,d);else return d;if(d.signum()<0)return d.add(m);else return d;}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];var lplim=(1<<26)/lowprimes[lowprimes.length-1];//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t){var i,x=this.abs();if(x.t==1&&x.data[0]<=lowprimes[lowprimes.length-1]){for(i=0;i<lowprimes.length;++i){if(x.data[0]==lowprimes[i])return true;}return false;}if(x.isEven())return false;i=1;while(i<lowprimes.length){var m=lowprimes[i],j=i+1;while(j<lowprimes.length&&m<lplim){m*=lowprimes[j++];}m=x.modInt(m);while(i<j){if(m%lowprimes[i++]==0)return false;}}return x.millerRabin(t);}//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t){var n1=this.subtract(BigInteger.ONE);var k=n1.getLowestSetBit();if(k<=0)return false;var r=n1.shiftRight(k);var prng=bnGetPrng();var a;for(var i=0;i<t;++i){// select witness 'a' at random from between 1 and n1
do{a=new BigInteger(this.bitLength(),prng);}while(a.compareTo(BigInteger.ONE)<=0||a.compareTo(n1)>=0);var y=a.modPow(r,this);if(y.compareTo(BigInteger.ONE)!=0&&y.compareTo(n1)!=0){var j=1;while(j++<k&&y.compareTo(n1)!=0){y=y.modPowInt(2,this);if(y.compareTo(BigInteger.ONE)==0)return false;}if(y.compareTo(n1)!=0)return false;}}return true;}// get pseudo random number generator
function bnGetPrng(){// create prng with api that matches BigInteger secure random
return{// x is an array to fill with bytes
nextBytes:function nextBytes(x){for(var i=0;i<x.length;++i){x[i]=Math.floor(Math.random()*0x0100);}}};}//protected
BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;//public
BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;//BigInteger interfaces not implemented in jsbn:
//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)
/***/},/* 17 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha1=module.exports=forge.sha1=forge.sha1||{};forge.md.sha1=forge.md.algorithms.sha1=sha1;/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */sha1.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-1 state contains five 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(80);// message digest object
var md={algorithm:'sha1',blockLength:64,digestLength:20,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x67452301,h1:0xEFCDAB89,h2:0x98BADCFE,h3:0x10325476,h4:0xC3D2E1F0};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
    * Produces the digest.
    *
    * @return a byte buffer containing the digest value.
    */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);return rval;};return md;};// sha-1 padding bytes not initialized yet
var _padding=null;var _initialized=false;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// now initialized
_initialized=true;}/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t,a,b,c,d,e,f,i;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 80 32-bit words according to SHA-1 algorithm
// and for 32-79 using Max Locktyukhin's optimization
// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;// round 1
for(i=0;i<16;++i){t=bytes.getInt32();w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<20;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=d^b&(c^d);t=(a<<5|a>>>27)+f+e+0x5A827999+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 2
for(;i<32;++i){t=w[i-3]^w[i-8]^w[i-14]^w[i-16];t=t<<1|t>>>31;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}for(;i<40;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0x6ED9EBA1+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 3
for(;i<60;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b&c|d&(b^c);t=(a<<5|a>>>27)+f+e+0x8F1BBCDC+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// round 4
for(;i<80;++i){t=w[i-6]^w[i-16]^w[i-28]^w[i-32];t=t<<2|t>>>30;w[i]=t;f=b^c^d;t=(a<<5|a>>>27)+f+e+0xCA62C1D6+t;e=d;d=c;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
c=(b<<30|b>>>2)>>>0;b=a;a=t;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;len-=64;}}/***/},/* 18 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */var forge=__webpack_require__(0);__webpack_require__(7);__webpack_require__(2);__webpack_require__(12);__webpack_require__(4);__webpack_require__(30);__webpack_require__(3);__webpack_require__(8);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};var oids=pki.oids;// short name OID mappings
var _shortNames={};_shortNames['CN']=oids['commonName'];_shortNames['commonName']='CN';_shortNames['C']=oids['countryName'];_shortNames['countryName']='C';_shortNames['L']=oids['localityName'];_shortNames['localityName']='L';_shortNames['ST']=oids['stateOrProvinceName'];_shortNames['stateOrProvinceName']='ST';_shortNames['O']=oids['organizationName'];_shortNames['organizationName']='O';_shortNames['OU']=oids['organizationalUnitName'];_shortNames['organizationalUnitName']='OU';_shortNames['E']=oids['emailAddress'];_shortNames['emailAddress']='E';// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator=forge.pki.rsa.publicKeyValidator;// validator for an X.509v3 certificate
var x509CertificateValidator={name:'Certificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'tbsCertificate',value:[{name:'Certificate.TBSCertificate.version',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.version.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certVersion'}]},{name:'Certificate.TBSCertificate.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certSerialNumber'},{name:'Certificate.TBSCertificate.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Certificate.TBSCertificate.signature.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certinfoSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certinfoSignatureParams'}]},{name:'Certificate.TBSCertificate.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certIssuer'},{name:'Certificate.TBSCertificate.validity',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,// Note: UTC and generalized times may both appear so the capture
// names are based on their detected order, the names used below
// are only for the common case, which validity time really means
// "notBefore" and which means "notAfter" will be determined by order
value:[{// notBefore (Time) (UTC time case)
name:'Certificate.TBSCertificate.validity.notBefore (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity1UTCTime'},{// notBefore (Time) (generalized time case)
name:'Certificate.TBSCertificate.validity.notBefore (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity2GeneralizedTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (utc)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.UTCTIME,constructed:false,optional:true,capture:'certValidity3UTCTime'},{// notAfter (Time) (only UTC time is supported)
name:'Certificate.TBSCertificate.validity.notAfter (generalized)',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.GENERALIZEDTIME,constructed:false,optional:true,capture:'certValidity4GeneralizedTime'}]},{// Name (subject) (RDNSequence)
name:'Certificate.TBSCertificate.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{// issuerUniqueID (optional)
name:'Certificate.TBSCertificate.issuerUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.issuerUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certIssuerUniqueId'}]},{// subjectUniqueID (optional)
name:'Certificate.TBSCertificate.subjectUniqueID',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,constructed:true,optional:true,value:[{name:'Certificate.TBSCertificate.subjectUniqueID.id',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,// TODO: support arbitrary bit length ids
captureBitStringValue:'certSubjectUniqueId'}]},{// Extensions (optional)
name:'Certificate.TBSCertificate.extensions',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,constructed:true,captureAsn1:'certExtensions',optional:true}]},{// AlgorithmIdentifier (signature algorithm)
name:'Certificate.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'Certificate.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certSignatureOid'},{name:'Certificate.TBSCertificate.signature.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'certSignatureParams'}]},{// SignatureValue
name:'Certificate.signatureValue',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'certSignature'}]};var rsassaPssParameterValidator={name:'rsapss',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.hashAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'hashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]},{name:'rsapss.maskGenAlgorithm',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.SEQUENCE,constructed:true,optional:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenOid'},{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'maskGenHashOid'/* parameter block omitted, for SHA1 NULL anyhow. */}]}]}]},{name:'rsapss.saltLength',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:2,optional:true,value:[{name:'rsapss.saltLength.saltLength',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'saltLength'}]},{name:'rsapss.trailerField',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:3,optional:true,value:[{name:'rsapss.trailer.trailer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.INTEGER,constructed:false,capture:'trailer'}]}]};// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator={name:'CertificationRequestInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfo',value:[{name:'CertificationRequestInfo.integer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'certificationRequestInfoVersion'},{// Name (subject) (RDNSequence)
name:'CertificationRequestInfo.subject',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'certificationRequestInfoSubject'},// SubjectPublicKeyInfo
publicKeyValidator,{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'certificationRequestInfoAttributes',value:[{name:'CertificationRequestInfo.attributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertificationRequestInfo.attributes.type',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false},{name:'CertificationRequestInfo.attributes.value',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true}]}]}]};// validator for a CertificationRequest structure
var certificationRequestValidator={name:'CertificationRequest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'csr',value:[certificationRequestInfoValidator,{// AlgorithmIdentifier (signature algorithm)
name:'CertificationRequest.signatureAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{// algorithm
name:'CertificationRequest.signatureAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'csrSignatureOid'},{name:'CertificationRequest.signatureAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,optional:true,captureAsn1:'csrSignatureParams'}]},{// signature
name:'CertificationRequest.signature',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.BITSTRING,constructed:false,captureBitStringValue:'csrSignature'}]};/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */pki.RDNAttributesAsArray=function(rdn,md){var rval=[];// each value in 'rdn' in is a SET of RelativeDistinguishedName
var set,attr,obj;for(var si=0;si<rdn.value.length;++si){// get the RelativeDistinguishedName set
set=rdn.value[si];// each value in the SET is an AttributeTypeAndValue sequence
// containing first a type (an OID) and second a value (defined by
// the OID)
for(var i=0;i<set.value.length;++i){obj={};attr=set.value[i];obj.type=asn1.derToOid(attr.value[0].value);obj.value=attr.value[1].value;obj.valueTagClass=attr.value[1].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}if(md){md.update(obj.type);md.update(obj.value);}rval.push(obj);}}return rval;};/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */pki.CRIAttributesAsArray=function(attributes){var rval=[];// each value in 'attributes' in is a SEQUENCE with an OID and a SET
for(var si=0;si<attributes.length;++si){// get the attribute sequence
var seq=attributes[si];// each value in the SEQUENCE containing first a type (an OID) and
// second a set of values (defined by the OID)
var type=asn1.derToOid(seq.value[0].value);var values=seq.value[1].value;for(var vi=0;vi<values.length;++vi){var obj={};obj.type=type;obj.value=values[vi].value;obj.valueTagClass=values[vi].type;// if the OID is known, get its name and short name
if(obj.type in oids){obj.name=oids[obj.type];if(obj.name in _shortNames){obj.shortName=_shortNames[obj.name];}}// parse extensions
if(obj.type===oids.extensionRequest){obj.extensions=[];for(var ei=0;ei<obj.value.length;++ei){obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));}}rval.push(obj);}}return rval;};/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */function _getAttribute(obj,options){if(typeof options==='string'){options={shortName:options};}var rval=null;var attr;for(var i=0;rval===null&&i<obj.attributes.length;++i){attr=obj.attributes[i];if(options.type&&options.type===attr.type){rval=attr;}else if(options.name&&options.name===attr.name){rval=attr;}else if(options.shortName&&options.shortName===attr.shortName){rval=attr;}}return rval;}/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */var _readSignatureParameters=function _readSignatureParameters(oid,obj,fillDefaults){var params={};if(oid!==oids['RSASSA-PSS']){return params;}if(fillDefaults){params={hash:{algorithmOid:oids['sha1']},mgf:{algorithmOid:oids['mgf1'],hash:{algorithmOid:oids['sha1']}},saltLength:20};}var capture={};var errors=[];if(!asn1.validate(obj,rsassaPssParameterValidator,capture,errors)){var error=new Error('Cannot read RSASSA-PSS parameter block.');error.errors=errors;throw error;}if(capture.hashOid!==undefined){params.hash=params.hash||{};params.hash.algorithmOid=asn1.derToOid(capture.hashOid);}if(capture.maskGenOid!==undefined){params.mgf=params.mgf||{};params.mgf.algorithmOid=asn1.derToOid(capture.maskGenOid);params.mgf.hash=params.mgf.hash||{};params.mgf.hash.algorithmOid=asn1.derToOid(capture.maskGenHashOid);}if(capture.saltLength!==undefined){params.saltLength=capture.saltLength.charCodeAt(0);}return params;};/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */pki.certificateFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE'&&msg.type!=='X509 CERTIFICATE'&&msg.type!=='TRUSTED CERTIFICATE'){var error=new Error('Could not convert certificate from PEM; PEM header type '+'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certificate from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificateFromAsn1(obj,computeHash);};/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */pki.certificateToPem=function(cert,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE',body:asn1.toDer(pki.certificateToAsn1(cert)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */pki.publicKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PUBLIC KEY'&&msg.type!=='RSA PUBLIC KEY'){var error=new Error('Could not convert public key from PEM; PEM header '+'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert public key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.publicKeyFromAsn1(obj);};/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'PUBLIC KEY',body:asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */pki.publicKeyToRSAPublicKeyPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PUBLIC KEY',body:asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */pki.getPublicKeyFingerprint=function(key,options){options=options||{};var md=options.md||forge.md.sha1.create();var type=options.type||'RSAPublicKey';var bytes;switch(type){case'RSAPublicKey':bytes=asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();break;case'SubjectPublicKeyInfo':bytes=asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+options.type+'".');}// hash public key bytes
md.start();md.update(bytes);var digest=md.digest();if(options.encoding==='hex'){var hex=digest.toHex();if(options.delimiter){return hex.match(/.{2}/g).join(options.delimiter);}return hex;}else if(options.encoding==='binary'){return digest.getBytes();}else if(options.encoding){throw new Error('Unknown encoding "'+options.encoding+'".');}return digest;};/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromPem=function(pem,computeHash,strict){var msg=forge.pem.decode(pem)[0];if(msg.type!=='CERTIFICATE REQUEST'){var error=new Error('Could not convert certification request from PEM; '+'PEM header type is not "CERTIFICATE REQUEST".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert certification request from PEM; '+'PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body,strict);return pki.certificationRequestFromAsn1(obj,computeHash);};/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */pki.certificationRequestToPem=function(csr,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'CERTIFICATE REQUEST',body:asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */pki.createCertificate=function(){var cert={};cert.version=0x02;cert.serialNumber='00';cert.signatureOid=null;cert.signature=null;cert.siginfo={};cert.siginfo.algorithmOid=null;cert.validity={};cert.validity.notBefore=new Date();cert.validity.notAfter=new Date();cert.issuer={};cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=[];cert.issuer.hash=null;cert.subject={};cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=[];cert.subject.hash=null;cert.extensions=[];cert.publicKey=null;cert.md=null;/**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setSubject=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.subject.attributes=attrs;delete cert.subject.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.subject.uniqueId=uniqueId;}cert.subject.hash=null;};/**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */cert.setIssuer=function(attrs,uniqueId){// set new attributes, clear hash
_fillMissingFields(attrs);cert.issuer.attributes=attrs;delete cert.issuer.uniqueId;if(uniqueId){// TODO: support arbitrary bit length ids
cert.issuer.uniqueId=uniqueId;}cert.issuer.hash=null;};/**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */cert.setExtensions=function(exts){for(var i=0;i<exts.length;++i){_fillMissingExtensionFields(exts[i],{cert:cert});}// set new extensions
cert.extensions=exts;};/**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */cert.getExtension=function(options){if(typeof options==='string'){options={name:options};}var rval=null;var ext;for(var i=0;rval===null&&i<cert.extensions.length;++i){ext=cert.extensions[i];if(options.id&&ext.id===options.id){rval=ext;}else if(options.name&&ext.name===options.name){rval=ext;}}return rval;};/**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */cert.sign=function(key,md){// TODO: get signature OID from private key
cert.md=md||forge.md.sha1.create();var algorithmOid=oids[cert.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certificate digest. '+'Unknown message digest algorithm OID.');error.algorithm=cert.md.algorithm;throw error;}cert.signatureOid=cert.siginfo.algorithmOid=algorithmOid;// get TBSCertificate, convert to DER
cert.tbsCertificate=pki.getTBSCertificate(cert);var bytes=asn1.toDer(cert.tbsCertificate);// digest and sign
cert.md.update(bytes.getBytes());cert.signature=key.sign(cert.md);};/**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */cert.verify=function(child){var rval=false;if(!cert.issued(child)){var issuer=child.issuer;var subject=cert.subject;var error=new Error('The parent certificate did not issue the given child '+'certificate; the child certificate\'s issuer does not match the '+'parent\'s subject.');error.expectedIssuer=issuer.attributes;error.actualIssuer=subject.attributes;throw error;}var md=child.md;if(md===null){// check signature OID for supported signature types
if(child.signatureOid in oids){var oid=oids[child.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=child.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var tbsCertificate=child.tbsCertificate||pki.getTBSCertificate(child);var bytes=asn1.toDer(tbsCertificate);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(child.signatureOid){case oids.sha1WithRSAEncryption:scheme=undefined;/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[child.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=child.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[child.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=child.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[child.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){throw{message:'Unsupported RSASSA-PSS hash function.',oid:child.signatureParameters.hash.algorithmOid,name:hash};}scheme=forge.pss.create(forge.md[hash].create(),mgf,child.signatureParameters.saltLength);break;}// verify signature on cert using public key
rval=cert.publicKey.verify(md.digest().getBytes(),child.signature,scheme);}return rval;};/**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */cert.isIssuer=function(parent){var rval=false;var i=cert.issuer;var s=parent.subject;// compare hashes if present
if(i.hash&&s.hash){rval=i.hash===s.hash;}else if(i.attributes.length===s.attributes.length){// all attributes are the same so issuer matches subject
rval=true;var iattr,sattr;for(var n=0;rval&&n<i.attributes.length;++n){iattr=i.attributes[n];sattr=s.attributes[n];if(iattr.type!==sattr.type||iattr.value!==sattr.value){// attribute mismatch
rval=false;}}}return rval;};/**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */cert.issued=function(child){return child.isIssuer(cert);};/**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */cert.generateSubjectKeyIdentifier=function(){/* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */ // skipping the tag, length, and number of unused bits is the same
// as just using the RSAPublicKey (for RSA keys, which are the
// only ones supported)
return pki.getPublicKeyFingerprint(cert.publicKey,{type:'RSAPublicKey'});};/**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */cert.verifySubjectKeyIdentifier=function(){var oid=oids['subjectKeyIdentifier'];for(var i=0;i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.id===oid){var ski=cert.generateSubjectKeyIdentifier().getBytes();return forge.util.hexToBytes(ext.subjectKeyIdentifier)===ski;}}return false;};return cert;};/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */pki.certificateFromAsn1=function(obj,computeHash){// validate certificate and capture data
var capture={};var errors=[];if(!asn1.validate(obj,x509CertificateValidator,capture,errors)){var error=new Error('Cannot read X.509 certificate. '+'ASN.1 object is not an X509v3 Certificate.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certificate
var cert=pki.createCertificate();cert.version=capture.certVersion?capture.certVersion.charCodeAt(0):0;var serial=forge.util.createBuffer(capture.certSerialNumber);cert.serialNumber=serial.toHex();cert.signatureOid=forge.asn1.derToOid(capture.certSignatureOid);cert.signatureParameters=_readSignatureParameters(cert.signatureOid,capture.certSignatureParams,true);cert.siginfo.algorithmOid=forge.asn1.derToOid(capture.certinfoSignatureOid);cert.siginfo.parameters=_readSignatureParameters(cert.siginfo.algorithmOid,capture.certinfoSignatureParams,false);cert.signature=capture.certSignature;var validity=[];if(capture.certValidity1UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));}if(capture.certValidity2GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));}if(capture.certValidity3UTCTime!==undefined){validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));}if(capture.certValidity4GeneralizedTime!==undefined){validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));}if(validity.length>2){throw new Error('Cannot read notBefore/notAfter validity times; more '+'than two times were provided in the certificate.');}if(validity.length<2){throw new Error('Cannot read notBefore/notAfter validity times; they '+'were not provided as either UTCTime or GeneralizedTime.');}cert.validity.notBefore=validity[0];cert.validity.notAfter=validity[1];// keep TBSCertificate to preserve signature when exporting
cert.tbsCertificate=capture.tbsCertificate;if(computeHash){// check signature OID for supported signature types
cert.md=null;if(cert.signatureOid in oids){var oid=oids[cert.signatureOid];switch(oid){case'sha1WithRSAEncryption':cert.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':cert.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':cert.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':cert.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':cert.md=forge.md.sha512.create();break;case'RSASSA-PSS':cert.md=forge.md.sha256.create();break;}}if(cert.md===null){var error=new Error('Could not compute certificate digest. '+'Unknown signature OID.');error.signatureOid=cert.signatureOid;throw error;}// produce DER formatted TBSCertificate and digest it
var bytes=asn1.toDer(cert.tbsCertificate);cert.md.update(bytes.getBytes());}// handle issuer, build issuer message digest
var imd=forge.md.sha1.create();cert.issuer.getField=function(sn){return _getAttribute(cert.issuer,sn);};cert.issuer.addField=function(attr){_fillMissingFields([attr]);cert.issuer.attributes.push(attr);};cert.issuer.attributes=pki.RDNAttributesAsArray(capture.certIssuer,imd);if(capture.certIssuerUniqueId){cert.issuer.uniqueId=capture.certIssuerUniqueId;}cert.issuer.hash=imd.digest().toHex();// handle subject, build subject message digest
var smd=forge.md.sha1.create();cert.subject.getField=function(sn){return _getAttribute(cert.subject,sn);};cert.subject.addField=function(attr){_fillMissingFields([attr]);cert.subject.attributes.push(attr);};cert.subject.attributes=pki.RDNAttributesAsArray(capture.certSubject,smd);if(capture.certSubjectUniqueId){cert.subject.uniqueId=capture.certSubjectUniqueId;}cert.subject.hash=smd.digest().toHex();// handle extensions
if(capture.certExtensions){cert.extensions=pki.certificateExtensionsFromAsn1(capture.certExtensions);}else{cert.extensions=[];}// convert RSA public key from ASN.1
cert.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);return cert;};/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */pki.certificateExtensionsFromAsn1=function(exts){var rval=[];for(var i=0;i<exts.value.length;++i){// get extension sequence
var extseq=exts.value[i];for(var ei=0;ei<extseq.value.length;++ei){rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));}}return rval;};/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */pki.certificateExtensionFromAsn1=function(ext){// an extension has:
// [0] extnID      OBJECT IDENTIFIER
// [1] critical    BOOLEAN DEFAULT FALSE
// [2] extnValue   OCTET STRING
var e={};e.id=asn1.derToOid(ext.value[0].value);e.critical=false;if(ext.value[1].type===asn1.Type.BOOLEAN){e.critical=ext.value[1].value.charCodeAt(0)!==0x00;e.value=ext.value[2].value;}else{e.value=ext.value[1].value;}// if the oid is known, get its name
if(e.id in oids){e.name=oids[e.id];// handle key usage
if(e.name==='keyUsage'){// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;var b3=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);b3=ev.value.length>2?ev.value.charCodeAt(2):0;}// set flags
e.digitalSignature=(b2&0x80)===0x80;e.nonRepudiation=(b2&0x40)===0x40;e.keyEncipherment=(b2&0x20)===0x20;e.dataEncipherment=(b2&0x10)===0x10;e.keyAgreement=(b2&0x08)===0x08;e.keyCertSign=(b2&0x04)===0x04;e.cRLSign=(b2&0x02)===0x02;e.encipherOnly=(b2&0x01)===0x01;e.decipherOnly=(b3&0x80)===0x80;}else if(e.name==='basicConstraints'){// handle basic constraints
// get value as SEQUENCE
var ev=asn1.fromDer(e.value);// get cA BOOLEAN flag (defaults to false)
if(ev.value.length>0&&ev.value[0].type===asn1.Type.BOOLEAN){e.cA=ev.value[0].value.charCodeAt(0)!==0x00;}else{e.cA=false;}// get path length constraint
var value=null;if(ev.value.length>0&&ev.value[0].type===asn1.Type.INTEGER){value=ev.value[0].value;}else if(ev.value.length>1){value=ev.value[1].value;}if(value!==null){e.pathLenConstraint=asn1.derToInteger(value);}}else if(e.name==='extKeyUsage'){// handle extKeyUsage
// value is a SEQUENCE of OIDs
var ev=asn1.fromDer(e.value);for(var vi=0;vi<ev.value.length;++vi){var oid=asn1.derToOid(ev.value[vi].value);if(oid in oids){e[oids[oid]]=true;}else{e[oid]=true;}}}else if(e.name==='nsCertType'){// handle nsCertType
// get value as BIT STRING
var ev=asn1.fromDer(e.value);var b2=0x00;if(ev.value.length>1){// skip first byte, just indicates unused bits which
// will be padded with 0s anyway
// get bytes with flag bits
b2=ev.value.charCodeAt(1);}// set flags
e.client=(b2&0x80)===0x80;e.server=(b2&0x40)===0x40;e.email=(b2&0x20)===0x20;e.objsign=(b2&0x10)===0x10;e.reserved=(b2&0x08)===0x08;e.sslCA=(b2&0x04)===0x04;e.emailCA=(b2&0x02)===0x02;e.objCA=(b2&0x01)===0x01;}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// handle subjectAltName/issuerAltName
e.altNames=[];// ev is a SYNTAX SEQUENCE
var gn;var ev=asn1.fromDer(e.value);for(var n=0;n<ev.value.length;++n){// get GeneralName
gn=ev.value[n];var altName={type:gn.type,value:gn.value};e.altNames.push(altName);// Note: Support for types 1,2,6,7,8
switch(gn.type){// rfc822Name
case 1:// dNSName
case 2:// uniformResourceIdentifier (URI)
case 6:break;// IPAddress
case 7:// convert to IPv4/IPv6 string representation
altName.ip=forge.util.bytesToIP(gn.value);break;// registeredID
case 8:altName.oid=asn1.derToOid(gn.value);break;default:// unsupported
}}}else if(e.name==='subjectKeyIdentifier'){// value is an OCTETSTRING w/the hash of the key-type specific
// public key structure (eg: RSAPublicKey)
var ev=asn1.fromDer(e.value);e.subjectKeyIdentifier=forge.util.bytesToHex(ev.value);}}return e;};/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */pki.certificationRequestFromAsn1=function(obj,computeHash){// validate certification request and capture data
var capture={};var errors=[];if(!asn1.validate(obj,certificationRequestValidator,capture,errors)){var error=new Error('Cannot read PKCS#10 certificate request. '+'ASN.1 object is not a PKCS#10 CertificationRequest.');error.errors=errors;throw error;}// get oid
var oid=asn1.derToOid(capture.publicKeyOid);if(oid!==pki.oids.rsaEncryption){throw new Error('Cannot read public key. OID is not RSA.');}// create certification request
var csr=pki.createCertificationRequest();csr.version=capture.csrVersion?capture.csrVersion.charCodeAt(0):0;csr.signatureOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.signatureParameters=_readSignatureParameters(csr.signatureOid,capture.csrSignatureParams,true);csr.siginfo.algorithmOid=forge.asn1.derToOid(capture.csrSignatureOid);csr.siginfo.parameters=_readSignatureParameters(csr.siginfo.algorithmOid,capture.csrSignatureParams,false);csr.signature=capture.csrSignature;// keep CertificationRequestInfo to preserve signature when exporting
csr.certificationRequestInfo=capture.certificationRequestInfo;if(computeHash){// check signature OID for supported signature types
csr.md=null;if(csr.signatureOid in oids){var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':csr.md=forge.md.sha1.create();break;case'md5WithRSAEncryption':csr.md=forge.md.md5.create();break;case'sha256WithRSAEncryption':csr.md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':csr.md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':csr.md=forge.md.sha512.create();break;case'RSASSA-PSS':csr.md=forge.md.sha256.create();break;}}if(csr.md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var bytes=asn1.toDer(csr.certificationRequestInfo);csr.md.update(bytes.getBytes());}// handle subject, build subject message digest
var smd=forge.md.sha1.create();csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject,smd);csr.subject.hash=smd.digest().toHex();// convert RSA public key from ASN.1
csr.publicKey=pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);// convert attributes from ASN.1
csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.attributes=pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes||[]);return csr;};/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */pki.createCertificationRequest=function(){var csr={};csr.version=0x00;csr.signatureOid=null;csr.signature=null;csr.siginfo={};csr.siginfo.algorithmOid=null;csr.subject={};csr.subject.getField=function(sn){return _getAttribute(csr.subject,sn);};csr.subject.addField=function(attr){_fillMissingFields([attr]);csr.subject.attributes.push(attr);};csr.subject.attributes=[];csr.subject.hash=null;csr.publicKey=null;csr.attributes=[];csr.getAttribute=function(sn){return _getAttribute(csr,sn);};csr.addAttribute=function(attr){_fillMissingFields([attr]);csr.attributes.push(attr);};csr.md=null;/**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */csr.setSubject=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.subject.attributes=attrs;csr.subject.hash=null;};/**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */csr.setAttributes=function(attrs){// set new attributes
_fillMissingFields(attrs);csr.attributes=attrs;};/**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */csr.sign=function(key,md){// TODO: get signature OID from private key
csr.md=md||forge.md.sha1.create();var algorithmOid=oids[csr.md.algorithm+'WithRSAEncryption'];if(!algorithmOid){var error=new Error('Could not compute certification request digest. '+'Unknown message digest algorithm OID.');error.algorithm=csr.md.algorithm;throw error;}csr.signatureOid=csr.siginfo.algorithmOid=algorithmOid;// get CertificationRequestInfo, convert to DER
csr.certificationRequestInfo=pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(csr.certificationRequestInfo);// digest and sign
csr.md.update(bytes.getBytes());csr.signature=key.sign(csr.md);};/**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */csr.verify=function(){var rval=false;var md=csr.md;if(md===null){// check signature OID for supported signature types
if(csr.signatureOid in oids){// TODO: create DRY `OID to md` function
var oid=oids[csr.signatureOid];switch(oid){case'sha1WithRSAEncryption':md=forge.md.sha1.create();break;case'md5WithRSAEncryption':md=forge.md.md5.create();break;case'sha256WithRSAEncryption':md=forge.md.sha256.create();break;case'sha384WithRSAEncryption':md=forge.md.sha384.create();break;case'sha512WithRSAEncryption':md=forge.md.sha512.create();break;case'RSASSA-PSS':md=forge.md.sha256.create();break;}}if(md===null){var error=new Error('Could not compute certification request digest. '+'Unknown signature OID.');error.signatureOid=csr.signatureOid;throw error;}// produce DER formatted CertificationRequestInfo and digest it
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);var bytes=asn1.toDer(cri);md.update(bytes.getBytes());}if(md!==null){var scheme;switch(csr.signatureOid){case oids.sha1WithRSAEncryption:/* use PKCS#1 v1.5 padding scheme */break;case oids['RSASSA-PSS']:var hash,mgf;/* initialize mgf */hash=oids[csr.signatureParameters.mgf.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported MGF hash function.');error.oid=csr.signatureParameters.mgf.hash.algorithmOid;error.name=hash;throw error;}mgf=oids[csr.signatureParameters.mgf.algorithmOid];if(mgf===undefined||forge.mgf[mgf]===undefined){var error=new Error('Unsupported MGF function.');error.oid=csr.signatureParameters.mgf.algorithmOid;error.name=mgf;throw error;}mgf=forge.mgf[mgf].create(forge.md[hash].create());/* initialize hash function */hash=oids[csr.signatureParameters.hash.algorithmOid];if(hash===undefined||forge.md[hash]===undefined){var error=new Error('Unsupported RSASSA-PSS hash function.');error.oid=csr.signatureParameters.hash.algorithmOid;error.name=hash;throw error;}scheme=forge.pss.create(forge.md[hash].create(),mgf,csr.signatureParameters.saltLength);break;}// verify signature on csr using its public key
rval=csr.publicKey.verify(md.digest().getBytes(),csr.signature,scheme);}return rval;};return csr;};/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */function _dnToAsn1(obj){// create an empty RDNSequence
var rval=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// iterate over attributes
var attr,set;var attrs=obj.attributes;for(var i=0;i<attrs.length;++i){attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.PRINTABLESTRING;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}// FIXME: handle more encodings
}// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
set=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,false,value)])]);rval.value.push(set);}return rval;}/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */function _getAttributesAsJson(attrs){var rval={};for(var i=0;i<attrs.length;++i){var attr=attrs[i];if(attr.shortName&&(attr.valueTagClass===asn1.Type.UTF8||attr.valueTagClass===asn1.Type.PRINTABLESTRING||attr.valueTagClass===asn1.Type.IA5STRING)){var value=attr.value;if(attr.valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(attr.value);}if(!(attr.shortName in rval)){rval[attr.shortName]=value;}else if(forge.util.isArray(rval[attr.shortName])){rval[attr.shortName].push(value);}else{rval[attr.shortName]=[rval[attr.shortName],value];}}}return rval;}/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */function _fillMissingFields(attrs){var attr;for(var i=0;i<attrs.length;++i){attr=attrs[i];// populate missing name
if(typeof attr.name==='undefined'){if(attr.type&&attr.type in pki.oids){attr.name=pki.oids[attr.type];}else if(attr.shortName&&attr.shortName in _shortNames){attr.name=pki.oids[_shortNames[attr.shortName]];}}// populate missing type (OID)
if(typeof attr.type==='undefined'){if(attr.name&&attr.name in pki.oids){attr.type=pki.oids[attr.name];}else{var error=new Error('Attribute type not specified.');error.attribute=attr;throw error;}}// populate missing shortname
if(typeof attr.shortName==='undefined'){if(attr.name&&attr.name in _shortNames){attr.shortName=_shortNames[attr.name];}}// convert extensions to value
if(attr.type===oids.extensionRequest){attr.valueConstructed=true;attr.valueTagClass=asn1.Type.SEQUENCE;if(!attr.value&&attr.extensions){attr.value=[];for(var ei=0;ei<attr.extensions.length;++ei){attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));}}}if(typeof attr.value==='undefined'){var error=new Error('Attribute value not specified.');error.attribute=attr;throw error;}}}/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */function _fillMissingExtensionFields(e,options){options=options||{};// populate missing name
if(typeof e.name==='undefined'){if(e.id&&e.id in pki.oids){e.name=pki.oids[e.id];}}// populate missing id
if(typeof e.id==='undefined'){if(e.name&&e.name in pki.oids){e.id=pki.oids[e.name];}else{var error=new Error('Extension ID not specified.');error.extension=e;throw error;}}if(typeof e.value!=='undefined'){return e;}// handle missing value:
// value is a BIT STRING
if(e.name==='keyUsage'){// build flags
var unused=0;var b2=0x00;var b3=0x00;if(e.digitalSignature){b2|=0x80;unused=7;}if(e.nonRepudiation){b2|=0x40;unused=6;}if(e.keyEncipherment){b2|=0x20;unused=5;}if(e.dataEncipherment){b2|=0x10;unused=4;}if(e.keyAgreement){b2|=0x08;unused=3;}if(e.keyCertSign){b2|=0x04;unused=2;}if(e.cRLSign){b2|=0x02;unused=1;}if(e.encipherOnly){b2|=0x01;unused=0;}if(e.decipherOnly){b3|=0x80;unused=7;}// create bit string
var value=String.fromCharCode(unused);if(b3!==0){value+=String.fromCharCode(b2)+String.fromCharCode(b3);}else if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='basicConstraints'){// basicConstraints is a SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// cA BOOLEAN flag defaults to false
if(e.cA){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}if('pathLenConstraint'in e){e.value.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(e.pathLenConstraint).getBytes()));}}else if(e.name==='extKeyUsage'){// extKeyUsage is a SEQUENCE of OIDs
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;for(var key in e){if(e[key]!==true){continue;}// key is name in OID map
if(key in oids){seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(oids[key]).getBytes()));}else if(key.indexOf('.')!==-1){// assume key is an OID
seq.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(key).getBytes()));}}}else if(e.name==='nsCertType'){// nsCertType is a BIT STRING
// build flags
var unused=0;var b2=0x00;if(e.client){b2|=0x80;unused=7;}if(e.server){b2|=0x40;unused=6;}if(e.email){b2|=0x20;unused=5;}if(e.objsign){b2|=0x10;unused=4;}if(e.reserved){b2|=0x08;unused=3;}if(e.sslCA){b2|=0x04;unused=2;}if(e.emailCA){b2|=0x02;unused=1;}if(e.objCA){b2|=0x01;unused=0;}// create bit string
var value=String.fromCharCode(unused);if(b2!==0){value+=String.fromCharCode(b2);}e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,value);}else if(e.name==='subjectAltName'||e.name==='issuerAltName'){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}}else if(e.name==='subjectKeyIdentifier'&&options.cert){var ski=options.cert.generateSubjectKeyIdentifier();e.subjectKeyIdentifier=ski.toHex();// OCTETSTRING w/digest
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,ski.getBytes());}else if(e.name==='authorityKeyIdentifier'&&options.cert){// SYNTAX SEQUENCE
e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;if(e.keyIdentifier){var keyIdentifier=e.keyIdentifier===true?options.cert.generateSubjectKeyIdentifier().getBytes():e.keyIdentifier;seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,false,keyIdentifier));}if(e.authorityCertIssuer){var authorityCertIssuer=[asn1.create(asn1.Class.CONTEXT_SPECIFIC,4,true,[_dnToAsn1(e.authorityCertIssuer===true?options.cert.issuer:e.authorityCertIssuer)])];seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,authorityCertIssuer));}if(e.serialNumber){var serialNumber=forge.util.hexToBytes(e.serialNumber===true?options.cert.serialNumber:e.serialNumber);seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,false,serialNumber));}}else if(e.name==='cRLDistributionPoints'){e.value=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);var seq=e.value.value;// Create sub SEQUENCE of DistributionPointName
var subSeq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// Create fullName CHOICE
var fullNameGeneralNames=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);var altName;for(var n=0;n<e.altNames.length;++n){altName=e.altNames[n];var value=altName.value;// handle IP
if(altName.type===7&&altName.ip){value=forge.util.bytesFromIP(altName.ip);if(value===null){var error=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');error.extension=e;throw error;}}else if(altName.type===8){// handle OID
if(altName.oid){value=asn1.oidToDer(asn1.oidToDer(altName.oid));}else{// deprecated ... convert value to OID
value=asn1.oidToDer(value);}}fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,altName.type,false,value));}// Add to the parent SEQUENCE
subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[fullNameGeneralNames]));seq.push(subSeq);}// ensure value has been defined by now
if(typeof e.value==='undefined'){var error=new Error('Extension value not specified.');error.extension=e;throw error;}return e;}/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */function _signatureParametersToAsn1(oid,params){switch(oid){case oids['RSASSA-PSS']:var parts=[];if(params.hash.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])]));}if(params.mgf.algorithmOid!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')])])]));}if(params.saltLength!==undefined){parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(params.saltLength).getBytes())]));}return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,parts);default:return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'');}}/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */function _CRIAttributesToAsn1(csr){// create an empty context-specific container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[]);// no attributes, return empty container
if(csr.attributes.length===0){return rval;}// each attribute has a sequence with a type and a set of values
var attrs=csr.attributes;for(var i=0;i<attrs.length;++i){var attr=attrs[i];var value=attr.value;// reuse tag class for attribute value if available
var valueTagClass=asn1.Type.UTF8;if('valueTagClass'in attr){valueTagClass=attr.valueTagClass;}if(valueTagClass===asn1.Type.UTF8){value=forge.util.encodeUtf8(value);}var valueConstructed=false;if('valueConstructed'in attr){valueConstructed=attr.valueConstructed;}// FIXME: handle more encodings
// create a RelativeDistinguishedName set
// each value in the set is an AttributeTypeAndValue first
// containing the type (an OID) and second the value
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// AttributeType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(attr.type).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[// AttributeValue
asn1.create(asn1.Class.UNIVERSAL,valueTagClass,valueConstructed,value)])]);rval.value.push(seq);}return rval;}var jan_1_1950=new Date('1950-01-01T00:00:00Z');var jan_1_2050=new Date('2050-01-01T00:00:00Z');/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */function _dateToAsn1(date){if(date>=jan_1_1950&&date<jan_1_2050){return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.UTCTIME,false,asn1.dateToUtcTime(date));}else{return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.GENERALIZEDTIME,false,asn1.dateToGeneralizedTime(date));}}/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */pki.getTBSCertificate=function(cert){// TBSCertificate
var notBefore=_dateToAsn1(cert.validity.notBefore);var notAfter=_dateToAsn1(cert.validity.notAfter);var tbs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// integer
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(cert.version).getBytes())]),// serialNumber
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,forge.util.hexToBytes(cert.serialNumber)),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.siginfo.algorithmOid,cert.siginfo.parameters)]),// issuer
_dnToAsn1(cert.issuer),// validity
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[notBefore,notAfter]),// subject
_dnToAsn1(cert.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(cert.publicKey)]);if(cert.issuer.uniqueId){// issuerUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,1,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.issuer.uniqueId)]));}if(cert.subject.uniqueId){// subjectUniqueID (optional)
tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC,2,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,// TODO: support arbitrary bit length ids
String.fromCharCode(0x00)+cert.subject.uniqueId)]));}if(cert.extensions.length>0){// extensions (optional)
tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));}return tbs;};/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */pki.getCertificationRequestInfo=function(csr){// CertificationRequestInfo
var cri=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(csr.version).getBytes()),// subject
_dnToAsn1(csr.subject),// SubjectPublicKeyInfo
pki.publicKeyToAsn1(csr.publicKey),// attributes
_CRIAttributesToAsn1(csr)]);return cri;};/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */pki.distinguishedNameToAsn1=function(dn){return _dnToAsn1(dn);};/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */pki.certificateToAsn1=function(cert){// prefer cached TBSCertificate over generating one
var tbsCertificate=cert.tbsCertificate||pki.getTBSCertificate(cert);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// TBSCertificate
tbsCertificate,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(cert.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(cert.signatureOid,cert.signatureParameters)]),// SignatureValue
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+cert.signature)]);};/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */pki.certificateExtensionsToAsn1=function(exts){// create top-level extension container
var rval=asn1.create(asn1.Class.CONTEXT_SPECIFIC,3,true,[]);// create extension sequence (stores a sequence for each extension)
var seq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);rval.value.push(seq);for(var i=0;i<exts.length;++i){seq.value.push(pki.certificateExtensionToAsn1(exts[i]));}return rval;};/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */pki.certificateExtensionToAsn1=function(ext){// create a sequence for each extension
var extseq=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[]);// extnID (OID)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(ext.id).getBytes()));// critical defaults to false
if(ext.critical){// critical BOOLEAN DEFAULT FALSE
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BOOLEAN,false,String.fromCharCode(0xFF)));}var value=ext.value;if(typeof ext.value!=='string'){// value is asn.1
value=asn1.toDer(value).getBytes();}// extnValue (OCTET STRING)
extseq.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,value));return extseq;};/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */pki.certificationRequestToAsn1=function(csr){// prefer cached CertificationRequestInfo over generating one
var cri=csr.certificationRequestInfo||pki.getCertificationRequestInfo(csr);// Certificate
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// CertificationRequestInfo
cri,// AlgorithmIdentifier (signature algorithm)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(csr.signatureOid).getBytes()),// parameters
_signatureParametersToAsn1(csr.signatureOid,csr.signatureParameters)]),// signature
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BITSTRING,false,String.fromCharCode(0x00)+csr.signature)]);};/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */pki.createCaStore=function(certs){// create CA store
var caStore={// stored certificates
certs:{}};/**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */caStore.getIssuer=function(cert){var rval=getBySubject(cert.issuer);// see if there are multiple matches
/*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/return rval;};/**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */caStore.addCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){// avoid duplicate certificates in store
if(cert.subject.hash in caStore.certs){// subject hash already exists, append to array
var tmp=caStore.certs[cert.subject.hash];if(!forge.util.isArray(tmp)){tmp=[tmp];}tmp.push(cert);caStore.certs[cert.subject.hash]=tmp;}else{caStore.certs[cert.subject.hash]=cert;}}};/**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */caStore.hasCertificate=function(cert){// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}var match=getBySubject(cert.subject);if(!match){return false;}if(!forge.util.isArray(match)){match=[match];}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){return true;}}return false;};/**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */caStore.listAllCertificates=function(){var certList=[];for(var hash in caStore.certs){if(caStore.certs.hasOwnProperty(hash)){var value=caStore.certs[hash];if(!forge.util.isArray(value)){certList.push(value);}else{for(var i=0;i<value.length;++i){certList.push(value[i]);}}}}return certList;};/**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */caStore.removeCertificate=function(cert){var result;// convert from pem if necessary
if(typeof cert==='string'){cert=forge.pki.certificateFromPem(cert);}ensureSubjectHasHash(cert.subject);if(!caStore.hasCertificate(cert)){return null;}var match=getBySubject(cert.subject);if(!forge.util.isArray(match)){result=caStore.certs[cert.subject.hash];delete caStore.certs[cert.subject.hash];return result;}// compare DER-encoding of certificates
var der1=asn1.toDer(pki.certificateToAsn1(cert)).getBytes();for(var i=0;i<match.length;++i){var der2=asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();if(der1===der2){result=match[i];match.splice(i,1);}}if(match.length===0){delete caStore.certs[cert.subject.hash];}return result;};function getBySubject(subject){ensureSubjectHasHash(subject);return caStore.certs[subject.hash]||null;}function ensureSubjectHasHash(subject){// produce subject hash if it doesn't exist
if(!subject.hash){var md=forge.md.sha1.create();subject.attributes=pki.RDNAttributesAsArray(_dnToAsn1(subject),md);subject.hash=md.digest().toHex();}}// auto-add passed in certs
if(certs){// parse PEM-formatted certificates as necessary
for(var i=0;i<certs.length;++i){var cert=certs[i];caStore.addCertificate(cert);}}return caStore;};/**
 * Certificate verification errors, based on TLS.
 */pki.certificateError={bad_certificate:'forge.pki.BadCertificate',unsupported_certificate:'forge.pki.UnsupportedCertificate',certificate_revoked:'forge.pki.CertificateRevoked',certificate_expired:'forge.pki.CertificateExpired',certificate_unknown:'forge.pki.CertificateUnknown',unknown_ca:'forge.pki.UnknownCertificateAuthority'};/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param verify called for every certificate in the chain.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */pki.verifyCertificateChain=function(caStore,chain,verify){/* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */ /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */ // copy cert chain references to another array to protect against changes
// in verify callback
chain=chain.slice(0);var certs=chain.slice(0);// get current date
var now=new Date();// verify each cert in the chain using its parent, where the parent
// is either the next in the chain or from the CA store
var first=true;var error=null;var depth=0;do{var cert=chain.shift();var parent=null;var selfSigned=false;// 1. check valid time
if(now<cert.validity.notBefore||now>cert.validity.notAfter){error={message:'Certificate is not valid yet or has expired.',error:pki.certificateError.certificate_expired,notBefore:cert.validity.notBefore,notAfter:cert.validity.notAfter,now:now};}// 2. verify with parent from chain or CA store
if(error===null){parent=chain[0]||caStore.getIssuer(cert);if(parent===null){// check for self-signed cert
if(cert.isIssuer(cert)){selfSigned=true;parent=cert;}}if(parent){// FIXME: current CA store implementation might have multiple
// certificates where the issuer can't be determined from the
// certificate (happens rarely with, eg: old certificates) so normalize
// by always putting parents into an array
// TODO: there's may be an extreme degenerate case currently uncovered
// where an old intermediate certificate seems to have a matching parent
// but none of the parents actually verify ... but the intermediate
// is in the CA and it should pass this check; needs investigation
var parents=parent;if(!forge.util.isArray(parents)){parents=[parents];}// try to verify with each possible parent (typically only one)
var verified=false;while(!verified&&parents.length>0){parent=parents.shift();try{verified=parent.verify(cert);}catch(ex){// failure to verify, don't care why, try next one
}}if(!verified){error={message:'Certificate signature is invalid.',error:pki.certificateError.bad_certificate};}}if(error===null&&(!parent||selfSigned)&&!caStore.hasCertificate(cert)){// no parent issuer and certificate itself is not trusted
error={message:'Certificate is not trusted.',error:pki.certificateError.unknown_ca};}}// TODO: 3. check revoked
// 4. check for matching issuer/subject
if(error===null&&parent&&!cert.isIssuer(parent)){// parent is not issuer
error={message:'Certificate issuer is invalid.',error:pki.certificateError.bad_certificate};}// 5. TODO: check names with permitted names tree
// 6. TODO: check names against excluded names tree
// 7. check for unsupported critical extensions
if(error===null){// supported extensions
var se={keyUsage:true,basicConstraints:true};for(var i=0;error===null&&i<cert.extensions.length;++i){var ext=cert.extensions[i];if(ext.critical&&!(ext.name in se)){error={message:'Certificate has an unsupported critical extension.',error:pki.certificateError.unsupported_certificate};}}}// 8. check for CA if cert is not first or is the only certificate
// remaining in chain with no parent or is self-signed
if(error===null&&(!first||chain.length===0&&(!parent||selfSigned))){// first check keyUsage extension and then basic constraints
var bcExt=cert.getExtension('basicConstraints');var keyUsageExt=cert.getExtension('keyUsage');if(keyUsageExt!==null){// keyCertSign must be true and there must be a basic
// constraints extension
if(!keyUsageExt.keyCertSign||bcExt===null){// bad certificate
error={message:'Certificate keyUsage or basicConstraints conflict '+'or indicate that the certificate is not a CA. '+'If the certificate is the only one in the chain or '+'isn\'t the first then the certificate must be a '+'valid CA.',error:pki.certificateError.bad_certificate};}}// basic constraints cA flag must be set
if(error===null&&bcExt!==null&&!bcExt.cA){// bad certificate
error={message:'Certificate basicConstraints indicates the certificate '+'is not a CA.',error:pki.certificateError.bad_certificate};}// if error is not null and keyUsage is available, then we know it
// has keyCertSign and there is a basic constraints extension too,
// which means we can check pathLenConstraint (if it exists)
if(error===null&&keyUsageExt!==null&&'pathLenConstraint'in bcExt){// pathLen is the maximum # of intermediate CA certs that can be
// found between the current certificate and the end-entity (depth 0)
// certificate; this number does not include the end-entity (depth 0,
// last in the chain) even if it happens to be a CA certificate itself
var pathLen=depth-1;if(pathLen>bcExt.pathLenConstraint){// pathLenConstraint violated, bad certificate
error={message:'Certificate basicConstraints pathLenConstraint violated.',error:pki.certificateError.bad_certificate};}}}// call application callback
var vfd=error===null?true:error.error;var ret=verify?verify(vfd,depth,certs):vfd;if(ret===true){// clear any set error
error=null;}else{// if passed basic tests, set default message and alert
if(vfd===true){error={message:'The application rejected the certificate.',error:pki.certificateError.bad_certificate};}// check for custom error info
if(ret||ret===0){// set custom message and error
if(_typeof(ret)==='object'&&!forge.util.isArray(ret)){if(ret.message){error.message=ret.message;}if(ret.error){error.error=ret.error;}}else if(typeof ret==='string'){// set custom error
error.error=ret;}}// throw error
throw error;}// no longer first cert in chain
first=false;++depth;}while(chain.length>0);return true;};/***/},/* 19 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(5);__webpack_require__(1);// shortcut for PSS API
var pss=module.exports=forge.pss=forge.pss||{};/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */pss.create=function(options){// backwards compatibility w/legacy args: hash, mgf, sLen
if(arguments.length===3){options={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]};}var hash=options.md;var mgf=options.mgf;var hLen=hash.digestLength;var salt_=options.salt||null;if(typeof salt_==='string'){// assume binary-encoded string
salt_=forge.util.createBuffer(salt_);}var sLen;if('saltLength'in options){sLen=options.saltLength;}else if(salt_!==null){sLen=salt_.length();}else{throw new Error('Salt length not specified or specific salt not given.');}if(salt_!==null&&salt_.length()!==sLen){throw new Error('Given salt length does not match length of given salt.');}var prng=options.prng||forge.random;var pssobj={};/**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */pssobj.encode=function(md,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* 2. Let mHash = Hash(M), an octet string of length hLen. */var mHash=md.digest().getBytes();/* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */if(emLen<hLen+sLen+2){throw new Error('Message is too long to encrypt.');}/* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */var salt;if(salt_===null){salt=prng.getBytesSync(sLen);}else{salt=salt_.bytes();}/* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 6. Let H = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h=hash.digest().getBytes();/* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */var ps=new forge.util.ByteBuffer();ps.fillWithByte(0,emLen-sLen-hLen-2);/* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */ps.putByte(0x01);ps.putBytes(salt);var db=ps.getBytes();/* 9. Let dbMask = MGF(H, emLen - hLen - 1). */var maskLen=emLen-hLen-1;var dbMask=mgf.generate(h,maskLen);/* 10. Let maskedDB = DB \xor dbMask. */var maskedDB='';for(i=0;i<maskLen;i++){maskedDB+=String.fromCharCode(db.charCodeAt(i)^dbMask.charCodeAt(i));}/* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */var mask=0xFF00>>8*emLen-emBits&0xFF;maskedDB=String.fromCharCode(maskedDB.charCodeAt(0)&~mask)+maskedDB.substr(1);/* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */return maskedDB+h+String.fromCharCode(0xbc);};/**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */pssobj.verify=function(mHash,em,modBits){var i;var emBits=modBits-1;var emLen=Math.ceil(emBits/8);/* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */em=em.substr(-emLen);/* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */if(emLen<hLen+sLen+2){throw new Error('Inconsistent parameters to PSS signature verification.');}/* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */if(em.charCodeAt(emLen-1)!==0xbc){throw new Error('Encoded message does not end in 0xBC.');}/* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */var maskLen=emLen-hLen-1;var maskedDB=em.substr(0,maskLen);var h=em.substr(maskLen,hLen);/* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */var mask=0xFF00>>8*emLen-emBits&0xFF;if((maskedDB.charCodeAt(0)&mask)!==0){throw new Error('Bits beyond keysize not zero as expected.');}/* 7. Let dbMask = MGF(H, emLen - hLen - 1). */var dbMask=mgf.generate(h,maskLen);/* 8. Let DB = maskedDB \xor dbMask. */var db='';for(i=0;i<maskLen;i++){db+=String.fromCharCode(maskedDB.charCodeAt(i)^dbMask.charCodeAt(i));}/* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */db=String.fromCharCode(db.charCodeAt(0)&~mask)+db.substr(1);/* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */var checkLen=emLen-hLen-sLen-2;for(i=0;i<checkLen;i++){if(db.charCodeAt(i)!==0x00){throw new Error('Leftmost octets not zero as expected');}}if(db.charCodeAt(checkLen)!==0x01){throw new Error('Inconsistent PSS signature, 0x01 marker not found');}/* 11. Let salt be the last sLen octets of DB. */var salt=db.substr(-sLen);/* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */var m_=new forge.util.ByteBuffer();m_.fillWithByte(0,8);m_.putBytes(mHash);m_.putBytes(salt);/* 13. Let H' = Hash(M'), an octet string of length hLen. */hash.start();hash.update(m_.getBytes());var h_=hash.digest().getBytes();/* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */return h===h_;};return pssobj;};/***/},/* 20 */ /***/function(module,exports,__webpack_require__){__webpack_require__(21);module.exports=__webpack_require__(0);/***/},/* 21 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of a basic Public Key Infrastructure, including
 * support for RSA public and private keys.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(3);__webpack_require__(9);__webpack_require__(8);__webpack_require__(13);__webpack_require__(28);__webpack_require__(19);__webpack_require__(6);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 API
var asn1=forge.asn1;/* Public Key Infrastructure (PKI) implementation. */var pki=module.exports=forge.pki=forge.pki||{};/**
 * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
 *
 * Converts PEM-formatted data to DER.
 *
 * @param pem the PEM-formatted data.
 *
 * @return the DER-formatted data.
 */pki.pemToDer=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert PEM to DER; PEM is encrypted.');}return forge.util.createBuffer(msg.body);};/**
 * Converts an RSA private key from PEM format.
 *
 * @param pem the PEM-formatted private key.
 *
 * @return the private key.
 */pki.privateKeyFromPem=function(pem){var msg=forge.pem.decode(pem)[0];if(msg.type!=='PRIVATE KEY'&&msg.type!=='RSA PRIVATE KEY'){var error=new Error('Could not convert private key from PEM; PEM '+'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');error.headerType=msg.type;throw error;}if(msg.procType&&msg.procType.type==='ENCRYPTED'){throw new Error('Could not convert private key from PEM; PEM is encrypted.');}// convert DER to ASN.1 object
var obj=asn1.fromDer(msg.body);return pki.privateKeyFromAsn1(obj);};/**
 * Converts an RSA private key to PEM format.
 *
 * @param key the private key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyToPem=function(key,maxline){// convert to ASN.1, then DER, then PEM-encode
var msg={type:'RSA PRIVATE KEY',body:asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/**
 * Converts a PrivateKeyInfo to PEM format.
 *
 * @param pki the PrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */pki.privateKeyInfoToPem=function(pki,maxline){// convert to DER, then PEM-encode
var msg={type:'PRIVATE KEY',body:asn1.toDer(pki).getBytes()};return forge.pem.encode(msg,{maxline:maxline});};/***/},/* 22 */ /***/function(module,exports){/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */var api={};module.exports=api;// baseN alphabet indexes
var _reverseAlphabets={};/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */api.encode=function(input,alphabet,maxline){if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}if(maxline!==undefined&&typeof maxline!=='number'){throw new TypeError('"maxline" must be a number.');}var output='';if(!(input instanceof Uint8Array)){// assume forge byte buffer
output=_encodeWithByteBuffer(input,alphabet);}else{var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length;++i){for(var j=0,carry=input[i];j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}// deal with leading zeros
for(i=0;input[i]===0&&i<input.length-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}}if(maxline){var regex=new RegExp('.{1,'+maxline+'}','g');output=output.match(regex).join('\r\n');}return output;};/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */api.decode=function(input,alphabet){if(typeof input!=='string'){throw new TypeError('"input" must be a string.');}if(typeof alphabet!=='string'){throw new TypeError('"alphabet" must be a string.');}var table=_reverseAlphabets[alphabet];if(!table){// compute reverse alphabet
table=_reverseAlphabets[alphabet]=[];for(var i=0;i<alphabet.length;++i){table[alphabet.charCodeAt(i)]=i;}}// remove whitespace characters
input=input.replace(/\s/g,'');var base=alphabet.length;var first=alphabet.charAt(0);var bytes=[0];for(var i=0;i<input.length;i++){var value=table[input.charCodeAt(i)];if(value===undefined){return;}for(var j=0,carry=value;j<bytes.length;++j){carry+=bytes[j]*base;bytes[j]=carry&0xff;carry>>=8;}while(carry>0){bytes.push(carry&0xff);carry>>=8;}}// deal with leading zeros
for(var k=0;input[k]===first&&k<input.length-1;++k){bytes.push(0);}if(typeof Buffer!=='undefined'){return Buffer.from(bytes.reverse());}return new Uint8Array(bytes.reverse());};function _encodeWithByteBuffer(input,alphabet){var i=0;var base=alphabet.length;var first=alphabet.charAt(0);var digits=[0];for(i=0;i<input.length();++i){for(var j=0,carry=input.at(i);j<digits.length;++j){carry+=digits[j]<<8;digits[j]=carry%base;carry=carry/base|0;}while(carry>0){digits.push(carry%base);carry=carry/base|0;}}var output='';// deal with leading zeros
for(i=0;input.at(i)===0&&i<input.length()-1;++i){output+=first;}// convert digits to a string
for(i=digits.length-1;i>=0;--i){output+=alphabet[digits[i]];}return output;}/***/},/* 23 */ /***/function(module,exports,__webpack_require__){/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(4);__webpack_require__(1);var sha256=module.exports=forge.sha256=forge.sha256||{};forge.md.sha256=forge.md.algorithms.sha256=sha256;/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */sha256.create=function(){// do initialization as necessary
if(!_initialized){_init();}// SHA-256 state contains eight 32-bit integers
var _state=null;// input buffer
var _input=forge.util.createBuffer();// used for word storage
var _w=new Array(64);// message digest object
var md={algorithm:'sha256',blockLength:64,digestLength:32,// 56-bit length of message so far (does not including padding)
messageLength:0,// true message length
fullMessageLength:null,// size of message length in bytes
messageLengthSize:8};/**
   * Starts the digest.
   *
   * @return this digest object.
   */md.start=function(){// up to 56-bit message length for convenience
md.messageLength=0;// full message length (set md.messageLength64 for backwards-compatibility)
md.fullMessageLength=md.messageLength64=[];var int32s=md.messageLengthSize/4;for(var i=0;i<int32s;++i){md.fullMessageLength.push(0);}_input=forge.util.createBuffer();_state={h0:0x6A09E667,h1:0xBB67AE85,h2:0x3C6EF372,h3:0xA54FF53A,h4:0x510E527F,h5:0x9B05688C,h6:0x1F83D9AB,h7:0x5BE0CD19};return md;};// start digest automatically for first time
md.start();/**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */md.update=function(msg,encoding){if(encoding==='utf8'){msg=forge.util.encodeUtf8(msg);}// update message length
var len=msg.length;md.messageLength+=len;len=[len/0x100000000>>>0,len>>>0];for(var i=md.fullMessageLength.length-1;i>=0;--i){md.fullMessageLength[i]+=len[1];len[1]=len[0]+(md.fullMessageLength[i]/0x100000000>>>0);md.fullMessageLength[i]=md.fullMessageLength[i]>>>0;len[0]=len[1]/0x100000000>>>0;}// add bytes to input buffer
_input.putBytes(msg);// process bytes
_update(_state,_w,_input);// compact input buffer every 2K or if empty
if(_input.read>2048||_input.length()===0){_input.compact();}return md;};/**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */md.digest=function(){/* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */ /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */var finalBlock=forge.util.createBuffer();finalBlock.putBytes(_input.bytes());// compute remaining size to be digested (include message length size)
var remaining=md.fullMessageLength[md.fullMessageLength.length-1]+md.messageLengthSize;// add padding for overflow blockSize - overflow
// _padding starts with 1 byte with first bit is set (byte value 128), then
// there may be up to (blockSize - 1) other pad bytes
var overflow=remaining&md.blockLength-1;finalBlock.putBytes(_padding.substr(0,md.blockLength-overflow));// serialize message length in bits in big-endian order; since length
// is stored in bytes we multiply by 8 and add carry from next int
var next,carry;var bits=md.fullMessageLength[0]*8;for(var i=0;i<md.fullMessageLength.length-1;++i){next=md.fullMessageLength[i+1]*8;carry=next/0x100000000>>>0;bits+=carry;finalBlock.putInt32(bits>>>0);bits=next>>>0;}finalBlock.putInt32(bits);var s2={h0:_state.h0,h1:_state.h1,h2:_state.h2,h3:_state.h3,h4:_state.h4,h5:_state.h5,h6:_state.h6,h7:_state.h7};_update(s2,_w,finalBlock);var rval=forge.util.createBuffer();rval.putInt32(s2.h0);rval.putInt32(s2.h1);rval.putInt32(s2.h2);rval.putInt32(s2.h3);rval.putInt32(s2.h4);rval.putInt32(s2.h5);rval.putInt32(s2.h6);rval.putInt32(s2.h7);return rval;};return md;};// sha-256 padding bytes not initialized yet
var _padding=null;var _initialized=false;// table of constants
var _k=null;/**
 * Initializes the constant tables.
 */function _init(){// create padding
_padding=String.fromCharCode(128);_padding+=forge.util.fillString(String.fromCharCode(0x00),64);// create K table for SHA-256
_k=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];// now initialized
_initialized=true;}/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */function _update(s,w,bytes){// consume 512 bit (64 byte) chunks
var t1,t2,s0,s1,ch,maj,i,a,b,c,d,e,f,g,h;var len=bytes.length();while(len>=64){// the w array will be populated with sixteen 32-bit big-endian words
// and then extended into 64 32-bit words according to SHA-256
for(i=0;i<16;++i){w[i]=bytes.getInt32();}for(;i<64;++i){// XOR word 2 words ago rot right 17, rot right 19, shft right 10
t1=w[i-2];t1=(t1>>>17|t1<<15)^(t1>>>19|t1<<13)^t1>>>10;// XOR word 15 words ago rot right 7, rot right 18, shft right 3
t2=w[i-15];t2=(t2>>>7|t2<<25)^(t2>>>18|t2<<14)^t2>>>3;// sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32
w[i]=t1+w[i-7]+t2+w[i-16]|0;}// initialize hash value for this chunk
a=s.h0;b=s.h1;c=s.h2;d=s.h3;e=s.h4;f=s.h5;g=s.h6;h=s.h7;// round function
for(i=0;i<64;++i){// Sum1(e)
s1=(e>>>6|e<<26)^(e>>>11|e<<21)^(e>>>25|e<<7);// Ch(e, f, g) (optimized the same way as SHA-1)
ch=g^e&(f^g);// Sum0(a)
s0=(a>>>2|a<<30)^(a>>>13|a<<19)^(a>>>22|a<<10);// Maj(a, b, c) (optimized the same way as SHA-1)
maj=a&b|c&(a^b);// main algorithm
t1=h+s1+ch+_k[i]+w[i];t2=s0+maj;h=g;g=f;f=e;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
e=d+t1>>>0;d=c;c=b;b=a;// `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
// can't truncate with `| 0`
a=t1+t2>>>0;}// update hash state
s.h0=s.h0+a|0;s.h1=s.h1+b|0;s.h2=s.h2+c|0;s.h3=s.h3+d|0;s.h4=s.h4+e|0;s.h5=s.h5+f|0;s.h6=s.h6+g|0;s.h7=s.h7+h|0;len-=64;}}/***/},/* 24 */ /***/function(module,exports,__webpack_require__){/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);var _crypto=null;if(forge.util.isNodejs&&!forge.options.usePureJavaScript&&!process.versions['node-webkit']){_crypto=__webpack_require__(15);}/* PRNG API */var prng=module.exports=forge.prng=forge.prng||{};/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */prng.create=function(plugin){var ctx={plugin:plugin,key:null,seed:null,time:null,// number of reseeds so far
reseeds:0,// amount of data generated so far
generated:0,// no initial key bytes
keyBytes:''};// create 32 entropy pools (each is a message digest)
var md=plugin.md;var pools=new Array(32);for(var i=0;i<32;++i){pools[i]=md.create();}ctx.pools=pools;// entropy pools are written to cyclically, starting at index 0
ctx.pool=0;/**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */ctx.generate=function(count,callback){// do synchronously
if(!callback){return ctx.generateSync(count);}// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;var b=forge.util.createBuffer();// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generate` call
ctx.key=null;generate();function generate(err){if(err){return callback(err);}// sufficient bytes generated
if(b.length()>=count){return callback(null,b.getBytes(count));}// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){// prevent stack overflow
return forge.util.nextTick(function(){_reseed(generate);});}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));forge.util.setImmediate(generate);}};/**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */ctx.generateSync=function(count){// simple generator using counter-based CBC
var cipher=ctx.plugin.cipher;var increment=ctx.plugin.increment;var formatKey=ctx.plugin.formatKey;var formatSeed=ctx.plugin.formatSeed;// paranoid deviation from Fortuna:
// reset key for every request to protect previously
// generated random bytes should the key be discovered;
// there is no 100ms based reseeding because of this
// forced reseed for every `generateSync` call
ctx.key=null;var b=forge.util.createBuffer();while(b.length()<count){// if amount of data generated is greater than 1 MiB, trigger reseed
if(ctx.generated>0xfffff){ctx.key=null;}if(ctx.key===null){_reseedSync();}// generate the random bytes
var bytes=cipher(ctx.key,ctx.seed);ctx.generated+=bytes.length;b.putBytes(bytes);// generate bytes for a new key and seed
ctx.key=formatKey(cipher(ctx.key,increment(ctx.seed)));ctx.seed=formatSeed(cipher(ctx.key,ctx.seed));}return b.getBytes(count);};/**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */function _reseed(callback){if(ctx.pools[0].messageLength>=32){_seed();return callback();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.seedFile(needed,function(err,bytes){if(err){return callback(err);}ctx.collect(bytes);_seed();callback();});}/**
   * Private function that synchronously reseeds a generator.
   */function _reseedSync(){if(ctx.pools[0].messageLength>=32){return _seed();}// not enough seed data...
var needed=32-ctx.pools[0].messageLength<<5;ctx.collect(ctx.seedFileSync(needed));_seed();}/**
   * Private function that seeds a generator once enough bytes are available.
   */function _seed(){// update reseed count
ctx.reseeds=ctx.reseeds===0xffffffff?0:ctx.reseeds+1;// goal is to update `key` via:
// key = hash(key + s)
//   where 's' is all collected entropy from selected pools, then...
// create a plugin-based message digest
var md=ctx.plugin.md.create();// consume current key bytes
md.update(ctx.keyBytes);// digest the entropy of pools whose index k meet the
// condition 'n mod 2^k == 0' where n is the number of reseeds
var _2powK=1;for(var k=0;k<32;++k){if(ctx.reseeds%_2powK===0){md.update(ctx.pools[k].digest().getBytes());ctx.pools[k].start();}_2powK=_2powK<<1;}// get digest for key bytes
ctx.keyBytes=md.digest().getBytes();// paranoid deviation from Fortuna:
// update `seed` via `seed = hash(key)`
// instead of initializing to zero once and only
// ever incrementing it
md.start();md.update(ctx.keyBytes);var seedBytes=md.digest().getBytes();// update state
ctx.key=ctx.plugin.formatKey(ctx.keyBytes);ctx.seed=ctx.plugin.formatSeed(seedBytes);ctx.generated=0;}/**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */function defaultSeedFile(needed){// use window.crypto.getRandomValues strong source of entropy if available
var getRandomValues=null;if(typeof window!=='undefined'){var _crypto=window.crypto||window.msCrypto;if(_crypto&&_crypto.getRandomValues){getRandomValues=function getRandomValues(arr){return _crypto.getRandomValues(arr);};}}var b=forge.util.createBuffer();if(getRandomValues){while(b.length()<needed){// max byte length is 65536 before QuotaExceededError is thrown
// http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
var count=Math.max(1,Math.min(needed-b.length(),65536)/4);var entropy=new Uint32Array(Math.floor(count));try{getRandomValues(entropy);for(var i=0;i<entropy.length;++i){b.putInt32(entropy[i]);}}catch(e){/* only ignore QuotaExceededError */if(!(typeof QuotaExceededError!=='undefined'&&e instanceof QuotaExceededError)){throw e;}}}}// be sad and add some weak random data
if(b.length()<needed){/* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */var hi,lo,next;var seed=Math.floor(Math.random()*0x010000);while(b.length()<needed){lo=16807*(seed&0xFFFF);hi=16807*(seed>>16);lo+=(hi&0x7FFF)<<16;lo+=hi>>15;lo=(lo&0x7FFFFFFF)+(lo>>31);seed=lo&0xFFFFFFFF;// consume lower 3 bytes of seed
for(var i=0;i<3;++i){// throw in more pseudo random
next=seed>>>(i<<3);next^=Math.floor(Math.random()*0x0100);b.putByte(String.fromCharCode(next&0xFF));}}}return b.getBytes(needed);}// initialize seed file APIs
if(_crypto){// use nodejs async API
ctx.seedFile=function(needed,callback){_crypto.randomBytes(needed,function(err,bytes){if(err){return callback(err);}callback(null,bytes.toString());});};// use nodejs sync API
ctx.seedFileSync=function(needed){return _crypto.randomBytes(needed).toString();};}else{ctx.seedFile=function(needed,callback){try{callback(null,defaultSeedFile(needed));}catch(e){callback(e);}};ctx.seedFileSync=defaultSeedFile;}/**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */ctx.collect=function(bytes){// iterate over pools distributing entropy cyclically
var count=bytes.length;for(var i=0;i<count;++i){ctx.pools[ctx.pool].update(bytes.substr(i,1));ctx.pool=ctx.pool===31?0:ctx.pool+1;}};/**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */ctx.collectInt=function(i,n){var bytes='';for(var x=0;x<n;x+=8){bytes+=String.fromCharCode(i>>x&0xFF);}ctx.collect(bytes);};/**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */ctx.registerWorker=function(worker){// worker receives random bytes
if(worker===self){ctx.seedFile=function(needed,callback){function listener(e){var data=e.data;if(data.forge&&data.forge.prng){self.removeEventListener('message',listener);callback(data.forge.prng.err,data.forge.prng.bytes);}}self.addEventListener('message',listener);self.postMessage({forge:{prng:{needed:needed}}});};}else{// main thread sends random bytes upon request
var listener=function listener(e){var data=e.data;if(data.forge&&data.forge.prng){ctx.seedFile(data.forge.prng.needed,function(err,bytes){worker.postMessage({forge:{prng:{err:err,bytes:bytes}}});});}};// TODO: do we need to remove the event listener when the worker dies?
worker.addEventListener('message',listener);}};return ctx;};/***/},/* 25 */ /***/function(module,exports,__webpack_require__){/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */var forge=__webpack_require__(0);__webpack_require__(1);var piTable=[0xd9,0x78,0xf9,0xc4,0x19,0xdd,0xb5,0xed,0x28,0xe9,0xfd,0x79,0x4a,0xa0,0xd8,0x9d,0xc6,0x7e,0x37,0x83,0x2b,0x76,0x53,0x8e,0x62,0x4c,0x64,0x88,0x44,0x8b,0xfb,0xa2,0x17,0x9a,0x59,0xf5,0x87,0xb3,0x4f,0x13,0x61,0x45,0x6d,0x8d,0x09,0x81,0x7d,0x32,0xbd,0x8f,0x40,0xeb,0x86,0xb7,0x7b,0x0b,0xf0,0x95,0x21,0x22,0x5c,0x6b,0x4e,0x82,0x54,0xd6,0x65,0x93,0xce,0x60,0xb2,0x1c,0x73,0x56,0xc0,0x14,0xa7,0x8c,0xf1,0xdc,0x12,0x75,0xca,0x1f,0x3b,0xbe,0xe4,0xd1,0x42,0x3d,0xd4,0x30,0xa3,0x3c,0xb6,0x26,0x6f,0xbf,0x0e,0xda,0x46,0x69,0x07,0x57,0x27,0xf2,0x1d,0x9b,0xbc,0x94,0x43,0x03,0xf8,0x11,0xc7,0xf6,0x90,0xef,0x3e,0xe7,0x06,0xc3,0xd5,0x2f,0xc8,0x66,0x1e,0xd7,0x08,0xe8,0xea,0xde,0x80,0x52,0xee,0xf7,0x84,0xaa,0x72,0xac,0x35,0x4d,0x6a,0x2a,0x96,0x1a,0xd2,0x71,0x5a,0x15,0x49,0x74,0x4b,0x9f,0xd0,0x5e,0x04,0x18,0xa4,0xec,0xc2,0xe0,0x41,0x6e,0x0f,0x51,0xcb,0xcc,0x24,0x91,0xaf,0x50,0xa1,0xf4,0x70,0x39,0x99,0x7c,0x3a,0x85,0x23,0xb8,0xb4,0x7a,0xfc,0x02,0x36,0x5b,0x25,0x55,0x97,0x31,0x2d,0x5d,0xfa,0x98,0xe3,0x8a,0x92,0xae,0x05,0xdf,0x29,0x10,0x67,0x6c,0xba,0xc9,0xd3,0x00,0xe6,0xcf,0xe1,0x9e,0xa8,0x2c,0x63,0x16,0x01,0x3f,0x58,0xe2,0x89,0xa9,0x0d,0x38,0x34,0x1b,0xab,0x33,0xff,0xb0,0xbb,0x48,0x0c,0x5f,0xb9,0xb1,0xcd,0x2e,0xc5,0xf3,0xdb,0x47,0xe5,0xa5,0x9c,0x77,0x0a,0xa6,0x20,0x68,0xfe,0x7f,0xc1,0xad];var s=[1,2,3,5];/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var rol=function rol(word,bits){return word<<bits&0xffff|(word&0xffff)>>16-bits;};/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */var ror=function ror(word,bits){return(word&0xffff)>>bits|word<<16-bits&0xffff;};/* RC2 API */module.exports=forge.rc2=forge.rc2||{};/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */forge.rc2.expandKey=function(key,effKeyBits){if(typeof key==='string'){key=forge.util.createBuffer(key);}effKeyBits=effKeyBits||128;/* introduce variables that match the names used in RFC #2268 */var L=key;var T=key.length();var T1=effKeyBits;var T8=Math.ceil(T1/8);var TM=0xff>>(T1&0x07);var i;for(i=T;i<128;i++){L.putByte(piTable[L.at(i-1)+L.at(i-T)&0xff]);}L.setAt(128-T8,piTable[L.at(128-T8)&TM]);for(i=127-T8;i>=0;i--){L.setAt(i,piTable[L.at(i+1)^L.at(i+T8)]);}return L;};/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */var createCipher=function createCipher(key,bits,encrypt){var _finish=false,_input=null,_output=null,_iv=null;var mixRound,mashRound;var i,j,K=[];/* Expand key and fill into K[] Array */key=forge.rc2.expandKey(key,bits);for(i=0;i<64;i++){K.push(key.getInt16Le());}if(encrypt){/**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=0;i<4;i++){R[i]+=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);R[i]=rol(R[i],s[i]);j++;}};/**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=0;i<4;i++){R[i]+=K[R[(i+3)%4]&63];}};}else{/**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */mixRound=function mixRound(R){for(i=3;i>=0;i--){R[i]=ror(R[i],s[i]);R[i]-=K[j]+(R[(i+3)%4]&R[(i+2)%4])+(~R[(i+3)%4]&R[(i+1)%4]);j--;}};/**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */mashRound=function mashRound(R){for(i=3;i>=0;i--){R[i]-=K[R[(i+3)%4]&63];}};}/**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */var runPlan=function runPlan(plan){var R=[];/* Get data from input buffer and fill the four words into R */for(i=0;i<4;i++){var val=_input.getInt16Le();if(_iv!==null){if(encrypt){/* We're encrypting, apply the IV first. */val^=_iv.getInt16Le();}else{/* We're decryption, keep cipher text for next block. */_iv.putInt16Le(val);}}R.push(val&0xffff);}/* Reset global "j" variable as per spec. */j=encrypt?0:63;/* Run execution plan. */for(var ptr=0;ptr<plan.length;ptr++){for(var ctr=0;ctr<plan[ptr][0];ctr++){plan[ptr][1](R);}}/* Write back result to output buffer. */for(i=0;i<4;i++){if(_iv!==null){if(encrypt){/* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */_iv.putInt16Le(R[i]);}else{R[i]^=_iv.getInt16Le();}}_output.putInt16Le(R[i]);}};/* Create cipher object */var cipher=null;cipher={/**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */start:function start(iv,output){if(iv){/* CBC mode */if(typeof iv==='string'){iv=forge.util.createBuffer(iv);}}_finish=false;_input=forge.util.createBuffer();_output=output||new forge.util.createBuffer();_iv=iv;cipher.output=_output;},/**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */update:function update(input){if(!_finish){// not finishing, so fill the input buffer with more input
_input.putBuffer(input);}while(_input.length()>=8){runPlan([[5,mixRound],[1,mashRound],[6,mixRound],[1,mashRound],[5,mixRound]]);}},/**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */finish:function finish(pad){var rval=true;if(encrypt){if(pad){rval=pad(8,_input,!encrypt);}else{// add PKCS#7 padding to block (each pad byte is the
// value of the number of pad bytes)
var padding=_input.length()===8?8:8-_input.length();_input.fillWithByte(padding,padding);}}if(rval){// do final update
_finish=true;cipher.update();}if(!encrypt){// check for error: input data not a multiple of block size
rval=_input.length()===0;if(rval){if(pad){rval=pad(8,_output,!encrypt);}else{// ensure padding byte count is valid
var len=_output.length();var count=_output.at(len-1);if(count>len){rval=false;}else{// trim off padding bytes
_output.truncate(count);}}}}return rval;}};return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startEncrypting=function(key,iv,output){var cipher=forge.rc2.createEncryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createEncryptionCipher=function(key,bits){return createCipher(key,bits,true);};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */forge.rc2.startDecrypting=function(key,iv,output){var cipher=forge.rc2.createDecryptionCipher(key,128);cipher.start(iv,output);return cipher;};/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */forge.rc2.createDecryptionCipher=function(key,bits){return createCipher(key,bits,false);};/***/},/* 26 */ /***/function(module,exports,__webpack_require__){/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(5);__webpack_require__(17);// shortcut for PKCS#1 API
var pkcs1=module.exports=forge.pkcs1=forge.pkcs1||{};/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */pkcs1.encode_rsa_oaep=function(key,message,options){// parse arguments
var label;var seed;var md;var mgf1Md;// legacy args (label, seed, md)
if(typeof options==='string'){label=options;seed=arguments[3]||undefined;md=arguments[4]||undefined;}else if(options){label=options.label||undefined;seed=options.seed||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// default OAEP to SHA-1 message digest
if(!md){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}// compute length in bytes and check output
var keyLength=Math.ceil(key.n.bitLength()/8);var maxLength=keyLength-2*md.digestLength-2;if(message.length>maxLength){var error=new Error('RSAES-OAEP input message length is too long.');error.length=message.length;error.maxLength=maxLength;throw error;}if(!label){label='';}md.update(label,'raw');var lHash=md.digest();var PS='';var PS_length=maxLength-message.length;for(var i=0;i<PS_length;i++){PS+='\x00';}var DB=lHash.getBytes()+PS+'\x01'+message;if(!seed){seed=forge.random.getBytes(md.digestLength);}else if(seed.length!==md.digestLength){var error=new Error('Invalid RSAES-OAEP seed. The seed length must '+'match the digest length.');error.seedLength=seed.length;error.digestLength=md.digestLength;throw error;}var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var maskedDB=forge.util.xorBytes(DB,dbMask,DB.length);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var maskedSeed=forge.util.xorBytes(seed,seedMask,seed.length);// return encoded message
return'\x00'+maskedSeed+maskedDB;};/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */pkcs1.decode_rsa_oaep=function(key,em,options){// parse args
var label;var md;var mgf1Md;// legacy args
if(typeof options==='string'){label=options;md=arguments[3]||undefined;}else if(options){label=options.label||undefined;md=options.md||undefined;if(options.mgf1&&options.mgf1.md){mgf1Md=options.mgf1.md;}}// compute length in bytes
var keyLength=Math.ceil(key.n.bitLength()/8);if(em.length!==keyLength){var error=new Error('RSAES-OAEP encoded message length is invalid.');error.length=em.length;error.expectedLength=keyLength;throw error;}// default OAEP to SHA-1 message digest
if(md===undefined){md=forge.md.sha1.create();}else{md.start();}// default MGF-1 to same as OAEP
if(!mgf1Md){mgf1Md=md;}if(keyLength<2*md.digestLength+2){throw new Error('RSAES-OAEP key is too short for the hash function.');}if(!label){label='';}md.update(label,'raw');var lHash=md.digest().getBytes();// split the message into its parts
var y=em.charAt(0);var maskedSeed=em.substring(1,md.digestLength+1);var maskedDB=em.substring(1+md.digestLength);var seedMask=rsa_mgf1(maskedDB,md.digestLength,mgf1Md);var seed=forge.util.xorBytes(maskedSeed,seedMask,maskedSeed.length);var dbMask=rsa_mgf1(seed,keyLength-md.digestLength-1,mgf1Md);var db=forge.util.xorBytes(maskedDB,dbMask,maskedDB.length);var lHashPrime=db.substring(0,md.digestLength);// constant time check that all values match what is expected
var error=y!=='\x00';// constant time check lHash vs lHashPrime
for(var i=0;i<md.digestLength;++i){error|=lHash.charAt(i)!==lHashPrime.charAt(i);}// "constant time" find the 0x1 byte separating the padding (zeros) from the
// message
// TODO: It must be possible to do this in a better/smarter way?
var in_ps=1;var index=md.digestLength;for(var j=md.digestLength;j<db.length;j++){var code=db.charCodeAt(j);var is_0=code&0x1^0x1;// non-zero if not 0 or 1 in the ps section
var error_mask=in_ps?0xfffe:0x0000;error|=code&error_mask;// latch in_ps to zero after we find 0x1
in_ps=in_ps&is_0;index+=in_ps;}if(error||db.charCodeAt(index)!==0x1){throw new Error('Invalid RSAES-OAEP padding.');}return db.substring(index+1);};function rsa_mgf1(seed,maskLength,hash){// default to SHA-1 message digest
if(!hash){hash=forge.md.sha1.create();}var t='';var count=Math.ceil(maskLength/hash.digestLength);for(var i=0;i<count;++i){var c=String.fromCharCode(i>>24&0xFF,i>>16&0xFF,i>>8&0xFF,i&0xFF);hash.start();hash.update(seed+c);t+=hash.digest().getBytes();}return t.substring(0,maskLength);}/***/},/* 27 */ /***/function(module,exports,__webpack_require__){/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);__webpack_require__(16);__webpack_require__(5);(function(){// forge.prime already defined
if(forge.prime){module.exports=forge.prime;return;}/* PRIME API */var prime=module.exports=forge.prime=forge.prime||{};var BigInteger=forge.jsbn.BigInteger;// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA=[6,4,2,4,2,4,6,2];var THIRTY=new BigInteger(null);THIRTY.fromInt(30);var op_or=function op_or(x,y){return x|y;};/**
 * Generates a random probable prime with the given number of bits.
 *
 * Alternative algorithms can be specified by name as a string or as an
 * object with custom options like so:
 *
 * {
 *   name: 'PRIMEINC',
 *   options: {
 *     maxBlockTime: <the maximum amount of time to block the main
 *       thread before allowing I/O other JS to run>,
 *     millerRabinTests: <the number of miller-rabin tests to run>,
 *     workerScript: <the worker script URL>,
 *     workers: <the number of web workers (if supported) to use,
 *       -1 to use estimated cores minus one>.
 *     workLoad: the size of the work load, ie: number of possible prime
 *       numbers for each web worker to check per work assignment,
 *       (default: 100).
 *   }
 * }
 *
 * @param bits the number of bits for the prime number.
 * @param options the options to use.
 *          [algorithm] the algorithm to use (default: 'PRIMEINC').
 *          [prng] a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *
 * @return callback(err, num) called once the operation completes.
 */prime.generateProbablePrime=function(bits,options,callback){if(typeof options==='function'){callback=options;options={};}options=options||{};// default to PRIMEINC algorithm
var algorithm=options.algorithm||'PRIMEINC';if(typeof algorithm==='string'){algorithm={name:algorithm};}algorithm.options=algorithm.options||{};// create prng with api that matches BigInteger secure random
var prng=options.prng||forge.random;var rng={// x is an array to fill with bytes
nextBytes:function nextBytes(x){var b=prng.getBytesSync(x.length);for(var i=0;i<x.length;++i){x[i]=b.charCodeAt(i);}}};if(algorithm.name==='PRIMEINC'){return primeincFindPrime(bits,rng,algorithm.options,callback);}throw new Error('Invalid prime generation algorithm: '+algorithm.name);};function primeincFindPrime(bits,rng,options,callback){if('workers'in options){return primeincFindPrimeWithWorkers(bits,rng,options,callback);}return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}function primeincFindPrimeWithoutWorkers(bits,rng,options,callback){// initialize random number
var num=generateRandom(bits,rng);/* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
  number we are given is always aligned at 30k + 1. Each time the number is
  determined not to be prime we add to get to the next 'i', eg: if the number
  was at 30k + 1 we add 6. */var deltaIdx=0;// get required number of MR tests
var mrTests=getMillerRabinTests(num.bitLength());if('millerRabinTests'in options){mrTests=options.millerRabinTests;}// find prime nearest to 'num' for maxBlockTime ms
// 10 ms gives 5ms of leeway for other calculations before dropping
// below 60fps (1000/60 == 16.67), but in reality, the number will
// likely be higher due to an 'atomic' big int modPow
var maxBlockTime=10;if('maxBlockTime'in options){maxBlockTime=options.maxBlockTime;}_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);}function _primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback){var start=+new Date();do{// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// do primality test
if(num.isProbablePrime(mrTests)){return callback(null,num);}// get next potential prime
num.dAddOffset(GCD_30_DELTA[deltaIdx++%8],0);}while(maxBlockTime<0||+new Date()-start<maxBlockTime);// keep trying later
forge.util.setImmediate(function(){_primeinc(num,bits,rng,deltaIdx,mrTests,maxBlockTime,callback);});}// NOTE: This algorithm is indeterminate in nature because workers
// run in parallel looking at different segments of numbers. Even if this
// algorithm is run twice with the same input from a predictable RNG, it
// may produce different outputs.
function primeincFindPrimeWithWorkers(bits,rng,options,callback){// web workers unavailable
if(typeof Worker==='undefined'){return primeincFindPrimeWithoutWorkers(bits,rng,options,callback);}// initialize random number
var num=generateRandom(bits,rng);// use web workers to generate keys
var numWorkers=options.workers;var workLoad=options.workLoad||100;var range=workLoad*30/8;var workerScript=options.workerScript||'forge/prime.worker.js';if(numWorkers===-1){return forge.util.estimateCores(function(err,cores){if(err){// default to 2
cores=2;}numWorkers=cores-1;generate();});}generate();function generate(){// require at least 1 worker
numWorkers=Math.max(1,numWorkers);// TODO: consider optimizing by starting workers outside getPrime() ...
// note that in order to clean up they will have to be made internally
// asynchronous which may actually be slower
// start workers immediately
var workers=[];for(var i=0;i<numWorkers;++i){// FIXME: fix path or use blob URLs
workers[i]=new Worker(workerScript);}var running=numWorkers;// listen for requests from workers and assign ranges to find prime
for(var i=0;i<numWorkers;++i){workers[i].addEventListener('message',workerMessage);}/* Note: The distribution of random numbers is unknown. Therefore, each
    web worker is continuously allocated a range of numbers to check for a
    random number until one is found.

    Every 30 numbers will be checked just 8 times, because prime numbers
    have the form:

    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)

    Therefore, if we want a web worker to run N checks before asking for
    a new range of numbers, each range must contain N*30/8 numbers.

    For 100 checks (workLoad), this is a range of 375. */var found=false;function workerMessage(e){// ignore message, prime already found
if(found){return;}--running;var data=e.data;if(data.found){// terminate all workers
for(var i=0;i<workers.length;++i){workers[i].terminate();}found=true;return callback(null,new BigInteger(data.prime,16));}// overflow, regenerate random number
if(num.bitLength()>bits){num=generateRandom(bits,rng);}// assign new range to check
var hex=num.toString(16);// start prime search
e.target.postMessage({hex:hex,workLoad:workLoad});num.dAddOffset(range,0);}}}/**
 * Generates a random number using the given number of bits and RNG.
 *
 * @param bits the number of bits for the number.
 * @param rng the random number generator to use.
 *
 * @return the random number.
 */function generateRandom(bits,rng){var num=new BigInteger(bits,rng);// force MSB set
var bits1=bits-1;if(!num.testBit(bits1)){num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1),op_or,num);}// align number on 30k+1 boundary
num.dAddOffset(31-num.mod(THIRTY).byteValue(),0);return num;}/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */function getMillerRabinTests(bits){if(bits<=100)return 27;if(bits<=150)return 18;if(bits<=200)return 15;if(bits<=250)return 12;if(bits<=300)return 9;if(bits<=350)return 8;if(bits<=400)return 7;if(bits<=500)return 6;if(bits<=600)return 5;if(bits<=800)return 4;if(bits<=1250)return 3;return 2;}})();/***/},/* 28 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of PKCS#12.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#12 is as follows
 * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
 *
 * PFX ::= SEQUENCE {
 *   version  INTEGER {v3(3)}(v3,...),
 *   authSafe ContentInfo,
 *   macData  MacData OPTIONAL
 * }
 *
 * MacData ::= SEQUENCE {
 *   mac DigestInfo,
 *   macSalt OCTET STRING,
 *   iterations INTEGER DEFAULT 1
 * }
 * Note: The iterations default is for historical reasons and its use is
 * deprecated. A higher value, like 1024, is recommended.
 *
 * DigestInfo is defined in PKCS#7 as follows:
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of SHA1 there is none.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * Digest ::= OCTET STRING
 *
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType ContentType,
 *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * AuthenticatedSafe ::= SEQUENCE OF ContentInfo
 * -- Data if unencrypted
 * -- EncryptedData if password-encrypted
 * -- EnvelopedData if public key-encrypted
 *
 *
 * SafeContents ::= SEQUENCE OF SafeBag
 *
 * SafeBag ::= SEQUENCE {
 *   bagId     BAG-TYPE.&id ({PKCS12BagSet})
 *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
 *   bagAttributes SET OF PKCS12Attribute OPTIONAL
 * }
 *
 * PKCS12Attribute ::= SEQUENCE {
 *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
 *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
 * } -- This type is compatible with the X.500 type Attribute
 *
 * PKCS12AttrSet ATTRIBUTE ::= {
 *   friendlyName | -- from PKCS #9
 *   localKeyId, -- from PKCS #9
 *   ... -- Other attributes are allowed
 * }
 *
 * CertBag ::= SEQUENCE {
 *   certId    BAG-TYPE.&id   ({CertTypes}),
 *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
 * }
 *
 * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
 *   -- DER-encoded X.509 certificate stored in OCTET STRING
 *
 * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
 * -- Base64-encoded SDSI certificate stored in IA5String
 *
 * CertTypes BAG-TYPE ::= {
 *   x509Certificate |
 *   sdsiCertificate,
 *   ... -- For future extensions
 * }
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(14);__webpack_require__(3);__webpack_require__(29);__webpack_require__(9);__webpack_require__(5);__webpack_require__(6);__webpack_require__(17);__webpack_require__(1);__webpack_require__(18);// shortcut for asn.1 & PKI API
var asn1=forge.asn1;var pki=forge.pki;// shortcut for PKCS#12 API
var p12=module.exports=forge.pkcs12=forge.pkcs12||{};var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// a ContentInfo
constructed:true,value:[{name:'ContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'content'}]};var pfxValidator={name:'PFX',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'PFX.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},contentInfoValidator,{name:'PFX.macData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,optional:true,captureAsn1:'mac',value:[{name:'PFX.macData.mac',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestInfo
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,// DigestAlgorithmIdentifier
constructed:true,value:[{name:'PFX.macData.mac.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'macAlgorithm'},{name:'PFX.macData.mac.digestAlgorithm.parameters',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'macAlgorithmParameters'}]},{name:'PFX.macData.mac.digest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macDigest'}]},{name:'PFX.macData.macSalt',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'macSalt'},{name:'PFX.macData.iterations',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,optional:true,capture:'macIterations'}]}]};var safeBagValidator={name:'SafeBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SafeBag.bagId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'bagId'},{name:'SafeBag.bagValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,captureAsn1:'bagValue'},{name:'SafeBag.bagAttributes',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,optional:true,capture:'bagAttributes'}]};var attributeValidator={name:'Attribute',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'Attribute.attrId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'oid'},{name:'Attribute.attrValues',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,capture:'values'}]};var certBagValidator={name:'CertBag',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'CertBag.certId',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'certId'},{name:'CertBag.certValue',tagClass:asn1.Class.CONTEXT_SPECIFIC,constructed:true,/* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */value:[{name:'CertBag.certValue[0]',tagClass:asn1.Class.UNIVERSAL,type:asn1.Class.OCTETSTRING,constructed:false,capture:'cert'}]}]};/**
 * Search SafeContents structure for bags with matching attributes.
 *
 * The search can optionally be narrowed by a certain bag type.
 *
 * @param safeContents the SafeContents structure to search in.
 * @param attrName the name of the attribute to compare against.
 * @param attrValue the attribute value to search for.
 * @param [bagType] bag type to narrow search by.
 *
 * @return an array of matching bags.
 */function _getBagsByAttribute(safeContents,attrName,attrValue,bagType){var result=[];for(var i=0;i<safeContents.length;i++){for(var j=0;j<safeContents[i].safeBags.length;j++){var bag=safeContents[i].safeBags[j];if(bagType!==undefined&&bag.type!==bagType){continue;}// only filter by bag type, no attribute specified
if(attrName===null){result.push(bag);continue;}if(bag.attributes[attrName]!==undefined&&bag.attributes[attrName].indexOf(attrValue)>=0){result.push(bag);}}}return result;}/**
 * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
 *
 * @param obj The PKCS#12 PFX in ASN.1 notation.
 * @param strict true to use strict DER decoding, false not to (default: true).
 * @param {String} password Password to decrypt with (optional).
 *
 * @return PKCS#12 PFX object.
 */p12.pkcs12FromAsn1=function(obj,strict,password){// handle args
if(typeof strict==='string'){password=strict;strict=true;}else if(strict===undefined){strict=true;}// validate PFX and capture data
var capture={};var errors=[];if(!asn1.validate(obj,pfxValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 PFX. '+'ASN.1 object is not an PKCS#12 PFX.');error.errors=error;throw error;}var pfx={version:capture.version.charCodeAt(0),safeContents:[],/**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */getBags:function getBags(filter){var rval={};var localKeyId;if('localKeyId'in filter){localKeyId=filter.localKeyId;}else if('localKeyIdHex'in filter){localKeyId=forge.util.hexToBytes(filter.localKeyIdHex);}// filter on bagType only
if(localKeyId===undefined&&!('friendlyName'in filter)&&'bagType'in filter){rval[filter.bagType]=_getBagsByAttribute(pfx.safeContents,null,null,filter.bagType);}if(localKeyId!==undefined){rval.localKeyId=_getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,filter.bagType);}if('friendlyName'in filter){rval.friendlyName=_getBagsByAttribute(pfx.safeContents,'friendlyName',filter.friendlyName,filter.bagType);}return rval;},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */getBagsByFriendlyName:function getBagsByFriendlyName(friendlyName,bagType){return _getBagsByAttribute(pfx.safeContents,'friendlyName',friendlyName,bagType);},/**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */getBagsByLocalKeyId:function getBagsByLocalKeyId(localKeyId,bagType){return _getBagsByAttribute(pfx.safeContents,'localKeyId',localKeyId,bagType);}};if(capture.version.charCodeAt(0)!==3){var error=new Error('PKCS#12 PFX of version other than 3 not supported.');error.version=capture.version.charCodeAt(0);throw error;}if(asn1.derToOid(capture.contentType)!==pki.oids.data){var error=new Error('Only PKCS#12 PFX in password integrity mode supported.');error.oid=asn1.derToOid(capture.contentType);throw error;}var data=capture.content.value[0];if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');}data=_decodePkcs7Data(data);// check for MAC
if(capture.mac){var md=null;var macKeyBytes=0;var macAlgorithm=asn1.derToOid(capture.macAlgorithm);switch(macAlgorithm){case pki.oids.sha1:md=forge.md.sha1.create();macKeyBytes=20;break;case pki.oids.sha256:md=forge.md.sha256.create();macKeyBytes=32;break;case pki.oids.sha384:md=forge.md.sha384.create();macKeyBytes=48;break;case pki.oids.sha512:md=forge.md.sha512.create();macKeyBytes=64;break;case pki.oids.md5:md=forge.md.md5.create();macKeyBytes=16;break;}if(md===null){throw new Error('PKCS#12 uses unsupported MAC algorithm: '+macAlgorithm);}// verify MAC (iterations default to 1)
var macSalt=new forge.util.ByteBuffer(capture.macSalt);var macIterations='macIterations'in capture?parseInt(forge.util.bytesToHex(capture.macIterations),16):1;var macKey=p12.generateKey(password,macSalt,3,macIterations,macKeyBytes,md);var mac=forge.hmac.create();mac.start(md,macKey);mac.update(data.value);var macValue=mac.getMac();if(macValue.getBytes()!==capture.macDigest){throw new Error('PKCS#12 MAC could not be verified. Invalid password?');}}_decodeAuthenticatedSafe(pfx,data.value,strict,password);return pfx;};/**
 * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
 * but it is sometimes an OCTET STRING that is composed/constructed of chunks,
 * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
 * function transforms this corner-case into the usual simple,
 * non-composed/constructed OCTET STRING.
 *
 * This function may be moved to ASN.1 at some point to better deal with
 * more BER-encoding issues, should they arise.
 *
 * @param data the ASN.1 Data object to transform.
 */function _decodePkcs7Data(data){// handle special case of "chunked" data content: an octet string composed
// of other octet strings
if(data.composed||data.constructed){var value=forge.util.createBuffer();for(var i=0;i<data.value.length;++i){value.putBytes(data.value[i].value);}data.composed=data.constructed=false;data.value=value.getBytes();}return data;}/**
 * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
 *
 * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
 *
 * @param pfx The PKCS#12 PFX object to fill.
 * @param {String} authSafe BER-encoded AuthenticatedSafe.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 */function _decodeAuthenticatedSafe(pfx,authSafe,strict,password){authSafe=asn1.fromDer(authSafe,strict);/* actually it's BER encoded */if(authSafe.tagClass!==asn1.Class.UNIVERSAL||authSafe.type!==asn1.Type.SEQUENCE||authSafe.constructed!==true){throw new Error('PKCS#12 AuthenticatedSafe expected to be a '+'SEQUENCE OF ContentInfo');}for(var i=0;i<authSafe.value.length;i++){var contentInfo=authSafe.value[i];// validate contentInfo and capture data
var capture={};var errors=[];if(!asn1.validate(contentInfo,contentInfoValidator,capture,errors)){var error=new Error('Cannot read ContentInfo.');error.errors=errors;throw error;}var obj={encrypted:false};var safeContents=null;var data=capture.content.value[0];switch(asn1.derToOid(capture.contentType)){case pki.oids.data:if(data.tagClass!==asn1.Class.UNIVERSAL||data.type!==asn1.Type.OCTETSTRING){throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');}safeContents=_decodePkcs7Data(data).value;break;case pki.oids.encryptedData:safeContents=_decryptSafeContents(data,password);obj.encrypted=true;break;default:var error=new Error('Unsupported PKCS#12 contentType.');error.contentType=asn1.derToOid(capture.contentType);throw error;}obj.safeBags=_decodeSafeContents(safeContents,strict,password);pfx.safeContents.push(obj);}}/**
 * Decrypt PKCS#7 EncryptedData structure.
 *
 * @param data ASN.1 encoded EncryptedContentInfo object.
 * @param password The user-provided password.
 *
 * @return The decrypted SafeContents (ASN.1 object).
 */function _decryptSafeContents(data,password){var capture={};var errors=[];if(!asn1.validate(data,forge.pkcs7.asn1.encryptedDataValidator,capture,errors)){var error=new Error('Cannot read EncryptedContentInfo.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.contentType);if(oid!==pki.oids.data){var error=new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');error.oid=oid;throw error;}// get cipher
oid=asn1.derToOid(capture.encAlgorithm);var cipher=pki.pbe.getCipher(oid,capture.encParameter,password);// get encrypted data
var encryptedContentAsn1=_decodePkcs7Data(capture.encryptedContentAsn1);var encrypted=forge.util.createBuffer(encryptedContentAsn1.value);cipher.update(encrypted);if(!cipher.finish()){throw new Error('Failed to decrypt PKCS#12 SafeContents.');}return cipher.output.getBytes();}/**
 * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
 *
 * The safeContents is a BER-encoded SEQUENCE OF SafeBag.
 *
 * @param {String} safeContents BER-encoded safeContents.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 *
 * @return {Array} Array of Bag objects.
 */function _decodeSafeContents(safeContents,strict,password){// if strict and no safe contents, return empty safes
if(!strict&&safeContents.length===0){return[];}// actually it's BER-encoded
safeContents=asn1.fromDer(safeContents,strict);if(safeContents.tagClass!==asn1.Class.UNIVERSAL||safeContents.type!==asn1.Type.SEQUENCE||safeContents.constructed!==true){throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');}var res=[];for(var i=0;i<safeContents.value.length;i++){var safeBag=safeContents.value[i];// validate SafeBag and capture data
var capture={};var errors=[];if(!asn1.validate(safeBag,safeBagValidator,capture,errors)){var error=new Error('Cannot read SafeBag.');error.errors=errors;throw error;}/* Create bag object and push to result array. */var bag={type:asn1.derToOid(capture.bagId),attributes:_decodeBagAttributes(capture.bagAttributes)};res.push(bag);var validator,decoder;var bagAsn1=capture.bagValue.value[0];switch(bag.type){case pki.oids.pkcs8ShroudedKeyBag:/* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.
           Afterwards we can handle it like a keyBag,
           which is a PrivateKeyInfo. */bagAsn1=pki.decryptPrivateKeyInfo(bagAsn1,password);if(bagAsn1===null){throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');}/* fall through */case pki.oids.keyBag:/* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our
           PKI module, hence we don't have to do validation/capturing here,
           just pass what we already got. */try{bag.key=pki.privateKeyFromAsn1(bagAsn1);}catch(e){// ignore unknown key type, pass asn1 value
bag.key=null;bag.asn1=bagAsn1;}continue;/* Nothing more to do. */case pki.oids.certBag:/* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.
           Therefore put the SafeBag content through another validator to
           capture the fields.  Afterwards check & store the results. */validator=certBagValidator;decoder=function decoder(){if(asn1.derToOid(capture.certId)!==pki.oids.x509Certificate){var error=new Error('Unsupported certificate type, only X.509 supported.');error.oid=asn1.derToOid(capture.certId);throw error;}// true=produce cert hash
var certAsn1=asn1.fromDer(capture.cert,strict);try{bag.cert=pki.certificateFromAsn1(certAsn1,true);}catch(e){// ignore unknown cert type, pass asn1 value
bag.cert=null;bag.asn1=certAsn1;}};break;default:var error=new Error('Unsupported PKCS#12 SafeBag type.');error.oid=bag.type;throw error;}/* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */if(validator!==undefined&&!asn1.validate(bagAsn1,validator,capture,errors)){var error=new Error('Cannot read PKCS#12 '+validator.name);error.errors=errors;throw error;}/* Call decoder function from above to store the results. */decoder();}return res;}/**
 * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
 *
 * @param attributes SET OF PKCS12Attribute (ASN.1 object).
 *
 * @return the decoded attributes.
 */function _decodeBagAttributes(attributes){var decodedAttrs={};if(attributes!==undefined){for(var i=0;i<attributes.length;++i){var capture={};var errors=[];if(!asn1.validate(attributes[i],attributeValidator,capture,errors)){var error=new Error('Cannot read PKCS#12 BagAttribute.');error.errors=errors;throw error;}var oid=asn1.derToOid(capture.oid);if(pki.oids[oid]===undefined){// unsupported attribute type, ignore.
continue;}decodedAttrs[pki.oids[oid]]=[];for(var j=0;j<capture.values.length;++j){decodedAttrs[pki.oids[oid]].push(capture.values[j].value);}}}return decodedAttrs;}/**
 * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
 * password is provided then the private key will be encrypted.
 *
 * An entire certificate chain may also be included. To do this, pass
 * an array for the "cert" parameter where the first certificate is
 * the one that is paired with the private key and each subsequent one
 * verifies the previous one. The certificates may be in PEM format or
 * have been already parsed by Forge.
 *
 * @todo implement password-based-encryption for the whole package
 *
 * @param key the private key.
 * @param cert the certificate (may be an array of certificates in order
 *          to specify a certificate chain).
 * @param password the password to use, null for none.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          useMac true to include a MAC, false not to, defaults to true.
 *          localKeyId the local key ID to use, in hex.
 *          friendlyName the friendly name to use.
 *          generateLocalKeyId true to generate a random local key ID,
 *            false not to, defaults to true.
 *
 * @return the PKCS#12 PFX ASN.1 object.
 */p12.toPkcs12Asn1=function(key,cert,password,options){// set default options
options=options||{};options.saltSize=options.saltSize||8;options.count=options.count||2048;options.algorithm=options.algorithm||options.encAlgorithm||'aes128';if(!('useMac'in options)){options.useMac=true;}if(!('localKeyId'in options)){options.localKeyId=null;}if(!('generateLocalKeyId'in options)){options.generateLocalKeyId=true;}var localKeyId=options.localKeyId;var bagAttrs;if(localKeyId!==null){localKeyId=forge.util.hexToBytes(localKeyId);}else if(options.generateLocalKeyId){// use SHA-1 of paired cert, if available
if(cert){var pairedCert=forge.util.isArray(cert)?cert[0]:cert;if(typeof pairedCert==='string'){pairedCert=pki.certificateFromPem(pairedCert);}var sha1=forge.md.sha1.create();sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());localKeyId=sha1.digest().getBytes();}else{// FIXME: consider using SHA-1 of public key (which can be generated
// from private key components), see: cert.generateSubjectKeyIdentifier
// generate random bytes
localKeyId=forge.random.getBytes(20);}}var attrs=[];if(localKeyId!==null){attrs.push(// localKeyID
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.localKeyId).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,localKeyId)])]));}if('friendlyName'in options){attrs.push(// friendlyName
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// attrId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.friendlyName).getBytes()),// attrValues
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.BMPSTRING,false,options.friendlyName)])]));}if(attrs.length>0){bagAttrs=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SET,true,attrs);}// collect contents for AuthenticatedSafe
var contents=[];// create safe bag(s) for certificate chain
var chain=[];if(cert!==null){if(forge.util.isArray(cert)){chain=cert;}else{chain=[cert];}}var certSafeBags=[];for(var i=0;i<chain.length;++i){// convert cert from PEM as necessary
cert=chain[i];if(typeof cert==='string'){cert=pki.certificateFromPem(cert);}// SafeBag
var certBagAttrs=i===0?bagAttrs:undefined;var certAsn1=pki.certificateToAsn1(cert);var certSafeBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.certBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// CertBag
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// certId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.x509Certificate).getBytes()),// certValue (x509Certificate)
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certAsn1).getBytes())])])]),// bagAttributes (OPTIONAL)
certBagAttrs]);certSafeBags.push(certSafeBag);}if(certSafeBags.length>0){// SafeContents
var certSafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,certSafeBags);// ContentInfo
var certCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(certSafeContents).getBytes())])]);contents.push(certCI);}// create safe contents for private key
var keyBag=null;if(key!==null){// SafeBag
var pkAsn1=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));if(password===null){// no encryption
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.keyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// PrivateKeyInfo
pkAsn1]),// bagAttributes (OPTIONAL)
bagAttrs]);}else{// encrypted PrivateKeyInfo
keyBag=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// bagId
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),// bagValue
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[// EncryptedPrivateKeyInfo
pki.encryptPrivateKeyInfo(pkAsn1,password,options)]),// bagAttributes (OPTIONAL)
bagAttrs]);}// SafeContents
var keySafeContents=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[keyBag]);// ContentInfo
var keyCI=// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(keySafeContents).getBytes())])]);contents.push(keyCI);}// create AuthenticatedSafe by stringing together the contents
var safe=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,contents);var macData;if(options.useMac){// MacData
var sha1=forge.md.sha1.create();var macSalt=new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));var count=options.count;// 160-bit key
var key=p12.generateKey(password,macSalt,3,count,20);var mac=forge.hmac.create();mac.start(sha1,key);mac.update(asn1.toDer(safe).getBytes());var macValue=mac.getMac();macData=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// mac DigestInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// digestAlgorithm
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// algorithm = SHA-1
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,asn1.oidToDer(pki.oids.sha1).getBytes()),// parameters = Null
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,false,'')]),// digest
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macValue.getBytes())]),// macSalt OCTET STRING
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,macSalt.getBytes()),// iterations INTEGER (XXX: Only support count < 65536)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(count).getBytes())]);}// PFX
return asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// version (3)
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,false,asn1.integerToDer(3).getBytes()),// PKCS#7 ContentInfo
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,true,[// contentType
asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,false,// OID for the content type is 'data'
asn1.oidToDer(pki.oids.data).getBytes()),// content
asn1.create(asn1.Class.CONTEXT_SPECIFIC,0,true,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,false,asn1.toDer(safe).getBytes())])]),macData]);};/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */p12.generateKey=forge.pbe.generatePkcs12Key;/***/},/* 29 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */var forge=__webpack_require__(0);__webpack_require__(2);__webpack_require__(1);// shortcut for ASN.1 API
var asn1=forge.asn1;// shortcut for PKCS#7 API
var p7v=module.exports=forge.pkcs7asn1=forge.pkcs7asn1||{};forge.pkcs7=forge.pkcs7||{};forge.pkcs7.asn1=p7v;var contentInfoValidator={name:'ContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'ContentInfo.ContentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'ContentInfo.content',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,captureAsn1:'content'}]};p7v.contentInfoValidator=contentInfoValidator;var encryptedContentInfoValidator={name:'EncryptedContentInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentType',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'contentType'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,captureAsn1:'encParameter'}]},{name:'EncryptedContentInfo.encryptedContent',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,/* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */capture:'encryptedContent',captureAsn1:'encryptedContentAsn1'}]};p7v.envelopedDataValidator={name:'EnvelopedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EnvelopedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'EnvelopedData.RecipientInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'recipientInfos'}].concat(encryptedContentInfoValidator)};p7v.encryptedDataValidator={name:'EncryptedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'EncryptedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'}].concat(encryptedContentInfoValidator)};var signerValidator={name:'SignerInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false},{name:'SignerInfo.issuerAndSerialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.issuerAndSerialNumber.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'SignerInfo.issuerAndSerialNumber.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'SignerInfo.digestAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignerInfo.digestAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'digestAlgorithm'},{name:'SignerInfo.digestAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'digestParameter',optional:true}]},{name:'SignerInfo.authenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,constructed:true,optional:true,capture:'authenticatedAttributes'},{name:'SignerInfo.digestEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,capture:'signatureAlgorithm'},{name:'SignerInfo.encryptedDigest',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'signature'},{name:'SignerInfo.unauthenticatedAttributes',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,constructed:true,optional:true,capture:'unauthenticatedAttributes'}]};p7v.signedDataValidator={name:'SignedData',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'SignedData.Version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'SignedData.DigestAlgorithms',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,constructed:true,captureAsn1:'digestAlgorithms'},contentInfoValidator,{name:'SignedData.Certificates',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:0,optional:true,captureAsn1:'certificates'},{name:'SignedData.CertificateRevocationLists',tagClass:asn1.Class.CONTEXT_SPECIFIC,type:1,optional:true,captureAsn1:'crls'},{name:'SignedData.SignerInfos',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SET,capture:'signerInfos',optional:true,value:[signerValidator]}]};p7v.recipientInfoValidator={name:'RecipientInfo',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.version',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'version'},{name:'RecipientInfo.issuerAndSerial',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.issuerAndSerial.issuer',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,captureAsn1:'issuer'},{name:'RecipientInfo.issuerAndSerial.serialNumber',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:false,capture:'serial'}]},{name:'RecipientInfo.keyEncryptionAlgorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:true,value:[{name:'RecipientInfo.keyEncryptionAlgorithm.algorithm',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:false,capture:'encAlgorithm'},{name:'RecipientInfo.keyEncryptionAlgorithm.parameter',tagClass:asn1.Class.UNIVERSAL,constructed:false,captureAsn1:'encParameter'}]},{name:'RecipientInfo.encryptedKey',tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:false,capture:'encKey'}]};/***/},/* 30 */ /***/function(module,exports,__webpack_require__){/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */var forge=__webpack_require__(0);__webpack_require__(31);module.exports=forge.mgf=forge.mgf||{};forge.mgf.mgf1=forge.mgf1;/***/},/* 31 */ /***/function(module,exports,__webpack_require__){/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */var forge=__webpack_require__(0);__webpack_require__(1);forge.mgf=forge.mgf||{};var mgf1=module.exports=forge.mgf.mgf1=forge.mgf1=forge.mgf1||{};/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */mgf1.create=function(md){var mgf={/**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */generate:function generate(seed,maskLen){/* 2. Let T be the empty octet string. */var t=new forge.util.ByteBuffer();/* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */var len=Math.ceil(maskLen/md.digestLength);for(var i=0;i<len;i++){/* a. Convert counter to an octet string C of length 4 octets */var c=new forge.util.ByteBuffer();c.putInt32(i);/* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */md.start();md.update(seed+c.getBytes());t.putBuffer(md.digest());}/* Output the leading maskLen octets of T as the octet string mask. */t.truncate(t.length()-maskLen);return t.getBytes();}};return mgf;};/***/}]));});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zL2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL2NhY2hlQWRhcHRlckVuaGFuY2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy1leHRlbnNpb25zL2VzbS90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zLWV4dGVuc2lvbnMvZXNtL3V0aWxzL2J1aWxkU29ydGVkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MtZXh0ZW5zaW9ucy9lc20vdXRpbHMvaXNDYWNoZUxpa2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2JpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9taWNyb3Rhc2suanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtc3ltYm9sLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXVybC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXJzZS1pbnQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGVyZm9ybS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Byb21pc2UtcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3B1bnljb2RlLXRvLWFzY2lpLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWF0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdGFzay5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9mZnNldC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdHlwZWQtYXJyYXktZnJvbS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5cy1jb25zdHJ1Y3RvcnMtcmVxdWlyZXMtd3JhcHBlcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2VyLWFnZW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdmFsaWRhdGUtc2V0LXByb3RvdHlwZS1vZi1hcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd3JhcHBlZC13ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXktYnVmZmVyLnNsaWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5kYXRhLXZpZXcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc2VhcmNoLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWxsLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbHRlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2UuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnVybC1zZWFyY2gtcGFyYW1zLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9qc2VuY3J5cHQvYmluL2pzZW5jcnlwdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3Byb21pc2Utd2luZG93L2Rpc3QvcHJvbWlzZS13aW5kb3cuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy9wc2V1ZG9tYXAvbWFwLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL3BzZXVkb21hcC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Lyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Lyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2Rpc2NvdXJzZS5qcyIsIndlYnBhY2s6Ly9kaXNjb3Vyc2UtY2xpZW50Ly4vc3JjL2Rpc2NvdXJzZUF1dGguanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9kaXNjb3Vyc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9rZXlHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vZGlzY291cnNlLWNsaWVudC8uL3NyYy9rZXlNYW5hZ2VyLmpzIiwid2VicGFjazovL2Rpc2NvdXJzZS1jbGllbnQvLi9zcmMvdmVuZG9yL2ZvcmdlLXBraS5qcyJdLCJuYW1lcyI6WyJEaXNjb3Vyc2UiLCJvcHRpb25zIiwiX3JlcXVpcmVPcHRpb25zIiwiX2Zvcm1hdE9wdGlvbnMiLCJhdXRoIiwiRGlzY291cnNlQXV0aCIsImNsaWVudCIsIkRpc2NvdXJzZUNsaWVudCIsImFwaUJhc2VVcmwiLCJpbml0IiwiRXJyb3IiLCJhcHBOYW1lIiwibGVuZ3RoIiwic2NvcGVzIiwiQXJyYXkiLCJmb3JtYXR0ZWRPcHRpb25zIiwicmVwbGFjZSIsImpvaW4iLCJpc0xvZ2dlZEluIiwiUHJvbWlzZVdpbmRvdyIsIl9nZXRMb2dpblVybCIsIndpZHRoIiwiaGVpZ2h0Iiwib3JpZ2luUmVnZXhwIiwiUmVnRXhwIiwibG9jYXRpb24iLCJvcmlnaW4iLCJkYXRhIiwiX3NldFVzZXJBcGlLZXkiLCJyZXN1bHQiLCJrZXkiLCJfcmVmcmVzaEN1cnJlbnRVc2VyIiwiZXJyb3IiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJvcGVuIiwidGhlbiIsIl9kb0xvZ291dCIsImdldEN1cnJlbnRVc2VyTmFtZSIsIl9jbGVhckF1dGhEYXRhIiwiX2dldENhbGxSZXN1bHQiLCJfaGFzVXNlckFwaUtleSIsIkpTT04iLCJwYXJzZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJnZXRDdXJyZW50VXNlciIsInNpemUiLCJnZXRDdXJyZW50U2Vzc2lvblVzZXIiLCJzdHJpbmdpZnkiLCJzZXRJdGVtIiwibG9nb3V0IiwiZGVzY2VuZGluZyIsInBvc3RzIiwicmV2ZXJzZSIsImZpbHRlciIsInBvc3QiLCJwb3N0X3R5cGUiLCJ0b3BpY0lkIiwibm9jYWNoZSIsInRvcGljIiwicG9zdF9zdHJlYW0iLCJ1c2VybmFtZSIsImZpZWxkIiwiZ2V0UHVibGljVXNlckZpZWxkcyIsInVzZXJGaWVsZHMiLCJtZXNzYWdlIiwiX2NoZWNrVXNlckFwaUtleSIsIl9wb3N0Q2FsbFJlc3VsdCIsInRvcGljX2lkIiwicmF3IiwicmVzcG9uc2UiLCJoaWRkZW4iLCJQcm9taXNlIiwicmVqZWN0IiwiaGlkZGVuX3JlYXNvbl9pZCIsImVycm9ycyIsInBvc3RJZCIsImlkIiwicG9zdF9hY3Rpb25fdHlwZV9pZCIsImluc3RhbmNlIiwid2luZG93IiwiYXBwSWQiLCJfc2x1Z2lmeSIsImttIiwiS2V5TWFuYWdlciIsImdldEtleXMiLCJfbWFuYWdlUGF5bG9hZCIsImdldFB1YmxpY0tleSIsIl9nZW5lcmF0ZVN0b3JlZFJhbmRvbSIsIl9nZXRTdG9yZWRSYW5kb20iLCJocmVmIiwicGFyYW1zIiwiYXBwbGljYXRpb25fbmFtZSIsInB1YmxpY19rZXkiLCJub25jZSIsImNsaWVudF9pZCIsImF1dGhfcmVkaXJlY3QiLCJfc2VyaWFsaXplUGFyYW1zIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImsiLCJlbmNvZGVVUklDb21wb25lbnQiLCJuYW1lIiwic3RvcmVkUmFuZG9tIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwicmVtb3ZlSXRlbSIsIl9yZW1vdmVTdG9yZWRSYW5kb20iLCJ1cmwiLCJVUkxTZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJoYXNoIiwic3BsaXQiLCJoYXMiLCJvcGVuZXIiLCJkZWNyeXB0UGF5bG9hZCIsImdldCIsInBheWxvYWRPYmplY3QiLCJhcGkiLCJwb3N0TWVzc2FnZSIsInRleHQiLCJ0b0xvd2VyQ2FzZSIsImF4aW9zIiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJhZGFwdGVyIiwiZGVmYXVsdHMiLCJ0aHJlc2hvbGQiLCJlbmRwb2ludCIsInByb3AiLCJmb3JjZVVwZGF0ZSIsInJlZHVjZSIsInJldHVybmVkUmVzcG9uc2UiLCJjdXJyZW50UHJvcCIsInBheWxvYWQiLCJ1c2VyQXBpS2V5IiwiY29tbW9uIiwiX3NldENzcmZUb2tlbiIsImZvcmdlIiwicmVxdWlyZSIsImdlbmVyYXRlIiwicmVzb2x2ZSIsInJzYSIsImdlbmVyYXRlS2V5UGFpciIsIndvcmtlclNjcmlwdCIsImdlbmVyYXRlZEtleXBhaXIiLCJrZXlwYWlyIiwicGtpIiwicHVibGljS2V5VG9QZW0iLCJwdWJsaWNLZXkiLCJwcml2YXRlS2V5VG9QZW0iLCJwcml2YXRlS2V5Iiwia2V5R2VuZXJhdG9yIiwicmVhZEtleXNGcm9tU3RvcmFnZSIsImdlbmVyYXRlTmV3S2V5cGFpciIsImdldFByaXZhdGVLZXkiLCJKc2VuY3J5cHQiLCJqc2VuY3J5cHQiLCJzZXRQcml2YXRlS2V5IiwiZGVjcnlwdCIsIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwic2VsZiIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwiZ2V0dGVyIiwibyIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIm4iLCJfX2VzTW9kdWxlIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJ1c2VQdXJlSmF2YVNjcmlwdCIsImJhc2VOIiwidXRpbCIsInByb2Nlc3MiLCJuZXh0VGljayIsImJyb3dzZXIiLCJzZXRJbW1lZGlhdGUiLCJhcHBseSIsInVuZGVmaW5lZCIsImFyZ3VtZW50cyIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsImhhbmRsZXIiLCJldmVudCIsInNvdXJjZSIsIm1zZyIsInN0b3BQcm9wYWdhdGlvbiIsImNvcHkiLCJjYWxsYmFja3MiLCJzbGljZSIsImZvckVhY2giLCJwdXNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJub3ciLCJEYXRlIiwiYXR0ciIsImRpdiIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwib2xkU2V0SW1tZWRpYXRlIiwic2V0QXR0cmlidXRlIiwiaXNOb2RlanMiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJpc0FycmF5IiwieCIsImlzQXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnVmZmVyIiwiYnl0ZUxlbmd0aCIsIl9jaGVja0JpdHNQYXJhbSIsIkJ5dGVCdWZmZXIiLCJCeXRlU3RyaW5nQnVmZmVyIiwiYiIsInJlYWQiLCJCdWZmZXIiLCJhcnIiLCJVaW50OEFycmF5IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZSIsInB1dEJ5dGUiLCJfY29uc3RydWN0ZWRTdHJpbmdMZW5ndGgiLCJfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgiLCJfb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyIsImlzRW1wdHkiLCJwdXRCeXRlcyIsImZpbGxXaXRoQnl0ZSIsImJ5dGVzIiwicHV0U3RyaW5nIiwic3RyIiwiZW5jb2RlVXRmOCIsInB1dEludDE2IiwicHV0SW50MjQiLCJwdXRJbnQzMiIsInB1dEludDE2TGUiLCJwdXRJbnQyNExlIiwicHV0SW50MzJMZSIsInB1dEludCIsInB1dFNpZ25lZEludCIsInB1dEJ1ZmZlciIsImdldEJ5dGVzIiwiZ2V0Qnl0ZSIsImNoYXJDb2RlQXQiLCJnZXRJbnQxNiIsInJ2YWwiLCJnZXRJbnQyNCIsImdldEludDMyIiwiZ2V0SW50MTZMZSIsImdldEludDI0TGUiLCJnZXRJbnQzMkxlIiwiZ2V0SW50IiwiZ2V0U2lnbmVkSW50IiwibWF4IiwiY291bnQiLCJtaW4iLCJjbGVhciIsImF0Iiwic2V0QXQiLCJsYXN0IiwiY3JlYXRlQnVmZmVyIiwiY29tcGFjdCIsInRydW5jYXRlIiwibGVuIiwidG9IZXgiLCJkZWNvZGVVdGY4IiwiRGF0YUJ1ZmZlciIsInJlYWRPZmZzZXQiLCJncm93U2l6ZSIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsIndyaXRlIiwid3JpdGVPZmZzZXQiLCJhY2NvbW1vZGF0ZSIsImFtb3VudCIsInNyYyIsImRzdCIsInNldCIsInNldFVpbnQ4IiwiZW5jb2RpbmciLCJ2aWV3IiwiY2VpbCIsImJpbmFyeSIsImhleCIsImRlY29kZSIsImJhc2U2NCIsIlVpbnQxNkFycmF5IiwidXRmMTYiLCJlbmNvZGUiLCJzZXRJbnQxNiIsInNldEludDgiLCJzZXRJbnQzMiIsImdldEludDgiLCJnZXRVaW50OCIsInV0ZjgiLCJpbnB1dCIsImZpbGxTdHJpbmciLCJ4b3JCeXRlcyIsInMxIiwiczIiLCJzMyIsInQiLCJoZXhUb0J5dGVzIiwicGFyc2VJbnQiLCJieXRlc1RvSGV4IiwiaW50MzJUb0J5dGVzIiwiX2Jhc2U2NCIsIl9iYXNlNjRJZHgiLCJfYmFzZTU4IiwiZW5jb2RlNjQiLCJtYXhsaW5lIiwibGluZSIsIm91dHB1dCIsImNocjEiLCJjaHIyIiwiY2hyMyIsImNoYXJBdCIsImlzTmFOIiwiZGVjb2RlNjQiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwidW5lc2NhcGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJiYXNlNTgiLCJvZmZzZXQiLCJvdXQiLCJqIiwic3ViYXJyYXkiLCJkZWZsYXRlIiwic3RhcnQiLCJmbGciLCJzdWJzdHJpbmciLCJpbmZsYXRlIiwiX3NldFN0b3JhZ2VPYmplY3QiLCJvYmoiLCJfZ2V0U3RvcmFnZU9iamVjdCIsIl9zZXRJdGVtIiwiX2dldEl0ZW0iLCJfcmVtb3ZlSXRlbSIsImVtcHR5IiwiX2NsZWFySXRlbXMiLCJfY2FsbFN0b3JhZ2VGdW5jdGlvbiIsImZ1bmMiLCJhcmdzIiwidHlwZSIsImRvbmUiLCJleGNlcHRpb24iLCJpZHgiLCJleCIsImNsZWFySXRlbXMiLCJwYXJzZVVybCIsInJlZ2V4IiwibGFzdEluZGV4IiwiZXhlYyIsImZ1bGwiLCJzY2hlbWUiLCJob3N0IiwicG9ydCIsInBhdGgiLCJmdWxsSG9zdCIsIl9xdWVyeVZhcmlhYmxlcyIsImdldFF1ZXJ5VmFyaWFibGVzIiwicXVlcnkiLCJxIiwia3ZwYWlycyIsInBvcyIsImluZGV4T2YiLCJ2YWwiLCJwYXJzZUZyYWdtZW50IiwiZnJhZ21lbnQiLCJmcCIsImZxIiwic2hpZnQiLCJwYXRoU3RyaW5nIiwicXVlcnlTdHJpbmciLCJtYWtlUmVxdWVzdCIsInJlcVN0cmluZyIsImZyYWciLCJyZXEiLCJnZXRQYXRoIiwiZ2V0UXVlcnkiLCJnZXRRdWVyeUxhc3QiLCJfZGVmYXVsdCIsInZhbHMiLCJtYWtlTGluayIsImpRdWVyeSIsInFzdHIiLCJwYXJhbSIsInNldFBhdGgiLCJ2YWx1ZSIsIm5leHQiLCJoYXNOZXh0IiwiZGVsZXRlUGF0aCIsImZvcm1hdCIsInJlIiwibWF0Y2giLCJwYXJ0IiwiYXJnaSIsInBhcnRzIiwiY29kZSIsImZvcm1hdE51bWJlciIsIm51bWJlciIsImRlY2ltYWxzIiwiZGVjX3BvaW50IiwidGhvdXNhbmRzX3NlcCIsImFicyIsInRvRml4ZWQiLCJmb3JtYXRTaXplIiwiYnl0ZXNGcm9tSVAiLCJpcCIsImJ5dGVzRnJvbUlQdjQiLCJieXRlc0Zyb21JUHY2IiwibnVtIiwiYmxhbmtzIiwiemVyb3MiLCJieXRlc1RvSVAiLCJieXRlc1RvSVB2NCIsImJ5dGVzVG9JUHY2IiwiemVyb0dyb3VwcyIsInplcm9NYXhHcm91cCIsImVuZCIsImdyb3VwIiwic3BsaWNlIiwidW5zaGlmdCIsImVzdGltYXRlQ29yZXMiLCJ1cGRhdGUiLCJjb3JlcyIsIm5hdmlnYXRvciIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJXb3JrZXIiLCJCbG9iIiwiYmxvYlVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInN0IiwiZXQiLCJzYW1wbGUiLCJzYW1wbGVzIiwibnVtV29ya2VycyIsImF2ZyIsImZsb29yIiwicmV2b2tlT2JqZWN0VVJMIiwiZXJyIiwicmVzdWx0cyIsIndvcmtlcnMiLCJ3b3JrZXIiLCJ0ZXJtaW5hdGUiLCJvdmVybGFwcyIsInIxIiwib3ZlcmxhcCIsInIyIiwiYXNuMSIsIkNsYXNzIiwiVU5JVkVSU0FMIiwiQVBQTElDQVRJT04iLCJDT05URVhUX1NQRUNJRklDIiwiUFJJVkFURSIsIlR5cGUiLCJOT05FIiwiQk9PTEVBTiIsIklOVEVHRVIiLCJCSVRTVFJJTkciLCJPQ1RFVFNUUklORyIsIk5VTEwiLCJPSUQiLCJPREVTQyIsIkVYVEVSTkFMIiwiUkVBTCIsIkVOVU1FUkFURUQiLCJFTUJFRERFRCIsIlVURjgiLCJST0lEIiwiU0VRVUVOQ0UiLCJTRVQiLCJQUklOVEFCTEVTVFJJTkciLCJJQTVTVFJJTkciLCJVVENUSU1FIiwiR0VORVJBTElaRURUSU1FIiwiQk1QU1RSSU5HIiwidGFnQ2xhc3MiLCJjb25zdHJ1Y3RlZCIsInRtcCIsImNvbXBvc2VkIiwiYml0U3RyaW5nQ29udGVudHMiLCJvcmlnaW5hbCIsImV4Y2x1ZGVCaXRTdHJpbmdDb250ZW50cyIsImVxdWFscyIsIm9iajEiLCJvYmoyIiwiZXF1YWwiLCJpbmNsdWRlQml0U3RyaW5nQ29udGVudHMiLCJnZXRCZXJWYWx1ZUxlbmd0aCIsImIyIiwibG9uZ0Zvcm0iLCJfY2hlY2tCdWZmZXJMZW5ndGgiLCJyZW1haW5pbmciLCJhdmFpbGFibGUiLCJyZXF1ZXN0ZWQiLCJfZ2V0VmFsdWVMZW5ndGgiLCJsb25nRm9ybUJ5dGVzIiwiZnJvbURlciIsInN0cmljdCIsImRlY29kZUJpdFN0cmluZ3MiLCJfZnJvbURlciIsImRlcHRoIiwiYjEiLCJzYXZlZFJlYWQiLCJzYXZlZFJlbWFpbmluZyIsInVudXNlZCIsInN1Yk9wdGlvbnMiLCJ2ZXJib3NlIiwidXNlZCIsInRjIiwiYXNuMU9wdGlvbnMiLCJ0b0RlciIsInVzZUJpdFN0cmluZ0NvbnRlbnRzIiwibGVuQnl0ZXMiLCJvaWRUb0RlciIsIm9pZCIsInZhbHVlcyIsInZhbHVlQnl0ZXMiLCJkZXJUb09pZCIsInV0Y1RpbWVUb0RhdGUiLCJ1dGMiLCJkYXRlIiwieWVhciIsIk1NIiwiREQiLCJoaCIsIm1tIiwic3MiLCJzZXRVVENGdWxsWWVhciIsInNldFVUQ0hvdXJzIiwiaGhvZmZzZXQiLCJtbW9mZnNldCIsInNldFRpbWUiLCJnZW5lcmFsaXplZFRpbWVUb0RhdGUiLCJnZW50aW1lIiwiWVlZWSIsImZmZiIsImlzVVRDIiwicGFyc2VGbG9hdCIsInNldEZ1bGxZZWFyIiwic2V0SG91cnMiLCJkYXRlVG9VdGNUaW1lIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lIiwiaW50ZWdlclRvRGVyIiwiaW50ZWdlciIsImRlclRvSW50ZWdlciIsInZhbGlkYXRlIiwidiIsImNhcHR1cmUiLCJvcHRpb25hbCIsImNhcHR1cmVBc24xIiwiY2FwdHVyZUJpdFN0cmluZ0NvbnRlbnRzIiwiY2FwdHVyZUJpdFN0cmluZ1ZhbHVlIiwiX25vbkxhdGluUmVnZXgiLCJwcmV0dHlQcmludCIsImxldmVsIiwiaW5kZW50YXRpb24iLCJpbmRlbnQiLCJJQTVTdHJpbmciLCJzdWJ2YWx1ZXMiLCJzdWIiLCJvaWRzIiwidGVzdCIsIl9JTiIsIl9JXyIsIm1kIiwiYWxnb3JpdGhtcyIsInBybmdfYWVzIiwiX3BybmdfYWVzX291dHB1dCIsIl9wcm5nX2Flc19idWZmZXIiLCJmb3JtYXRLZXkiLCJhZXMiLCJfZXhwYW5kS2V5IiwiZm9ybWF0U2VlZCIsInNlZWQiLCJjaXBoZXIiLCJfdXBkYXRlQmxvY2siLCJpbmNyZW1lbnQiLCJzaGEyNTYiLCJzcGF3blBybmciLCJjdHgiLCJwcm5nIiwiZ2V0Qnl0ZXNTeW5jIiwiX2N0eCIsImdldFJhbmRvbVZhbHVlcyIsIl9jcnlwdG8iLCJjcnlwdG8iLCJtc0NyeXB0byIsImNvbGxlY3RJbnQiLCJfbmF2Qnl0ZXMiLCJjb2xsZWN0IiwibW91c2Vtb3ZlIiwiY2xpZW50WCIsImNsaWVudFkiLCJrZXlwcmVzcyIsImNoYXJDb2RlIiwiY3JlYXRlSW5zdGFuY2UiLCJCaWdJbnRlZ2VyIiwianNibiIsIkdDRF8zMF9ERUxUQSIsInByaXZhdGVLZXlWYWxpZGF0b3IiLCJyc2FQcml2YXRlS2V5VmFsaWRhdG9yIiwicnNhUHVibGljS2V5VmFsaWRhdG9yIiwicHVibGljS2V5VmFsaWRhdG9yIiwiZW1zYVBrY3MxdjE1ZW5jb2RlIiwiYWxnb3JpdGhtIiwib2lkQnl0ZXMiLCJkaWdlc3RJbmZvIiwiZGlnZXN0QWxnb3JpdGhtIiwiZGlnZXN0IiwiX21vZFBvdyIsInB1YiIsIm1vZFBvdyIsImRQIiwibW9kIiwic3VidHJhY3QiLCJPTkUiLCJkUSIsInFJbnYiLCJtb2RJbnZlcnNlIiwiciIsImJpdExlbmd0aCIsImNvbXBhcmVUbyIsImdjZCIsIm11bHRpcGx5IiwieHAiLCJ4cSIsImFkZCIsInkiLCJlbmNyeXB0IiwiYnQiLCJlYiIsIl9lbmNvZGVQa2NzMV92MV81IiwieWhleCIsImVkIiwibWwiLCJleHBlY3RlZCIsInhoZXgiLCJfZGVjb2RlUGtjczFfdjFfNSIsImNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGUiLCJiaXRzIiwicm5nIiwibmV4dEJ5dGVzIiwic3RhdGUiLCJlSW50IiwicUJpdHMiLCJwQml0cyIsInBxU3RhdGUiLCJmcm9tSW50Iiwic3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUiLCJUSElSVFkiLCJkZWx0YUlkeCIsIm9wX29yIiwidDEiLCJ0MiIsInRvdGFsIiwiYml0czEiLCJ0ZXN0Qml0IiwiYml0d2lzZVRvIiwic2hpZnRMZWZ0IiwiZEFkZE9mZnNldCIsImJ5dGVWYWx1ZSIsImlzUHJvYmFibGVQcmltZSIsIl9nZXRNaWxsZXJSYWJpblRlc3RzIiwicDEiLCJxMSIsInBoaSIsInNldFB1YmxpY0tleSIsIl9kZXRlY3RTdWJ0bGVDcnlwdG8iLCJzdWJ0bGUiLCJnZW5lcmF0ZUtleSIsIm1vZHVsdXNMZW5ndGgiLCJwdWJsaWNFeHBvbmVudCIsIl9pbnRUb1VpbnQ4QXJyYXkiLCJwYWlyIiwiZXhwb3J0S2V5IiwicGtjczgiLCJwcml2YXRlS2V5RnJvbUFzbjEiLCJzZXRSc2FQdWJsaWNLZXkiLCJfZGV0ZWN0U3VidGxlTXNDcnlwdG8iLCJnZW5PcCIsIm9uY29tcGxldGUiLCJ0YXJnZXQiLCJleHBvcnRPcCIsIm9uZXJyb3IiLCJfZ2VuZXJhdGVLZXlQYWlyIiwic2NoZW1lT3B0aW9ucyIsInRvVXBwZXJDYXNlIiwicGtjczEiLCJlbmNvZGVfcnNhX29hZXAiLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJzZXRSc2FQcml2YXRlS2V5IiwiZGVjb2RlX3JzYV9vYWVwIiwic2lnbiIsIndyYXBSc2FQcml2YXRlS2V5IiwicnNhS2V5IiwicnNhRW5jcnlwdGlvbiIsInByaXZhdGVLZXlNb2R1bHVzIiwicHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50IiwicHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCIsInByaXZhdGVLZXlQcmltZTEiLCJwcml2YXRlS2V5UHJpbWUyIiwicHJpdmF0ZUtleUV4cG9uZW50MSIsInByaXZhdGVLZXlFeHBvbmVudDIiLCJwcml2YXRlS2V5Q29lZmZpY2llbnQiLCJwcml2YXRlS2V5VG9Bc24xIiwicHJpdmF0ZUtleVRvUlNBUHJpdmF0ZUtleSIsIl9iblRvQnl0ZXMiLCJwdWJsaWNLZXlGcm9tQXNuMSIsInB1YmxpY0tleU9pZCIsInJzYVB1YmxpY0tleSIsInB1YmxpY0tleU1vZHVsdXMiLCJwdWJsaWNLZXlFeHBvbmVudCIsInB1YmxpY0tleVRvQXNuMSIsInB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8iLCJwdWJsaWNLZXlUb1JTQVB1YmxpY0tleSIsInBhZE51bSIsInBhZEJ5dGUiLCJudW1aZXJvcyIsInBhZEJ5dGVzIiwiZW0iLCJmaXJzdCIsInplcm8iLCJvcHRzIiwid29ya0xvYWQiLCJnZXRQcmltZSIsImZpbmlzaCIsInByaW1lIiwiZ2VuZXJhdGVQcm9iYWJsZVByaW1lIiwiZm4iLCJfcHJpdmF0ZUtleUZyb21Kd2siLCJqd2siLCJrdHkiLCJfYmFzZTY0VG9CaWdJbnQiLCJkcCIsImRxIiwicWkiLCJfcHVibGljS2V5RnJvbUp3ayIsImI2NCIsInN0YXJ0RW5jcnlwdGluZyIsIml2IiwibW9kZSIsIl9jcmVhdGVDaXBoZXIiLCJjcmVhdGVFbmNyeXB0aW9uQ2lwaGVyIiwic3RhcnREZWNyeXB0aW5nIiwiY3JlYXRlRGVjcnlwdGlvbkNpcGhlciIsIkFsZ29yaXRobSIsImluaXRpYWxpemUiLCJibG9ja1NpemUiLCJpbkJsb2NrIiwib3V0QmxvY2siLCJfdyIsIl9pbml0IiwiZW5jcnlwdE9wIiwicmVnaXN0ZXJBbGdvcml0aG0iLCJtb2RlcyIsImVjYiIsImNiYyIsImNmYiIsIm9mYiIsImN0ciIsImdjbSIsIk5iIiwic2JveCIsImlzYm94IiwicmNvbiIsIm1peCIsImltaXgiLCJ4dGltZSIsImVpIiwiZTIiLCJlNCIsImU4Iiwic3giLCJzeDIiLCJtZSIsImltZSIsInciLCJ0ZW1wIiwiaU5rIiwiTmsiLCJOcjEiLCJtMCIsIm0xIiwibTIiLCJtMyIsInduZXciLCJ3aSIsIk5yIiwiYSIsImEyIiwiYzIiLCJyb3VuZCIsImNyZWF0ZURlY2lwaGVyIiwiY3JlYXRlQ2lwaGVyIiwicGVtIiwiaGVhZGVyIiwicHJvY1R5cGUiLCJ2ZXJzaW9uIiwiZm9sZEhlYWRlciIsImNvbnRlbnREb21haW4iLCJkZWtJbmZvIiwicGFyYW1ldGVycyIsImJvZHkiLCJyTWVzc2FnZSIsInJIZWFkZXIiLCJyQ1JMRiIsImxpbmVzIiwibGkiLCJubCIsInZpIiwibHRyaW0iLCJpbnNlcnRTcGFjZSIsIiQxIiwiY2FuZGlkYXRlIiwiaW5zZXJ0IiwicGJlIiwiZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciIsIlBCRVMyQWxnb3JpdGhtc1ZhbGlkYXRvciIsInBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciIsImVuY3J5cHRQcml2YXRlS2V5SW5mbyIsInBhc3N3b3JkIiwic2FsdFNpemUiLCJwcmZBbGdvcml0aG0iLCJzYWx0IiwiY291bnRCeXRlcyIsImRrTGVuIiwiZW5jcnlwdGlvbkFsZ29yaXRobSIsImVuY3J5cHRlZERhdGEiLCJpdkxlbiIsImVuY09pZCIsImNpcGhlckZuIiwiZGVzIiwicHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0IiwiZGsiLCJwa2NzNSIsInBia2RmMiIsImNyZWF0ZVBia2RmMlBhcmFtcyIsInNhbHRCeXRlcyIsImdlbmVyYXRlUGtjczEyS2V5IiwiZGVjcnlwdFByaXZhdGVLZXlJbmZvIiwiZW5jcnlwdGlvbk9pZCIsImdldENpcGhlciIsImVuY3J5cHRpb25QYXJhbXMiLCJlbmNyeXB0ZWQiLCJlbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0iLCJlcGtpIiwiZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0iLCJoZWFkZXJUeXBlIiwiZW5jcnlwdFJzYVByaXZhdGVLZXkiLCJsZWdhY3kiLCJvcGVuc3NsRGVyaXZlQnl0ZXMiLCJkZWNyeXB0UnNhUHJpdmF0ZUtleSIsInJjMiIsIml0ZXIiLCJzaGExIiwidSIsImRpZ2VzdExlbmd0aCIsImJsb2NrTGVuZ3RoIiwicGFzc0J1ZiIsIkQiLCJTbGVuIiwiUyIsIlBsZW4iLCJQIiwiSSIsImJ1ZiIsIkIiLCJJbmV3IiwiY2h1bmsiLCJnZXRDaXBoZXJGb3JQQkVTMiIsImdldENpcGhlckZvclBLQ1MxMlBCRSIsInN1cHBvcnRlZE9pZHMiLCJrZGZPaWQiLCJrZGZTYWx0Iiwia2RmSXRlcmF0aW9uQ291bnQiLCJwcmZPaWRUb01lc3NhZ2VEaWdlc3QiLCJwcmZPaWQiLCJlbmNJdiIsIml0ZXJhdGlvbnMiLCJkSXZMZW4iLCJtZDUiLCJkaWdlc3RzIiwic3VwcG9ydGVkIiwic2hhNTEyIiwiZ2V0QWxnb3JpdGhtIiwiQmxvY2tDaXBoZXIiLCJfZmluaXNoIiwiX2lucHV0IiwiX29wIiwiX2RlY3J5cHQiLCJwYWQiLCJ1bnBhZCIsIm92ZXJmbG93IiwiYWZ0ZXJGaW5pc2giLCJfaW50cyIsIl9pbkJsb2NrIiwiX291dEJsb2NrIiwicGFkZGluZyIsIl9wcmV2IiwiX2l2IiwidHJhbnNmb3JtSVYiLCJfcGFydGlhbEJsb2NrIiwiX3BhcnRpYWxPdXRwdXQiLCJfcGFydGlhbEJ5dGVzIiwiaW5wdXRMZW5ndGgiLCJwYXJ0aWFsQnl0ZXMiLCJpbmMzMiIsIl9SIiwiX2NpcGhlckxlbmd0aCIsImFkZGl0aW9uYWxEYXRhIiwiX3RhZ0xlbmd0aCIsInRhZ0xlbmd0aCIsIl90YWciLCJ0YWciLCJfaGFzaEJsb2NrIiwiX2hhc2hTdWJrZXkiLCJjb21wb25lbnRCaXRzIiwiX20iLCJnZW5lcmF0ZUhhc2hUYWJsZSIsIml2TGVuZ3RoIiwiX2owIiwiZ2hhc2giLCJjb25jYXQiLCJmcm9tNjRUbzMyIiwiX2FEYXRhTGVuZ3RoIiwiX3MiLCJsZW5ndGhzIiwiel9pIiwidl9pIiwieF9pIiwicG93IiwibHNiIiwidGFibGVNdWx0aXBseSIsInoiLCJhaCIsImgiLCJtdWx0aXBsaWVyIiwicGVySW50Iiwic2hmdCIsImdlbmVyYXRlU3ViSGFzaFRhYmxlIiwibWlkIiwiaGFsZiIsIm1faSIsIm1faiIsImJsb2NrIiwiX2tleXMiLCJfY3JlYXRlS2V5cyIsInNwZnVuY3Rpb24xIiwic3BmdW5jdGlvbjIiLCJzcGZ1bmN0aW9uMyIsInNwZnVuY3Rpb240Iiwic3BmdW5jdGlvbjUiLCJzcGZ1bmN0aW9uNiIsInNwZnVuY3Rpb243Iiwic3BmdW5jdGlvbjgiLCJwYzJieXRlczAiLCJwYzJieXRlczEiLCJwYzJieXRlczIiLCJwYzJieXRlczMiLCJwYzJieXRlczQiLCJwYzJieXRlczUiLCJwYzJieXRlczYiLCJwYzJieXRlczciLCJwYzJieXRlczgiLCJwYzJieXRlczkiLCJwYzJieXRlczEwIiwicGMyYnl0ZXMxMSIsInBjMmJ5dGVzMTIiLCJwYzJieXRlczEzIiwic2hpZnRzIiwibGVmdCIsInJpZ2h0IiwibGVmdHRtcCIsInJpZ2h0dG1wIiwibG9vcGluZyIsImVuZGxvb3AiLCJsb29waW5jIiwicmlnaHQxIiwicmlnaHQyIiwicGJrZGYyU3luYyIsImhMZW4iLCJwcmYiLCJobWFjIiwieG9yIiwidV9jIiwidV9jMSIsIm91dGVyIiwiaW5uZXIiLCJfa2V5IiwiX21kIiwiX2lwYWRkaW5nIiwiX29wYWRkaW5nIiwia2V5bGVuIiwiZ2V0TWFjIiwiZGJpdHMiLCJjYW5hcnkiLCJqX2xtIiwiZnJvbU51bWJlciIsImZyb21TdHJpbmciLCJuYmkiLCJhbTEiLCJhbTIiLCJ4bCIsInhoIiwiYW0zIiwiYW0iLCJEQiIsIkRNIiwiRFYiLCJCSV9GUCIsIkZWIiwiRjEiLCJGMiIsIkJJX1JNIiwiQklfUkMiLCJyciIsInZ2IiwiaW50MmNoYXIiLCJpbnRBdCIsImJucENvcHlUbyIsImJucEZyb21JbnQiLCJuYnYiLCJibnBGcm9tU3RyaW5nIiwiZnJvbVJhZGl4IiwibWkiLCJzaCIsImNsYW1wIiwiWkVSTyIsInN1YlRvIiwiYm5wQ2xhbXAiLCJiblRvU3RyaW5nIiwibmVnYXRlIiwidG9SYWRpeCIsImJuTmVnYXRlIiwiYm5BYnMiLCJibkNvbXBhcmVUbyIsIm5iaXRzIiwiYm5CaXRMZW5ndGgiLCJibnBETFNoaWZ0VG8iLCJibnBEUlNoaWZ0VG8iLCJibnBMU2hpZnRUbyIsImJzIiwiY2JzIiwiYm0iLCJkcyIsImJucFJTaGlmdFRvIiwiYm5wU3ViVG8iLCJibnBNdWx0aXBseVRvIiwiYm5wU3F1YXJlVG8iLCJibnBEaXZSZW1UbyIsInBtIiwicHQiLCJjb3B5VG8iLCJ0cyIsIm1zIiwibnNoIiwibFNoaWZ0VG8iLCJ5cyIsInkwIiwieXQiLCJkMSIsImQyIiwiZGxTaGlmdFRvIiwicWQiLCJkclNoaWZ0VG8iLCJyU2hpZnRUbyIsImJuTW9kIiwiZGl2UmVtVG8iLCJDbGFzc2ljIiwiY0NvbnZlcnQiLCJjUmV2ZXJ0IiwiY1JlZHVjZSIsImNNdWxUbyIsIm11bHRpcGx5VG8iLCJjU3FyVG8iLCJzcXVhcmVUbyIsImNvbnZlcnQiLCJyZXZlcnQiLCJtdWxUbyIsInNxclRvIiwiYm5wSW52RGlnaXQiLCJNb250Z29tZXJ5IiwibXAiLCJpbnZEaWdpdCIsIm1wbCIsIm1waCIsInVtIiwibXQyIiwibW9udENvbnZlcnQiLCJtb250UmV2ZXJ0IiwibW9udFJlZHVjZSIsInUwIiwibW9udFNxclRvIiwibW9udE11bFRvIiwiYm5wSXNFdmVuIiwiYm5wRXhwIiwiZyIsImJuTW9kUG93SW50IiwiaXNFdmVuIiwiZXhwIiwibW9kUG93SW50IiwiYm5DbG9uZSIsImJuSW50VmFsdWUiLCJibkJ5dGVWYWx1ZSIsImJuU2hvcnRWYWx1ZSIsImJucENodW5rU2l6ZSIsIkxOMiIsImxvZyIsImJuU2lnTnVtIiwiYm5wVG9SYWRpeCIsInNpZ251bSIsImNzIiwiY2h1bmtTaXplIiwiaW50VmFsdWUiLCJibnBGcm9tUmFkaXgiLCJkTXVsdGlwbHkiLCJibnBGcm9tTnVtYmVyIiwiYm5Ub0J5dGVBcnJheSIsImJuRXF1YWxzIiwiYm5NaW4iLCJibk1heCIsImJucEJpdHdpc2VUbyIsIm9wIiwiZiIsIm9wX2FuZCIsImJuQW5kIiwiYm5PciIsIm9wX3hvciIsImJuWG9yIiwib3BfYW5kbm90IiwiYm5BbmROb3QiLCJibk5vdCIsImJuU2hpZnRMZWZ0IiwiYm5TaGlmdFJpZ2h0IiwibGJpdCIsImJuR2V0TG93ZXN0U2V0Qml0IiwiY2JpdCIsImJuQml0Q291bnQiLCJiblRlc3RCaXQiLCJibnBDaGFuZ2VCaXQiLCJiblNldEJpdCIsImNoYW5nZUJpdCIsImJuQ2xlYXJCaXQiLCJibkZsaXBCaXQiLCJibnBBZGRUbyIsImJuQWRkIiwiYWRkVG8iLCJiblN1YnRyYWN0IiwiYm5NdWx0aXBseSIsImJuRGl2aWRlIiwiYm5SZW1haW5kZXIiLCJibkRpdmlkZUFuZFJlbWFpbmRlciIsImJucERNdWx0aXBseSIsImJucERBZGRPZmZzZXQiLCJOdWxsRXhwIiwibk5vcCIsIm5NdWxUbyIsIm5TcXJUbyIsImJuUG93IiwiYm5wTXVsdGlwbHlMb3dlclRvIiwiYm5wTXVsdGlwbHlVcHBlclRvIiwiQmFycmV0dCIsInEzIiwibXUiLCJkaXZpZGUiLCJiYXJyZXR0Q29udmVydCIsImJhcnJldHRSZXZlcnQiLCJiYXJyZXR0UmVkdWNlIiwibXVsdGlwbHlVcHBlclRvIiwibXVsdGlwbHlMb3dlclRvIiwiYmFycmV0dFNxclRvIiwiYmFycmV0dE11bFRvIiwiYm5Nb2RQb3ciLCJrMSIsImcyIiwiaXMxIiwiYm5HQ0QiLCJjbG9uZSIsImdldExvd2VzdFNldEJpdCIsImJucE1vZEludCIsImJuTW9kSW52ZXJzZSIsImFjIiwibG93cHJpbWVzIiwibHBsaW0iLCJibklzUHJvYmFibGVQcmltZSIsIm1vZEludCIsIm1pbGxlclJhYmluIiwiYm5wTWlsbGVyUmFiaW4iLCJuMSIsInNoaWZ0UmlnaHQiLCJibkdldFBybmciLCJzaG9ydFZhbHVlIiwidG9CeXRlQXJyYXkiLCJhbmQiLCJvciIsImFuZE5vdCIsIm5vdCIsImJpdENvdW50Iiwic2V0Qml0IiwiY2xlYXJCaXQiLCJmbGlwQml0IiwicmVtYWluZGVyIiwiZGl2aWRlQW5kUmVtYWluZGVyIiwiX2luaXRpYWxpemVkIiwiX3N0YXRlIiwibWVzc2FnZUxlbmd0aCIsImZ1bGxNZXNzYWdlTGVuZ3RoIiwibWVzc2FnZUxlbmd0aFNpemUiLCJtZXNzYWdlTGVuZ3RoNjQiLCJpbnQzMnMiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiX3VwZGF0ZSIsImZpbmFsQmxvY2siLCJfcGFkZGluZyIsImNhcnJ5IiwiX3Nob3J0TmFtZXMiLCJ4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IiLCJyc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9WYWxpZGF0b3IiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdFZhbGlkYXRvciIsIlJETkF0dHJpYnV0ZXNBc0FycmF5IiwicmRuIiwic2kiLCJ2YWx1ZVRhZ0NsYXNzIiwic2hvcnROYW1lIiwiQ1JJQXR0cmlidXRlc0FzQXJyYXkiLCJzZXEiLCJleHRlbnNpb25SZXF1ZXN0IiwiZXh0ZW5zaW9ucyIsImNlcnRpZmljYXRlRXh0ZW5zaW9uRnJvbUFzbjEiLCJfZ2V0QXR0cmlidXRlIiwiX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzIiwiZmlsbERlZmF1bHRzIiwiYWxnb3JpdGhtT2lkIiwibWdmIiwic2FsdExlbmd0aCIsImhhc2hPaWQiLCJtYXNrR2VuT2lkIiwibWFza0dlbkhhc2hPaWQiLCJjZXJ0aWZpY2F0ZUZyb21QZW0iLCJjb21wdXRlSGFzaCIsImNlcnRpZmljYXRlRnJvbUFzbjEiLCJjZXJ0aWZpY2F0ZVRvUGVtIiwiY2VydCIsImNlcnRpZmljYXRlVG9Bc24xIiwicHVibGljS2V5RnJvbVBlbSIsInB1YmxpY0tleVRvUlNBUHVibGljS2V5UGVtIiwiZ2V0UHVibGljS2V5RmluZ2VycHJpbnQiLCJkZWxpbWl0ZXIiLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21QZW0iLCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21Bc24xIiwiY2VydGlmaWNhdGlvblJlcXVlc3RUb1BlbSIsImNzciIsImNlcnRpZmljYXRpb25SZXF1ZXN0VG9Bc24xIiwiY3JlYXRlQ2VydGlmaWNhdGUiLCJzZXJpYWxOdW1iZXIiLCJzaWduYXR1cmVPaWQiLCJzaWdpbmZvIiwidmFsaWRpdHkiLCJub3RCZWZvcmUiLCJub3RBZnRlciIsImlzc3VlciIsImdldEZpZWxkIiwic24iLCJhZGRGaWVsZCIsIl9maWxsTWlzc2luZ0ZpZWxkcyIsInN1YmplY3QiLCJzZXRTdWJqZWN0IiwiYXR0cnMiLCJ1bmlxdWVJZCIsInNldElzc3VlciIsInNldEV4dGVuc2lvbnMiLCJleHRzIiwiX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzIiwiZ2V0RXh0ZW5zaW9uIiwiZXh0IiwidGJzQ2VydGlmaWNhdGUiLCJnZXRUQlNDZXJ0aWZpY2F0ZSIsImNoaWxkIiwiaXNzdWVkIiwiZXhwZWN0ZWRJc3N1ZXIiLCJhY3R1YWxJc3N1ZXIiLCJzaGEzODQiLCJzaGExV2l0aFJTQUVuY3J5cHRpb24iLCJzaWduYXR1cmVQYXJhbWV0ZXJzIiwicHNzIiwiaXNJc3N1ZXIiLCJwYXJlbnQiLCJpYXR0ciIsInNhdHRyIiwiZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllciIsInZlcmlmeVN1YmplY3RLZXlJZGVudGlmaWVyIiwic2tpIiwic3ViamVjdEtleUlkZW50aWZpZXIiLCJjZXJ0VmVyc2lvbiIsInNlcmlhbCIsImNlcnRTZXJpYWxOdW1iZXIiLCJjZXJ0U2lnbmF0dXJlT2lkIiwiY2VydFNpZ25hdHVyZVBhcmFtcyIsImNlcnRpbmZvU2lnbmF0dXJlT2lkIiwiY2VydGluZm9TaWduYXR1cmVQYXJhbXMiLCJjZXJ0U2lnbmF0dXJlIiwiY2VydFZhbGlkaXR5MVVUQ1RpbWUiLCJjZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lIiwiY2VydFZhbGlkaXR5M1VUQ1RpbWUiLCJjZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lIiwiaW1kIiwiY2VydElzc3VlciIsImNlcnRJc3N1ZXJVbmlxdWVJZCIsInNtZCIsImNlcnRTdWJqZWN0IiwiY2VydFN1YmplY3RVbmlxdWVJZCIsImNlcnRFeHRlbnNpb25zIiwiY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEiLCJzdWJqZWN0UHVibGljS2V5SW5mbyIsImV4dHNlcSIsImNyaXRpY2FsIiwiZXYiLCJiMyIsImRpZ2l0YWxTaWduYXR1cmUiLCJub25SZXB1ZGlhdGlvbiIsImtleUVuY2lwaGVybWVudCIsImRhdGFFbmNpcGhlcm1lbnQiLCJrZXlBZ3JlZW1lbnQiLCJrZXlDZXJ0U2lnbiIsImNSTFNpZ24iLCJlbmNpcGhlck9ubHkiLCJkZWNpcGhlck9ubHkiLCJjQSIsInBhdGhMZW5Db25zdHJhaW50Iiwic2VydmVyIiwiZW1haWwiLCJvYmpzaWduIiwicmVzZXJ2ZWQiLCJzc2xDQSIsImVtYWlsQ0EiLCJvYmpDQSIsImFsdE5hbWVzIiwiZ24iLCJhbHROYW1lIiwiY3JlYXRlQ2VydGlmaWNhdGlvblJlcXVlc3QiLCJjc3JWZXJzaW9uIiwiY3NyU2lnbmF0dXJlT2lkIiwiY3NyU2lnbmF0dXJlUGFyYW1zIiwiY3NyU2lnbmF0dXJlIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIiwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCIsImdldEF0dHJpYnV0ZSIsImFkZEF0dHJpYnV0ZSIsImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGVzIiwiZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIiwiY3JpIiwiX2RuVG9Bc24xIiwiX2dldEF0dHJpYnV0ZXNBc0pzb24iLCJhdHRyaWJ1dGUiLCJ2YWx1ZUNvbnN0cnVjdGVkIiwiY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEiLCJleHRlbnNpb24iLCJrZXlJZGVudGlmaWVyIiwiYXV0aG9yaXR5Q2VydElzc3VlciIsInN1YlNlcSIsImZ1bGxOYW1lR2VuZXJhbE5hbWVzIiwiX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEiLCJfQ1JJQXR0cmlidXRlc1RvQXNuMSIsImphbl8xXzE5NTAiLCJqYW5fMV8yMDUwIiwiX2RhdGVUb0FzbjEiLCJ0YnMiLCJjZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEiLCJkaXN0aW5ndWlzaGVkTmFtZVRvQXNuMSIsImRuIiwiY3JlYXRlQ2FTdG9yZSIsImNlcnRzIiwiY2FTdG9yZSIsImdldElzc3VlciIsImdldEJ5U3ViamVjdCIsImFkZENlcnRpZmljYXRlIiwiZW5zdXJlU3ViamVjdEhhc0hhc2giLCJoYXNDZXJ0aWZpY2F0ZSIsImRlcjEiLCJkZXIyIiwibGlzdEFsbENlcnRpZmljYXRlcyIsImNlcnRMaXN0IiwicmVtb3ZlQ2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZUVycm9yIiwiYmFkX2NlcnRpZmljYXRlIiwidW5zdXBwb3J0ZWRfY2VydGlmaWNhdGUiLCJjZXJ0aWZpY2F0ZV9yZXZva2VkIiwiY2VydGlmaWNhdGVfZXhwaXJlZCIsImNlcnRpZmljYXRlX3Vua25vd24iLCJ1bmtub3duX2NhIiwidmVyaWZ5Q2VydGlmaWNhdGVDaGFpbiIsImNoYWluIiwic2VsZlNpZ25lZCIsInBhcmVudHMiLCJ2ZXJpZmllZCIsInNlIiwia2V5VXNhZ2UiLCJiYXNpY0NvbnN0cmFpbnRzIiwiYmNFeHQiLCJrZXlVc2FnZUV4dCIsInBhdGhMZW4iLCJ2ZmQiLCJyZXQiLCJzYWx0XyIsInNMZW4iLCJwc3NvYmoiLCJtb2RCaXRzIiwiZW1CaXRzIiwiZW1MZW4iLCJtSGFzaCIsIm1fIiwicHMiLCJkYiIsIm1hc2tMZW4iLCJkYk1hc2siLCJtYXNrZWREQiIsIm1hc2siLCJjaGVja0xlbiIsImhfIiwicGVtVG9EZXIiLCJwcml2YXRlS2V5RnJvbVBlbSIsInByaXZhdGVLZXlJbmZvVG9QZW0iLCJfcmV2ZXJzZUFscGhhYmV0cyIsImFscGhhYmV0IiwiVHlwZUVycm9yIiwiX2VuY29kZVdpdGhCeXRlQnVmZmVyIiwiYmFzZSIsImRpZ2l0cyIsInRhYmxlIiwiZnJvbSIsImg1IiwiaDYiLCJoNyIsIl9rIiwiczAiLCJjaCIsIm1haiIsInBsdWdpbiIsInRpbWUiLCJyZXNlZWRzIiwiZ2VuZXJhdGVkIiwia2V5Qnl0ZXMiLCJwb29scyIsInBvb2wiLCJnZW5lcmF0ZVN5bmMiLCJfcmVzZWVkIiwiX3Jlc2VlZFN5bmMiLCJfc2VlZCIsIm5lZWRlZCIsInNlZWRGaWxlIiwic2VlZEZpbGVTeW5jIiwiXzJwb3dLIiwic2VlZEJ5dGVzIiwiZGVmYXVsdFNlZWRGaWxlIiwiZW50cm9weSIsIlVpbnQzMkFycmF5IiwiUXVvdGFFeGNlZWRlZEVycm9yIiwiaGkiLCJsbyIsInJhbmRvbUJ5dGVzIiwicmVnaXN0ZXJXb3JrZXIiLCJsaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwaVRhYmxlIiwicm9sIiwid29yZCIsInJvciIsImV4cGFuZEtleSIsImVmZktleUJpdHMiLCJMIiwiVCIsIlQxIiwiVDgiLCJUTSIsIl9vdXRwdXQiLCJtaXhSb3VuZCIsIm1hc2hSb3VuZCIsIksiLCJSIiwicnVuUGxhbiIsInBsYW4iLCJwdHIiLCJsYWJlbCIsIm1nZjFNZCIsIm1nZjEiLCJrZXlMZW5ndGgiLCJtYXhMZW5ndGgiLCJsSGFzaCIsIlBTIiwiUFNfbGVuZ3RoIiwic2VlZExlbmd0aCIsInJzYV9tZ2YxIiwic2VlZE1hc2siLCJtYXNrZWRTZWVkIiwiZXhwZWN0ZWRMZW5ndGgiLCJsSGFzaFByaW1lIiwiaW5fcHMiLCJpbmRleCIsImlzXzAiLCJlcnJvcl9tYXNrIiwibWFza0xlbmd0aCIsInByaW1laW5jRmluZFByaW1lIiwicHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyIsInByaW1laW5jRmluZFByaW1lV2l0aG91dFdvcmtlcnMiLCJnZW5lcmF0ZVJhbmRvbSIsIm1yVGVzdHMiLCJnZXRNaWxsZXJSYWJpblRlc3RzIiwibWlsbGVyUmFiaW5UZXN0cyIsIm1heEJsb2NrVGltZSIsIl9wcmltZWluYyIsInJhbmdlIiwicnVubmluZyIsIndvcmtlck1lc3NhZ2UiLCJmb3VuZCIsInAxMiIsInBrY3MxMiIsImNvbnRlbnRJbmZvVmFsaWRhdG9yIiwicGZ4VmFsaWRhdG9yIiwic2FmZUJhZ1ZhbGlkYXRvciIsImF0dHJpYnV0ZVZhbGlkYXRvciIsImNlcnRCYWdWYWxpZGF0b3IiLCJfZ2V0QmFnc0J5QXR0cmlidXRlIiwic2FmZUNvbnRlbnRzIiwiYXR0ck5hbWUiLCJhdHRyVmFsdWUiLCJiYWdUeXBlIiwic2FmZUJhZ3MiLCJiYWciLCJwa2NzMTJGcm9tQXNuMSIsInBmeCIsImdldEJhZ3MiLCJsb2NhbEtleUlkIiwibG9jYWxLZXlJZEhleCIsImZyaWVuZGx5TmFtZSIsImdldEJhZ3NCeUZyaWVuZGx5TmFtZSIsImdldEJhZ3NCeUxvY2FsS2V5SWQiLCJjb250ZW50VHlwZSIsImNvbnRlbnQiLCJfZGVjb2RlUGtjczdEYXRhIiwibWFjIiwibWFjS2V5Qnl0ZXMiLCJtYWNBbGdvcml0aG0iLCJtYWNTYWx0IiwibWFjSXRlcmF0aW9ucyIsIm1hY0tleSIsIm1hY1ZhbHVlIiwibWFjRGlnZXN0IiwiX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlIiwiYXV0aFNhZmUiLCJjb250ZW50SW5mbyIsIl9kZWNyeXB0U2FmZUNvbnRlbnRzIiwiX2RlY29kZVNhZmVDb250ZW50cyIsInBrY3M3IiwiZW5jcnlwdGVkRGF0YVZhbGlkYXRvciIsImVuY0FsZ29yaXRobSIsImVuY1BhcmFtZXRlciIsImVuY3J5cHRlZENvbnRlbnRBc24xIiwicmVzIiwic2FmZUJhZyIsImJhZ0lkIiwiX2RlY29kZUJhZ0F0dHJpYnV0ZXMiLCJiYWdBdHRyaWJ1dGVzIiwidmFsaWRhdG9yIiwiZGVjb2RlciIsImJhZ0FzbjEiLCJiYWdWYWx1ZSIsInBrY3M4U2hyb3VkZWRLZXlCYWciLCJrZXlCYWciLCJjZXJ0QmFnIiwiY2VydElkIiwieDUwOUNlcnRpZmljYXRlIiwiY2VydEFzbjEiLCJkZWNvZGVkQXR0cnMiLCJ0b1BrY3MxMkFzbjEiLCJ1c2VNYWMiLCJnZW5lcmF0ZUxvY2FsS2V5SWQiLCJiYWdBdHRycyIsInBhaXJlZENlcnQiLCJjb250ZW50cyIsImNlcnRTYWZlQmFncyIsImNlcnRCYWdBdHRycyIsImNlcnRTYWZlQmFnIiwiY2VydFNhZmVDb250ZW50cyIsImNlcnRDSSIsInBrQXNuMSIsImtleVNhZmVDb250ZW50cyIsImtleUNJIiwic2FmZSIsIm1hY0RhdGEiLCJwN3YiLCJwa2NzN2FzbjEiLCJlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvciIsImVudmVsb3BlZERhdGFWYWxpZGF0b3IiLCJzaWduZXJWYWxpZGF0b3IiLCJzaWduZWREYXRhVmFsaWRhdG9yIiwicmVjaXBpZW50SW5mb1ZhbGlkYXRvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQVEsb0JBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGtEQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOVNZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFD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QztBQUNwQyxvQkFBb0IsUUFBUTtBQUM1QixDQUFDO0FBQ0Qsd0NBQXdDO0FBQ3hDLG9CQUFvQjtBQUNwQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBbUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFtQjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1CQUFPLENBQUMsNkZBQWdDOztBQUV4QyxtQkFBTyxDQUFDLHVFQUFxQixHQUFHLDREQUE0RDtBQUM1RjtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3orQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BCQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQSxDQUFDLEtBQTREO0FBQzdELENBQUMsU0FDa0M7QUFDbkMsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLEVBQUUsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZLEVBQUUsS0FBSztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVksRUFBRSxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFx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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QyxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNLDhDQUE4QyxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNLDhDQUE4QyxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25kQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMEVBQW9COztBQUUvQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVU7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QUF3RixHQUF4RixDQUE0RixHQUE1RixDQUFnRyxHQUFoRyxDQUFvRyxHQUFwRyxDQUF3RyxHQUF4RyxDQUE0RyxHQUE1RyxDQUFnSCxHQUFoSCxDQUFvSCxHQUFwSCxDQUF3SCxHQUF4SCxDQUE0SCxHQUE1SCxDQUFnSSxHQUFoSSxDQUFvSSxHQUFwSSxDQUF3SSxHQUF4SSxDQUE0SSxHQUE1SSxDQUFnSixHQUFoSixDQUFvSixHQUFwSixDQUF3SixHQUF4SixDQUE0SixHQUE1SixDQUFnSyxHQUFoSyxDQUFvSyxHQUFwSyxDQUF3SyxHQUF4SyxDQUE0SyxHQUE1SyxDQUFnTCxHQUFoTCxDQUFvTCxHQUFwTCxDQUF3TCxHQUF4TCxDQUE0TCxHQUE1TCxDQUFnTSxHQUFoTSxDQUFvTSxHQUFwTSxDQUF3TSxHQUF4TSxDQUE0TSxHQUE1TSxDQUFnTixHQUFoTixDQUFvTixHQUFwTixDQUF3TixHQUF4TixDQUE0TixHQUE1TixDQUFnTyxHQUFoTyxDQUFvTyxHQUFwTyxDQUF3TyxHQUF4TyxDQUE0TyxHQUE1TyxDQUFnUCxHQUFoUCxDQUFvUCxHQUFwUCxDQUF3UCxHQUF4UCxDQUE0UCxHQUE1UCxDQUFnUSxHQUFoUSxDQUFvUSxHQUFwUSxDQUF3USxHQUF4USxDQUE0USxHQUE1USxDQUFnUixHQUFoUixDQUFvUixHQUFwUixDQUF3UixHQUF4UixDQUE0UixHQUE1UixDQUFnUyxHQUFoUyxDQUFvUyxHQUFwUyxDQUF3UyxHQUF4UyxDQUE0UyxHQUE1UyxDQUFnVCxHQUFoVCxDQUFvVCxHQUFwVCxDQUF3VCxHQUF4VCxDQUE0VCxHQUE1VCxDQUFnVSxHQUFoVSxDQUFvVSxHQUFwVSxDQUF3VSxHQUF4VSxDQUE0VSxHQUE1VSxDQUFnVixHQUFoVixDQUFvVixHQUFwVixDQUF3VixHQUF4VixDQUE0VixHQUE1VixDQUFnVyxHQUFoVyxDQUFvVyxHQUFwVyxDQUFoQixDQUNBLEdBQUlDLE1BQUssQ0FBRyxDQUFDLEdBQUcsRUFBSixFQUFRRCxTQUFTLENBQUNBLFNBQVMsQ0FBQy9yQyxNQUFWLENBQWlCLENB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RUFBVCxDQUFhLENBQ3pCLEdBQUltcUIsSUFBRyxDQUFHLENBQ1I7Ozs7OztPQU9BbG5DLFFBQVEsQ0FBRSxrQkFBU3dkLElBQVQsQ0FBZSswQixPQUFmLENBQXdCLENBQ2hDLHlDQUNBLEdBQUk1bUMsRUFBQyxDQUFHLEdBQUk3TCxNQUFLLENBQUN3RCxJQUFOLENBQVcyQyxVQUFmLEVBQVIsQ0FFQSxzRUFDQSxHQUFJb0QsSUFBRyxDQUFHNUwsSUFBSSxDQUFDOE0sSUFBTCxDQUFVZ29DLE9BQU8sQ0FBR3gxQixFQUFFLENBQUNxUyxZQUF2QixDQUFWLENBQ0EsSUFBSSxHQUFJcnRCLEVBQUMsQ0FBRyxDQUFaLENBQWVBLENBQUMsQ0FBR3NILEdBQW5CLENBQXdCdEgsQ0FBQyxFQUF6QixDQUE2QixDQUMzQixnRUFDQSxHQUFJSSxFQUFDLENBQUcsR0FBSXJDLE1BQUssQ0FBQ3dELElBQU4sQ0FBVzJDLFVBQWYsRUFBUixDQUNBOUQsQ0FBQyxDQUFDcUYsUUFBRixDQUFXekYsQ0FBWCxFQUVBO3VCQUVBZ2IsRUFBRSxDQUFDclAsS0FBSCxHQUNBcVAsRUFBRSxDQUFDckosTUFBSCxDQUFVOEosSUFBSSxDQUFHcmIsQ0FBQyxDQUFDNEYsUUFBRixFQUFqQixFQUNBNEQsQ0FBQyxDQUFDN0QsU0FBRixDQUFZaVYsRUFBRSxDQUFDNEMsTUFBSCxFQUFaLEVBQ0QsQ0FFRCxzRUFDQWhVLENBQUMsQ0FBQ3ZDLFFBQUYsQ0FBV3VDLENBQUMsQ0FBQ2hVLE1BQUYsR0FBYTQ2QyxPQUF4QixFQUNBLE1BQU81bUMsRUFBQyxDQUFDNUQsUUFBRixFQUFQLENBQ0QsQ0E3Qk8sQ0FBVixDQWdDQSxNQUFPbS9CLElBQVAsQ0FDRCxDQWxDRCxDQXFDQSxLQUFPLENBOTRtQkcsQ0FqRU0sQ0FBaEIsRUFpOW1CQyxDQTM5bUJELEUiLCJmaWxlIjoiZGlzY291cnNlLWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiZGlzY291cnNlLWNsaWVudFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJkaXNjb3Vyc2UtY2xpZW50XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImRpc2NvdXJzZS1jbGllbnRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0ZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soZGF0YSkge1xuIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuIFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuXG5cbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oZGF0YSk7XG5cbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcbiBcdC8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuIFx0Ly8gUHJvbWlzZSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdFwiZGlzY291cnNlLWNsaWVudC5qc1wiOiAwXG4gXHR9O1xuXG5cblxuIFx0Ly8gc2NyaXB0IHBhdGggZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIGpzb25wU2NyaXB0U3JjKGNodW5rSWQpIHtcbiBcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyAoe31bY2h1bmtJZF18fGNodW5rSWQpICsgXCIuanNcIlxuIFx0fVxuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0Ly8gU2luY2UgYWxsIHJlZmVyZW5jZWQgY2h1bmtzIGFyZSBhbHJlYWR5IGluY2x1ZGVkXG4gXHQvLyBpbiB0aGlzIGZpbGUsIHRoaXMgZnVuY3Rpb24gaXMgZW1wdHkgaGVyZS5cbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoKSB7XG4gXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiBcdH07XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wZGlzY291cnNlX2NsaWVudFwiXSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucGRpc2NvdXJzZV9jbGllbnRcIl0gfHwgW107XG4gXHR2YXIgb2xkSnNvbnBGdW5jdGlvbiA9IGpzb25wQXJyYXkucHVzaC5iaW5kKGpzb25wQXJyYXkpO1xuIFx0anNvbnBBcnJheS5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2s7XG4gXHRqc29ucEFycmF5ID0ganNvbnBBcnJheS5zbGljZSgpO1xuIFx0Zm9yKHZhciBpID0gMDsgaSA8IGpzb25wQXJyYXkubGVuZ3RoOyBpKyspIHdlYnBhY2tKc29ucENhbGxiYWNrKGpzb25wQXJyYXlbaV0pO1xuIFx0dmFyIHBhcmVudEpzb25wRnVuY3Rpb24gPSBvbGRKc29ucEZ1bmN0aW9uO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9kaXNjb3Vyc2UuanNcIik7XG4iLCIvKiEgKGMpIEFuZHJlYSBHaWFtbWFyY2hpIC0gSVNDICovXG52YXIgc2VsZiA9IHRoaXMgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307XG50cnkge1xuICAoZnVuY3Rpb24gKFVSTFNlYXJjaFBhcmFtcywgcGx1cykge1xuICAgIGlmIChcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoJ3E9JTJCJykuZ2V0KCdxJykgIT09IHBsdXMgfHxcbiAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoe3E6IHBsdXN9KS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhbWydxJywgcGx1c11dKS5nZXQoJ3EnKSAhPT0gcGx1cyB8fFxuICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcygncT1cXG4nKS50b1N0cmluZygpICE9PSAncT0lMEEnIHx8XG4gICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHtxOiAnICYnfSkudG9TdHJpbmcoKSAhPT0gJ3E9KyUyNidcbiAgICApXG4gICAgICB0aHJvdyBVUkxTZWFyY2hQYXJhbXM7XG4gICAgc2VsZi5VUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG4gIH0oVVJMU2VhcmNoUGFyYW1zLCAnKycpKTtcbn0gY2F0Y2goVVJMU2VhcmNoUGFyYW1zKSB7XG4gIChmdW5jdGlvbiAoT2JqZWN0LCBTdHJpbmcsIGlzQXJyYXkpIHsndXNlIHN0cmljdCc7XG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBmaW5kID0gL1shJ1xcKFxcKX5dfCUyMHwlMDAvZztcbiAgICB2YXIgcGx1cyA9IC9cXCsvZztcbiAgICB2YXIgcmVwbGFjZSA9IHtcbiAgICAgICchJzogJyUyMScsXG4gICAgICBcIidcIjogJyUyNycsXG4gICAgICAnKCc6ICclMjgnLFxuICAgICAgJyknOiAnJTI5JyxcbiAgICAgICd+JzogJyU3RScsXG4gICAgICAnJTIwJzogJysnLFxuICAgICAgJyUwMCc6ICdcXHgwMCdcbiAgICB9O1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgIGFwcGVuZDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXBwZW5kVG8odGhpcy5fdW5nYXAsIGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldWzBdIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBnZXRBbGw6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl91bmdhcFtrZXldLnNsaWNlKDApIDogW107XG4gICAgICB9LFxuICAgICAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5fdW5nYXA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl91bmdhcFtrZXldID0gW1N0cmluZyh2YWx1ZSldO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzZWxmLl91bmdhcClcbiAgICAgICAgICBzZWxmLl91bmdhcFtrZXldLmZvckVhY2goaW52b2tlLCBrZXkpO1xuICAgICAgICBmdW5jdGlvbiBpbnZva2UodmFsdWUpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBTdHJpbmcoa2V5KSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fdW5nYXApIHtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZShrZXkpO1xuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fdW5nYXBba2V5XTtcbiAgICAgICAgICAgIGkgPCB2YWx1ZS5sZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcXVlcnkucHVzaChlbmNvZGVkICsgJz0nICsgZW5jb2RlKHZhbHVlW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWVyeS5qb2luKCcmJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG8pXG4gICAgICBkZWZpbmVQcm9wZXJ0eShVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHByb3RvW2tleV1cbiAgICAgIH0pO1xuICAgIHNlbGYuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuICAgIGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcyhxdWVyeSkge1xuICAgICAgdmFyIGRpY3QgPSBjcmVhdGUobnVsbCk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3VuZ2FwJywge3ZhbHVlOiBkaWN0fSk7XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAhcXVlcnk6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZW9mIHF1ZXJ5ID09PSAnc3RyaW5nJzpcbiAgICAgICAgICBpZiAocXVlcnkuY2hhckF0KDApID09PSAnPycpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyXG4gICAgICAgICAgICBwYWlycyA9IHF1ZXJ5LnNwbGl0KCcmJyksXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYWlyc1tpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZhbHVlLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGlmICgtMSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKDAsIGluZGV4KSksXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlLnNsaWNlKGluZGV4ICsgMSkpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCl7XG4gICAgICAgICAgICAgIGFwcGVuZFRvKFxuICAgICAgICAgICAgICAgIGRpY3QsXG4gICAgICAgICAgICAgICAgZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpc0FycmF5KHF1ZXJ5KTpcbiAgICAgICAgICBmb3IgKHZhclxuICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcXVlcnlbaV07XG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9yRWFjaCcgaW4gcXVlcnk6XG4gICAgICAgICAgcXVlcnkuZm9yRWFjaChhZGRFYWNoLCBkaWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpXG4gICAgICAgICAgICBhcHBlbmRUbyhkaWN0LCBrZXksIHF1ZXJ5W2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVhY2godmFsdWUsIGtleSkge1xuICAgICAgYXBwZW5kVG8odGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGFwcGVuZFRvKGRpY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywnKSA6IHZhbHVlO1xuICAgICAgaWYgKGtleSBpbiBkaWN0KVxuICAgICAgICBkaWN0W2tleV0ucHVzaChyZXMpO1xuICAgICAgZWxzZVxuICAgICAgICBkaWN0W2tleV0gPSBbcmVzXTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZShwbHVzLCAnICcpKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoZmluZCwgcmVwbGFjZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVttYXRjaF07XG4gICAgfVxuXG4gIH0oT2JqZWN0LCBTdHJpbmcsIEFycmF5LmlzQXJyYXkpKTtcbn1cblxuKGZ1bmN0aW9uIChVUkxTZWFyY2hQYXJhbXNQcm90bykge1xuXG4gIHZhciBpdGVyYWJsZSA9IGZhbHNlO1xuICB0cnkgeyBpdGVyYWJsZSA9ICEhU3ltYm9sLml0ZXJhdG9yOyB9IGNhdGNoIChvX08pIHt9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2ZvckVhY2gnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy50b1N0cmluZygpXG4gICAgICAgICAgLnJlcGxhY2UoLz1bXFxzXFxTXSo/KD86JnwkKS9nLCAnPScpXG4gICAgICAgICAgLnNwbGl0KCc9JylcbiAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKCFuYW1lLmxlbmd0aCB8fCBuYW1lIGluIG5hbWVzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAobmFtZXNbbmFtZV0gPSBzZWxmLmdldEFsbChuYW1lKSkuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCBzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgna2V5cycgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8ua2V5cyA9IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2goa2V5KTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgndmFsdWVzJyBpbiBVUkxTZWFyY2hQYXJhbXNQcm90bykpIHtcbiAgICBVUkxTZWFyY2hQYXJhbXNQcm90by52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3IodGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkgeyB0aGlzLnB1c2godmFsdWUpOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCEoJ2VudHJpZXMnIGluIFVSTFNlYXJjaFBhcmFtc1Byb3RvKSkge1xuICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgdGhpcy5wdXNoKFtrZXksIHZhbHVlXSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXRlcmFibGUgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG9bU3ltYm9sLml0ZXJhdG9yXSA9IFVSTFNlYXJjaFBhcmFtc1Byb3RvLmVudHJpZXM7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoISgnc29ydCcgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG8pKSB7XG4gICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc29ydCA9IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgICB2YXJcbiAgICAgICAgZW50cmllcyA9IHRoaXMuZW50cmllcygpLFxuICAgICAgICBlbnRyeSA9IGVudHJpZXMubmV4dCgpLFxuICAgICAgICBkb25lID0gZW50cnkuZG9uZSxcbiAgICAgICAga2V5cyA9IFtdLFxuICAgICAgICB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICBpLCBrZXksIHZhbHVlXG4gICAgICA7XG4gICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAga2V5ID0gdmFsdWVbMF07XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBpZiAoIShrZXkgaW4gdmFsdWVzKSkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2tleV0ucHVzaCh2YWx1ZVsxXSk7XG4gICAgICAgIGVudHJ5ID0gZW50cmllcy5uZXh0KCk7XG4gICAgICAgIGRvbmUgPSBlbnRyeS5kb25lO1xuICAgICAgfVxuICAgICAgLy8gbm90IHRoZSBjaGFtcGlvbiBpbiBlZmZpY2llbmN5XG4gICAgICAvLyBidXQgdGhlc2UgdHdvIGJpdHMganVzdCBkbyB0aGUgam9iXG4gICAgICBrZXlzLnNvcnQoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGtleXNbaV0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdGhpcy5hcHBlbmQoa2V5LCB2YWx1ZXNba2V5XS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3Ioc2VsZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBzZWxmLmZvckVhY2goY2FsbGJhY2ssIGl0ZW1zKTtcbiAgICByZXR1cm4gaXRlcmFibGUgP1xuICAgICAgaXRlbXNbU3ltYm9sLml0ZXJhdG9yXSgpIDpcbiAgICAgIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICAgIH07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAoZnVuY3Rpb24gKE9iamVjdCkge1xuICAgIHZhclxuICAgICAgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgICBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1BvbGx1dGUgPSBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIFVSTFNlYXJjaFBhcmFtc1Byb3RvLmFwcGVuZC5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVsKG5hbWUpIHtcbiAgICAgICAgICBVUkxTZWFyY2hQYXJhbXNQcm90by5kZWxldGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLl91c3AsIG5hbWUgPyAoJz8nICsgbmFtZSkgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgVVJMU2VhcmNoUGFyYW1zUHJvdG8uc2V0LmNhbGwodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgc2VhcmNoLnNldC5jYWxsKHRoaXMuX3VzcCwgbmFtZSA/ICgnPycgKyBuYW1lKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNwLCB2YWx1ZSkge1xuICAgICAgICAgIHNwLmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgICAgICBzcC5kZWxldGUgPSBkZWw7XG4gICAgICAgICAgc3Auc2V0ID0gc2V0O1xuICAgICAgICAgIHJldHVybiBkUChzcCwgJ191c3AnLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc0NyZWF0ZSA9IGZ1bmN0aW9uIChwb2xsdXRlU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBzcCkge1xuICAgICAgICAgIGRQKFxuICAgICAgICAgICAgb2JqLCAnX3NlYXJjaFBhcmFtcycsIHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHBvbGx1dGVTZWFyY2hQYXJhbXMoc3AsIG9iailcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBzcDtcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAoc3ApIHtcbiAgICAgICAgdmFyIGFwcGVuZCA9IHNwLmFwcGVuZDtcbiAgICAgICAgc3AuYXBwZW5kID0gVVJMU2VhcmNoUGFyYW1zUHJvdG8uYXBwZW5kO1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMuY2FsbChzcCwgc3AuX3VzcC5zZWFyY2guc2xpY2UoMSkpO1xuICAgICAgICBzcC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICB9LFxuICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKG9iaiwgQ2xhc3MpIHtcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQ2xhc3MpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiJ3NlYXJjaFBhcmFtcycgYWNjZXNzZWQgb24gYW4gb2JqZWN0IHRoYXQgXCIgK1xuICAgICAgICAgIFwiZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBcIiArIENsYXNzLm5hbWVcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1cGdyYWRlQ2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgQ2xhc3NQcm90byA9IENsYXNzLnByb3RvdHlwZSxcbiAgICAgICAgICBzZWFyY2hQYXJhbXMgPSBnT1BEKENsYXNzUHJvdG8sICdzZWFyY2hQYXJhbXMnKSxcbiAgICAgICAgICBocmVmID0gZ09QRChDbGFzc1Byb3RvLCAnaHJlZicpLFxuICAgICAgICAgIHNlYXJjaCA9IGdPUEQoQ2xhc3NQcm90bywgJ3NlYXJjaCcpLFxuICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtc1xuICAgICAgICA7XG4gICAgICAgIGlmICghc2VhcmNoUGFyYW1zICYmIHNlYXJjaCAmJiBzZWFyY2guc2V0KSB7XG4gICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zQ3JlYXRlKFxuICAgICAgICAgICAgY3JlYXRlU2VhcmNoUGFyYW1zUG9sbHV0ZShzZWFyY2gpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICAgICAgICAgIENsYXNzUHJvdG8sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhyZWY6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBocmVmLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcCA9IHRoaXMuX3NlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICAgIGhyZWYuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNwKSB1cGRhdGVTZWFyY2hQYXJhbXMoc3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2VhcmNoOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoLmdldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzcCA9IHRoaXMuX3NlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICAgIHNlYXJjaC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoc3ApIHVwZGF0ZVNlYXJjaFBhcmFtcyhzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZlcmlmeVNlYXJjaFBhcmFtcyh0aGlzLCBDbGFzcyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoUGFyYW1zIHx8IGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyh0aGlzLnNlYXJjaC5zbGljZSgxKSlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzcCkge1xuICAgICAgICAgICAgICAgICAgdmVyaWZ5U2VhcmNoUGFyYW1zKHRoaXMsIENsYXNzKTtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVNlYXJjaFBhcmFtcyh0aGlzLCBzcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIDtcbiAgICB0cnkge1xuICAgICAgdXBncmFkZUNsYXNzKEhUTUxBbmNob3JFbGVtZW50KTtcbiAgICAgIGlmICgvXmZ1bmN0aW9ufG9iamVjdCQvLnRlc3QodHlwZW9mIFVSTCkgJiYgVVJMLnByb3RvdHlwZSlcbiAgICAgICAgdXBncmFkZUNsYXNzKFVSTCk7XG4gICAgfSBjYXRjaCAobWVoKSB7fVxuICB9KE9iamVjdCkpO1xuXG59KHNlbGYuVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZSwgT2JqZWN0KSk7XG5leHBvcnQgZGVmYXVsdCBzZWxmLlVSTFNlYXJjaFBhcmFtcztcbiIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMTAtMTJcbiAqL1xuaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCBMUlVDYWNoZSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IGJ1aWxkU29ydGVkVVJMIGZyb20gJy4vdXRpbHMvYnVpbGRTb3J0ZWRVUkwnO1xuaW1wb3J0IGlzQ2FjaGVMaWtlIGZyb20gJy4vdXRpbHMvaXNDYWNoZUxpa2UnO1xudmFyIEZJVkVfTUlOVVRFUyA9IDEwMDAgKiA2MCAqIDU7XG52YXIgQ0FQQUNJVFkgPSAxMDA7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYWNoZUFkYXB0ZXJFbmhhbmNlcihhZGFwdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5hYmxlZEJ5RGVmYXVsdCwgZW5hYmxlZEJ5RGVmYXVsdCA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIF9iID0gb3B0aW9ucy5jYWNoZUZsYWcsIGNhY2hlRmxhZyA9IF9iID09PSB2b2lkIDAgPyAnY2FjaGUnIDogX2IsIF9jID0gb3B0aW9ucy5kZWZhdWx0Q2FjaGUsIGRlZmF1bHRDYWNoZSA9IF9jID09PSB2b2lkIDAgPyBuZXcgTFJVQ2FjaGUoeyBtYXhBZ2U6IEZJVkVfTUlOVVRFUywgbWF4OiBDQVBBQ0lUWSB9KSA6IF9jO1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciB1cmwgPSBjb25maWcudXJsLCBtZXRob2QgPSBjb25maWcubWV0aG9kLCBwYXJhbXMgPSBjb25maWcucGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyID0gY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIsIGZvcmNlVXBkYXRlID0gY29uZmlnLmZvcmNlVXBkYXRlO1xuICAgICAgICB2YXIgdXNlQ2FjaGUgPSAoY29uZmlnW2NhY2hlRmxhZ10gIT09IHZvaWQgMCAmJiBjb25maWdbY2FjaGVGbGFnXSAhPT0gbnVsbCkgPyBjb25maWdbY2FjaGVGbGFnXSA6IGVuYWJsZWRCeURlZmF1bHQ7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdnZXQnICYmIHVzZUNhY2hlKSB7XG4gICAgICAgICAgICAvLyBpZiBoYWQgcHJvdmlkZSBhIHNwZWNpZmllZCBjYWNoZSwgdGhlbiB1c2UgaXQgaW5zdGVhZFxuICAgICAgICAgICAgdmFyIGNhY2hlXzEgPSBpc0NhY2hlTGlrZSh1c2VDYWNoZSkgPyB1c2VDYWNoZSA6IGRlZmF1bHRDYWNoZTtcbiAgICAgICAgICAgIC8vIGJ1aWxkIHRoZSBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIHVybCBhbmQgcGFyYW1zXG4gICAgICAgICAgICB2YXIgaW5kZXhfMSA9IGJ1aWxkU29ydGVkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKTtcbiAgICAgICAgICAgIHZhciByZXNwb25zZVByb21pc2UgPSBjYWNoZV8xLmdldChpbmRleF8xKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VQcm9taXNlIHx8IGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRzbGliXzEuX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhc29uXzE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWRhcHRlcihjb25maWcpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlXzEuZGVsKGluZGV4XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWFzb25fMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBwcm9taXNlIGZvciB0aGUgbm9uLXRyYW5zZm9ybWVkIHJlc3BvbnNlIGludG8gY2FjaGUgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIGNhY2hlXzEuc2V0KGluZGV4XzEsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTE9HR0VSX0xFVkVMID09PSAnaW5mbycpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInJlcXVlc3QgY2FjaGVkIGJ5IGNhY2hlIGFkYXB0ZXI6IFwiICsgaW5kZXhfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGFwdGVyKGNvbmZpZyk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlQWRhcHRlckVuaGFuY2VyLmpzLm1hcCIsIi8qKlxuICogQGF1dGhvciBLdWl0b3NcbiAqIEBob21lcGFnZSBodHRwczovL2dpdGh1Yi5jb20va3VpdG9zL1xuICogQHNpbmNlIDIwMTctMDktMjhcbiAqL1xuaW1wb3J0IENhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgY2FjaGVBZGFwdGVyRW5oYW5jZXIgZnJvbSAnLi9jYWNoZUFkYXB0ZXJFbmhhbmNlcic7XG5pbXBvcnQgdGhyb3R0bGVBZGFwdGVyRW5oYW5jZXIgZnJvbSAnLi90aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcic7XG5leHBvcnQgeyBDYWNoZSwgY2FjaGVBZGFwdGVyRW5oYW5jZXIsIHRocm90dGxlQWRhcHRlckVuaGFuY2VyLCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxNy0xMC0xMVxuICovXG5pbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJ2xydS1jYWNoZSc7XG5pbXBvcnQgYnVpbGRTb3J0ZWRVUkwgZnJvbSAnLi91dGlscy9idWlsZFNvcnRlZFVSTCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcihhZGFwdGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMudGhyZXNob2xkLCB0aHJlc2hvbGQgPSBfYSA9PT0gdm9pZCAwID8gMTAwMCA6IF9hLCBfYiA9IG9wdGlvbnMuY2FjaGUsIGNhY2hlID0gX2IgPT09IHZvaWQgMCA/IG5ldyBMUlVDYWNoZSh7IG1heDogMTAgfSkgOiBfYjtcbiAgICB2YXIgcmVjb3JkQ2FjaGVXaXRoUmVxdWVzdCA9IGZ1bmN0aW9uIChpbmRleCwgY29uZmlnKSB7XG4gICAgICAgIHZhciByZXNwb25zZVByb21pc2UgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UsIHJlYXNvbl8xO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgYWRhcHRlcihjb25maWcpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQoaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFByb21pc2UucmVzb2x2ZShyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGVsKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlYXNvbl8xO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IH0pKCk7XG4gICAgICAgIGNhY2hlLnNldChpbmRleCwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdmFsdWU6IHJlc3BvbnNlUHJvbWlzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB2YXIgdXJsID0gY29uZmlnLnVybCwgbWV0aG9kID0gY29uZmlnLm1ldGhvZCwgcGFyYW1zID0gY29uZmlnLnBhcmFtcywgcGFyYW1zU2VyaWFsaXplciA9IGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyO1xuICAgICAgICB2YXIgaW5kZXggPSBidWlsZFNvcnRlZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcik7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY2FjaGVkUmVjb3JkID0gY2FjaGUuZ2V0KGluZGV4KSB8fCB7IHRpbWVzdGFtcDogbm93IH07XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICBpZiAobm93IC0gY2FjaGVkUmVjb3JkLnRpbWVzdGFtcCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VQcm9taXNlID0gY2FjaGVkUmVjb3JkLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxPR0dFUl9MRVZFTCA9PT0gJ2luZm8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicmVxdWVzdCBjYWNoZWQgYnkgdGhyb3R0bGUgYWRhcHRlcjogXCIgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkQ2FjaGVXaXRoUmVxdWVzdChpbmRleCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRhcHRlcihjb25maWcpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZUFkYXB0ZXJFbmhhbmNlci5qcy5tYXAiLCIvKipcbiAqIEBhdXRob3IgS3VpdG9zXG4gKiBAaG9tZXBhZ2UgaHR0cHM6Ly9naXRodWIuY29tL2t1aXRvcy9cbiAqIEBzaW5jZSAyMDE3LTEwLTEyXG4gKi9cbmltcG9ydCBidWlsZFVSTCBmcm9tICdheGlvcy9saWIvaGVscGVycy9idWlsZFVSTCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZFNvcnRlZFVSTCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGJ1aWx0VVJMID0gYnVpbGRVUkwuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB2YXIgX2EgPSBidWlsdFVSTC5zcGxpdCgnPycpLCB1cmxQYXRoID0gX2FbMF0sIHF1ZXJ5U3RyaW5nID0gX2FbMV07XG4gICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHZhciBwYXJhbXNQYWlyID0gcXVlcnlTdHJpbmcuc3BsaXQoJyYnKTtcbiAgICAgICAgcmV0dXJuIHVybFBhdGggKyBcIj9cIiArIHBhcmFtc1BhaXIuc29ydCgpLmpvaW4oJyYnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0VVJMO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRTb3J0ZWRVUkwuanMubWFwIiwiLyoqXG4gKiBAYXV0aG9yIEt1aXRvc1xuICogQGhvbWVwYWdlIGh0dHBzOi8vZ2l0aHViLmNvbS9rdWl0b3MvXG4gKiBAc2luY2UgMjAxOC0wMy0xOVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0NhY2hlTGlrZShjYWNoZSkge1xuICAgIHJldHVybiAhIShjYWNoZS5zZXQgJiYgY2FjaGUuZ2V0ICYmIGNhY2hlLmRlbCAmJlxuICAgICAgICB0eXBlb2YgY2FjaGUuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYWNoZS5zZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNhY2hlLmRlbCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0NhY2hlTGlrZS5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSB1dGlscy5tZXJnZSh7XG4gICAgICB1cmw6IGFyZ3VtZW50c1swXVxuICAgIH0sIGFyZ3VtZW50c1sxXSk7XG4gIH1cblxuICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywge21ldGhvZDogJ2dldCd9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgfSxcblxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgndW5zY29wYWJsZXMnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkge1xuICBoaWRlKEFycmF5UHJvdG90eXBlLCBVTlNDT1BBQkxFUywgY3JlYXRlKG51bGwpKTtcbn1cblxuLy8gYWRkIGEga2V5IHRvIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY29kZVBvaW50QXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLWF0Jyk7XG5cbi8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGNvZGVQb2ludEF0KFMsIGluZGV4LCB0cnVlKS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCd0b1N0cmluZ1RhZycpO1xudmFyIFRZUEVEX0FSUkFZX1RBRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKSgnVFlQRURfQVJSQVlfVEFHJyk7XG5cbnZhciBEYXRhVmlldyA9IGdsb2JhbC5EYXRhVmlldztcbnZhciBEYXRhVmlld1Byb3RvdHlwZSA9IERhdGFWaWV3ICYmIERhdGFWaWV3LnByb3RvdHlwZTtcbnZhciBJbnQ4QXJyYXkgPSBnbG9iYWwuSW50OEFycmF5O1xudmFyIEludDhBcnJheVByb3RvdHlwZSA9IEludDhBcnJheSAmJiBJbnQ4QXJyYXkucHJvdG90eXBlO1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5ID0gZ2xvYmFsLlVpbnQ4Q2xhbXBlZEFycmF5O1xudmFyIFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlID0gVWludDhDbGFtcGVkQXJyYXkgJiYgVWludDhDbGFtcGVkQXJyYXkucHJvdG90eXBlO1xudmFyIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoSW50OEFycmF5KTtcbnZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5UHJvdG90eXBlICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheVByb3RvdHlwZSk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBpc1Byb3RvdHlwZU9mID0gT2JqZWN0UHJvdG90eXBlLmlzUHJvdG90eXBlT2Y7XG5cbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldyk7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IE5BVElWRV9BUlJBWV9CVUZGRVIgJiYgISFzZXRQcm90b3R5cGVPZjtcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IGZhbHNlO1xudmFyIE5BTUU7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiAgSW50OEFycmF5OiAxLFxuICBVaW50OEFycmF5OiAxLFxuICBVaW50OENsYW1wZWRBcnJheTogMSxcbiAgSW50MTZBcnJheTogMixcbiAgVWludDE2QXJyYXk6IDIsXG4gIEludDMyQXJyYXk6IDQsXG4gIFVpbnQzMkFycmF5OiA0LFxuICBGbG9hdDMyQXJyYXk6IDQsXG4gIEZsb2F0NjRBcnJheTogOFxufTtcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuICB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnIHx8IGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGlzVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwgY2xhc3NvZihpdCkpO1xufTtcblxudmFyIGFUeXBlZEFycmF5ID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1R5cGVkQXJyYXkoaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5Jyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgIGlmIChpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheSwgQykpIHJldHVybiBDO1xuICB9IGVsc2UgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIE5BTUUpKSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoQyA9PT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yIHx8IGlzUHJvdG90eXBlT2YuY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIEMpKSkge1xuICAgICAgcmV0dXJuIEM7XG4gICAgfVxuICB9IHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XG59O1xuXG52YXIgZXhwb3J0UHJvdG8gPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKGZvcmNlZCkgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB7XG4gICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldO1xuICAgIH1cbiAgfVxuICBpZiAoIVR5cGVkQXJyYXlQcm90b3R5cGVbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICByZWRlZmluZShUeXBlZEFycmF5UHJvdG90eXBlLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5UHJvdG90eXBlW0tFWV0gfHwgcHJvcGVydHkpO1xuICB9XG59O1xuXG52YXIgZXhwb3J0U3RhdGljID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICB2YXIgQVJSQVksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbiAgaWYgKCFERVNDUklQVE9SUykgcmV0dXJuO1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICBpZiAoZm9yY2VkKSBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB7XG4gICAgICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFUeXBlZEFycmF5W0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgICAvLyBWOCB+IENocm9tZSA0OS01MCBgJVR5cGVkQXJyYXklYCBtZXRob2RzIGFyZSBub24td3JpdGFibGUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlZGVmaW5lKFR5cGVkQXJyYXksIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVtLRVldIHx8IHByb3BlcnR5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG4gIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKCFUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXSB8fCBmb3JjZWQpKSB7XG4gICAgICByZWRlZmluZShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEtFWSwgcHJvcGVydHkpO1xuICAgIH1cbiAgfVxufTtcblxuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gIGlmICghZ2xvYmFsW05BTUVdKSBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gZmFsc2U7XG59XG5cbi8vIFdlYktpdCBidWcgLSB0eXBlZCBhcnJheXMgY29uc3RydWN0b3JzIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgdHlwZW9mIFR5cGVkQXJyYXkgIT0gJ2Z1bmN0aW9uJyB8fCBUeXBlZEFycmF5ID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBUeXBlZEFycmF5ID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICBpZiAoZ2xvYmFsW05BTUVdKSBzZXRQcm90b3R5cGVPZihnbG9iYWxbTkFNRV0sIFR5cGVkQXJyYXkpO1xuICB9XG59XG5cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSB8fCBUeXBlZEFycmF5UHJvdG90eXBlID09PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbFtOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsW05BTUVdLnByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSk7XG4gIH1cbn1cblxuLy8gV2ViS2l0IGJ1ZyAtIG9uZSBtb3JlIG9iamVjdCBpbiBVaW50OENsYW1wZWRBcnJheSBwcm90b3R5cGUgY2hhaW5cbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlKSAhPT0gVHlwZWRBcnJheVByb3RvdHlwZSkge1xuICBzZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSk7XG59XG5cbmlmIChERVNDUklQVE9SUyAmJiAhaGFzKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gIFRZUEVEX0FSUkFZX1RBR19SRVFJUkVEID0gdHJ1ZTtcbiAgZGVmaW5lUHJvcGVydHkoVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodGhpcykgPyB0aGlzW1RZUEVEX0FSUkFZX1RBR10gOiB1bmRlZmluZWQ7XG4gIH0gfSk7XG4gIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkgaWYgKGdsb2JhbFtOQU1FXSkge1xuICAgIGhpZGUoZ2xvYmFsW05BTUVdLCBUWVBFRF9BUlJBWV9UQUcsIE5BTUUpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSB0aGUgc2FtZSBwYXJlbnQgcHJvdG90eXBlIGZvciB0eXBlZCBhcnJheXMgYW5kIGRhdGEgdmlld1xuaWYgKE5BVElWRV9BUlJBWV9CVUZGRVIgJiYgc2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUpICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgc2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUsIE9iamVjdFByb3RvdHlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBOQVRJVkVfQVJSQVlfQlVGRkVSOiBOQVRJVkVfQVJSQVlfQlVGRkVSLFxuICBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLFxuICBUWVBFRF9BUlJBWV9UQUc6IFRZUEVEX0FSUkFZX1RBR19SRVFJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyxcbiAgYVR5cGVkQXJyYXk6IGFUeXBlZEFycmF5LFxuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yOiBhVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBleHBvcnRQcm90bzogZXhwb3J0UHJvdG8sXG4gIGV4cG9ydFN0YXRpYzogZXhwb3J0U3RhdGljLFxuICBpc1ZpZXc6IGlzVmlldyxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG4gIFR5cGVkQXJyYXk6IFR5cGVkQXJyYXksXG4gIFR5cGVkQXJyYXlQcm90b3R5cGU6IFR5cGVkQXJyYXlQcm90b3R5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJykuTkFUSVZFX0FSUkFZX0JVRkZFUjtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXgnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBhcnJheUZpbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZmlsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGgnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4JztcbnZhciBOYXRpdmVBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICRBcnJheUJ1ZmZlciA9IE5hdGl2ZUFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IDEgLyAwO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciBwYWNrSUVFRTc1NCA9IGZ1bmN0aW9uIChudW1iZXIsIG1hbnRpc3NhTGVuZ3RoLCBieXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGJ5dGVzKTtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbWFudGlzc2FMZW5ndGggPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBzaWduID0gbnVtYmVyIDwgMCB8fCBudW1iZXIgPT09IDAgJiYgMSAvIG51bWJlciA8IDAgPyAxIDogMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgYztcbiAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKG51bWJlciAhPSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtYW50aXNzYSA9IG51bWJlciAhPSBudW1iZXIgPyAxIDogMDtcbiAgICBleHBvbmVudCA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZXhwb25lbnQgPSBmbG9vcihsb2cobnVtYmVyKSAvIExOMik7XG4gICAgaWYgKG51bWJlciAqIChjID0gcG93KDIsIC1leHBvbmVudCkpIDwgMSkge1xuICAgICAgZXhwb25lbnQtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbnVtYmVyICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmIChudW1iZXIgKiBjID49IDIpIHtcbiAgICAgIGV4cG9uZW50Kys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG1hbnRpc3NhID0gMDtcbiAgICAgIGV4cG9uZW50ID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbWFudGlzc2EgPSAobnVtYmVyICogYyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWFudGlzc2EgPSBudW1iZXIgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtYW50aXNzYUxlbmd0aCA+PSA4OyBidWZmZXJbaW5kZXgrK10gPSBtYW50aXNzYSAmIDI1NSwgbWFudGlzc2EgLz0gMjU2LCBtYW50aXNzYUxlbmd0aCAtPSA4KTtcbiAgZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50aXNzYUxlbmd0aCB8IG1hbnRpc3NhO1xuICBleHBvbmVudExlbmd0aCArPSBtYW50aXNzYUxlbmd0aDtcbiAgZm9yICg7IGV4cG9uZW50TGVuZ3RoID4gMDsgYnVmZmVyW2luZGV4KytdID0gZXhwb25lbnQgJiAyNTUsIGV4cG9uZW50IC89IDI1NiwgZXhwb25lbnRMZW5ndGggLT0gOCk7XG4gIGJ1ZmZlclstLWluZGV4XSB8PSBzaWduICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxudmFyIHVucGFja0lFRUU3NTQgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYW50aXNzYUxlbmd0aCkge1xuICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBleHBvbmVudExlbmd0aCAtIDc7XG4gIHZhciBpbmRleCA9IGJ5dGVzIC0gMTtcbiAgdmFyIHNpZ24gPSBidWZmZXJbaW5kZXgtLV07XG4gIHZhciBleHBvbmVudCA9IHNpZ24gJiAxMjc7XG4gIHZhciBtYW50aXNzYTtcbiAgc2lnbiA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZXhwb25lbnQgPSBleHBvbmVudCAqIDI1NiArIGJ1ZmZlcltpbmRleF0sIGluZGV4LS0sIG5CaXRzIC09IDgpO1xuICBtYW50aXNzYSA9IGV4cG9uZW50ICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGV4cG9uZW50ID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1hbnRpc3NhTGVuZ3RoO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtYW50aXNzYSA9IG1hbnRpc3NhICogMjU2ICsgYnVmZmVyW2luZGV4XSwgaW5kZXgtLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgIGV4cG9uZW50ID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGV4cG9uZW50ID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG1hbnRpc3NhID8gTmFOIDogc2lnbiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSBlQmlhcztcbiAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG59O1xuXG52YXIgdW5wYWNrSW50MzIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXJbM10gPDwgMjQgfCBidWZmZXJbMl0gPDwgMTYgfCBidWZmZXJbMV0gPDwgOCB8IGJ1ZmZlclswXTtcbn07XG5cbnZhciBwYWNrSW50OCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MTYgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGLCBudW1iZXIgPj4gMTYgJiAweEZGLCBudW1iZXIgPj4gMjQgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrRmxvYXQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgMjMsIDQpO1xufTtcblxudmFyIHBhY2tGbG9hdDY0ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCA1MiwgOCk7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBrZXkpIHtcbiAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3JbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldOyB9IH0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUoc3RvcmUuYnVmZmVyKS5ieXRlcztcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyBzdG9yZS5ieXRlT2Zmc2V0O1xuICB2YXIgcGFjayA9IGJ5dGVzLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcblxudmFyIHNldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgYnl0ZXNbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogY291bnQgLSBpIC0gMV07XG59O1xuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVIpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBieXRlczogYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKSxcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGhcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUoYnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCAnYnl0ZU9mZnNldCcpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSW50MzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzKTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyKTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRJbnQzMjogZnVuY3Rpb24gc2V0SW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGbG9hdDMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRmxvYXQ2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gTmF0aXZlQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUgPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IE5hdGl2ZUFycmF5QnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlQXJyYXlCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgQXJyYXlCdWZmZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB0ZXN0VmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciBuYXRpdmVTZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdGVzdFZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgbmF0aXZlU2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgbmF0aXZlU2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29weXdpdGhpblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0IC8qID0gMCAqLywgc3RhcnQgLyogPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciB0byA9IHRvQWJzb2x1dGVJbmRleCh0YXJnZXQsIGxlbik7XG4gIHZhciBmcm9tID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuICB2YXIgaW5jID0gMTtcbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBuYXRpdmVGb3JFYWNoID0gW10uZm9yRWFjaDtcbnZhciBpbnRlcm5hbEZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDApO1xuXG52YXIgU0xPUFBZX01FVEhPRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJykoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5tb2R1bGUuZXhwb3J0cyA9IFNMT1BQWV9NRVRIT0QgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiBpbnRlcm5hbEZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbn0gOiBuYXRpdmVGb3JFYWNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZycpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LmZyb21cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KGFycmF5TGlrZSk7XG4gIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gIHZhciBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gIGlmIChtYXBwaW5nKSBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAvLyBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBpdGVyYWJsZSBvciBpdCdzIGFuIGFycmF5IHdpdGggdGhlIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2UgYSBzaW1wbGUgY2FzZVxuICBpZiAoaXRlcmF0b3JNZXRob2QgIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JNZXRob2QuY2FsbChPKTtcbiAgICByZXN1bHQgPSBuZXcgQygpO1xuICAgIGZvciAoOyEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZ1xuICAgICAgICA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKVxuICAgICAgICA6IHN0ZXAudmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICByZXN1bHQgPSBuZXcgQyhsZW5ndGgpO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIG5hdGl2ZUxhc3RJbmRleE9mID0gW10ubGFzdEluZGV4T2Y7XG5cbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVMYXN0SW5kZXhPZiAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG52YXIgU0xPUFBZX01FVEhPRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJykoJ2xhc3RJbmRleE9mJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2ZgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmxhc3RpbmRleG9mXG5tb2R1bGUuZXhwb3J0cyA9IChORUdBVElWRV9aRVJPIHx8IFNMT1BQWV9NRVRIT0QpID8gZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IEBbKi0xXSAqLykge1xuICAvLyBjb252ZXJ0IC0wIHRvICswXG4gIGlmIChORUdBVElWRV9aRVJPKSByZXR1cm4gbmF0aXZlTGFzdEluZGV4T2YuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gIGlmIChpbmRleCA8IDApIGluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gIGZvciAoO2luZGV4ID49IDA7IGluZGV4LS0pIGlmIChpbmRleCBpbiBPKSBpZiAoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICByZXR1cm4gLTE7XG59IDogbmF0aXZlTGFzdEluZGV4T2Y7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsInZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0KSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gICAgdmFyIHNlbGYgPSBJbmRleGVkT2JqZWN0KE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHRhcmdldC5wdXNoKHZhbHVlKTsgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgcmVkdWNlLCByZWR1Y2VSaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbywgaXNSaWdodCkge1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPID0gdG9PYmplY3QodGhhdCk7XG4gIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwO1xuICB2YXIgaSA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYgKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgfVxuICBmb3IgKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKSBpZiAoaW5kZXggaW4gc2VsZikge1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3NwZWNpZXMnKTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBuZXcgKEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQykobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCk7XG4gICAgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXR1cm5NZXRob2QuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuIiwidmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShpdGVyYXRvcldpdGhSZXR1cm4sIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IElURVJBVElPTl9TVVBQT1JUID0gdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgZXhlYyhvYmplY3QpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG4iLCJ2YXIgY2xhc3NvZlJhdyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMtY29yZScpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBoaWRlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgICAgaWYgKElTX1BVUkUpIEl0ZXJhdG9yc1tUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gdHJ1ZTtcbiAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpOyB9O1xuICB9XG5cbiAgLy8gZGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUlTX1BVUkUgfHwgRk9SQ0VEKSAmJiBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGhpZGUoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IpO1xuICB9XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgcmVkZWZpbmUoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJGV4cG9ydCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd3JhcHBlZC13ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgZXhpc3QgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBleGlzdCA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIiwiLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG4iLCIvLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcbiIsInZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xuXG4vLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdEtleXMoaXQpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhpdCk7XG4gICAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGhpZGUoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICByZWRlZmluZSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYywgc2hhbSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgIH1cblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcbiAgICB2YXIgc3RyaW5nTWV0aG9kID0gbWV0aG9kc1swXTtcbiAgICB2YXIgcmVnZXhNZXRob2QgPSBtZXRob2RzWzFdO1xuXG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJpbmdNZXRob2QpO1xuICAgIHJlZGVmaW5lKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcmVnZXhNZXRob2QuY2FsbChzdHJpbmcsIHRoaXMsIGFyZyk7IH1cbiAgICAgIC8vIDIxLjIuNS42IFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF0oc3RyaW5nKVxuICAgICAgLy8gMjEuMi41LjkgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF0oc3RyaW5nKVxuICAgICAgOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICAgIGlmIChzaGFtKSBoaWRlKFJlZ0V4cC5wcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpKCduYXRpdmUtZnVuY3Rpb24tdG8tc3RyaW5nJywgRnVuY3Rpb24udG9TdHJpbmcpO1xuIiwidmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSlcbiAgICA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvck1ldGhvZCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICB9IHJldHVybiBhbk9iamVjdChpdGVyYXRvck1ldGhvZC5jYWxsKGl0KSk7XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgd2luZG93Lk1hdGggPT0gTWF0aCA/IHdpbmRvd1xuICA6IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY29uc29sZS5lcnJvcihhKSA6IGNvbnNvbGUuZXJyb3IoYSwgYik7XG4gIH1cbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKSgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgdGFyZ2V0LCBDKSB7XG4gIHZhciBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICB2YXIgUDtcbiAgaWYgKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2YpIHtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG4iLCJ2YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIG9iamVjdEhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBXZWFrTWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQKSB7XG4gIHZhciBzdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaGlkZShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjbGFzc29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIE1BVENIID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZycpO1xudmFyIEJSRUFLID0ge307XG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGZuLCB0aGF0LCBFTlRSSUVTLCBJVEVSQVRPUikge1xuICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoZm4sIHRoYXQsIEVOVFJJRVMgPyAyIDogMSk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIHN0ZXA7XG5cbiAgaWYgKElURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBFTlRSSUVTID8gYm91bmRGdW5jdGlvbihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IEJSRUFLKSByZXR1cm4gQlJFQUs7XG4gICAgICB9IHJldHVybjtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG4gIH1cblxuICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgaWYgKGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIGJvdW5kRnVuY3Rpb24sIHN0ZXAudmFsdWUsIEVOVFJJRVMpID09PSBCUkVBSykgcmV0dXJuIEJSRUFLO1xuICB9XG59O1xuXG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2VyLWFnZW50Jyk7XG52YXIgTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgSVNfTk9ERSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuLy8gTm9kZS5qcyAxMSBzaG93cyBFeHBlcmltZW50YWxXYXJuaW5nIG9uIGdldHRpbmcgYHF1ZXVlTWljcm90YXNrYFxudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcblxudmFyIGZsdXNoLCBoZWFkLCBsYXN0LCBub3RpZnksIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZTtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoaGVhZCkgbm90aWZ5KCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIE5vZGUuanNcbiAgaWYgKElTX05PREUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoTXV0YXRpb25PYnNlcnZlciAmJiAhLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICB0b2dnbGUgPSB0cnVlO1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmIChQcm9taXNlICYmIFByb21pc2UucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkoKTtcbiAgfSBsYXN0ID0gdGFzaztcbn07XG4iLCIvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG4iLCJ2YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgdXJsID0gbmV3IFVSTCgnYj9lPTEnLCAnaHR0cDovL2EnKTtcbiAgdmFyIHNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gIHVybC5wYXRobmFtZSA9ICdjJTIwZCc7XG4gIHJldHVybiAoSVNfUFVSRSAmJiAhdXJsLnRvSlNPTilcbiAgICB8fCAhc2VhcmNoUGFyYW1zLnNvcnRcbiAgICB8fCB1cmwuaHJlZiAhPT0gJ2h0dHA6Ly9hL2MlMjBkP2U9MSdcbiAgICB8fCBzZWFyY2hQYXJhbXMuZ2V0KCdlJykgIT09ICcxJ1xuICAgIHx8IFN0cmluZyhuZXcgVVJMU2VhcmNoUGFyYW1zKCc/YT0xJykpICE9PSAnYT0xJ1xuICAgIHx8ICFzZWFyY2hQYXJhbXNbSVRFUkFUT1JdXG4gICAgLy8gdGhyb3dzIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwczovL2FAYicpLnVzZXJuYW1lICE9PSAnYSdcbiAgICB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InXG4gICAgLy8gbm90IHB1bnljb2RlZCBpbiBFZGdlXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL9GC0LXRgdGCJykuaG9zdCAhPT0gJ3huLS1lMWF5YmMnXG4gICAgLy8gbm90IGVzY2FwZWQgaW4gQ2hyb21lIDYyLVxuICAgIHx8IG5ldyBVUkwoJ2h0dHA6Ly9hI9CxJykuaGFzaCAhPT0gJyMlRDAlQjEnO1xufSk7XG4iLCJ2YXIgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcnKTtcbnZhciBXZWFrTWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbChXZWFrTWFwKSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAyNS40LjEuNSBOZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG5cbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uIChDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gKEMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgbmF0aXZlQXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICFuYXRpdmVBc3NpZ24gfHwgcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiBuYXRpdmVBc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKG5hdGl2ZUFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogbmF0aXZlQXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIHNjcmlwdCA9ICdzY3JpcHQnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBqcyA9ICdqYXZhJyArIHNjcmlwdCArICc6JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gU3RyaW5nKGpzKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArIHNjcmlwdCArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy8nICsgc2NyaXB0ICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2xlbmd0aF1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpW0lFX1BST1RPXSA9IHRydWU7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaSsrXSwgUHJvcGVydGllc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nXG4gICAgPyBnZXRXaW5kb3dOYW1lcyhpdClcbiAgICA6IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgdmFsaWRhdGVTZXRQcm90b3R5cGVPZkFyZ3VtZW50cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92YWxpZGF0ZS1zZXQtcHJvdG90eXBlLW9mLWFyZ3VtZW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3JyZWN0U2V0dGVyID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBjb3JyZWN0U2V0dGVyID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIHZhbGlkYXRlU2V0UHJvdG90eXBlT2ZBcmd1bWVudHMoTywgcHJvdG8pO1xuICAgIGlmIChjb3JyZWN0U2V0dGVyKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSAhPT0gJ1tvYmplY3Qgel0nID8gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn0gOiB0ZXN0LnRvU3RyaW5nO1xuIiwidmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIFJlZmxlY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykuUmVmbGVjdDtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCJ2YXIgbmF0aXZlUGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5wYXJzZUZsb2F0O1xudmFyIGludGVybmFsU3RyaW5nVHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG52YXIgRk9SQ0VEID0gMSAvIG5hdGl2ZVBhcnNlRmxvYXQod2hpdGVzcGFjZXMgKyAnLTAnKSAhPT0gLUluZmluaXR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyKSB7XG4gIHZhciBzdHJpbmcgPSBpbnRlcm5hbFN0cmluZ1RyaW0oU3RyaW5nKHN0ciksIDMpO1xuICB2YXIgcmVzdWx0ID0gbmF0aXZlUGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogbmF0aXZlUGFyc2VGbG9hdDtcbiIsInZhciBuYXRpdmVQYXJzZUludCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5wYXJzZUludDtcbnZhciBpbnRlcm5hbFN0cmluZ1RyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xudmFyIGhleCA9IC9eWy0rXT8wW3hYXS87XG52YXIgRk9SQ0VEID0gbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMDgnKSAhPT0gOCB8fCBuYXRpdmVQYXJzZUludCh3aGl0ZXNwYWNlcyArICcweDE2JykgIT09IDIyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpIHtcbiAgdmFyIHN0cmluZyA9IGludGVybmFsU3RyaW5nVHJpbShTdHJpbmcoc3RyKSwgMyk7XG4gIHJldHVybiBuYXRpdmVQYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogbmF0aXZlUGFyc2VJbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4geyBlcnJvcjogZmFsc2UsIHZhbHVlOiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgdmFsdWU6IGVycm9yIH07XG4gIH1cbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmV3LXByb21pc2UtY2FwYWJpbGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gIGFuT2JqZWN0KEMpO1xuICBpZiAoaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gIHZhciByZXNvbHZlID0gcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgcmVzb2x2ZSh4KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzL2Jsb2IvbWFzdGVyL3B1bnljb2RlLmpzXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx1MDA3RV0vOyAvLyBub24tQVNDSUkgY2hhcnNcbnZhciByZWdleFNlcGFyYXRvcnMgPSAvW1xcdTAwMkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcbnZhciBPVkVSRkxPV19FUlJPUiA9ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2Vzcyc7XG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqL1xudmFyIHVjczJkZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgIC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICB2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIExvdyBzdXJyb2dhdGUuXG4gICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuICAgICAgICAvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICBjb3VudGVyLS07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICovXG52YXIgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24gKGRpZ2l0KSB7XG4gIC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG4gIC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuICByZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpO1xufTtcblxuLyoqXG4gKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAqL1xudmFyIGFkYXB0ID0gZnVuY3Rpb24gKGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuICB2YXIgayA9IDA7XG4gIGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG4gIGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcbiAgZm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gIH1cbiAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIG1heC1zdGF0ZW1lbnRzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcblxuICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG4gIC8vIENhY2hlIHRoZSBsZW5ndGguXG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cbiAgdmFyIG4gPSBpbml0aWFsTjtcbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIGJpYXMgPSBpbml0aWFsQmlhcztcbiAgdmFyIGksIGN1cnJlbnRWYWx1ZTtcblxuICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7IC8vIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cbiAgdmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7IC8vIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXG4gIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG4gIGlmIChiYXNpY0xlbmd0aCkge1xuICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gIH1cblxuICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dCBsYXJnZXIgb25lOlxuICAgIHZhciBtID0gbWF4SW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICBtID0gY3VycmVudFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPiwgYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG4gICAgdmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICAgfVxuXG4gICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgICBuID0gbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG4gICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuICAgICAgICB2YXIgcSA9IGRlbHRhO1xuICAgICAgICBmb3IgKHZhciBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICB2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG4gICAgICAgICAgaWYgKHEgPCB0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHFNaW51c1QgPSBxIC0gdDtcbiAgICAgICAgICB2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNUKSkpO1xuICAgICAgICAgIHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEpKSk7XG4gICAgICAgIGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG4gICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICArK2RlbHRhO1xuICAgICsrbjtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcbiAgdmFyIGxhYmVscyA9IGlucHV0LnRvTG93ZXJDYXNlKCkucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHUwMDJFJykuc3BsaXQoJy4nKTtcbiAgdmFyIGksIGxhYmVsO1xuICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgZW5jb2RlZC5wdXNoKHJlZ2V4Tm9uQVNDSUkudGVzdChsYWJlbCkgPyAneG4tLScgKyBlbmNvZGUobGFiZWwpIDogbGFiZWwpO1xuICB9XG4gIHJldHVybiBlbmNvZGVkLmpvaW4oJy4nKTtcbn07XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhuYXRpdmVGdW5jdGlvblRvU3RyaW5nKS5zcGxpdCgndG9TdHJpbmcnKTtcblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpKCdpbnNwZWN0U291cmNlJywgZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xufSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkgaGlkZSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gIH1cbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICghdW5zYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgfSBlbHNlIGlmICghbm9UYXJnZXRHZXQgJiYgT1trZXldKSB7XG4gICAgc2ltcGxlID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBoaWRlKE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBuYXRpdmVGdW5jdGlvblRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9jbGFzc29mLXJhdycpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuL3JlZ2V4cC1leGVjJyk7XG5cbi8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGNsYXNzb2YoUikgIT09ICdSZWdFeHAnKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cblxuICByZXR1cm4gcmVnZXhwRXhlYy5jYWxsKFIsIFMpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL3JlZ2V4cC1mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBgU2FtZVZhbHVlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNhbWV2YWx1ZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIHJldHVybiB4ID09PSB5ID8geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkgOiB4ICE9IHggJiYgeSAhPSB5O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBoaWRlKGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIEMgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSkgZGVmaW5lUHJvcGVydHkoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0R2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjAuMScsXG4gIG1vZGU6IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJykgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gIW1ldGhvZCB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbFxuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNwZWNpZXNjb25zdHJ1Y3RvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFGdW5jdGlvbihTKTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuLy8gQ09OVkVSVF9UT19TVFJJTkc6IHRydWUgIC0+IFN0cmluZyNhdFxuLy8gQ09OVkVSVF9UT19TVFJJTkc6IGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGhhdCwgcG9zLCBDT05WRVJUX1RPX1NUUklORykge1xuICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoYXQpKTtcbiAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gIHZhciBzaXplID0gUy5sZW5ndGg7XG4gIHZhciBmaXJzdCwgc2Vjb25kO1xuICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICBmaXJzdCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgPyBDT05WRVJUX1RPX1NUUklORyA/IFMuY2hhckF0KHBvc2l0aW9uKSA6IGZpcnN0XG4gICAgICA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUucmVwZWF0YCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwZWF0XG5tb2R1bGUuZXhwb3J0cyA9ICcnLnJlcGVhdCB8fCBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMnKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyAxIC0+IFN0cmluZyN0cmltU3RhcnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1FbmRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZywgVFlQRSkge1xuICBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZShzdHJpbmcpKTtcbiAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG52YXIgc2V0ID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgaWYgKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0IHx8ICFjbGVhcikge1xuICBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBpID0gMTtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAoY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhiaW5kKHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGJpbmQocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmIChNZXNzYWdlQ2hhbm5lbCkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZChwb3J0LnBvc3RNZXNzYWdlLCBwb3J0LCAxKTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBwb3N0TWVzc2FnZSwgc2tpcCBXZWJXb3JrZXJzXG4gIC8vIElFOCBoYXMgcG9zdE1lc3NhZ2UsIGJ1dCBpdCdzIHN5bmMgJiB0eXBlb2YgaXRzIHBvc3RNZXNzYWdlIGlzICdvYmplY3QnXG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bi5jYWxsKGlkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgLy8gUmVzdCBvbGQgYnJvd3NlcnNcbiAgfSBlbHNlIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgc2V0VGltZW91dChiaW5kKHJ1biwgaWQsIDEpLCAwKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgY2xlYXI6IGNsZWFyXG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxuLy8gYHRoaXNOdW1iZXJWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10aGlzbnVtYmVydmFsdWVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgJiYgY2xhc3NvZih2YWx1ZSkgIT0gJ051bWJlcicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH1cbiAgcmV0dXJuICt2YWx1ZTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihsZW5ndGgsIGxlbmd0aCkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbi8vIGBUb0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgdmFyIG51bWJlciA9IHRvSW50ZWdlcihpdCk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCBvciBpbmRleCcpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcbiIsIi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG4iLCJ2YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuaWYgKHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpKSB7XG4gIHZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG4gIHZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuICB2YXIgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheXMtY29uc3RydWN0b3JzLXJlcXVpcmVzLXdyYXBwZXJzJyk7XG4gIHZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbiAgdmFyIEFycmF5QnVmZmVyTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlcicpO1xuICB2YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xuICB2YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG4gIHZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbiAgdmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuICB2YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleCcpO1xuICB2YXIgdG9PZmZzZXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2Zmc2V0Jyk7XG4gIHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbiAgdmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbiAgdmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xuICB2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG4gIHZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xuICB2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xuICB2YXIgdHlwZWRBcnJheUZyb20gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktZnJvbScpO1xuICB2YXIgYXJyYXlGb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSgwKTtcbiAgdmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG4gIHZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG4gIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG4gIHZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG4gIHZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgdmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbiAgdmFyIEFycmF5QnVmZmVyID0gQXJyYXlCdWZmZXJNb2R1bGUuQXJyYXlCdWZmZXI7XG4gIHZhciBEYXRhVmlldyA9IEFycmF5QnVmZmVyTW9kdWxlLkRhdGFWaWV3O1xuICB2YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IEFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcbiAgdmFyIFRZUEVEX0FSUkFZX1RBRyA9IEFycmF5QnVmZmVyVmlld0NvcmUuVFlQRURfQVJSQVlfVEFHO1xuICB2YXIgVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuVHlwZWRBcnJheTtcbiAgdmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXlQcm90b3R5cGU7XG4gIHZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuICB2YXIgaXNUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5pc1R5cGVkQXJyYXk7XG4gIHZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG4gIHZhciBXUk9OR19MRU5HVEggPSAnV3JvbmcgbGVuZ3RoJztcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQykpKGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldO1xuICAgIH0gfSk7XG4gIH07XG5cbiAgdmFyIGlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIga2xhc3M7XG4gICAgcmV0dXJuIGl0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihpdCkpID09ICdBcnJheUJ1ZmZlcicgfHwga2xhc3MgPT0gJ1NoYXJlZEFycmF5QnVmZmVyJztcbiAgfTtcblxuICB2YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICByZXR1cm4gaXNUeXBlZEFycmF5KHRhcmdldClcbiAgICAgICYmIHR5cGVvZiBrZXkgIT0gJ3N5bWJvbCdcbiAgICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAgICYmIFN0cmluZygra2V5KSA9PSBTdHJpbmcoa2V5KTtcbiAgfTtcblxuICB2YXIgd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBpc1R5cGVkQXJyYXlJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgfTtcblxuICB2YXIgd3JhcHBlZERlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzY3JpcHRvcilcbiAgICAgICYmIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjcmlwdG9yLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzY3JpcHRvciwgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSB8fCBkZXNjcmlwdG9yLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzY3JpcHRvciwgJ2VudW1lcmFibGUnKSB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUpXG4gICAgKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgfTtcblxuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9IHdyYXBwZWREZWZpbmVQcm9wZXJ0eTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZU9mZnNldCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XG4gIH1cblxuICAkZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwcGVkRGVmaW5lUHJvcGVydHlcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgdmFyIENPTlNUUlVDVE9SX05BTUUgPSBUWVBFICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcbiAgICB2YXIgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgcmV0dXJuIGRhdGEudmlld1tHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSkpIDwgMCA/IDAgOiB2YWx1ZSA+IDB4RkYgPyAweEZGIDogdmFsdWUgJiAweEZGO1xuICAgICAgZGF0YS52aWV3W1NFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEuYnl0ZU9mZnNldCwgdmFsdWUsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgbmF0aXZlRGVmaW5lUHJvcGVydHkodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLCBpbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKSB7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBkYXRhLCBvZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5Q29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgIHZhciBidWZmZXIsIGJ5dGVMZW5ndGgsIGxlbmd0aDtcbiAgICAgICAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgICAgICAgIGxlbmd0aCA9IHRvSW5kZXgoZGF0YSk7XG4gICAgICAgICAgYnl0ZUxlbmd0aCA9IGxlbmd0aCAqIEJZVEVTO1xuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gdG9PZmZzZXQob2Zmc2V0LCBCWVRFUyk7XG4gICAgICAgICAgdmFyICRsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgaWYgKCRsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCRsZW4gJSBCWVRFUykgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggKyBieXRlT2Zmc2V0ID4gJGxlbikgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlGcm9tLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICBieXRlT2Zmc2V0OiBieXRlT2Zmc2V0LFxuICAgICAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgdmlldzogbmV3IERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgdHlwZWRBcnJheU9mZnNldCwgJGxlbmd0aCkge1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgOiB0eXBlZEFycmF5T2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICA6IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSk7XG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdHlwZWRBcnJheUZyb20uY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcbiAgICAgIGFycmF5Rm9yRWFjaChnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBrZXksIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltrZXldKTtcbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCAnY29uc3RydWN0b3InLCBUeXBlZEFycmF5Q29uc3RydWN0b3IpO1xuICAgIH1cblxuICAgIGlmIChUWVBFRF9BUlJBWV9UQUcpIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBUWVBFRF9BUlJBWV9UQUcsIENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbiAgICAkZXhwb3J0KHtcbiAgICAgIGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBUeXBlZEFycmF5Q29uc3RydWN0b3IgIT0gTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBzaGFtOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXU1xuICAgIH0sIGV4cG9ydGVkKTtcblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIGlmICghKEJZVEVTX1BFUl9FTEVNRU5UIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSkpIHtcbiAgICAgIGhpZGUoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH07XG59IGVsc2UgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJ2YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBmbiwgdGhpc0FyZyAqLykge1xuICB2YXIgTyA9IHRvT2JqZWN0KHNvdXJjZSk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgaSwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZiAoaXRlcmF0b3JNZXRob2QgIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuICAgIE8gPSBbXTtcbiAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICBPLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXBwaW5nICYmIGFyZ3VtZW50c0xlbmd0aCA+IDIpIHtcbiAgICBtYXBmbiA9IGJpbmQobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gIH1cbiAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IodGhpcykpKGxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uJyk7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJykuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcbnZhciBBcnJheUJ1ZmZlciA9IGdsb2JhbC5BcnJheUJ1ZmZlcjtcbnZhciBJbnQ4QXJyYXkgPSBnbG9iYWwuSW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSgxKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG5ldyBJbnQ4QXJyYXkoLTEpO1xufSkgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgbmV3IEludDhBcnJheSgpO1xuICBuZXcgSW50OEFycmF5KG51bGwpO1xuICBuZXcgSW50OEFycmF5KDEuNSk7XG4gIG5ldyBJbnQ4QXJyYXkoaXRlcmFibGUpO1xufSwgdHJ1ZSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgMTEgYnVnXG4gIHJldHVybiBuZXcgSW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcigyKSwgMSwgdW5kZWZpbmVkKS5sZW5ndGggIT09IDE7XG59KTtcbiIsInZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBuYXZpZ2F0b3IgPSBnbG9iYWwubmF2aWdhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyBTdHJpbmcocHJvdG8pICsgJyBhcyBhIHByb3RvdHlwZScpO1xuICB9XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLlN5bWJvbDtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV1cbiAgICB8fCAoTkFUSVZFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcbiIsIi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIEFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlcicpW0FSUkFZX0JVRkZFUl07XG52YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJylbQVJSQVlfQlVGRkVSXTtcblxuLy8gYEFycmF5QnVmZmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlidWZmZXItY29uc3RydWN0b3JcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBOYXRpdmVBcnJheUJ1ZmZlciAhPT0gQXJyYXlCdWZmZXIgfSwge1xuICBBcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXJcbn0pO1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgQXJyYXlCdWZmZXIgPSBBcnJheUJ1ZmZlck1vZHVsZS5BcnJheUJ1ZmZlcjtcbnZhciBEYXRhVmlldyA9IEFycmF5QnVmZmVyTW9kdWxlLkRhdGFWaWV3O1xudmFyIG5hdGl2ZUFycmF5QnVmZmVyU2xpY2UgPSBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBJTkNPUlJFQ1RfU0xJQ0UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3IEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pO1xuXG4vLyBgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5YnVmZmVyLnByb3RvdHlwZS5zbGljZVxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBwcm90bzogdHJ1ZSwgdW5zYWZlOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9TTElDRSB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKG5hdGl2ZUFycmF5QnVmZmVyU2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFycmF5QnVmZmVyU2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1NvdXJjZSA9IG5ldyBEYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1RhcmdldCA9IG5ldyBEYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VGFyZ2V0LnNldFVpbnQ4KGluZGV4KyssIHZpZXdTb3VyY2UuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9ICFyZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0JykoJ2NvbmNhdCcpO1xuXG52YXIgaXNDb25jYXRTcHJlYWRhYmxlID0gZnVuY3Rpb24gKE8pIHtcbiAgaWYgKCFpc09iamVjdChPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheShPKTtcbn07XG5cbnZhciBGT1JDRUQgPSAhSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCB8fCAhU1BFQ0lFU19TVVBQT1JUO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gdG9MZW5ndGgoRS5sZW5ndGgpO1xuICAgICAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbnRlcm5hbEZpbHRlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoMik7XG5cbnZhciBTUEVDSUVTX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKSgnZmlsdGVyJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTUEVDSUVTX1NVUFBPUlQgfSwge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiBpbnRlcm5hbEZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBbXS5mb3JFYWNoICE9IGZvckVhY2ggfSwgeyBmb3JFYWNoOiBmb3JFYWNoIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsSW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBuYXRpdmVJbmRleE9mID0gW10uaW5kZXhPZjtcblxudmFyIE5FR0FUSVZFX1pFUk8gPSAhIW5hdGl2ZUluZGV4T2YgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG52YXIgU0xPUFBZX01FVEhPRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJykoJ2luZGV4T2YnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IE5FR0FUSVZFX1pFUk8gfHwgU0xPUFBZX01FVEhPRCB9LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyBuYXRpdmVJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiBpbnRlcm5hbEluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIvLyBgQXJyYXkuaXNBcnJheWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5pc2FycmF5XG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUgfSwgeyBpc0FycmF5OiByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKSB9KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG5hdGl2ZUpvaW4gPSBbXS5qb2luO1xuXG52YXIgRVMzX1NUUklOR1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKSAhPSBPYmplY3Q7XG52YXIgU0xPUFBZX01FVEhPRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJykoJ2pvaW4nLCAnLCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmpvaW5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmpvaW5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRVMzX1NUUklOR1MgfHwgU0xPUFBZX01FVEhPRCB9LCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUpvaW4uY2FsbCh0b0luZGV4ZWRPYmplY3QodGhpcyksIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywnIDogc2VwYXJhdG9yKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaW50ZXJuYWxNYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDEpO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0JykoJ21hcCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gaW50ZXJuYWxNYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaW50ZXJuYWxSZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJyk7XG5cbnZhciBTTE9QUFlfTUVUSE9EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKSgncmVkdWNlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU0xPUFBZX01FVEhPRCB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gaW50ZXJuYWxSZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJykoJ3NwZWNpZXMnKTtcbnZhciBuYXRpdmVTbGljZSA9IFtdLnNsaWNlO1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0JykoJ3NsaWNlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTUEVDSUVTX1NVUFBPUlQgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGsgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgICAvLyBpbmxpbmUgYEFycmF5U3BlY2llc0NyZWF0ZWAgZm9yIHVzYWdlIG5hdGl2ZSBgQXJyYXkjc2xpY2VgIHdoZXJlIGl0J3MgcG9zc2libGVcbiAgICB2YXIgQ29uc3RydWN0b3IsIHJlc3VsdCwgbjtcbiAgICBpZiAoaXNBcnJheShPKSkge1xuICAgICAgQ29uc3RydWN0b3IgPSBPLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgQ29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IGlzQXJyYXkoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KENvbnN0cnVjdG9yKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yW1NQRUNJRVNdO1xuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IG51bGwpIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVTbGljZS5jYWxsKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQ29uc3RydWN0b3IpKG1heChmaW4gLSBrLCAwKSk7XG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgbiwgT1trXSk7XG4gICAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWQnO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0JykoJ3NwbGljZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50IC8qICwgLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IDA7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFyZ3VtZW50c0xlbmd0aCAtIDI7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQgPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCk7XG4gICAgfVxuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICBmcm9tID0gYWN0dWFsU3RhcnQgKyBrO1xuICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkoQSwgaywgT1tmcm9tXSk7XG4gICAgfVxuICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlIE9bayAtIDFdO1xuICAgIH0gZWxzZSBpZiAoaW5zZXJ0Q291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsgPiBhY3R1YWxTdGFydDsgay0tKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudCAtIDE7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XG4gICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgIH1cbiAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwidmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLk5BVElWRV9BUlJBWV9CVUZGRVI7XG5cbi8vIGBEYXRhVmlld2AgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRhdGF2aWV3LWNvbnN0cnVjdG9yXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogIU5BVElWRV9BUlJBWV9CVUZGRVIgfSwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcbiIsIi8vIGBEYXRlLm5vd2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kYXRlLm5vd1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnRGF0ZScsIHN0YXQ6IHRydWUgfSwge1xuICBub3c6IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cbn0pO1xuIiwidmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIG5hdGl2ZURhdGVUb1N0cmluZyA9IERhdGVQcm90b3R5cGVbVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvdHlwZS5nZXRUaW1lO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpKERhdGVQcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gbmF0aXZlRGF0ZVRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZyA9IEZ1bmN0aW9uUHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIG5hbWVSRSA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztcbnZhciBOQU1FID0gJ25hbWUnO1xuXG4vLyBGdW5jdGlvbiBpbnN0YW5jZXMgYC5uYW1lYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZnVuY3Rpb24taW5zdGFuY2VzLW5hbWVcbmlmIChERVNDUklQVE9SUyAmJiAhKE5BTUUgaW4gRnVuY3Rpb25Qcm90b3R5cGUpKSB7XG4gIGRlZmluZVByb3BlcnR5KEZ1bmN0aW9uUHJvdG90eXBlLCBOQU1FLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcuY2FsbCh0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0aGlzTnVtYmVyVmFsdWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGhpcy1udW1iZXItdmFsdWUnKTtcbnZhciByZXBlYXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdCcpO1xudmFyIG5hdGl2ZVRvRml4ZWQgPSAxLjAudG9GaXhlZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24gKG4sIGMpIHtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraSA8IDYpIHtcbiAgICBjMiArPSBuICogZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG5cbnZhciBkaXZpZGUgPSBmdW5jdGlvbiAobikge1xuICB2YXIgaSA9IDY7XG4gIHZhciBjID0gMDtcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG5cbnZhciBudW1Ub1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGkgPSA2O1xuICB2YXIgcyA9ICcnO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAocyAhPT0gJycgfHwgaSA9PT0gMCB8fCBkYXRhW2ldICE9PSAwKSB7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoJzAnLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICB9XG4gIH0gcmV0dXJuIHM7XG59O1xuXG52YXIgcG93ID0gZnVuY3Rpb24gKHgsIG4sIGFjYykge1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xuXG52YXIgbG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG4gPSAwO1xuICB2YXIgeDIgPSB4O1xuICB3aGlsZSAoeDIgPj0gNDA5Nikge1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSAoeDIgPj0gMikge1xuICAgIG4gKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuLy8gYE51bWJlci5wcm90b3R5cGUudG9GaXhlZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1udW1iZXIucHJvdG90eXBlLnRvZml4ZWRcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ051bWJlcicsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IG5hdGl2ZVRvRml4ZWQgJiYgKFxuICAwLjAwMDA4LnRvRml4ZWQoMykgIT09ICcwLjAwMCcgfHxcbiAgMC45LnRvRml4ZWQoMCkgIT09ICcxJyB8fFxuICAxLjI1NS50b0ZpeGVkKDIpICE9PSAnMS4yNScgfHxcbiAgMTAwMDAwMDAwMDAwMDAwMDEyOC4wLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICBuYXRpdmVUb0ZpeGVkLmNhbGwoe30pO1xufSkgfSwge1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIHggPSB0aGlzTnVtYmVyVmFsdWUodGhpcyk7XG4gICAgdmFyIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIG0gPSAnMCc7XG4gICAgdmFyIGUsIHosIGosIGs7XG4gICAgaWYgKGYgPCAwIHx8IGYgPiAyMCkgdGhyb3cgUmFuZ2VFcnJvcignSW5jb3JyZWN0IGZyYWN0aW9uIGRpZ2l0cycpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoeCAhPSB4KSByZXR1cm4gJ05hTic7XG4gICAgaWYgKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKSByZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmICh4IDwgMCkge1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYgKHggPiAxZS0yMSkge1xuICAgICAgZSA9IGxvZyh4ICogcG93KDIsIDY5LCAxKSkgLSA2OTtcbiAgICAgIHogPSBlIDwgMCA/IHggKiBwb3coMiwgLWUsIDEpIDogeCAvIHBvdygyLCBlLCAxKTtcbiAgICAgIHogKj0gMHgxMDAwMDAwMDAwMDAwMDtcbiAgICAgIGUgPSA1MiAtIGU7XG4gICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpICsgcmVwZWF0LmNhbGwoJzAnLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGYgPiAwKSB7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoJzAnLCBmIC0gaykgKyBtIDogbS5zbGljZSgwLCBrIC0gZikgKyAnLicgKyBtLnNsaWNlKGsgLSBmKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBzICsgbTtcbiAgICB9IHJldHVybiBtO1xuICB9XG59KTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhREVTQ1JJUFRPUlMsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmZcbn0pO1xuIiwidmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0luZGV4ZWRPYmplY3QoaXQpLCBrZXkpO1xuICB9XG59KTtcbiIsInZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5pZiAodG9TdHJpbmcgIT09IE9iamVjdFByb3RvdHlwZS50b1N0cmluZykge1xuICByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKShPYmplY3RQcm90b3R5cGUsICd0b1N0cmluZycsIHRvU3RyaW5nLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cbiIsInZhciBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGFyc2UtZmxvYXQnKTtcblxuLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VmbG9hdC1zdHJpbmdcbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUZsb2F0ICE9IHBhcnNlRmxvYXRJbXBsZW1lbnRhdGlvbiB9LCB7XG4gIHBhcnNlRmxvYXQ6IHBhcnNlRmxvYXRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCJ2YXIgcGFyc2VJbnRJbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXJzZS1pbnQnKTtcblxuLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IHBhcnNlSW50SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUludDogcGFyc2VJbnRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9taWNyb3Rhc2snKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUnKTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hvc3QtcmVwb3J0LWVycm9ycycpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlci1hZ2VudCcpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKSgnc3BlY2llcycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gZ2xvYmFsW1BST01JU0VdO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbC5UeXBlRXJyb3I7XG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyICRmZXRjaCA9IGdsb2JhbC5mZXRjaDtcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eTtcbnZhciBJU19OT0RFID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlcjtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKFBST01JU0UsIGZ1bmN0aW9uICgpIHtcbiAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoMSk7XG4gIHZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiAgdmFyIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbU1BFQ0lFU10gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgfTtcbiAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICByZXR1cm4gISgoSVNfTk9ERSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpXG4gICAgJiYgKCFJU19QVVJFIHx8IHByb21pc2VbJ2ZpbmFsbHknXSlcbiAgICAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2VcbiAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODMwNTY1XG4gICAgLy8gd2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICYmIHVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTEpO1xufSk7XG5cbnZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gRk9SQ0VEIHx8ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIFByb21pc2VDb25zdHJ1Y3Rvci5hbGwoaXRlcmFibGUpWydjYXRjaCddKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxuLy8gaGVscGVyc1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG5cbnZhciBub3RpZnkgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUsIGlzUmVqZWN0KSB7XG4gIGlmIChzdGF0ZS5ub3RpZmllZCkgcmV0dXJuO1xuICBzdGF0ZS5ub3RpZmllZCA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHN0YXRlLnJlYWN0aW9ucztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbiAocmVhY3Rpb24pIHtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoID4gaSkgcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHN0YXRlLnJlYWN0aW9ucyA9IFtdO1xuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHByb21pc2UsIHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoaGFuZGxlciA9IGdsb2JhbFsnb24nICsgbmFtZV0pIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElTX05PREUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIHByb21pc2UsIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShwcm9taXNlLCBzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHByb21pc2UsIHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkocHJvbWlzZSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdCh0aGlzLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKShQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgLy8gYFByb21pc2UucHJvdG90eXBlLnRoZW5gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgc3RhdGUucGFyZW50ID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnJlYWN0aW9ucy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmIChzdGF0ZS5zdGF0ZSAhPSBQRU5ESU5HKSBub3RpZnkodGhpcywgc3RhdGUsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gYFByb21pc2UucHJvdG90eXBlLmNhdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnByb3RvdHlwZS5jYXRjaFxuICAgICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgT3duUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZChpbnRlcm5hbFJlc29sdmUsIHByb21pc2UsIHN0YXRlKTtcbiAgICB0aGlzLnJlamVjdCA9IGJpbmQoaW50ZXJuYWxSZWplY3QsIHByb21pc2UsIHN0YXRlKTtcbiAgfTtcbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG5cbiAgLy8gd3JhcCBmZXRjaCByZXN1bHRcbiAgaWYgKCFJU19QVVJFICYmIHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJykgJGV4cG9ydCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiB0cnVlIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShQcm9taXNlQ29uc3RydWN0b3IsICRmZXRjaC5hcHBseShnbG9iYWwsIGFyZ3VtZW50cykpO1xuICAgIH1cbiAgfSk7XG59XG5cbiRleHBvcnQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHsgUHJvbWlzZTogUHJvbWlzZUNvbnN0cnVjdG9yIH0pO1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKShQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlLCB0cnVlKTtcbnJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtc3BlY2llcycpKFBST01JU0UpO1xuXG5Qcm9taXNlV3JhcHBlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocikge1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcyk7XG4gICAgY2FwYWJpbGl0eS5yZWplY3QuY2FsbCh1bmRlZmluZWQsIHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElTX1BVUkUgfHwgRk9SQ0VEIH0sIHtcbiAgLy8gYFByb21pc2UucmVzb2x2ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmVzb2x2ZVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoSVNfUFVSRSAmJiB0aGlzID09PSBQcm9taXNlV3JhcHBlciA/IFByb21pc2VDb25zdHJ1Y3RvciA6IHRoaXMsIHgpO1xuICB9XG59KTtcblxuJGV4cG9ydCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgLy8gYFByb21pc2UuYWxsYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5hbGxcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBpdGVyYXRlKGl0ZXJhYmxlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7XG4gICAgICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyBgUHJvbWlzZS5yYWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yYWNlXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdtYXRjaCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIE5hdGl2ZVJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gTmF0aXZlUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG5cbi8vIFwibmV3XCIgc2hvdWxkIGNyZWF0ZSBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgTmF0aXZlUmVnRXhwKHJlMSkgIT09IHJlMTtcblxudmFyIEZPUkNFRCA9IGlzRm9yY2VkKCdSZWdFeHAnLCBERVNDUklQVE9SUyAmJiAoIUNPUlJFQ1RfTkVXIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmUyW01BVENIXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gTmF0aXZlUmVnRXhwKHJlMSkgIT0gcmUxIHx8IE5hdGl2ZVJlZ0V4cChyZTIpID09IHJlMiB8fCBOYXRpdmVSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSk7XG5cbi8vIGBSZWdFeHBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAtY29uc3RydWN0b3JcbmlmIChGT1JDRUQpIHtcbiAgdmFyIFJlZ0V4cFdyYXBwZXIgPSBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdGhpc0lzUmVnRXhwID0gdGhpcyBpbnN0YW5jZW9mIFJlZ0V4cFdyYXBwZXI7XG4gICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCA9IGlzUmVnRXhwKHBhdHRlcm4pO1xuICAgIHZhciBmbGFnc0FyZVVuZGVmaW5lZCA9IGZsYWdzID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aGlzSXNSZWdFeHAgJiYgcGF0dGVybklzUmVnRXhwICYmIHBhdHRlcm4uY29uc3RydWN0b3IgPT09IFJlZ0V4cFdyYXBwZXIgJiYgZmxhZ3NBcmVVbmRlZmluZWQgPyBwYXR0ZXJuXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IE5hdGl2ZVJlZ0V4cChwYXR0ZXJuSXNSZWdFeHAgJiYgIWZsYWdzQXJlVW5kZWZpbmVkID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuLCBmbGFncylcbiAgICAgICAgOiBOYXRpdmVSZWdFeHAoKHBhdHRlcm5Jc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHBXcmFwcGVyKVxuICAgICAgICAgID8gcGF0dGVybi5zb3VyY2VcbiAgICAgICAgICA6IHBhdHRlcm4sIHBhdHRlcm5Jc1JlZ0V4cCAmJiBmbGFnc0FyZVVuZGVmaW5lZCA/IGdldEZsYWdzLmNhbGwocGF0dGVybikgOiBmbGFncylcbiAgICAgICwgdGhpc0lzUmVnRXhwID8gdGhpcyA6IFJlZ0V4cFByb3RvdHlwZSwgUmVnRXhwV3JhcHBlcik7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gUmVnRXhwV3JhcHBlciB8fCBkZWZpbmVQcm9wZXJ0eShSZWdFeHBXcmFwcGVyLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmF0aXZlUmVnRXhwW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBOYXRpdmVSZWdFeHBba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVSZWdFeHApO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHByb3h5KGtleXNbaSsrXSk7XG4gIFJlZ0V4cFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlZ0V4cFdyYXBwZXI7XG4gIFJlZ0V4cFdyYXBwZXIucHJvdG90eXBlID0gUmVnRXhwUHJvdG90eXBlO1xuICByZWRlZmluZShnbG9iYWwsICdSZWdFeHAnLCBSZWdFeHBXcmFwcGVyKTtcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC1AQHNwZWNpZXNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IHJlZ2V4cEV4ZWMgfSwge1xuICBleGVjOiByZWdleHBFeGVjXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGZsYWdzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1mbGFncycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBuYXRpdmVUb1N0cmluZyA9IC8uL1tUT19TVFJJTkddO1xuXG52YXIgTk9UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVUb1N0cmluZy5jYWxsKHsgc291cmNlOiAnYScsIGZsYWdzOiAnYicgfSkgIT0gJy9hL2InOyB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG52YXIgSU5DT1JSRUNUX05BTUUgPSBuYXRpdmVUb1N0cmluZy5uYW1lICE9IFRPX1NUUklORztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKE5PVF9HRU5FUklDIHx8IElOQ09SUkVDVF9OQU1FKSB7XG4gIHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpKFJlZ0V4cC5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvZGVQb2ludEF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1hdCcpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGluZGV4LCB0cnVlKTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpKFxuICAnbWF0Y2gnLFxuICAxLFxuICBmdW5jdGlvbiAoTUFUQ0gsIG5hdGl2ZU1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gYFN0cmluZy5wcm90b3R5cGUubWF0Y2hgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuICAgICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIgIT09IHVuZGVmaW5lZCA/IG1hdGNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICAgICAgfSxcbiAgICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICAgICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1hdGNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdFeHBFeGVjKHJ4LCBTKTtcblxuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgICAgQVtuXSA9IG1hdGNoU3RyO1xuICAgICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgICB9XG4gICAgXTtcbiAgfVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCZgJ118XFxkXFxkP3w8W14+XSo+KS9nO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEID0gL1xcJChbJCZgJ118XFxkXFxkPykvZztcblxudmFyIG1heWJlVG9TdHJpbmcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xuXG4vLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJykoXG4gICdyZXBsYWNlJyxcbiAgMixcbiAgZnVuY3Rpb24gKFJFUExBQ0UsIG5hdGl2ZVJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgICAgdmFyIHJlcGxhY2VyID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICAgIHJldHVybiByZXBsYWNlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyByZXBsYWNlci5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICAgICAgOiBuYXRpdmVSZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEByZXBsYWNlXG4gICAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVSZXBsYWNlLCByZWdleHAsIHRoaXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSBTdHJpbmcocmVwbGFjZVZhbHVlKTtcblxuICAgICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgaWYgKCFnbG9iYWwpIGJyZWFrO1xuXG4gICAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gbWF4KG1pbih0b0ludGVnZXIocmVzdWx0LmluZGV4KSwgUy5sZW5ndGgpLCAwKTtcbiAgICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgICAvLyAgIGNhcHR1cmVzID0gcmVzdWx0LnNsaWNlKDEpLm1hcChtYXliZVRvU3RyaW5nKVxuICAgICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgICAvLyBjYXVzZXMgYSBjcmFzaCAoaHR0cHM6Ly9wYXN0ZWJpbi5jb20vTjIxUXplUUEpIHdoZW4gdHJ5aW5nIHRvIGRlYnVnIGl0LlxuICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICAgIGlmIChmdW5jdGlvbmFsUmVwbGFjZSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gU3RyaW5nKHJlcGxhY2VWYWx1ZS5hcHBseSh1bmRlZmluZWQsIHJlcGxhY2VyQXJncykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIG5leHRTb3VyY2VQb3NpdGlvbiA9IHBvc2l0aW9uICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRlZFJlc3VsdCArIFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICBdO1xuXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG4gICAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgdmFyIG0gPSBjYXB0dXJlcy5sZW5ndGg7XG4gICAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuYW1lZENhcHR1cmVzID0gdG9PYmplY3QobmFtZWRDYXB0dXJlcyk7XG4gICAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVSZXBsYWNlLmNhbGwocmVwbGFjZW1lbnQsIHN5bWJvbHMsIGZ1bmN0aW9uIChtYXRjaCwgY2gpIHtcbiAgICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICAgIHN3aXRjaCAoY2guY2hhckF0KDApKSB7XG4gICAgICAgICAgY2FzZSAnJCc6IHJldHVybiAnJCc7XG4gICAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc3RyLnNsaWNlKHRhaWxQb3MpO1xuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgICAgIGlmIChmID09PSAwKSByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FwdHVyZSA9PT0gdW5kZWZpbmVkID8gJycgOiBjYXB0dXJlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBzYW1lVmFsdWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2FtZS12YWx1ZScpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcblxuLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJykoXG4gICdzZWFyY2gnLFxuICAxLFxuICBmdW5jdGlvbiAoU0VBUkNILCBuYXRpdmVTZWFyY2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2hgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zZWFyY2hcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChyZWdleHApIHtcbiAgICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgICB2YXIgc2VhcmNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgICAgIHJldHVybiBzZWFyY2hlciAhPT0gdW5kZWZpbmVkID8gc2VhcmNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgICAgIH0sXG4gICAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNlYXJjaF1gIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNlYXJjaFxuICAgICAgZnVuY3Rpb24gKHJlZ2V4cCkge1xuICAgICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZVNlYXJjaCwgcmVnZXhwLCB0aGlzKTtcbiAgICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuXG4gICAgICAgIHZhciBwcmV2aW91c0xhc3RJbmRleCA9IHJ4Lmxhc3RJbmRleDtcbiAgICAgICAgaWYgKCFzYW1lVmFsdWUocHJldmlvdXNMYXN0SW5kZXgsIDApKSByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmICghc2FtZVZhbHVlKHJ4Lmxhc3RJbmRleCwgcHJldmlvdXNMYXN0SW5kZXgpKSByeC5sYXN0SW5kZXggPSBwcmV2aW91c0xhc3RJbmRleDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IC0xIDogcmVzdWx0LmluZGV4O1xuICAgICAgfVxuICAgIF07XG4gIH1cbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1yZWdleHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgY2FsbFJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhcnJheVB1c2ggPSBbXS5wdXNoO1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9VSU5UMzIgPSAweEZGRkZGRkZGO1xuXG4vLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJ3gnLCAneScpIC0+IC94L3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyIFNVUFBPUlRTX1kgPSAhZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gIVJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMnKShcbiAgJ3NwbGl0JyxcbiAgMixcbiAgZnVuY3Rpb24gKFNQTElULCBuYXRpdmVTcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gICAgdmFyIGludGVybmFsU3BsaXQ7XG4gICAgaWYgKFxuICAgICAgJ2FiYmMnLnNwbGl0KC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9IDQgfHxcbiAgICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT0gMiB8fFxuICAgICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPSA0IHx8XG4gICAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxIHx8XG4gICAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgICApIHtcbiAgICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtzdHJpbmddO1xuICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgdmFyIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weS5sYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSBhcnJheVB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbSA/IG91dHB1dC5zbGljZSgwLCBsaW0pIDogb3V0cHV0O1xuICAgICAgfTtcbiAgICAvLyBDaGFrcmEsIFY4XG4gICAgfSBlbHNlIGlmICgnMCcuc3BsaXQodW5kZWZpbmVkLCAwKS5sZW5ndGgpIHtcbiAgICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IG5hdGl2ZVNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpbnRlcm5hbFNwbGl0ID0gbmF0aXZlU3BsaXQ7XG5cbiAgICByZXR1cm4gW1xuICAgICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gc3BsaXR0ZXIuY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KVxuICAgICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB9LFxuICAgICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF1gIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgICAvL1xuICAgICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gdGhlICd5JyBmbGFnLlxuICAgICAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCByZWdleHAsIHRoaXMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSBuYXRpdmVTcGxpdCk7XG4gICAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcbiAgICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKFNVUFBPUlRTX1kgPyAneScgOiAnZycpO1xuXG4gICAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoU1VQUE9SVFNfWSA/IHJ4IDogJ14oPzonICsgcnguc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIHZhciBxID0gMDtcbiAgICAgICAgdmFyIEEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFNVUFBPUlRTX1kgPyBxIDogMDtcbiAgICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTVVBQT1JUU19ZID8gUyA6IFMuc2xpY2UocSkpO1xuICAgICAgICAgIHZhciBlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAgIChlID0gbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChTVVBQT1JUU19ZID8gMCA6IHEpKSwgUy5sZW5ndGgpKSA9PT0gcFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgICByZXR1cm4gQTtcbiAgICAgIH1cbiAgICBdO1xuICB9LFxuICAhU1VQUE9SVFNfWVxuKTtcbiIsIi8vIGBTeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cbid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xudmFyIE5hdGl2ZVN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKS5TeW1ib2w7XG5cbmlmIChERVNDUklQVE9SUyAmJiB0eXBlb2YgTmF0aXZlU3ltYm9sID09ICdmdW5jdGlvbicgJiYgKCEoJ2Rlc2NyaXB0aW9uJyBpbiBOYXRpdmVTeW1ib2wucHJvdG90eXBlKSB8fFxuICAvLyBTYWZhcmkgMTIgYnVnXG4gIE5hdGl2ZVN5bWJvbCgpLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWRcbikpIHtcbiAgdmFyIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSA9IHt9O1xuICAvLyB3cmFwIFN5bWJvbCBjb25zdHJ1Y3RvciBmb3IgY29ycmVjdCB3b3JrIHdpdGggdW5kZWZpbmVkIGRlc2NyaXB0aW9uXG4gIHZhciBTeW1ib2xXcmFwcGVyID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMgaW5zdGFuY2VvZiBTeW1ib2xXcmFwcGVyXG4gICAgICA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pXG4gICAgICAvLyBpbiBFZGdlIDEzLCBTdHJpbmcoU3ltYm9sKHVuZGVmaW5lZCkpID09PSAnU3ltYm9sKHVuZGVmaW5lZCknXG4gICAgICA6IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBOYXRpdmVTeW1ib2woKSA6IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgaWYgKGRlc2NyaXB0aW9uID09PSAnJykgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlW3Jlc3VsdF0gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoU3ltYm9sV3JhcHBlciwgTmF0aXZlU3ltYm9sKTtcbiAgdmFyIHN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlU3ltYm9sLnByb3RvdHlwZTtcbiAgc3ltYm9sUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ltYm9sV3JhcHBlcjtcblxuICB2YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBuYXRpdmUgPSBTdHJpbmcoTmF0aXZlU3ltYm9sKCd0ZXN0JykpID09ICdTeW1ib2wodGVzdCknO1xuICB2YXIgcmVnZXhwID0gL15TeW1ib2xcXCgoLiopXFwpW14pXSskLztcbiAgZGVmaW5lUHJvcGVydHkoc3ltYm9sUHJvdG90eXBlLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICB2YXIgc3ltYm9sID0gaXNPYmplY3QodGhpcykgPyB0aGlzLnZhbHVlT2YoKSA6IHRoaXM7XG4gICAgICB2YXIgc3RyaW5nID0gc3ltYm9sVG9TdHJpbmcuY2FsbChzeW1ib2wpO1xuICAgICAgaWYgKGhhcyhFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUsIHN5bWJvbCkpIHJldHVybiAnJztcbiAgICAgIHZhciBkZXNjID0gbmF0aXZlID8gc3RyaW5nLnNsaWNlKDcsIC0xKSA6IHN0cmluZy5yZXBsYWNlKHJlZ2V4cCwgJyQxJyk7XG4gICAgICByZXR1cm4gZGVzYyA9PT0gJycgPyB1bmRlZmluZWQgOiBkZXNjO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwgeyBTeW1ib2w6IFN5bWJvbFdyYXBwZXIgfSk7XG59XG4iLCIvLyBgU3ltYm9sLml0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJykoJ2l0ZXJhdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93cmFwcGVkLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIEhJRERFTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5JykoJ2hpZGRlbicpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNZTUJPTCk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBKU09OID0gZ2xvYmFsLkpTT047XG52YXIgbmF0aXZlSlNPTlN0cmluZ2lmeSA9IEpTT04gJiYgSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wnKTtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwga2V5KTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGVba2V5XTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIGl0ICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUsIGtleSwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgaXNTeW1ib2wgPSBOQVRJVkVfU1lNQk9MICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoaXQpIGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShpdCwgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBuYXRpdmVPYmplY3RDcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2NyaXB0b3IoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSW5kZXhlZE9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoaXQpLCBQKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JbmRleGVkT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xuICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICB2YXIgSVNfT1AgPSBpdCA9PT0gT2JqZWN0UHJvdG90eXBlO1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09QID8gT2JqZWN0UHJvdG90eXBlU3ltYm9scyA6IHRvSW5kZXhlZE9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90b3R5cGUsIGtleSkgOiB0cnVlKSkgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbik7XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSkgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnRhZztcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1TeW1ib2wtZGVzY3JpcHRpb25cbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSgkU3ltYm9sW1BST1RPVFlQRV0sICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2VsbEtub3duU3ltYm9sKG5hbWUpLCBuYW1lKTtcbiAgfTtcbn1cblxuJGV4cG9ydCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIU5BVElWRV9TWU1CT0wgfSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSBvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xufVxuXG4kZXhwb3J0KHsgdGFyZ2V0OiBTWU1CT0wsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5mb3JcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuXG4kZXhwb3J0KHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuSlNPTiAmJiAkZXhwb3J0KHsgdGFyZ2V0OiAnSlNPTicsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICByZXR1cm4gbmF0aXZlSlNPTlN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcbiAgICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICB8fCBuYXRpdmVKU09OU3RyaW5naWZ5KHsgYTogc3ltYm9sIH0pICE9ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8IG5hdGl2ZUpTT05TdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG59KSB9LCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gbmF0aXZlSlNPTlN0cmluZ2lmeS5hcHBseShKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuaWYgKCEkU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSkgaGlkZSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11gIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsIFNZTUJPTCk7XG5cbmhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXJyYXlDb3B5V2l0aGluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWNvcHktd2l0aGluJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5jb3B5V2l0aGluYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuY29weXdpdGhpblxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnY29weVdpdGhpbicsIGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiAsIGVuZCAqLykge1xuICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwoYVR5cGVkQXJyYXkodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5RXZlcnkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kcycpKDQpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5ldmVyeVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZXZlcnknLCBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gYXJyYXlFdmVyeShhVHlwZWRBcnJheSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZpbGwnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWxsXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZpbGwnLCBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykge1xuICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoMik7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbHRlclxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZmlsdGVyJywgZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHZhciBsaXN0ID0gYXJyYXlGaWx0ZXIoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihDKSkobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5RmluZEluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSg2KTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbmRpbmRleFxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZmluZEluZGV4JywgZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuIGFycmF5RmluZEluZGV4KGFUeXBlZEFycmF5KHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5RmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoNSk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5maW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmluZFxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZmluZCcsIGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gYXJyYXlGaW5kKGFUeXBlZEFycmF5KHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5Rm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2RzJykoMCk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZm9yZWFjaFxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZm9yRWFjaCcsIGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgYXJyYXlGb3JFYWNoKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmluY2x1ZGVzXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdpbmNsdWRlcycsIGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgcmV0dXJuIGFycmF5SW5jbHVkZXMoYVR5cGVkQXJyYXkodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5pbmRleG9mXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdpbmRleE9mJywgZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiBhcnJheUluZGV4T2YoYVR5cGVkQXJyYXkodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykuVWludDhBcnJheTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdpdGVyYXRvcicpO1xudmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xudmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG52YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0UHJvdG8gPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvO1xudmFyIG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvciA9IFVpbnQ4QXJyYXkgJiYgVWludDhBcnJheS5wcm90b3R5cGVbSVRFUkFUT1JdO1xuXG52YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhIW5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvclxuICAmJiAobmF0aXZlVHlwZWRBcnJheUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgbmF0aXZlVHlwZWRBcnJheUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcblxudmFyIHR5cGVkQXJyYXlWYWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKGFUeXBlZEFycmF5KHRoaXMpKTtcbn07XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5lbnRyaWVzXG5leHBvcnRQcm90bygnZW50cmllcycsIGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gIHJldHVybiBhcnJheUVudHJpZXMuY2FsbChhVHlwZWRBcnJheSh0aGlzKSk7XG59KTtcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5rZXlzXG5leHBvcnRQcm90bygna2V5cycsIGZ1bmN0aW9uIGtleXMoKSB7XG4gIHJldHVybiBhcnJheUtleXMuY2FsbChhVHlwZWRBcnJheSh0aGlzKSk7XG59KTtcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnZhbHVlc1xuZXhwb3J0UHJvdG8oJ3ZhbHVlcycsIHR5cGVkQXJyYXlWYWx1ZXMsICFDT1JSRUNUX0lURVJfTkFNRSk7XG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLUBAaXRlcmF0b3JcbmV4cG9ydFByb3RvKElURVJBVE9SLCB0eXBlZEFycmF5VmFsdWVzLCAhQ09SUkVDVF9JVEVSX05BTUUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuam9pblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdqb2luJywgZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseShhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5TGFzdEluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbGFzdC1pbmRleC1vZicpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUubGFzdEluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5sYXN0aW5kZXhvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdsYXN0SW5kZXhPZicsIGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggKi8pIHtcbiAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkoYVR5cGVkQXJyYXkodGhpcyksIGFyZ3VtZW50cyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG52YXIgaW50ZXJuYWxUeXBlZEFycmF5TWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSgxLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3Ioc3BlY2llc0NvbnN0cnVjdG9yKE8sIE8uY29uc3RydWN0b3IpKSkobGVuZ3RoKTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5tYXBcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ21hcCcsIGZ1bmN0aW9uIG1hcChtYXBmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuIGludGVybmFsVHlwZWRBcnJheU1hcChhVHlwZWRBcnJheSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhcnJheVJlZHVjZVJpZ2h0ID0gW10ucmVkdWNlUmlnaHQ7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnJlZHVjZVJpY2h0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygncmVkdWNlUmlnaHQnLCBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGFycmF5UmVkdWNlID0gW10ucmVkdWNlO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5yZWR1Y2Vcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygncmVkdWNlJywgZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUucmV2ZXJzZVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygncmV2ZXJzZScsIGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGxlbmd0aCA9IGFUeXBlZEFycmF5KHRoYXQpLmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IobGVuZ3RoIC8gMik7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciB2YWx1ZTtcbiAgd2hpbGUgKGluZGV4IDwgbWlkZGxlKSB7XG4gICAgdmFsdWUgPSB0aGF0W2luZGV4XTtcbiAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgdGhhdFtsZW5ndGhdID0gdmFsdWU7XG4gIH0gcmV0dXJuIHRoYXQ7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b09mZnNldCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vZmZzZXQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbnZhciBGT1JDRUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBuZXcgSW50OEFycmF5KDEpLnNldCh7fSk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2V0XG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzZXQnLCBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gIGFUeXBlZEFycmF5KHRoaXMpO1xuICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzWzFdLCAxKTtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB2YXIgc3JjID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKHNyYy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSAwO1xuICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGgnKTtcbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB0aGlzW29mZnNldCArIGluZGV4XSA9IHNyY1tpbmRleCsrXTtcbn0sIEZPUkNFRCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbnZhciBGT1JDRUQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBuZXcgSW50OEFycmF5KDEpLnNsaWNlKCk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zbGljZVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gIHZhciBsaXN0ID0gYXJyYXlTbGljZS5jYWxsKGFUeXBlZEFycmF5KHRoaXMpLCBzdGFydCwgZW5kKTtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihDKSkobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0sIEZPUkNFRCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYXJyYXlTb21lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZHMnKSgzKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb21lXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzb21lJywgZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gYXJyYXlTb21lKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYXJyYXlTb3J0ID0gW10uc29ydDtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvcnRcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3NvcnQnLCBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICByZXR1cm4gYXJyYXlTb3J0LmNhbGwoYVR5cGVkQXJyYXkodGhpcyksIGNvbXBhcmVmbik7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zdWJhcnJheVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnc3ViYXJyYXknLCBmdW5jdGlvbiBzdWJhcnJheShiZWdpbiwgZW5kKSB7XG4gIHZhciBPID0gYVR5cGVkQXJyYXkodGhpcyk7XG4gIHZhciBsZW5ndGggPSBPLmxlbmd0aDtcbiAgdmFyIGJlZ2luSW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPLmNvbnN0cnVjdG9yKSkoXG4gICAgTy5idWZmZXIsXG4gICAgTy5ieXRlT2Zmc2V0ICsgYmVnaW5JbmRleCAqIE8uQllURVNfUEVSX0VMRU1FTlQsXG4gICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKSkgLSBiZWdpbkluZGV4KVxuICApO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgSW50OEFycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLkludDhBcnJheTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhcnJheVRvTG9jYWxlU3RyaW5nID0gW10udG9Mb2NhbGVTdHJpbmc7XG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG52YXIgVE9fTE9DQUxFX0JVRyA9ICEhSW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgYXJyYXlUb0xvY2FsZVN0cmluZy5jYWxsKG5ldyBJbnQ4QXJyYXkoMSkpO1xufSk7XG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IEludDhBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBJbnQ4QXJyYXkucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnRvbG9jYWxlc3RyaW5nXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCd0b0xvY2FsZVN0cmluZycsIGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKGFUeXBlZEFycmF5KHRoaXMpKSA6IGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xufSwgRk9SQ0VEKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpLlVpbnQ4QXJyYXk7XG52YXIgVWludDhBcnJheVByb3RvdHlwZSA9IFVpbnQ4QXJyYXkgJiYgVWludDhBcnJheS5wcm90b3R5cGU7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgYXJyYXlUb1N0cmluZyA9IFtdLnRvU3RyaW5nO1xudmFyIGFycmF5Sm9pbiA9IFtdLmpvaW47XG5cbmlmIChyZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKShmdW5jdGlvbiAoKSB7IGFycmF5VG9TdHJpbmcuY2FsbCh7fSk7IH0pKSB7XG4gIGFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodGhpcyk7XG4gIH07XG59XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUudG9zdHJpbmdcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3RvU3RyaW5nJywgYXJyYXlUb1N0cmluZywgKFVpbnQ4QXJyYXlQcm90b3R5cGUgfHwge30pLnRvU3RyaW5nICE9IGFycmF5VG9TdHJpbmcpO1xuIiwiLy8gYFVpbnQxNkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3InKSgnVWludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsIi8vIGBVaW50MzJBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCIvLyBgVWludDhBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJykoJ1VpbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwidmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCAnZm9yRWFjaCcsIGZvckVhY2gpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCA9IGZvckVhY2g7XG4gIH1cbn1cbiIsInZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSA9IEFycmF5VmFsdWVzO1xuICAgIH1cbiAgICBpZiAoIUNvbGxlY3Rpb25Qcm90b3R5cGVbVE9fU1RSSU5HX1RBR10pIGhpZGUoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICBpZiAoRE9NSXRlcmFibGVzW0NPTExFQ1RJT05fTkFNRV0pIGZvciAodmFyIE1FVEhPRF9OQU1FIGluIEFycmF5SXRlcmF0b3JNZXRob2RzKSB7XG4gICAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSAhPT0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKSB0cnkge1xuICAgICAgICBoaWRlKENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHRhc2sgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdGFzaycpO1xudmFyIEZPUkNFRCA9ICFnbG9iYWwuc2V0SW1tZWRpYXRlIHx8ICFnbG9iYWwuY2xlYXJJbW1lZGlhdGU7XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzZXRJbW1lZGlhdGU6IHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogdGFzay5jbGVhclxufSk7XG4iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2VyLWFnZW50Jyk7XG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZm4sIHRpbWUgLyogLCAuLi5hcmdzICovKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIHZhciBhcmdzID0gYm91bmRBcmdzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogZmFsc2U7XG4gICAgcmV0dXJuIHNldChib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IDogZm4sIHRpbWUpO1xuICB9O1xufTtcblxucmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpKHsgZ2xvYmFsOiB0cnVlLCBiaW5kOiB0cnVlLCBmb3JjZWQ6IE1TSUUgfSwge1xuICBzZXRUaW1lb3V0OiB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgVVNFX05BVElWRV9VUkwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXVybCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpKCdpdGVyYXRvcicpO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TID0gJ1VSTFNlYXJjaFBhcmFtcyc7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IgPSBVUkxfU0VBUkNIX1BBUkFNUyArICdJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUGFyYW1zU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNUyk7XG52YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IpO1xuXG52YXIgcGx1cyA9IC9cXCsvZztcbnZhciBzZXF1ZW5jZXMgPSBBcnJheSg0KTtcblxudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gc2VxdWVuY2VzW2J5dGVzIC0gMV0gfHwgKHNlcXVlbmNlc1tieXRlcyAtIDFdID0gUmVnRXhwKCcoKD86JVtcXFxcZGEtZl17Mn0peycgKyBieXRlcyArICd9KScsICdnaScpKTtcbn07XG5cbnZhciBwZXJjZW50RGVjb2RlID0gZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzZXF1ZW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlO1xuICB9XG59O1xuXG52YXIgZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGl0LnJlcGxhY2UocGx1cywgJyAnKTtcbiAgdmFyIGJ5dGVzID0gNDtcbiAgd2hpbGUgKGJ5dGVzKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UocGVyY2VudFNlcXVlbmNlKGJ5dGVzLS0pLCBwZXJjZW50RGVjb2RlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGZpbmQgPSAvWyEnKCl+XXwlMjAvZztcblxudmFyIHJlcGxhY2UgPSB7XG4gICchJzogJyUyMScsXG4gIFwiJ1wiOiAnJTI3JyxcbiAgJygnOiAnJTI4JyxcbiAgJyknOiAnJTI5JyxcbiAgJ34nOiAnJTdFJyxcbiAgJyUyMCc6ICcrJ1xufTtcblxudmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gIHJldHVybiByZXBsYWNlW21hdGNoXTtcbn07XG5cbnZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpdCkucmVwbGFjZShmaW5kLCByZXBsYWNlcik7XG59O1xuXG52YXIgcGFyc2VTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAocmVzdWx0LCBxdWVyeSkge1xuICBpZiAocXVlcnkpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHF1ZXJ5LnNwbGl0KCcmJyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhdHRyaWJ1dGUsIGVudHJ5O1xuICAgIHdoaWxlIChpIDwgYXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaSsrXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgIGVudHJ5ID0gYXR0cmlidXRlLnNwbGl0KCc9Jyk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBrZXk6IGRlc2VyaWFsaXplKGVudHJ5LnNoaWZ0KCkpLFxuICAgICAgICAgIHZhbHVlOiBkZXNlcmlhbGl6ZShlbnRyeS5qb2luKCc9JykpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHVwZGF0ZVNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICB0aGlzLmVudHJpZXMubGVuZ3RoID0gMDtcbiAgcGFyc2VTZWFyY2hQYXJhbXModGhpcy5lbnRyaWVzLCBxdWVyeSk7XG59O1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IFR5cGVFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoZnVuY3Rpb24gSXRlcmF0b3IocGFyYW1zLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TX0lURVJBVE9SLFxuICAgIGl0ZXJhdG9yOiBnZXRJdGVyYXRvcihnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHBhcmFtcykuZW50cmllcyksXG4gICAga2luZDoga2luZFxuICB9KTtcbn0sICdJdGVyYXRvcicsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSh0aGlzKTtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgc3RlcCA9IHN0YXRlLml0ZXJhdG9yLm5leHQoKTtcbiAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICBzdGVwLnZhbHVlID0ga2luZCA9PT0gJ2tleXMnID8gZW50cnkua2V5IDoga2luZCA9PT0gJ3ZhbHVlcycgPyBlbnRyeS52YWx1ZSA6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXTtcbiAgfSByZXR1cm4gc3RlcDtcbn0pO1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtdXJsc2VhcmNocGFyYW1zXG52YXIgVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBVUkxTZWFyY2hQYXJhbXMoLyogaW5pdCAqLykge1xuICBhbkluc3RhbmNlKHRoaXMsIFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLCBVUkxfU0VBUkNIX1BBUkFNUyk7XG4gIHZhciBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kLCBpdGVyYXRvciwgc3RlcCwgZW50cnlJdGVyYXRvciwgZmlyc3QsIHNlY29uZCwga2V5O1xuXG4gIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgIHR5cGU6IFVSTF9TRUFSQ0hfUEFSQU1TLFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgdXBkYXRlVVJMOiBudWxsLFxuICAgIHVwZGF0ZVNlYXJjaFBhcmFtczogdXBkYXRlU2VhcmNoUGFyYW1zXG4gIH0pO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNPYmplY3QoaW5pdCkpIHtcbiAgICAgIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoaW5pdCk7XG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yTWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JNZXRob2QuY2FsbChpbml0KTtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGVudHJ5SXRlcmF0b3IgPSBnZXRJdGVyYXRvcihhbk9iamVjdChzdGVwLnZhbHVlKSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGZpcnN0ID0gZW50cnlJdGVyYXRvci5uZXh0KCkpLmRvbmUgfHxcbiAgICAgICAgICAgIChzZWNvbmQgPSBlbnRyeUl0ZXJhdG9yLm5leHQoKSkuZG9uZSB8fFxuICAgICAgICAgICAgIWVudHJ5SXRlcmF0b3IubmV4dCgpLmRvbmVcbiAgICAgICAgICApIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgc2VxdWVuY2Ugd2l0aCBsZW5ndGggMicpO1xuICAgICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogZmlyc3QudmFsdWUgKyAnJywgdmFsdWU6IHNlY29uZC52YWx1ZSArICcnIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yIChrZXkgaW4gaW5pdCkgaWYgKGhhc093bihpbml0LCBrZXkpKSBlbnRyaWVzLnB1c2goeyBrZXk6IGtleSwgdmFsdWU6IGluaXRba2V5XSArICcnIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZVNlYXJjaFBhcmFtcyhlbnRyaWVzLCB0eXBlb2YgaW5pdCA9PT0gJ3N0cmluZycgPyBpbml0LmNoYXJBdCgwKSA9PT0gJz8nID8gaW5pdC5zbGljZSgxKSA6IGluaXQgOiBpbml0ICsgJycpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSA9IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxucmVkZWZpbmVBbGwoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCB7XG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmFwcGVudGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1hcHBlbmRcbiAgYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQobmFtZSwgdmFsdWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHN0YXRlLmVudHJpZXMucHVzaCh7IGtleTogbmFtZSArICcnLCB2YWx1ZTogdmFsdWUgKyAnJyB9KTtcbiAgICBpZiAoc3RhdGUudXBkYXRlVVJMKSBzdGF0ZS51cGRhdGVVUkwoKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZGVsZXRlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWRlbGV0ZVxuICAnZGVsZXRlJzogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoZW50cmllc1tpXS5rZXkgPT09IGtleSkgZW50cmllcy5zcGxpY2UoaSwgMSk7XG4gICAgICBlbHNlIGkrKztcbiAgICB9XG4gICAgaWYgKHN0YXRlLnVwZGF0ZVVSTCkgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1nZXRcbiAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykgaWYgKGVudHJpZXNbaV0ua2V5ID09PSBrZXkpIHJldHVybiBlbnRyaWVzW2ldLnZhbHVlO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRBbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0YWxsXG4gIGdldEFsbDogZnVuY3Rpb24gZ2V0QWxsKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSBpZiAoZW50cmllc1tpXS5rZXkgPT09IGtleSkgcmVzdWx0LnB1c2goZW50cmllc1tpXS52YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaGFzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWhhc1xuICBoYXM6IGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBlbnRyaWVzLmxlbmd0aCkgaWYgKGVudHJpZXNbaSsrXS5rZXkgPT09IGtleSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zZXRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtc2V0XG4gIHNldDogZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgICB2YXIgdmFsID0gdmFsdWUgKyAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGVudHJ5O1xuICAgIGZvciAoOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgaWYgKGVudHJ5LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChmb3VuZCkgZW50cmllcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIGVudHJpZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgIGlmIChzdGF0ZS51cGRhdGVVUkwpIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zb3J0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNvcnRcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICAvLyBBcnJheSNzb3J0IGlzIG5vdCBzdGFibGUgaW4gc29tZSBlbmdpbmVzXG4gICAgdmFyIHNsaWNlID0gZW50cmllcy5zbGljZSgpO1xuICAgIHZhciBlbnRyeSwgaSwgajtcbiAgICBlbnRyaWVzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHNsaWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbnRyeSA9IHNsaWNlW2ldO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykgaWYgKGVudHJpZXNbal0ua2V5ID4gZW50cnkua2V5KSB7XG4gICAgICAgIGVudHJpZXMuc3BsaWNlKGosIDAsIGVudHJ5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gaSkgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnVwZGF0ZVVSTCkgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFjaywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgd2hpbGUgKGkgPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2krK107XG4gICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xuICAgIH1cbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAna2V5cycpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yKHRoaXMsICd2YWx1ZXMnKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAnZW50cmllcycpO1xuICB9XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2RcbnJlZGVmaW5lKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzKTtcblxuLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMtc3RyaW5naWZpY2F0aW9uLWJlaGF2aW9yXG5yZWRlZmluZShVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBlbnRyeTtcbiAgd2hpbGUgKGkgPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgIGVudHJ5ID0gZW50cmllc1tpKytdO1xuICAgIHJlc3VsdC5wdXNoKHNlcmlhbGl6ZShlbnRyeS5rZXkpICsgJz0nICsgc2VyaWFsaXplKGVudHJ5LnZhbHVlKSk7XG4gIH0gcmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpKFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLCBVUkxfU0VBUkNIX1BBUkFNUyk7XG5cbnJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKSh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiAhVVNFX05BVElWRV9VUkwgfSwge1xuICBVUkxTZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsXG4gIGdldFN0YXRlOiBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3InKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS11cmwnKTtcbnZhciBOYXRpdmVVUkwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJykuVVJMO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG52YXIgYXJyYXlGcm9tID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZyb20nKTtcbnZhciBjb2RlUG9pbnRBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctYXQnKTtcbnZhciB0b0FTQ0lJID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3B1bnljb2RlLXRvLWFzY2lpJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zTW9kdWxlID0gcmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMnKTtcbnZhciBVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xudmFyIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuZ2V0U3RhdGU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFVSTFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoJ1VSTCcpO1xudmFyIHBvdyA9IE1hdGgucG93O1xuXG52YXIgSU5WQUxJRF9BVVRIT1JJVFkgPSAnSW52YWxpZCBhdXRob3JpdHknO1xudmFyIElOVkFMSURfU0NIRU1FID0gJ0ludmFsaWQgc2NoZW1lJztcbnZhciBJTlZBTElEX0hPU1QgPSAnSW52YWxpZCBob3N0JztcbnZhciBJTlZBTElEX1BPUlQgPSAnSW52YWxpZCBwb3J0JztcblxudmFyIEFMUEhBID0gL1thLXpBLVpdLztcbnZhciBBTFBIQU5VTUVSSUMgPSAvW2EtekEtWjAtOStcXC0uXS87XG52YXIgRElHSVQgPSAvXFxkLztcbnZhciBIRVhfU1RBUlQgPSAvXigweHwwWCkvO1xudmFyIE9DVCA9IC9eWzAtN10rJC87XG52YXIgREVDID0gL15cXGQrJC87XG52YXIgSEVYID0gL15bMC05QS1GYS1mXSskLztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVCA9IC9cXHUwMDAwfFxcdTAwMDl8XFx1MDAwQXxcXHUwMDBEfFxcdTAwMjB8I3wlfFxcL3w6fFxcP3xAfFxcW3xcXFxcfFxcXS87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQgPSAvXFx1MDAwMHxcXHUwMDA5fFxcdTAwMEF8XFx1MDAwRHxcXHUwMDIwfCN8XFwvfDp8XFw/fEB8XFxbfFxcXFx8XFxdLztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgTEVBRElOR19BTkRfVFJBSUxJTkdfQzBfQ09OVFJPTF9PUl9TUEFDRSA9IC9eW1xcdTAwMDAtXFx1MDAxRlxcdTAwMjBdK3xbXFx1MDAwMC1cXHUwMDFGXFx1MDAyMF0rJC9nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBUQUJfQU5EX05FV19MSU5FID0gL1xcdTAwMDl8XFx1MDAwQXxcXHUwMDBEL2c7XG52YXIgRU9GO1xuXG52YXIgcGFyc2VIb3N0ID0gZnVuY3Rpb24gKHVybCwgaW5wdXQpIHtcbiAgdmFyIHJlc3VsdCwgY29kZVBvaW50cywgaTtcbiAgaWYgKGlucHV0LmNoYXJBdCgwKSA9PSAnWycpIHtcbiAgICBpZiAoaW5wdXQuY2hhckF0KGlucHV0Lmxlbmd0aCAtIDEpICE9ICddJykgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICByZXN1bHQgPSBwYXJzZUlQdjYoaW5wdXQuc2xpY2UoMSwgLTEpKTtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICB1cmwuaG9zdCA9IHJlc3VsdDtcbiAgLy8gb3BhcXVlIGhvc3RcbiAgfSBlbHNlIGlmICghaXNTcGVjaWFsKHVybCkpIHtcbiAgICBpZiAoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVF9FWENMVURJTkdfUEVSQ0VOVC50ZXN0KGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICByZXN1bHQgPSAnJztcbiAgICBjb2RlUG9pbnRzID0gYXJyYXlGcm9tKGlucHV0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykgcmVzdWx0ICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaW5wdXQgPSB0b0FTQ0lJKGlucHV0KTtcbiAgICBpZiAoRk9SQklEREVOX0hPU1RfQ09ERV9QT0lOVC50ZXN0KGlucHV0KSkgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgICByZXN1bHQgPSBwYXJzZUlQdjQoaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBwYXJzZUlQdjQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdmFyIHBhcnRzID0gaW5wdXQuc3BsaXQoJy4nKTtcbiAgdmFyIHBhcnRzTGVuZ3RoLCBudW1iZXJzLCBpLCBwYXJ0LCBSLCBuLCBpcHY0O1xuICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT0gJycpIHtcbiAgICBpZiAocGFydHMubGVuZ3RoKSBwYXJ0cy5wb3AoKTtcbiAgfVxuICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgaWYgKHBhcnRzTGVuZ3RoID4gNCkgcmV0dXJuIGlucHV0O1xuICBudW1iZXJzID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09ICcnKSByZXR1cm4gaW5wdXQ7XG4gICAgUiA9IDEwO1xuICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDEgJiYgcGFydC5jaGFyQXQoMCkgPT0gJzAnKSB7XG4gICAgICBSID0gSEVYX1NUQVJULnRlc3QocGFydCkgPyAxNiA6IDg7XG4gICAgICBwYXJ0ID0gcGFydC5zbGljZShSID09IDggPyAxIDogMik7XG4gICAgfVxuICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKFIgPT0gMTAgPyBERUMgOiBSID09IDggPyBPQ1QgOiBIRVgpLnRlc3QocGFydCkpIHJldHVybiBpbnB1dDtcbiAgICAgIG4gPSBwYXJzZUludChwYXJ0LCBSKTtcbiAgICB9XG4gICAgbnVtYmVycy5wdXNoKG4pO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgbiA9IG51bWJlcnNbaV07XG4gICAgaWYgKGkgPT0gcGFydHNMZW5ndGggLSAxKSB7XG4gICAgICBpZiAobiA+PSBwb3coMjU2LCA1IC0gcGFydHNMZW5ndGgpKSByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG4gPiAyNTUpIHJldHVybiBudWxsO1xuICB9XG4gIGlwdjQgPSBudW1iZXJzLnBvcCgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgIGlwdjQgKz0gbnVtYmVyc1tpXSAqIHBvdygyNTYsIDMgLSBpKTtcbiAgfVxuICByZXR1cm4gaXB2NDtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xudmFyIHBhcnNlSVB2NiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgYWRkcmVzcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgdmFyIHBpZWNlSW5kZXggPSAwO1xuICB2YXIgY29tcHJlc3MgPSBudWxsO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciB2YWx1ZSwgbGVuZ3RoLCBudW1iZXJzU2VlbiwgaXB2NFBpZWNlLCBudW1iZXIsIHN3YXBzLCBzd2FwO1xuXG4gIHZhciBjaGFyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnB1dC5jaGFyQXQocG9pbnRlcik7XG4gIH07XG5cbiAgaWYgKGNoYXIoKSA9PSAnOicpIHtcbiAgICBpZiAoaW5wdXQuY2hhckF0KDEpICE9ICc6JykgcmV0dXJuO1xuICAgIHBvaW50ZXIgKz0gMjtcbiAgICBwaWVjZUluZGV4Kys7XG4gICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICB9XG4gIHdoaWxlIChjaGFyKCkpIHtcbiAgICBpZiAocGllY2VJbmRleCA9PSA4KSByZXR1cm47XG4gICAgaWYgKGNoYXIoKSA9PSAnOicpIHtcbiAgICAgIGlmIChjb21wcmVzcyAhPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgcGllY2VJbmRleCsrO1xuICAgICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gbGVuZ3RoID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoIDwgNCAmJiBIRVgudGVzdChjaGFyKCkpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogMTYgKyBwYXJzZUludChjaGFyKCksIDE2KTtcbiAgICAgIHBvaW50ZXIrKztcbiAgICAgIGxlbmd0aCsrO1xuICAgIH1cbiAgICBpZiAoY2hhcigpID09ICcuJykge1xuICAgICAgaWYgKGxlbmd0aCA9PSAwKSByZXR1cm47XG4gICAgICBwb2ludGVyIC09IGxlbmd0aDtcbiAgICAgIGlmIChwaWVjZUluZGV4ID4gNikgcmV0dXJuO1xuICAgICAgbnVtYmVyc1NlZW4gPSAwO1xuICAgICAgd2hpbGUgKGNoYXIoKSkge1xuICAgICAgICBpcHY0UGllY2UgPSBudWxsO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPiAwKSB7XG4gICAgICAgICAgaWYgKGNoYXIoKSA9PSAnLicgJiYgbnVtYmVyc1NlZW4gPCA0KSBwb2ludGVyKys7XG4gICAgICAgICAgZWxzZSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFESUdJVC50ZXN0KGNoYXIoKSkpIHJldHVybjtcbiAgICAgICAgd2hpbGUgKERJR0lULnRlc3QoY2hhcigpKSkge1xuICAgICAgICAgIG51bWJlciA9IHBhcnNlSW50KGNoYXIoKSwgMTApO1xuICAgICAgICAgIGlmIChpcHY0UGllY2UgPT09IG51bGwpIGlwdjRQaWVjZSA9IG51bWJlcjtcbiAgICAgICAgICBlbHNlIGlmIChpcHY0UGllY2UgPT0gMCkgcmV0dXJuO1xuICAgICAgICAgIGVsc2UgaXB2NFBpZWNlID0gaXB2NFBpZWNlICogMTAgKyBudW1iZXI7XG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA+IDI1NSkgcmV0dXJuO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzW3BpZWNlSW5kZXhdID0gYWRkcmVzc1twaWVjZUluZGV4XSAqIDI1NiArIGlwdjRQaWVjZTtcbiAgICAgICAgbnVtYmVyc1NlZW4rKztcbiAgICAgICAgaWYgKG51bWJlcnNTZWVuID09IDIgfHwgbnVtYmVyc1NlZW4gPT0gNCkgcGllY2VJbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKG51bWJlcnNTZWVuICE9IDQpIHJldHVybjtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2hhcigpID09ICc6Jykge1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgaWYgKCFjaGFyKCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGNoYXIoKSkgcmV0dXJuO1xuICAgIGFkZHJlc3NbcGllY2VJbmRleCsrXSA9IHZhbHVlO1xuICB9XG4gIGlmIChjb21wcmVzcyAhPT0gbnVsbCkge1xuICAgIHN3YXBzID0gcGllY2VJbmRleCAtIGNvbXByZXNzO1xuICAgIHBpZWNlSW5kZXggPSA3O1xuICAgIHdoaWxlIChwaWVjZUluZGV4ICE9IDAgJiYgc3dhcHMgPiAwKSB7XG4gICAgICBzd2FwID0gYWRkcmVzc1twaWVjZUluZGV4XTtcbiAgICAgIGFkZHJlc3NbcGllY2VJbmRleC0tXSA9IGFkZHJlc3NbY29tcHJlc3MgKyBzd2FwcyAtIDFdO1xuICAgICAgYWRkcmVzc1tjb21wcmVzcyArIC0tc3dhcHNdID0gc3dhcDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGllY2VJbmRleCAhPSA4KSByZXR1cm47XG4gIHJldHVybiBhZGRyZXNzO1xufTtcblxudmFyIGZpbmRMb25nZXN0WmVyb1NlcXVlbmNlID0gZnVuY3Rpb24gKGlwdjYpIHtcbiAgdmFyIG1heEluZGV4ID0gbnVsbDtcbiAgdmFyIG1heExlbmd0aCA9IDE7XG4gIHZhciBjdXJyU3RhcnQgPSBudWxsO1xuICB2YXIgY3Vyckxlbmd0aCA9IDA7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCA4OyBpKyspIHtcbiAgICBpZiAoaXB2NltpXSAhPT0gMCkge1xuICAgICAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gICAgICB9XG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xuICAgICAgY3Vyckxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIGN1cnJTdGFydCA9IGk7XG4gICAgICArK2N1cnJMZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgbWF4TGVuZ3RoID0gY3Vyckxlbmd0aDtcbiAgfVxuICByZXR1cm4gbWF4SW5kZXg7XG59O1xuXG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIHZhciByZXN1bHQsIGksIGNvbXByZXNzLCBpZ25vcmUwO1xuICAvLyBpcHY0XG4gIGlmICh0eXBlb2YgaG9zdCA9PSAnbnVtYmVyJykge1xuICAgIHJlc3VsdCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHJlc3VsdC51bnNoaWZ0KGhvc3QgJSAyNTYpO1xuICAgICAgaG9zdCA9IE1hdGguZmxvb3IoaG9zdCAvIDI1Nik7XG4gICAgfSByZXR1cm4gcmVzdWx0LmpvaW4oJy4nKTtcbiAgLy8gaXB2NlxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09ICdvYmplY3QnKSB7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICBpZiAoaWdub3JlMCAmJiBob3N0W2ldID09PSAwKSBjb250aW51ZTtcbiAgICAgIGlmIChpZ25vcmUwKSBpZ25vcmUwID0gZmFsc2U7XG4gICAgICBpZiAoY29tcHJlc3MgPT09IGkpIHtcbiAgICAgICAgcmVzdWx0ICs9IGkgPyAnOicgOiAnOjonO1xuICAgICAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBob3N0W2ldLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGkgPCA3KSByZXN1bHQgKz0gJzonO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1snICsgcmVzdWx0ICsgJ10nO1xuICB9IHJldHVybiBob3N0O1xufTtcblxudmFyIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQgPSB7fTtcbnZhciBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJyAnOiAxLCAnXCInOiAxLCAnPCc6IDEsICc+JzogMSwgJ2AnOiAxXG59KTtcbnZhciBwYXRoUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcjJzogMSwgJz8nOiAxLCAneyc6IDEsICd9JzogMVxufSk7XG52YXIgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBwYXRoUGVyY2VudEVuY29kZVNldCwge1xuICAnLyc6IDEsICc6JzogMSwgJzsnOiAxLCAnPSc6IDEsICdAJzogMSwgJ1snOiAxLCAnXFxcXCc6IDEsICddJzogMSwgJ14nOiAxLCAnfCc6IDFcbn0pO1xuXG52YXIgcGVyY2VudEVuY29kZSA9IGZ1bmN0aW9uIChjaGFyLCBzZXQpIHtcbiAgdmFyIGNvZGUgPSBjb2RlUG9pbnRBdChjaGFyLCAwKTtcbiAgcmV0dXJuIGNvZGUgPiAweDIwICYmIGNvZGUgPCAweDdGICYmICFoYXMoc2V0LCBjaGFyKSA/IGNoYXIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hhcik7XG59O1xuXG52YXIgc3BlY2lhbFNjaGVtZXMgPSB7XG4gIGZ0cDogMjEsXG4gIGZpbGU6IG51bGwsXG4gIGdvcGhlcjogNzAsXG4gIGh0dHA6IDgwLFxuICBodHRwczogNDQzLFxuICB3czogODAsXG4gIHdzczogNDQzXG59O1xuXG52YXIgaXNTcGVjaWFsID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gaGFzKHNwZWNpYWxTY2hlbWVzLCB1cmwuc2NoZW1lKTtcbn07XG5cbnZhciBpbmNsdWRlc0NyZWRlbnRpYWxzID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gdXJsLnVzZXJuYW1lICE9ICcnIHx8IHVybC5wYXNzd29yZCAhPSAnJztcbn07XG5cbnZhciBjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQgPSBmdW5jdGlvbiAodXJsKSB7XG4gIHJldHVybiAhdXJsLmhvc3QgfHwgdXJsLmNhbm5vdEJlQUJhc2VVUkwgfHwgdXJsLnNjaGVtZSA9PSAnZmlsZSc7XG59O1xuXG52YXIgaXNXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nLCBub3JtYWxpemVkKSB7XG4gIHZhciBzZWNvbmQ7XG4gIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgQUxQSEEudGVzdChzdHJpbmcuY2hhckF0KDApKVxuICAgICYmICgoc2Vjb25kID0gc3RyaW5nLmNoYXJBdCgxKSkgPT0gJzonIHx8ICghbm9ybWFsaXplZCAmJiBzZWNvbmQgPT0gJ3wnKSk7XG59O1xuXG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHRoaXJkO1xuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nLnNsaWNlKDAsIDIpKSAmJiAoXG4gICAgc3RyaW5nLmxlbmd0aCA9PSAyIHx8XG4gICAgKCh0aGlyZCA9IHN0cmluZy5jaGFyQXQoMikpID09PSAnLycgfHwgdGhpcmQgPT09ICdcXFxcJyB8fCB0aGlyZCA9PT0gJz8nIHx8IHRoaXJkID09PSAnIycpXG4gICk7XG59O1xuXG52YXIgc2hvcnRlblVSTHNQYXRoID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgcGF0aCA9IHVybC5wYXRoO1xuICB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcbiAgaWYgKHBhdGhTaXplICYmICh1cmwuc2NoZW1lICE9ICdmaWxlJyB8fCBwYXRoU2l6ZSAhPSAxIHx8ICFpc1dpbmRvd3NEcml2ZUxldHRlcihwYXRoWzBdLCB0cnVlKSkpIHtcbiAgICBwYXRoLnBvcCgpO1xuICB9XG59O1xuXG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4nIHx8IHNlZ21lbnQudG9Mb3dlckNhc2UoKSA9PT0gJyUyZSc7XG59O1xuXG52YXIgaXNEb3VibGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICBzZWdtZW50ID0gc2VnbWVudC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4uJyB8fCBzZWdtZW50ID09PSAnJTJlLicgfHwgc2VnbWVudCA9PT0gJy4lMmUnIHx8IHNlZ21lbnQgPT09ICclMmUlMmUnO1xufTtcblxuLy8gU3RhdGVzOlxudmFyIFNDSEVNRV9TVEFSVCA9IHt9O1xudmFyIFNDSEVNRSA9IHt9O1xudmFyIE5PX1NDSEVNRSA9IHt9O1xudmFyIFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUEFUSF9PUl9BVVRIT1JJVFkgPSB7fTtcbnZhciBSRUxBVElWRSA9IHt9O1xudmFyIFJFTEFUSVZFX1NMQVNIID0ge307XG52YXIgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUyA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTID0ge307XG52YXIgQVVUSE9SSVRZID0ge307XG52YXIgSE9TVCA9IHt9O1xudmFyIEhPU1ROQU1FID0ge307XG52YXIgUE9SVCA9IHt9O1xudmFyIEZJTEUgPSB7fTtcbnZhciBGSUxFX1NMQVNIID0ge307XG52YXIgRklMRV9IT1NUID0ge307XG52YXIgUEFUSF9TVEFSVCA9IHt9O1xudmFyIFBBVEggPSB7fTtcbnZhciBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIID0ge307XG52YXIgUVVFUlkgPSB7fTtcbnZhciBGUkFHTUVOVCA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbnZhciBwYXJzZVVSTCA9IGZ1bmN0aW9uICh1cmwsIGlucHV0LCBzdGF0ZU92ZXJyaWRlLCBiYXNlKSB7XG4gIHZhciBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgfHwgU0NIRU1FX1NUQVJUO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciBidWZmZXIgPSAnJztcbiAgdmFyIHNlZW5BdCA9IGZhbHNlO1xuICB2YXIgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgdmFyIHNlZW5QYXNzd29yZFRva2VuID0gZmFsc2U7XG4gIHZhciBjb2RlUG9pbnRzLCBjaGFyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuXG4gIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICB1cmwudXNlcm5hbWUgPSAnJztcbiAgICB1cmwucGFzc3dvcmQgPSAnJztcbiAgICB1cmwuaG9zdCA9IG51bGw7XG4gICAgdXJsLnBvcnQgPSBudWxsO1xuICAgIHVybC5wYXRoID0gW107XG4gICAgdXJsLnF1ZXJ5ID0gbnVsbDtcbiAgICB1cmwuZnJhZ21lbnQgPSBudWxsO1xuICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gZmFsc2U7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UsICcnKTtcbiAgfVxuXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZShUQUJfQU5EX05FV19MSU5FLCAnJyk7XG5cbiAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG5cbiAgd2hpbGUgKHBvaW50ZXIgPD0gY29kZVBvaW50cy5sZW5ndGgpIHtcbiAgICBjaGFyID0gY29kZVBvaW50c1twb2ludGVyXTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFNDSEVNRV9TVEFSVDpcbiAgICAgICAgaWYgKGNoYXIgJiYgQUxQSEEudGVzdChjaGFyKSkge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgc3RhdGUgPSBTQ0hFTUU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU0NIRU1FOlxuICAgICAgICBpZiAoY2hhciAmJiAoQUxQSEFOVU1FUklDLnRlc3QoY2hhcikgfHwgY2hhciA9PSAnKycgfHwgY2hhciA9PSAnLScgfHwgY2hhciA9PSAnLicpKSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc6Jykge1xuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIChpc1NwZWNpYWwodXJsKSAhPSBoYXMoc3BlY2lhbFNjaGVtZXMsIGJ1ZmZlcikpIHx8XG4gICAgICAgICAgICAgIChidWZmZXIgPT0gJ2ZpbGUnICYmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKSB8fFxuICAgICAgICAgICAgICAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5ob3N0KVxuICAgICAgICAgICAgKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHVybC5zY2hlbWUgPSBidWZmZXI7XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChpc1NwZWNpYWwodXJsKSAmJiBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSA9PSB1cmwucG9ydCkgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpICYmIGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gdXJsLnNjaGVtZSkge1xuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgc3RhdGUgPSBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgIHBvaW50ZXIgPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBOT19TQ0hFTUU6XG4gICAgICAgIGlmICghYmFzZSB8fCAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNoYXIgIT0gJyMnKSkgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICBpZiAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IGJhc2Uuc2NoZW1lID09ICdmaWxlJyA/IEZJTEUgOiBSRUxBVElWRTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk6XG4gICAgICAgIGlmIChjaGFyID09ICcvJyAmJiBjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcbiAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFBBVEhfT1JfQVVUSE9SSVRZOlxuICAgICAgICBpZiAoY2hhciA9PSAnLycpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUxBVElWRTpcbiAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICBpZiAoY2hhciA9PSBFT0YpIHtcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJy8nIHx8IChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkpIHtcbiAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFX1NMQVNIO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICB1cmwucGF0aC5wb3AoKTtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVMQVRJVkVfU0xBU0g6XG4gICAgICAgIGlmIChpc1NwZWNpYWwodXJsKSAmJiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpKSB7XG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcvJykge1xuICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcbiAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgaWYgKGNoYXIgIT0gJy8nIHx8IGJ1ZmZlci5jaGFyQXQocG9pbnRlciArIDEpICE9ICcvJykgY29udGludWU7XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiBjaGFyICE9ICdcXFxcJykge1xuICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIEFVVEhPUklUWTpcbiAgICAgICAgaWYgKGNoYXIgPT0gJ0AnKSB7XG4gICAgICAgICAgaWYgKHNlZW5BdCkgYnVmZmVyID0gJyU0MCcgKyBidWZmZXI7XG4gICAgICAgICAgc2VlbkF0ID0gdHJ1ZTtcbiAgICAgICAgICBidWZmZXJDb2RlUG9pbnRzID0gYXJyYXlGcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJDb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gYnVmZmVyQ29kZVBvaW50c1tpXTtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gJzonICYmICFzZWVuUGFzc3dvcmRUb2tlbikge1xuICAgICAgICAgICAgICBzZWVuUGFzc3dvcmRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVuY29kZWRDb2RlUG9pbnRzID0gcGVyY2VudEVuY29kZShjb2RlUG9pbnQsIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgICBpZiAoc2VlblBhc3N3b3JkVG9rZW4pIHVybC5wYXNzd29yZCArPSBlbmNvZGVkQ29kZVBvaW50cztcbiAgICAgICAgICAgIGVsc2UgdXJsLnVzZXJuYW1lICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fFxuICAgICAgICAgIChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHNlZW5BdCAmJiBidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0FVVEhPUklUWTtcbiAgICAgICAgICBwb2ludGVyIC09IGFycmF5RnJvbShidWZmZXIpLmxlbmd0aCArIDE7XG4gICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBIT1NUO1xuICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhPU1Q6XG4gICAgICBjYXNlIEhPU1ROQU1FOlxuICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiB1cmwuc2NoZW1lID09ICdmaWxlJykge1xuICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgICAgICAgIGlmIChidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICAgICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XG4gICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gUE9SVDtcbiAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSA9PSBIT1NUTkFNRSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnIHx8XG4gICAgICAgICAgKGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIGJ1ZmZlciA9PSAnJyAmJiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgcmV0dXJuO1xuICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hhciA9PSAnWycpIHNlZW5CcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICBlbHNlIGlmIChjaGFyID09ICddJykgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBQT1JUOlxuICAgICAgICBpZiAoRElHSVQudGVzdChjaGFyKSkge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnIHx8XG4gICAgICAgICAgKGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpKSB8fFxuICAgICAgICAgIHN0YXRlT3ZlcnJpZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICAgICAgICAgdmFyIHBvcnQgPSBwYXJzZUludChidWZmZXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChwb3J0ID4gMHhGRkZGKSByZXR1cm4gSU5WQUxJRF9QT1JUO1xuICAgICAgICAgICAgdXJsLnBvcnQgPSAoaXNTcGVjaWFsKHVybCkgJiYgcG9ydCA9PT0gc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0pID8gbnVsbCA6IHBvcnQ7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gSU5WQUxJRF9QT1JUO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGSUxFOlxuICAgICAgICB1cmwuc2NoZW1lID0gJ2ZpbGUnO1xuICAgICAgICBpZiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpIHN0YXRlID0gRklMRV9TTEFTSDtcbiAgICAgICAgZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICBpZiAoY2hhciA9PSBFT0YpIHtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgICAgc2hvcnRlblVSTHNQYXRoKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIEZJTEVfU0xBU0g6XG4gICAgICAgIGlmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJykge1xuICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlICYmIGJhc2Uuc2NoZW1lID09ICdmaWxlJyAmJiAhc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgICAgICAgIGlmIChpc1dpbmRvd3NEcml2ZUxldHRlcihiYXNlLnBhdGhbMF0sIHRydWUpKSB1cmwucGF0aC5wdXNoKGJhc2UucGF0aFswXSk7XG4gICAgICAgICAgZWxzZSB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIEZJTEVfSE9TVDpcbiAgICAgICAgaWYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PSAnJykge1xuICAgICAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgaWYgKHVybC5ob3N0ID09ICdsb2NhbGhvc3QnKSB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgIH0gY29udGludWU7XG4gICAgICAgIH0gZWxzZSBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUEFUSF9TVEFSVDpcbiAgICAgICAgaWYgKGlzU3BlY2lhbCh1cmwpKSB7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiBjaGFyICE9ICdcXFxcJykgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnPycpIHtcbiAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyICE9IEVPRikge1xuICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICBpZiAoY2hhciAhPSAnLycpIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFBBVEg6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fFxuICAgICAgICAgIChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkgfHxcbiAgICAgICAgICAoIXN0YXRlT3ZlcnJpZGUgJiYgKGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGlzRG91YmxlRG90KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHNob3J0ZW5VUkxzUGF0aCh1cmwpO1xuICAgICAgICAgICAgaWYgKGNoYXIgIT0gJy8nICYmICEoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICAgICAgICAgaWYgKGNoYXIgIT0gJy8nICYmICEoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5wYXRoLmxlbmd0aCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICAgIGlmICh1cmwuaG9zdCkgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmNoYXJBdCgwKSArICc6JzsgLy8gbm9ybWFsaXplIHdpbmRvd3MgZHJpdmUgbGV0dGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwucGF0aC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAoY2hhciA9PSBFT0YgfHwgY2hhciA9PSAnPycgfHwgY2hhciA9PSAnIycpKSB7XG4gICAgICAgICAgICB3aGlsZSAodXJsLnBhdGgubGVuZ3RoID4gMSAmJiB1cmwucGF0aFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgdXJsLnBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXIgKz0gcGVyY2VudEVuY29kZShjaGFyLCBwYXRoUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDpcbiAgICAgICAgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xuICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcbiAgICAgICAgICB1cmwucGF0aFswXSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFFVRVJZOlxuICAgICAgICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnIycpIHtcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgIT0gRU9GKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT0gXCInXCIgJiYgaXNTcGVjaWFsKHVybCkpIHVybC5xdWVyeSArPSAnJTI3JztcbiAgICAgICAgICBlbHNlIGlmIChjaGFyID09ICcjJykgdXJsLnF1ZXJ5ICs9ICclMjMnO1xuICAgICAgICAgIGVsc2UgdXJsLnF1ZXJ5ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgRlJBR01FTlQ6XG4gICAgICAgIGlmIChjaGFyICE9IEVPRikgdXJsLmZyYWdtZW50ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9pbnRlcisrO1xuICB9XG59O1xuXG4vLyBgVVJMYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtY2xhc3NcbnZhciBVUkxDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTCh1cmwgLyogLCBiYXNlICovKSB7XG4gIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuICB2YXIgYmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgdXJsU3RyaW5nID0gU3RyaW5nKHVybCk7XG4gIHZhciBzdGF0ZSA9IHNldEludGVybmFsU3RhdGUodGhhdCwgeyB0eXBlOiAnVVJMJyB9KTtcbiAgdmFyIGJhc2VTdGF0ZSwgZmFpbHVyZTtcbiAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChiYXNlIGluc3RhbmNlb2YgVVJMQ29uc3RydWN0b3IpIGJhc2VTdGF0ZSA9IGdldEludGVybmFsVVJMU3RhdGUoYmFzZSk7XG4gICAgZWxzZSB7XG4gICAgICBmYWlsdXJlID0gcGFyc2VVUkwoYmFzZVN0YXRlID0ge30sIFN0cmluZyhiYXNlKSk7XG4gICAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xuICAgIH1cbiAgfVxuICBmYWlsdXJlID0gcGFyc2VVUkwoc3RhdGUsIHVybFN0cmluZywgbnVsbCwgYmFzZVN0YXRlKTtcbiAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvcihmYWlsdXJlKTtcbiAgdmFyIHNlYXJjaFBhcmFtcyA9IHN0YXRlLnNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgdmFyIHNlYXJjaFBhcmFtc1N0YXRlID0gZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZShzZWFyY2hQYXJhbXMpO1xuICBzZWFyY2hQYXJhbXNTdGF0ZS51cGRhdGVTZWFyY2hQYXJhbXMoc3RhdGUucXVlcnkpO1xuICBzZWFyY2hQYXJhbXNTdGF0ZS51cGRhdGVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdGUucXVlcnkgPSBTdHJpbmcoc2VhcmNoUGFyYW1zKSB8fCBudWxsO1xuICB9O1xuICBpZiAoIURFU0NSSVBUT1JTKSB7XG4gICAgdGhhdC5ocmVmID0gc2VyaWFsaXplVVJMLmNhbGwodGhhdCk7XG4gICAgdGhhdC5vcmlnaW4gPSBnZXRPcmlnaW4uY2FsbCh0aGF0KTtcbiAgICB0aGF0LnByb3RvY29sID0gZ2V0UHJvdG9jb2wuY2FsbCh0aGF0KTtcbiAgICB0aGF0LnVzZXJuYW1lID0gZ2V0VXNlcm5hbWUuY2FsbCh0aGF0KTtcbiAgICB0aGF0LnBhc3N3b3JkID0gZ2V0UGFzc3dvcmQuY2FsbCh0aGF0KTtcbiAgICB0aGF0Lmhvc3QgPSBnZXRIb3N0LmNhbGwodGhhdCk7XG4gICAgdGhhdC5ob3N0bmFtZSA9IGdldEhvc3RuYW1lLmNhbGwodGhhdCk7XG4gICAgdGhhdC5wb3J0ID0gZ2V0UG9ydC5jYWxsKHRoYXQpO1xuICAgIHRoYXQucGF0aG5hbWUgPSBnZXRQYXRobmFtZS5jYWxsKHRoYXQpO1xuICAgIHRoYXQuc2VhcmNoID0gZ2V0U2VhcmNoLmNhbGwodGhhdCk7XG4gICAgdGhhdC5zZWFyY2hQYXJhbXMgPSBnZXRTZWFyY2hQYXJhbXMuY2FsbCh0aGF0KTtcbiAgICB0aGF0Lmhhc2ggPSBnZXRIYXNoLmNhbGwodGhhdCk7XG4gIH1cbn07XG5cbnZhciBVUkxQcm90b3R5cGUgPSBVUkxDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBzZXJpYWxpemVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgc2NoZW1lID0gdXJsLnNjaGVtZTtcbiAgdmFyIHVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuICB2YXIgcGFzc3dvcmQgPSB1cmwucGFzc3dvcmQ7XG4gIHZhciBob3N0ID0gdXJsLmhvc3Q7XG4gIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gIHZhciBxdWVyeSA9IHVybC5xdWVyeTtcbiAgdmFyIGZyYWdtZW50ID0gdXJsLmZyYWdtZW50O1xuICB2YXIgb3V0cHV0ID0gc2NoZW1lICsgJzonO1xuICBpZiAoaG9zdCAhPT0gbnVsbCkge1xuICAgIG91dHB1dCArPSAnLy8nO1xuICAgIGlmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkpIHtcbiAgICAgIG91dHB1dCArPSB1c2VybmFtZSArIChwYXNzd29yZCA/ICc6JyArIHBhc3N3b3JkIDogJycpICsgJ0AnO1xuICAgIH1cbiAgICBvdXRwdXQgKz0gc2VyaWFsaXplSG9zdChob3N0KTtcbiAgICBpZiAocG9ydCAhPT0gbnVsbCkgb3V0cHV0ICs9ICc6JyArIHBvcnQ7XG4gIH0gZWxzZSBpZiAoc2NoZW1lID09ICdmaWxlJykgb3V0cHV0ICs9ICcvLyc7XG4gIG91dHB1dCArPSB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIHBhdGguam9pbignLycpIDogJyc7XG4gIGlmIChxdWVyeSAhPT0gbnVsbCkgb3V0cHV0ICs9ICc/JyArIHF1ZXJ5O1xuICBpZiAoZnJhZ21lbnQgIT09IG51bGwpIG91dHB1dCArPSAnIycgKyBmcmFnbWVudDtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgc2NoZW1lID0gdXJsLnNjaGVtZTtcbiAgdmFyIHBvcnQgPSB1cmwucG9ydDtcbiAgaWYgKHNjaGVtZSA9PSAnYmxvYicpIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc2NoZW1lLnBhdGhbMF0pLm9yaWdpbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmIChzY2hlbWUgPT0gJ2ZpbGUnIHx8ICFpc1NwZWNpYWwodXJsKSkgcmV0dXJuICdudWxsJztcbiAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgc2VyaWFsaXplSG9zdCh1cmwuaG9zdCkgKyAocG9ydCAhPT0gbnVsbCA/ICc6JyArIHBvcnQgOiAnJyk7XG59O1xuXG52YXIgZ2V0UHJvdG9jb2wgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNjaGVtZSArICc6Jztcbn07XG5cbnZhciBnZXRVc2VybmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykudXNlcm5hbWU7XG59O1xuXG52YXIgZ2V0UGFzc3dvcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnBhc3N3b3JkO1xufTtcblxudmFyIGdldEhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgaG9zdCA9IHVybC5ob3N0O1xuICB2YXIgcG9ydCA9IHVybC5wb3J0O1xuICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnXG4gICAgOiBwb3J0ID09PSBudWxsID8gc2VyaWFsaXplSG9zdChob3N0KVxuICAgIDogc2VyaWFsaXplSG9zdChob3N0KSArICc6JyArIHBvcnQ7XG59O1xuXG52YXIgZ2V0SG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBob3N0ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5ob3N0O1xuICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnIDogc2VyaWFsaXplSG9zdChob3N0KTtcbn07XG5cbnZhciBnZXRQb3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcG9ydCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykucG9ydDtcbiAgcmV0dXJuIHBvcnQgPT09IG51bGwgPyAnJyA6IFN0cmluZyhwb3J0KTtcbn07XG5cbnZhciBnZXRQYXRobmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gIHJldHVybiB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIHBhdGguam9pbignLycpIDogJyc7XG59O1xuXG52YXIgZ2V0U2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnF1ZXJ5O1xuICByZXR1cm4gcXVlcnkgPyAnPycgKyBxdWVyeSA6ICcnO1xufTtcblxudmFyIGdldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykuc2VhcmNoUGFyYW1zO1xufTtcblxudmFyIGdldEhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmcmFnbWVudCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykuZnJhZ21lbnQ7XG4gIHJldHVybiBmcmFnbWVudCA/ICcjJyArIGZyYWdtZW50IDogJyc7XG59O1xuXG52YXIgYWNjZXNzb3JEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGdldHRlciwgc2V0dGVyKSB7XG4gIHJldHVybiB7IGdldDogZ2V0dGVyLCBzZXQ6IHNldHRlciwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgZGVmaW5lUHJvcGVydGllcyhVUkxQcm90b3R5cGUsIHtcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ocmVmYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ocmVmXG4gICAgaHJlZjogYWNjZXNzb3JEZXNjcmlwdG9yKHNlcmlhbGl6ZVVSTCwgZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgdmFyIHVybFN0cmluZyA9IFN0cmluZyhocmVmKTtcbiAgICAgIHZhciBmYWlsdXJlID0gcGFyc2VVUkwodXJsLCB1cmxTdHJpbmcpO1xuICAgICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvcihmYWlsdXJlKTtcbiAgICAgIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUodXJsLnNlYXJjaFBhcmFtcykudXBkYXRlU2VhcmNoUGFyYW1zKHVybC5xdWVyeSk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUub3JpZ2luYCBnZXR0ZXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gICAgb3JpZ2luOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0T3JpZ2luKSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wcm90b2NvbGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgICBwcm90b2NvbDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFByb3RvY29sLCBmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgcGFyc2VVUkwodXJsLCBTdHJpbmcocHJvdG9jb2wpICsgJzonLCBTQ0hFTUVfU1RBUlQpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnVzZXJuYW1lYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICAgIHVzZXJuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0VXNlcm5hbWUsIGZ1bmN0aW9uICh1c2VybmFtZSkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICB2YXIgY29kZVBvaW50cyA9IGFycmF5RnJvbShTdHJpbmcodXNlcm5hbWUpKTtcbiAgICAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSkgcmV0dXJuO1xuICAgICAgdXJsLnVzZXJuYW1lID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXJsLnVzZXJuYW1lICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wYXNzd29yZGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGFzc3dvcmRcbiAgICBwYXNzd29yZDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBhc3N3b3JkLCBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oU3RyaW5nKHBhc3N3b3JkKSk7XG4gICAgICBpZiAoY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KHVybCkpIHJldHVybjtcbiAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVybC5wYXNzd29yZCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdFxuICAgIGhvc3Q6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRIb3N0LCBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICBpZiAodXJsLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKGhvc3QpLCBIT1NUKTtcbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ob3N0bmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgICBob3N0bmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhvc3RuYW1lLCBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XG4gICAgICBwYXJzZVVSTCh1cmwsIFN0cmluZyhob3N0bmFtZSksIEhPU1ROQU1FKTtcbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wb3J0YCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wb3J0XG4gICAgcG9ydDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBvcnQsIGZ1bmN0aW9uIChwb3J0KSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSkgcmV0dXJuO1xuICAgICAgcG9ydCA9IFN0cmluZyhwb3J0KTtcbiAgICAgIGlmIChwb3J0ID09ICcnKSB1cmwucG9ydCA9IG51bGw7XG4gICAgICBlbHNlIHBhcnNlVVJMKHVybCwgcG9ydCwgUE9SVCk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucGF0aG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhdGhuYW1lXG4gICAgcGF0aG5hbWU6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQYXRobmFtZSwgZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIGlmICh1cmwuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xuICAgICAgdXJsLnBhdGggPSBbXTtcbiAgICAgIHBhcnNlVVJMKHVybCwgcGF0aG5hbWUgKyAnJywgUEFUSF9TVEFSVCk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuc2VhcmNoYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hcbiAgICBzZWFyY2g6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRTZWFyY2gsIGZ1bmN0aW9uIChzZWFyY2gpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgc2VhcmNoID0gU3RyaW5nKHNlYXJjaCk7XG4gICAgICBpZiAoc2VhcmNoID09ICcnKSB7XG4gICAgICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJz8nID09IHNlYXJjaC5jaGFyQXQoMCkpIHNlYXJjaCA9IHNlYXJjaC5zbGljZSgxKTtcbiAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgIHBhcnNlVVJMKHVybCwgc2VhcmNoLCBRVUVSWSk7XG4gICAgICB9XG4gICAgICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaFBhcmFtc2AgZ2V0dGVyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xuICAgIHNlYXJjaFBhcmFtczogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFNlYXJjaFBhcmFtcyksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaGFzaGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICAgIGhhc2g6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRIYXNoLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICBoYXNoID0gU3RyaW5nKGhhc2gpO1xuICAgICAgaWYgKGhhc2ggPT0gJycpIHtcbiAgICAgICAgdXJsLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCcjJyA9PSBoYXNoLmNoYXJBdCgwKSkgaGFzaCA9IGhhc2guc2xpY2UoMSk7XG4gICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgIHBhcnNlVVJMKHVybCwgaGFzaCwgRlJBR01FTlQpO1xuICAgIH0pXG4gIH0pO1xufVxuXG4vLyBgVVJMLnByb3RvdHlwZS50b0pTT05gIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXRvanNvblxucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9KU09OJywgZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gc2VyaWFsaXplVVJMLmNhbGwodGhpcyk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8vIGBVUkwucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jVVJMLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZVVSTC5jYWxsKHRoaXMpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5pZiAoTmF0aXZlVVJMKSB7XG4gIHZhciBuYXRpdmVDcmVhdGVPYmplY3RVUkwgPSBOYXRpdmVVUkwuY3JlYXRlT2JqZWN0VVJMO1xuICB2YXIgbmF0aXZlUmV2b2tlT2JqZWN0VVJMID0gTmF0aXZlVVJMLnJldm9rZU9iamVjdFVSTDtcbiAgLy8gYFVSTC5jcmVhdGVPYmplY3RVUkxgIG1ldGhvZFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML2NyZWF0ZU9iamVjdFVSTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgaWYgKG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCkgcmVkZWZpbmUoVVJMQ29uc3RydWN0b3IsICdjcmVhdGVPYmplY3RVUkwnLCBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkwoYmxvYikge1xuICAgIHJldHVybiBuYXRpdmVDcmVhdGVPYmplY3RVUkwuYXBwbHkoTmF0aXZlVVJMLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgLy8gYFVSTC5yZXZva2VPYmplY3RVUkxgIG1ldGhvZFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML3Jldm9rZU9iamVjdFVSTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgaWYgKG5hdGl2ZVJldm9rZU9iamVjdFVSTCkgcmVkZWZpbmUoVVJMQ29uc3RydWN0b3IsICdyZXZva2VPYmplY3RVUkwnLCBmdW5jdGlvbiByZXZva2VPYmplY3RVUkwodXJsKSB7XG4gICAgcmV0dXJuIG5hdGl2ZVJldm9rZU9iamVjdFVSTC5hcHBseShOYXRpdmVVUkwsIGFyZ3VtZW50cyk7XG4gIH0pO1xufVxuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKShVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBVUkw6IFVSTENvbnN0cnVjdG9yXG59KTtcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5KU0VuY3J5cHQgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbmZ1bmN0aW9uIGludDJjaGFyKG4pIHtcbiAgICByZXR1cm4gQklfUk0uY2hhckF0KG4pO1xufVxuLy8jcmVnaW9uIEJJVF9PUEVSQVRJT05TXG4vLyAocHVibGljKSB0aGlzICYgYVxuZnVuY3Rpb24gb3BfYW5kKHgsIHkpIHtcbiAgICByZXR1cm4geCAmIHk7XG59XG4vLyAocHVibGljKSB0aGlzIHwgYVxuZnVuY3Rpb24gb3Bfb3IoeCwgeSkge1xuICAgIHJldHVybiB4IHwgeTtcbn1cbi8vIChwdWJsaWMpIHRoaXMgXiBhXG5mdW5jdGlvbiBvcF94b3IoeCwgeSkge1xuICAgIHJldHVybiB4IF4geTtcbn1cbi8vIChwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgsIHkpIHtcbiAgICByZXR1cm4geCAmIH55O1xufVxuLy8gcmV0dXJuIGluZGV4IG9mIGxvd2VzdCAxLWJpdCBpbiB4LCB4IDwgMl4zMVxuZnVuY3Rpb24gbGJpdCh4KSB7XG4gICAgaWYgKHggPT0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHggJiAweGZmZmYpID09IDApIHtcbiAgICAgICAgeCA+Pj0gMTY7XG4gICAgICAgIHIgKz0gMTY7XG4gICAgfVxuICAgIGlmICgoeCAmIDB4ZmYpID09IDApIHtcbiAgICAgICAgeCA+Pj0gODtcbiAgICAgICAgciArPSA4O1xuICAgIH1cbiAgICBpZiAoKHggJiAweGYpID09IDApIHtcbiAgICAgICAgeCA+Pj0gNDtcbiAgICAgICAgciArPSA0O1xuICAgIH1cbiAgICBpZiAoKHggJiAzKSA9PSAwKSB7XG4gICAgICAgIHggPj49IDI7XG4gICAgICAgIHIgKz0gMjtcbiAgICB9XG4gICAgaWYgKCh4ICYgMSkgPT0gMCkge1xuICAgICAgICArK3I7XG4gICAgfVxuICAgIHJldHVybiByO1xufVxuLy8gcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHdoaWxlICh4ICE9IDApIHtcbiAgICAgICAgeCAmPSB4IC0gMTtcbiAgICAgICAgKytyO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbi8vI2VuZHJlZ2lvbiBCSVRfT1BFUkFUSU9OU1xuXG52YXIgYjY0bWFwID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG52YXIgYjY0cGFkID0gXCI9XCI7XG5mdW5jdGlvbiBoZXgyYjY0KGgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYztcbiAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICBmb3IgKGkgPSAwOyBpICsgMyA8PSBoLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGMgPSBwYXJzZUludChoLnN1YnN0cmluZyhpLCBpICsgMyksIDE2KTtcbiAgICAgICAgcmV0ICs9IGI2NG1hcC5jaGFyQXQoYyA+PiA2KSArIGI2NG1hcC5jaGFyQXQoYyAmIDYzKTtcbiAgICB9XG4gICAgaWYgKGkgKyAxID09IGgubGVuZ3RoKSB7XG4gICAgICAgIGMgPSBwYXJzZUludChoLnN1YnN0cmluZyhpLCBpICsgMSksIDE2KTtcbiAgICAgICAgcmV0ICs9IGI2NG1hcC5jaGFyQXQoYyA8PCAyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaSArIDIgPT0gaC5sZW5ndGgpIHtcbiAgICAgICAgYyA9IHBhcnNlSW50KGguc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICAgICAgICByZXQgKz0gYjY0bWFwLmNoYXJBdChjID4+IDIpICsgYjY0bWFwLmNoYXJBdCgoYyAmIDMpIDw8IDQpO1xuICAgIH1cbiAgICB3aGlsZSAoKHJldC5sZW5ndGggJiAzKSA+IDApIHtcbiAgICAgICAgcmV0ICs9IGI2NHBhZDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIGNvbnZlcnQgYSBiYXNlNjQgc3RyaW5nIHRvIGhleFxuZnVuY3Rpb24gYjY0dG9oZXgocykge1xuICAgIHZhciByZXQgPSBcIlwiO1xuICAgIHZhciBpO1xuICAgIHZhciBrID0gMDsgLy8gYjY0IHN0YXRlLCAwLTNcbiAgICB2YXIgc2xvcCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09IGI2NHBhZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBiNjRtYXAuaW5kZXhPZihzLmNoYXJBdChpKSk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPT0gMCkge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKHYgPj4gMik7XG4gICAgICAgICAgICBzbG9wID0gdiAmIDM7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrID09IDEpIHtcbiAgICAgICAgICAgIHJldCArPSBpbnQyY2hhcigoc2xvcCA8PCAyKSB8ICh2ID4+IDQpKTtcbiAgICAgICAgICAgIHNsb3AgPSB2ICYgMHhmO1xuICAgICAgICAgICAgayA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoayA9PSAyKSB7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIoc2xvcCk7XG4gICAgICAgICAgICByZXQgKz0gaW50MmNoYXIodiA+PiAyKTtcbiAgICAgICAgICAgIHNsb3AgPSB2ICYgMztcbiAgICAgICAgICAgIGsgPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKChzbG9wIDw8IDIpIHwgKHYgPj4gNCkpO1xuICAgICAgICAgICAgcmV0ICs9IGludDJjaGFyKHYgJiAweGYpO1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGsgPT0gMSkge1xuICAgICAgICByZXQgKz0gaW50MmNoYXIoc2xvcCA8PCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vLyBIZXggSmF2YVNjcmlwdCBkZWNvZGVyXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMyBMYXBvIEx1Y2hpbmkgPGxhcG9AbGFwby5pdD5cbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcbi8vIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcbi8vIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xudmFyIGRlY29kZXI7XG52YXIgSGV4ID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChkZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBoZXggPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgICAgIHZhciBpZ25vcmUgPSBcIiBcXGZcXG5cXHJcXHRcXHUwMEEwXFx1MjAyOFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlY29kZXIgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlcltoZXguY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZXggPSBoZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDEwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJbaGV4LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlnbm9yZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXJbaWdub3JlLmNoYXJBdChpKV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHZhciBiaXRzID0gMDtcbiAgICAgICAgdmFyIGNoYXJfY291bnQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBhLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gZGVjb2RlcltjXTtcbiAgICAgICAgICAgIGlmIChjID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjaGFyYWN0ZXIgYXQgb2Zmc2V0IFwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IGM7XG4gICAgICAgICAgICBpZiAoKytjaGFyX2NvdW50ID49IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICAgIGNoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYml0cyA8PD0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcl9jb3VudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGV4IGVuY29kaW5nIGluY29tcGxldGU6IDQgYml0cyBtaXNzaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufTtcblxuLy8gQmFzZTY0IEphdmFTY3JpcHQgZGVjb2RlclxuLy8gQ29weXJpZ2h0IChjKSAyMDA4LTIwMTMgTGFwbyBMdWNoaW5pIDxsYXBvQGxhcG8uaXQ+XG4vLyBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbi8vIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbi8vIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4vLyBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4vLyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4vLyBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCBpbW1lZDogdHJ1ZSwgbGF0ZWRlZjogdHJ1ZSwgdW5kZWY6IHRydWUsIHJlZ2V4ZGFzaDogZmFsc2UgKi9cbnZhciBkZWNvZGVyJDE7XG52YXIgQmFzZTY0ID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmIChkZWNvZGVyJDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICAgICAgICAgICAgdmFyIGlnbm9yZSA9IFwiPSBcXGZcXG5cXHJcXHRcXHUwMEEwXFx1MjAyOFxcdTIwMjlcIjtcbiAgICAgICAgICAgIGRlY29kZXIkMSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlY29kZXIkMVtiNjQuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaWdub3JlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlciQxW2lnbm9yZS5jaGFyQXQoaSldID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICB2YXIgYml0cyA9IDA7XG4gICAgICAgIHZhciBjaGFyX2NvdW50ID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gYS5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9IGRlY29kZXIkMVtjXTtcbiAgICAgICAgICAgIGlmIChjID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjaGFyYWN0ZXIgYXQgb2Zmc2V0IFwiICsgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRzIHw9IGM7XG4gICAgICAgICAgICBpZiAoKytjaGFyX2NvdW50ID49IDQpIHtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiAxNik7XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IGJpdHMgJiAweEZGO1xuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgICAgIGNoYXJfY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYml0cyA8PD0gNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNoYXJfY291bnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXNlNjQgZW5jb2RpbmcgaW5jb21wbGV0ZTogYXQgbGVhc3QgMiBiaXRzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgb3V0W291dC5sZW5ndGhdID0gKGJpdHMgPj4gMTApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG91dFtvdXQubGVuZ3RoXSA9IChiaXRzID4+IDE2KTtcbiAgICAgICAgICAgICAgICBvdXRbb3V0Lmxlbmd0aF0gPSAoYml0cyA+PiA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9LFxuICAgIHJlOiAvLS0tLS1CRUdJTiBbXi1dKy0tLS0tKFtBLVphLXowLTkrXFwvPVxcc10rKS0tLS0tRU5EIFteLV0rLS0tLS18YmVnaW4tYmFzZTY0W15cXG5dK1xcbihbQS1aYS16MC05K1xcLz1cXHNdKyk9PT09LyxcbiAgICB1bmFybW9yOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgbSA9IEJhc2U2NC5yZS5leGVjKGEpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgaWYgKG1bMV0pIHtcbiAgICAgICAgICAgICAgICBhID0gbVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICBhID0gbVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ0V4cCBvdXQgb2Ygc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmFzZTY0LmRlY29kZShhKTtcbiAgICB9XG59O1xuXG4vLyBCaWcgaW50ZWdlciBiYXNlLTEwIHByaW50aW5nIGxpYnJhcnlcbi8vIENvcHlyaWdodCAoYykgMjAxNCBMYXBvIEx1Y2hpbmkgPGxhcG9AbGFwby5pdD5cbi8vIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuLy8gcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuLy8gV0lUSCBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1Jcbi8vIEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcbi8vIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST00gTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0Zcbi8vIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIGltbWVkOiB0cnVlLCBsYXRlZGVmOiB0cnVlLCB1bmRlZjogdHJ1ZSwgcmVnZXhkYXNoOiBmYWxzZSAqL1xudmFyIG1heCA9IDEwMDAwMDAwMDAwMDAwOyAvLyBiaWdnZXN0IGludGVnZXIgdGhhdCBjYW4gc3RpbGwgZml0IDJeNTMgd2hlbiBtdWx0aXBsaWVkIGJ5IDI1NlxudmFyIEludDEwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludDEwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnVmID0gWyt2YWx1ZSB8fCAwXTtcbiAgICB9XG4gICAgSW50MTAucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIChtLCBjKSB7XG4gICAgICAgIC8vIGFzc2VydChtIDw9IDI1NilcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIGwgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICB0ID0gYltpXSAqIG0gKyBjO1xuICAgICAgICAgICAgaWYgKHQgPCBtYXgpIHtcbiAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGMgPSAwIHwgKHQgLyBtYXgpO1xuICAgICAgICAgICAgICAgIHQgLT0gYyAqIG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJbaV0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID4gMCkge1xuICAgICAgICAgICAgYltpXSA9IGM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBhc3NlcnQobSA8PSAyNTYpXG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHZhciBsID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdCA9IGJbaV0gLSBjO1xuICAgICAgICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdCArPSBtYXg7XG4gICAgICAgICAgICAgICAgYyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJbaV0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChiW2IubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgICAgIGIucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgIGlmICgoYmFzZSB8fCAxMCkgIT0gMTApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9ubHkgYmFzZSAxMCBpcyBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgdmFyIHMgPSBiW2IubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHMgKz0gKG1heCArIGJbaV0pLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgSW50MTAucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5idWY7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHYgPSB2ICogbWF4ICsgYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIEludDEwLnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmJ1ZjtcbiAgICAgICAgcmV0dXJuIChiLmxlbmd0aCA9PSAxKSA/IGJbMF0gOiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEludDEwO1xufSgpKTtcblxuLy8gQVNOLjEgSmF2YVNjcmlwdCBkZWNvZGVyXG52YXIgZWxsaXBzaXMgPSBcIlxcdTIwMjZcIjtcbnZhciByZVRpbWVTID0gL14oXFxkXFxkKSgwWzEtOV18MVswLTJdKSgwWzEtOV18WzEyXVxcZHwzWzAxXSkoWzAxXVxcZHwyWzAtM10pKD86KFswLTVdXFxkKSg/OihbMC01XVxcZCkoPzpbLixdKFxcZHsxLDN9KSk/KT8pPyhafFstK10oPzpbMF1cXGR8MVswLTJdKShbMC01XVxcZCk/KT8kLztcbnZhciByZVRpbWVMID0gL14oXFxkXFxkXFxkXFxkKSgwWzEtOV18MVswLTJdKSgwWzEtOV18WzEyXVxcZHwzWzAxXSkoWzAxXVxcZHwyWzAtM10pKD86KFswLTVdXFxkKSg/OihbMC01XVxcZCkoPzpbLixdKFxcZHsxLDN9KSk/KT8pPyhafFstK10oPzpbMF1cXGR8MVswLTJdKShbMC01XVxcZCk/KT8kLztcbmZ1bmN0aW9uIHN0cmluZ0N1dChzdHIsIGxlbikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gbGVuKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgbGVuKSArIGVsbGlwc2lzO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxudmFyIFN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHJlYW0oZW5jLCBwb3MpIHtcbiAgICAgICAgdGhpcy5oZXhEaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgaWYgKGVuYyBpbnN0YW5jZW9mIFN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5lbmMgPSBlbmMuZW5jO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmMucG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZW5jIHNob3VsZCBiZSBhbiBhcnJheSBvciBhIGJpbmFyeSBzdHJpbmdcbiAgICAgICAgICAgIHRoaXMuZW5jID0gZW5jO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RyZWFtLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3MrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IHRoaXMuZW5jLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGluZyBieXRlIG9mZnNldCBcIiArIHBvcyArIFwiIG9uIGEgc3RyZWFtIG9mIGxlbmd0aCBcIiArIHRoaXMuZW5jLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcInN0cmluZ1wiID09PSB0eXBlb2YgdGhpcy5lbmMpID8gdGhpcy5lbmMuY2hhckNvZGVBdChwb3MpIDogdGhpcy5lbmNbcG9zXTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUuaGV4Qnl0ZSA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhleERpZ2l0cy5jaGFyQXQoKGIgPj4gNCkgJiAweEYpICsgdGhpcy5oZXhEaWdpdHMuY2hhckF0KGIgJiAweEYpO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5oZXhEdW1wID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHJhdykge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBzICs9IHRoaXMuaGV4Qnl0ZSh0aGlzLmdldChpKSk7XG4gICAgICAgICAgICBpZiAocmF3ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChpICYgMHhGKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHg3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBcIiAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweEY6XG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyZWFtLnByb3RvdHlwZS5pc0FTQ0lJID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5nZXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxNzYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlU3RyaW5nSVNPID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VTdHJpbmdVVEYgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDspIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5nZXQoaSsrKTtcbiAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGMgPiAxOTEpICYmIChjIDwgMjI0KSkge1xuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFGKSA8PCA2KSB8ICh0aGlzLmdldChpKyspICYgMHgzRikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MEYpIDw8IDEyKSB8ICgodGhpcy5nZXQoaSsrKSAmIDB4M0YpIDw8IDYpIHwgKHRoaXMuZ2V0KGkrKykgJiAweDNGKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlU3RyaW5nQk1QID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIHZhciBoaTtcbiAgICAgICAgdmFyIGxvO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7KSB7XG4gICAgICAgICAgICBoaSA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgICAgICBsbyA9IHRoaXMuZ2V0KGkrKyk7XG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaGkgPDwgOCkgfCBsbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VUaW1lID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHNob3J0WWVhcikge1xuICAgICAgICB2YXIgcyA9IHRoaXMucGFyc2VTdHJpbmdJU08oc3RhcnQsIGVuZCk7XG4gICAgICAgIHZhciBtID0gKHNob3J0WWVhciA/IHJlVGltZVMgOiByZVRpbWVMKS5leGVjKHMpO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIlVucmVjb2duaXplZCB0aW1lOiBcIiArIHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3J0WWVhcikge1xuICAgICAgICAgICAgLy8gdG8gYXZvaWQgcXVlcnlpbmcgdGhlIHRpbWVyLCB1c2UgdGhlIGZpeGVkIHJhbmdlIFsxOTcwLCAyMDY5XVxuICAgICAgICAgICAgLy8gaXQgd2lsbCBjb25mb3JtIHdpdGggSVRVIFguNDAwIFstMTAsICs0MF0gc2xpZGluZyB3aW5kb3cgdW50aWwgMjAzMFxuICAgICAgICAgICAgbVsxXSA9ICttWzFdO1xuICAgICAgICAgICAgbVsxXSArPSAoK21bMV0gPCA3MCkgPyAyMDAwIDogMTkwMDtcbiAgICAgICAgfVxuICAgICAgICBzID0gbVsxXSArIFwiLVwiICsgbVsyXSArIFwiLVwiICsgbVszXSArIFwiIFwiICsgbVs0XTtcbiAgICAgICAgaWYgKG1bNV0pIHtcbiAgICAgICAgICAgIHMgKz0gXCI6XCIgKyBtWzVdO1xuICAgICAgICAgICAgaWYgKG1bNl0pIHtcbiAgICAgICAgICAgICAgICBzICs9IFwiOlwiICsgbVs2XTtcbiAgICAgICAgICAgICAgICBpZiAobVs3XSkge1xuICAgICAgICAgICAgICAgICAgICBzICs9IFwiLlwiICsgbVs3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1bOF0pIHtcbiAgICAgICAgICAgIHMgKz0gXCIgVVRDXCI7XG4gICAgICAgICAgICBpZiAobVs4XSAhPSBcIlpcIikge1xuICAgICAgICAgICAgICAgIHMgKz0gbVs4XTtcbiAgICAgICAgICAgICAgICBpZiAobVs5XSkge1xuICAgICAgICAgICAgICAgICAgICBzICs9IFwiOlwiICsgbVs5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBTdHJlYW0ucHJvdG90eXBlLnBhcnNlSW50ZWdlciA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy5nZXQoc3RhcnQpO1xuICAgICAgICB2YXIgbmVnID0gKHYgPiAxMjcpO1xuICAgICAgICB2YXIgcGFkID0gbmVnID8gMjU1IDogMDtcbiAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgdmFyIHMgPSBcIlwiO1xuICAgICAgICAvLyBza2lwIHVudXNlZnVsIGJpdHMgKG5vdCBhbGxvd2VkIGluIERFUilcbiAgICAgICAgd2hpbGUgKHYgPT0gcGFkICYmICsrc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldChzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZWcgPyAtMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdyBiaXQgbGVuZ3RoIG9mIGh1Z2UgaW50ZWdlcnNcbiAgICAgICAgaWYgKGxlbiA+IDQpIHtcbiAgICAgICAgICAgIHMgPSB2O1xuICAgICAgICAgICAgbGVuIDw8PSAzO1xuICAgICAgICAgICAgd2hpbGUgKCgoK3MgXiBwYWQpICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHMgPSArcyA8PCAxO1xuICAgICAgICAgICAgICAgIC0tbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IFwiKFwiICsgbGVuICsgXCIgYml0KVxcblwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlY29kZSB0aGUgaW50ZWdlclxuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgICB2ID0gdiAtIDI1NjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IG5ldyBJbnQxMCh2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMTsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBuLm11bEFkZCgyNTYsIHRoaXMuZ2V0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcyArIG4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VCaXRTdHJpbmcgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB1bnVzZWRCaXQgPSB0aGlzLmdldChzdGFydCk7XG4gICAgICAgIHZhciBsZW5CaXQgPSAoKGVuZCAtIHN0YXJ0IC0gMSkgPDwgMykgLSB1bnVzZWRCaXQ7XG4gICAgICAgIHZhciBpbnRybyA9IFwiKFwiICsgbGVuQml0ICsgXCIgYml0KVxcblwiO1xuICAgICAgICB2YXIgcyA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDE7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmdldChpKTtcbiAgICAgICAgICAgIHZhciBza2lwID0gKGkgPT0gZW5kIC0gMSkgPyB1bnVzZWRCaXQgOiAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDc7IGogPj0gc2tpcDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgcyArPSAoYiA+PiBqKSAmIDEgPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludHJvICsgc3RyaW5nQ3V0KHMsIG1heExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludHJvICsgcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VPY3RldFN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBtYXhMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBU0NJSShzdGFydCwgZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dCh0aGlzLnBhcnNlU3RyaW5nSVNPKHN0YXJ0LCBlbmQpLCBtYXhMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgdmFyIHMgPSBcIihcIiArIGxlbiArIFwiIGJ5dGUpXFxuXCI7XG4gICAgICAgIG1heExlbmd0aCAvPSAyOyAvLyB3ZSB3b3JrIGluIGJ5dGVzXG4gICAgICAgIGlmIChsZW4gPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgbWF4TGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgICAgICBzICs9IHRoaXMuaGV4Qnl0ZSh0aGlzLmdldChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgcyArPSBlbGxpcHNpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIFN0cmVhbS5wcm90b3R5cGUucGFyc2VPSUQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciBzID0gXCJcIjtcbiAgICAgICAgdmFyIG4gPSBuZXcgSW50MTAoKTtcbiAgICAgICAgdmFyIGJpdHMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmdldChpKTtcbiAgICAgICAgICAgIG4ubXVsQWRkKDEyOCwgdiAmIDB4N0YpO1xuICAgICAgICAgICAgYml0cyArPSA3O1xuICAgICAgICAgICAgaWYgKCEodiAmIDB4ODApKSB7IC8vIGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgaWYgKHMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4uc2ltcGxpZnkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBJbnQxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5zdWIoODApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IFwiMi5cIiArIG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gbiA8IDgwID8gbiA8IDQwID8gMCA6IDEgOiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG0gKyBcIi5cIiArIChuIC0gbSAqIDQwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyArPSBcIi5cIiArIG4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdDdXQocywgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbiA9IG5ldyBJbnQxMCgpO1xuICAgICAgICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgcyArPSBcIi5pbmNvbXBsZXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyZWFtO1xufSgpKTtcbnZhciBBU04xID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFTTjEoc3RyZWFtLCBoZWFkZXIsIGxlbmd0aCwgdGFnLCBzdWIpIHtcbiAgICAgICAgaWYgKCEodGFnIGluc3RhbmNlb2YgQVNOMVRhZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGFnIHZhbHVlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5zdWIgPSBzdWI7XG4gICAgfVxuICAgIEFTTjEucHJvdG90eXBlLnR5cGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudGFnLnRhZ0NsYXNzKSB7XG4gICAgICAgICAgICBjYXNlIDA6IC8vIHVuaXZlcnNhbFxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy50YWcudGFnTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVPQ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJCT09MRUFOXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIklOVEVHRVJcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQklUX1NUUklOR1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJPQ1RFVF9TVFJJTkdcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTlVMTFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJPQkpFQ1RfSURFTlRJRklFUlwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MDc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJPYmplY3REZXNjcmlwdG9yXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwODpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVYVEVSTkFMXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgwOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlJFQUxcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDBBOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRU5VTUVSQVRFRFwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MEI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFTUJFRERFRF9QRFZcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDBDOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVVRGOFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTRVFVRU5DRVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJTRVRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTnVtZXJpY1N0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJQcmludGFibGVTdHJpbmdcIjsgLy8gQVNDSUkgc3Vic2V0XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlRlbGV0ZXhTdHJpbmdcIjsgLy8gYWthIFQ2MVN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJWaWRlb3RleFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTY6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJJQTVTdHJpbmdcIjsgLy8gQVNDSUlcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiVVRDVGltZVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MTg6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHZW5lcmFsaXplZFRpbWVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAweDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR3JhcGhpY1N0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MUE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJWaXNpYmxlU3RyaW5nXCI7IC8vIEFTQ0lJIHN1YnNldFxuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MUI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHZW5lcmFsU3RyaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMHgxQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVuaXZlcnNhbFN0cmluZ1wiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDB4MUU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJCTVBTdHJpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVW5pdmVyc2FsX1wiICsgdGhpcy50YWcudGFnTnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQXBwbGljYXRpb25fXCIgKyB0aGlzLnRhZy50YWdOdW1iZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyB0aGlzLnRhZy50YWdOdW1iZXIudG9TdHJpbmcoKSArIFwiXVwiOyAvLyBDb250ZXh0XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUHJpdmF0ZV9cIiArIHRoaXMudGFnLnRhZ051bWJlci50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKG1heExlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXhMZW5ndGggPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMucG9zQ29udGVudCgpO1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5hYnModGhpcy5sZW5ndGgpO1xuICAgICAgICBpZiAoIXRoaXMudGFnLmlzVW5pdmVyc2FsKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIHRoaXMuc3ViLmxlbmd0aCArIFwiIGVsZW0pXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VPY3RldFN0cmluZyhjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy50YWcudGFnTnVtYmVyKSB7XG4gICAgICAgICAgICBjYXNlIDB4MDE6IC8vIEJPT0xFQU5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuc3RyZWFtLmdldChjb250ZW50KSA9PT0gMCkgPyBcImZhbHNlXCIgOiBcInRydWVcIjtcbiAgICAgICAgICAgIGNhc2UgMHgwMjogLy8gSU5URUdFUlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZUludGVnZXIoY29udGVudCwgY29udGVudCArIGxlbik7XG4gICAgICAgICAgICBjYXNlIDB4MDM6IC8vIEJJVF9TVFJJTkdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIgPyBcIihcIiArIHRoaXMuc3ViLmxlbmd0aCArIFwiIGVsZW0pXCIgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXJzZUJpdFN0cmluZyhjb250ZW50LCBjb250ZW50ICsgbGVuLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweDA0OiAvLyBPQ1RFVF9TVFJJTkdcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWIgPyBcIihcIiArIHRoaXMuc3ViLmxlbmd0aCArIFwiIGVsZW0pXCIgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXJzZU9jdGV0U3RyaW5nKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4sIG1heExlbmd0aCk7XG4gICAgICAgICAgICAvLyBjYXNlIDB4MDU6IC8vIE5VTExcbiAgICAgICAgICAgIGNhc2UgMHgwNjogLy8gT0JKRUNUX0lERU5USUZJRVJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ucGFyc2VPSUQoY29udGVudCwgY29udGVudCArIGxlbiwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwNzogLy8gT2JqZWN0RGVzY3JpcHRvclxuICAgICAgICAgICAgLy8gY2FzZSAweDA4OiAvLyBFWFRFUk5BTFxuICAgICAgICAgICAgLy8gY2FzZSAweDA5OiAvLyBSRUFMXG4gICAgICAgICAgICAvLyBjYXNlIDB4MEE6IC8vIEVOVU1FUkFURURcbiAgICAgICAgICAgIC8vIGNhc2UgMHgwQjogLy8gRU1CRURERURfUERWXG4gICAgICAgICAgICBjYXNlIDB4MTA6IC8vIFNFUVVFTkNFXG4gICAgICAgICAgICBjYXNlIDB4MTE6IC8vIFNFVFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyB0aGlzLnN1Yi5sZW5ndGggKyBcIiBlbGVtKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKG5vIGVsZW0pXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAweDBDOiAvLyBVVEY4U3RyaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0N1dCh0aGlzLnN0cmVhbS5wYXJzZVN0cmluZ1VURihjb250ZW50LCBjb250ZW50ICsgbGVuKSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhc2UgMHgxMjogLy8gTnVtZXJpY1N0cmluZ1xuICAgICAgICAgICAgY2FzZSAweDEzOiAvLyBQcmludGFibGVTdHJpbmdcbiAgICAgICAgICAgIGNhc2UgMHgxNDogLy8gVGVsZXRleFN0cmluZ1xuICAgICAgICAgICAgY2FzZSAweDE1OiAvLyBWaWRlb3RleFN0cmluZ1xuICAgICAgICAgICAgY2FzZSAweDE2OiAvLyBJQTVTdHJpbmdcbiAgICAgICAgICAgIC8vIGNhc2UgMHgxOTogLy8gR3JhcGhpY1N0cmluZ1xuICAgICAgICAgICAgY2FzZSAweDFBOiAvLyBWaXNpYmxlU3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2FzZSAweDFCOiAvLyBHZW5lcmFsU3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2FzZSAweDFDOiAvLyBVbml2ZXJzYWxTdHJpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMuc3RyZWFtLnBhcnNlU3RyaW5nSVNPKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweDFFOiAvLyBCTVBTdHJpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nQ3V0KHRoaXMuc3RyZWFtLnBhcnNlU3RyaW5nQk1QKGNvbnRlbnQsIGNvbnRlbnQgKyBsZW4pLCBtYXhMZW5ndGgpO1xuICAgICAgICAgICAgY2FzZSAweDE3OiAvLyBVVENUaW1lXG4gICAgICAgICAgICBjYXNlIDB4MTg6IC8vIEdlbmVyYWxpemVkVGltZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wYXJzZVRpbWUoY29udGVudCwgY29udGVudCArIGxlbiwgKHRoaXMudGFnLnRhZ051bWJlciA9PSAweDE3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZU5hbWUoKSArIFwiQFwiICsgdGhpcy5zdHJlYW0ucG9zICsgXCJbaGVhZGVyOlwiICsgdGhpcy5oZWFkZXIgKyBcIixsZW5ndGg6XCIgKyB0aGlzLmxlbmd0aCArIFwiLHN1YjpcIiArICgodGhpcy5zdWIgPT09IG51bGwpID8gXCJudWxsXCIgOiB0aGlzLnN1Yi5sZW5ndGgpICsgXCJdXCI7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS50b1ByZXR0eVN0cmluZyA9IGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgaWYgKGluZGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gaW5kZW50ICsgdGhpcy50eXBlTmFtZSgpICsgXCIgQFwiICsgdGhpcy5zdHJlYW0ucG9zO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgcyArPSBcIitcIjtcbiAgICAgICAgfVxuICAgICAgICBzICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy50YWcudGFnQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIHMgKz0gXCIgKGNvbnN0cnVjdGVkKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0aGlzLnRhZy5pc1VuaXZlcnNhbCgpICYmICgodGhpcy50YWcudGFnTnVtYmVyID09IDB4MDMpIHx8ICh0aGlzLnRhZy50YWdOdW1iZXIgPT0gMHgwNCkpKSAmJiAodGhpcy5zdWIgIT09IG51bGwpKSB7XG4gICAgICAgICAgICBzICs9IFwiIChlbmNhcHN1bGF0ZXMpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBcIlxcblwiO1xuICAgICAgICBpZiAodGhpcy5zdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluZGVudCArPSBcIiAgXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gdGhpcy5zdWIubGVuZ3RoOyBpIDwgbWF4OyArK2kpIHtcbiAgICAgICAgICAgICAgICBzICs9IHRoaXMuc3ViW2ldLnRvUHJldHR5U3RyaW5nKGluZGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBBU04xLnByb3RvdHlwZS5wb3NTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvcztcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnBvc0NvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb3MgKyB0aGlzLmhlYWRlcjtcbiAgICB9O1xuICAgIEFTTjEucHJvdG90eXBlLnBvc0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvcyArIHRoaXMuaGVhZGVyICsgTWF0aC5hYnModGhpcy5sZW5ndGgpO1xuICAgIH07XG4gICAgQVNOMS5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5oZXhEdW1wKHRoaXMucG9zU3RhcnQoKSwgdGhpcy5wb3NFbmQoKSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBBU04xLmRlY29kZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHN0cmVhbS5nZXQoKTtcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZiAmIDB4N0Y7XG4gICAgICAgIGlmIChsZW4gPT0gYnVmKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIHJlYXNvbiB0byB1c2UgSW50MTAsIGFzIGl0IHdvdWxkIGJlIGEgaHVnZSBidWZmZXIgYW55d2F5c1xuICAgICAgICBpZiAobGVuID4gNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG92ZXIgNDggYml0cyBub3Qgc3VwcG9ydGVkIGF0IHBvc2l0aW9uIFwiICsgKHN0cmVhbS5wb3MgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gdW5kZWZpbmVkXG4gICAgICAgIGJ1ZiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGJ1ZiA9IChidWYgKiAyNTYpICsgc3RyZWFtLmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgaGV4YWRlY2ltYWwgdmFsdWUgKGFzIGEgc3RyaW5nKSBvZiB0aGUgY3VycmVudCBBU04uMSBlbGVtZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgQVNOMS5wcm90b3R5cGUuZ2V0SGV4U3RyaW5nVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZXhTdHJpbmcgPSB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmhlYWRlciAqIDI7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCAqIDI7XG4gICAgICAgIHJldHVybiBoZXhTdHJpbmcuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICB9O1xuICAgIEFTTjEuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgc3RyZWFtO1xuICAgICAgICBpZiAoIShzdHIgaW5zdGFuY2VvZiBTdHJlYW0pKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgU3RyZWFtKHN0ciwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmVhbVN0YXJ0ID0gbmV3IFN0cmVhbShzdHJlYW0pO1xuICAgICAgICB2YXIgdGFnID0gbmV3IEFTTjFUYWcoc3RyZWFtKTtcbiAgICAgICAgdmFyIGxlbiA9IEFTTjEuZGVjb2RlTGVuZ3RoKHN0cmVhbSk7XG4gICAgICAgIHZhciBzdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICAgIHZhciBoZWFkZXIgPSBzdGFydCAtIHN0cmVhbVN0YXJ0LnBvcztcbiAgICAgICAgdmFyIHN1YiA9IG51bGw7XG4gICAgICAgIHZhciBnZXRTdWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICBpZiAobGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5pdGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgbGVuO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IEFTTjEuZGVjb2RlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0ucG9zICE9IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IHNpemUgaXMgbm90IGNvcnJlY3QgZm9yIGNvbnRhaW5lciBzdGFydGluZyBhdCBvZmZzZXQgXCIgKyBzdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIGxlbmd0aFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gQVNOMS5kZWNvZGUoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnRhZy5pc0VPQygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSBzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHN0YXJ0IC0gc3RyZWFtLnBvczsgLy8gdW5kZWZpbmVkIGxlbmd0aHMgYXJlIHJlcHJlc2VudGVkIGFzIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlcHRpb24gd2hpbGUgZGVjb2RpbmcgdW5kZWZpbmVkIGxlbmd0aCBjb250ZW50OiBcIiArIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0YWcudGFnQ29uc3RydWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIG11c3QgaGF2ZSB2YWxpZCBjb250ZW50XG4gICAgICAgICAgICBzdWIgPSBnZXRTdWIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YWcuaXNVbml2ZXJzYWwoKSAmJiAoKHRhZy50YWdOdW1iZXIgPT0gMHgwMykgfHwgKHRhZy50YWdOdW1iZXIgPT0gMHgwNCkpKSB7XG4gICAgICAgICAgICAvLyBzb21ldGltZXMgQml0U3RyaW5nIGFuZCBPY3RldFN0cmluZyBhcmUgdXNlZCB0byBlbmNhcHN1bGF0ZSBBU04uMVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGFnLnRhZ051bWJlciA9PSAweDAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uZ2V0KCkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQklUIFNUUklOR3Mgd2l0aCB1bnVzZWQgYml0cyBjYW5ub3QgZW5jYXBzdWxhdGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YiA9IGdldFN1YigpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ViLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJbaV0udGFnLmlzRU9DKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVPQyBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgYWN0dWFsIGNvbnRlbnQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBidXQgc2lsZW50bHkgaWdub3JlIHdoZW4gdGhleSBkb24ndFxuICAgICAgICAgICAgICAgIHN1YiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlIGNhbid0IHNraXAgb3ZlciBhbiBpbnZhbGlkIHRhZyB3aXRoIHVuZGVmaW5lZCBsZW5ndGggYXQgb2Zmc2V0IFwiICsgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyZWFtLnBvcyA9IHN0YXJ0ICsgTWF0aC5hYnMobGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTTjEoc3RyZWFtU3RhcnQsIGhlYWRlciwgbGVuLCB0YWcsIHN1Yik7XG4gICAgfTtcbiAgICByZXR1cm4gQVNOMTtcbn0oKSk7XG52YXIgQVNOMVRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU04xVGFnKHN0cmVhbSkge1xuICAgICAgICB2YXIgYnVmID0gc3RyZWFtLmdldCgpO1xuICAgICAgICB0aGlzLnRhZ0NsYXNzID0gYnVmID4+IDY7XG4gICAgICAgIHRoaXMudGFnQ29uc3RydWN0ZWQgPSAoKGJ1ZiAmIDB4MjApICE9PSAwKTtcbiAgICAgICAgdGhpcy50YWdOdW1iZXIgPSBidWYgJiAweDFGO1xuICAgICAgICBpZiAodGhpcy50YWdOdW1iZXIgPT0gMHgxRikgeyAvLyBsb25nIHRhZ1xuICAgICAgICAgICAgdmFyIG4gPSBuZXcgSW50MTAoKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBidWYgPSBzdHJlYW0uZ2V0KCk7XG4gICAgICAgICAgICAgICAgbi5tdWxBZGQoMTI4LCBidWYgJiAweDdGKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGJ1ZiAmIDB4ODApO1xuICAgICAgICAgICAgdGhpcy50YWdOdW1iZXIgPSBuLnNpbXBsaWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQVNOMVRhZy5wcm90b3R5cGUuaXNVbml2ZXJzYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0NsYXNzID09PSAweDAwO1xuICAgIH07XG4gICAgQVNOMVRhZy5wcm90b3R5cGUuaXNFT0MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ0NsYXNzID09PSAweDAwICYmIHRoaXMudGFnTnVtYmVyID09PSAweDAwO1xuICAgIH07XG4gICAgcmV0dXJuIEFTTjFUYWc7XG59KCkpO1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcbi8vIEphdmFTY3JpcHQgZW5naW5lIGFuYWx5c2lzXG52YXIgY2FuYXJ5ID0gMHhkZWFkYmVlZmNhZmU7XG52YXIgal9sbSA9ICgoY2FuYXJ5ICYgMHhmZmZmZmYpID09IDB4ZWZjYWZlKTtcbi8vI3JlZ2lvblxudmFyIGxvd3ByaW1lcyA9IFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzcsIDQxLCA0MywgNDcsIDUzLCA1OSwgNjEsIDY3LCA3MSwgNzMsIDc5LCA4MywgODksIDk3LCAxMDEsIDEwMywgMTA3LCAxMDksIDExMywgMTI3LCAxMzEsIDEzNywgMTM5LCAxNDksIDE1MSwgMTU3LCAxNjMsIDE2NywgMTczLCAxNzksIDE4MSwgMTkxLCAxOTMsIDE5NywgMTk5LCAyMTEsIDIyMywgMjI3LCAyMjksIDIzMywgMjM5LCAyNDEsIDI1MSwgMjU3LCAyNjMsIDI2OSwgMjcxLCAyNzcsIDI4MSwgMjgzLCAyOTMsIDMwNywgMzExLCAzMTMsIDMxNywgMzMxLCAzMzcsIDM0NywgMzQ5LCAzNTMsIDM1OSwgMzY3LCAzNzMsIDM3OSwgMzgzLCAzODksIDM5NywgNDAxLCA0MDksIDQxOSwgNDIxLCA0MzEsIDQzMywgNDM5LCA0NDMsIDQ0OSwgNDU3LCA0NjEsIDQ2MywgNDY3LCA0NzksIDQ4NywgNDkxLCA0OTksIDUwMywgNTA5LCA1MjEsIDUyMywgNTQxLCA1NDcsIDU1NywgNTYzLCA1NjksIDU3MSwgNTc3LCA1ODcsIDU5MywgNTk5LCA2MDEsIDYwNywgNjEzLCA2MTcsIDYxOSwgNjMxLCA2NDEsIDY0MywgNjQ3LCA2NTMsIDY1OSwgNjYxLCA2NzMsIDY3NywgNjgzLCA2OTEsIDcwMSwgNzA5LCA3MTksIDcyNywgNzMzLCA3MzksIDc0MywgNzUxLCA3NTcsIDc2MSwgNzY5LCA3NzMsIDc4NywgNzk3LCA4MDksIDgxMSwgODIxLCA4MjMsIDgyNywgODI5LCA4MzksIDg1MywgODU3LCA4NTksIDg2MywgODc3LCA4ODEsIDg4MywgODg3LCA5MDcsIDkxMSwgOTE5LCA5MjksIDkzNywgOTQxLCA5NDcsIDk1MywgOTY3LCA5NzEsIDk3NywgOTgzLCA5OTEsIDk5N107XG52YXIgbHBsaW0gPSAoMSA8PCAyNikgLyBsb3dwcmltZXNbbG93cHJpbWVzLmxlbmd0aCAtIDFdO1xuLy8jZW5kcmVnaW9uXG4vLyAocHVibGljKSBDb25zdHJ1Y3RvclxudmFyIEJpZ0ludGVnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmlnSW50ZWdlcihhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tTnVtYmVyKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA9PSBudWxsICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcoYSwgMjU2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyhhLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyNyZWdpb24gUFVCTElDXG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBiblRvU3RyaW5nO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW4gZ2l2ZW4gcmFkaXhcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCItXCIgKyB0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZiAoYiA9PSAxNikge1xuICAgICAgICAgICAgayA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSA4KSB7XG4gICAgICAgICAgICBrID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDIpIHtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gMzIpIHtcbiAgICAgICAgICAgIGsgPSA1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIgPT0gNCkge1xuICAgICAgICAgICAgayA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1JhZGl4KGIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbSA9ICgxIDw8IGspIC0gMTtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHZhciBtID0gZmFsc2U7XG4gICAgICAgIHZhciByID0gXCJcIjtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnQ7XG4gICAgICAgIHZhciBwID0gdGhpcy5EQiAtIChpICogdGhpcy5EQikgJSBrO1xuICAgICAgICBpZiAoaS0tID4gMCkge1xuICAgICAgICAgICAgaWYgKHAgPCB0aGlzLkRCICYmIChkID0gdGhpc1tpXSA+PiBwKSA+IDApIHtcbiAgICAgICAgICAgICAgICBtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByID0gaW50MmNoYXIoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPCBrKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSAmICgoMSA8PCBwKSAtIDEpKSA8PCAoayAtIHApO1xuICAgICAgICAgICAgICAgICAgICBkIHw9IHRoaXNbLS1pXSA+PiAocCArPSB0aGlzLkRCIC0gayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gKHRoaXNbaV0gPj4gKHAgLT0gaykpICYga207XG4gICAgICAgICAgICAgICAgICAgIGlmIChwIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0gdGhpcy5EQjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgKz0gaW50MmNoYXIoZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtID8gciA6IFwiMFwiO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gYm5OZWdhdGU7XG4gICAgLy8gKHB1YmxpYykgLXRoaXNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBibkFicztcbiAgICAvLyAocHVibGljKSB8dGhpc3xcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zIDwgMCkgPyB0aGlzLm5lZ2F0ZSgpIDogdGhpcztcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGJuQ29tcGFyZVRvO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnMgLSBhLnM7XG4gICAgICAgIGlmIChyICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgICByID0gaSAtIGEudDtcbiAgICAgICAgaWYgKHIgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnMgPCAwKSA/IC1yIDogcjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIGlmICgociA9IHRoaXNbaV0gLSBhW2ldKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbiAgICAvLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBiaXRzIGluIFwidGhpc1wiXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLkRCICogKHRoaXMudCAtIDEpICsgbmJpdHModGhpc1t0aGlzLnQgLSAxXSBeICh0aGlzLnMgJiB0aGlzLkRNKSk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBibk1vZDtcbiAgICAvLyAocHVibGljKSB0aGlzIG1vZCBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5hYnMoKS5kaXZSZW1UbyhhLCBudWxsLCByKTtcbiAgICAgICAgaWYgKHRoaXMucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHtcbiAgICAgICAgICAgIGEuc3ViVG8ociwgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3dJbnQgPSBibk1vZFBvd0ludDtcbiAgICAvLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gZnVuY3Rpb24gKGUsIG0pIHtcbiAgICAgICAgdmFyIHo7XG4gICAgICAgIGlmIChlIDwgMjU2IHx8IG0uaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIHogPSBuZXcgQ2xhc3NpYyhtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHAoZSwgeik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG4gICAgLy8gKHB1YmxpYylcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5jb3B5VG8ocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBibkludFZhbHVlO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1swXSAtIHRoaXMuRFY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnQgPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50ID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc3VtZXMgMTYgPCBEQiA8IDMyXG4gICAgICAgIHJldHVybiAoKHRoaXNbMV0gJiAoKDEgPDwgKDMyIC0gdGhpcy5EQikpIC0gMSkpIDw8IHRoaXMuREIpIHwgdGhpc1swXTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJ5dGVWYWx1ZSA9IGJuQnl0ZVZhbHVlO1xuICAgIC8vIChwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBieXRlXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudCA9PSAwKSA/IHRoaXMucyA6ICh0aGlzWzBdIDw8IDI0KSA+PiAyNDtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIHNob3J0IChhc3N1bWVzIERCPj0xNilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaG9ydFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudCA9PSAwKSA/IHRoaXMucyA6ICh0aGlzWzBdIDw8IDE2KSA+PiAxNjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNpZ251bSA9IGJuU2lnTnVtO1xuICAgIC8vIChwdWJsaWMpIDAgaWYgdGhpcyA9PSAwLCAxIGlmIHRoaXMgPiAwXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudCA8PSAwIHx8ICh0aGlzLnQgPT0gMSAmJiB0aGlzWzBdIDw9IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGJuVG9CeXRlQXJyYXk7XG4gICAgLy8gKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMudDtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgclswXSA9IHRoaXMucztcbiAgICAgICAgdmFyIHAgPSB0aGlzLkRCIC0gKGkgKiB0aGlzLkRCKSAlIDg7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIGlmIChpLS0gPiAwKSB7XG4gICAgICAgICAgICBpZiAocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzW2ldID4+IHApICE9ICh0aGlzLnMgJiB0aGlzLkRNKSA+PiBwKSB7XG4gICAgICAgICAgICAgICAgcltrKytdID0gZCB8ICh0aGlzLnMgPDwgKHRoaXMuREIgLSBwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPCA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAodGhpc1tpXSAmICgoMSA8PCBwKSAtIDEpKSA8PCAoOCAtIHApO1xuICAgICAgICAgICAgICAgICAgICBkIHw9IHRoaXNbLS1pXSA+PiAocCArPSB0aGlzLkRCIC0gOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gKHRoaXNbaV0gPj4gKHAgLT0gOCkpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB0aGlzLkRCO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZCAmIDB4ODApICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCB8PSAtMjU2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA9PSAwICYmICh0aGlzLnMgJiAweDgwKSAhPSAoZCAmIDB4ODApKSB7XG4gICAgICAgICAgICAgICAgICAgICsraztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPiAwIHx8IGQgIT0gdGhpcy5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJbaysrXSA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gYm5FcXVhbHM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA9PSAwKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbiA9IGJuTWluO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb21wYXJlVG8oYSkgPCAwKSA/IHRoaXMgOiBhO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubWF4ID0gYm5NYXg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmNvbXBhcmVUbyhhKSA+IDApID8gdGhpcyA6IGE7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBibkFuZDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhhLCBvcF9hbmQsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gYm5PcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX29yLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBiblhvcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmJpdHdpc2VUbyhhLCBvcF94b3IsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZE5vdCA9IGJuQW5kTm90O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZE5vdCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuYml0d2lzZVRvKGEsIG9wX2FuZG5vdCwgcik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubm90ID0gYm5Ob3Q7XG4gICAgLy8gKHB1YmxpYykgfnRoaXNcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgICAgIHJbaV0gPSB0aGlzLkRNICYgfnRoaXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgICByLnMgPSB+dGhpcy5zO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGJuU2hpZnRMZWZ0O1xuICAgIC8vIChwdWJsaWMpIHRoaXMgPDwgblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5yU2hpZnRUbygtbiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxTaGlmdFRvKG4sIHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGJuU2hpZnRSaWdodDtcbiAgICAvLyAocHVibGljKSB0aGlzID4+IG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmxTaGlmdFRvKC1uLCByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuclNoaWZ0VG8obiwgcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQgPSBibkdldExvd2VzdFNldEJpdDtcbiAgICAvLyAocHVibGljKSByZXR1cm5zIGluZGV4IG9mIGxvd2VzdCAxLWJpdCAob3IgLTEgaWYgbm9uZSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXRMb3dlc3RTZXRCaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAqIHRoaXMuREIgKyBsYml0KHRoaXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ICogdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IDA7XG4gICAgICAgIHZhciB4ID0gdGhpcy5zICYgdGhpcy5ETTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgciArPSBjYml0KHRoaXNbaV0gXiB4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnRlc3RCaXQgPSBiblRlc3RCaXQ7XG4gICAgLy8gKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdmFyIGogPSBNYXRoLmZsb29yKG4gLyB0aGlzLkRCKTtcbiAgICAgICAgaWYgKGogPj0gdGhpcy50KSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucyAhPSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCh0aGlzW2pdICYgKDEgPDwgKG4gJSB0aGlzLkRCKSkpICE9IDApO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyB8ICgxPDxuKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNldEJpdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF9vcik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF9hbmRub3QpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZmxpcEJpdCA9IGJuRmxpcEJpdDtcbiAgICAvLyAocHVibGljKSB0aGlzIF4gKDE8PG4pXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZmxpcEJpdCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJpdChuLCBvcF94b3IpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG4gICAgLy8gKHB1YmxpYykgdGhpcyArIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmFkZFRvKGEsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gYm5TdWJ0cmFjdDtcbiAgICAvLyAocHVibGljKSB0aGlzIC0gYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgdGhpcy5zdWJUbyhhLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG4gICAgLy8gKHB1YmxpYykgdGhpcyAqIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMubXVsdGlwbHlUbyhhLCByKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbiAgICAvLyAocHVibGljKSB0aGlzIC8gYVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgciwgbnVsbCk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyID0gYm5SZW1haW5kZXI7XG4gICAgLy8gKHB1YmxpYykgdGhpcyAlIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB0aGlzLmRpdlJlbVRvKGEsIG51bGwsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlciA9IGJuRGl2aWRlQW5kUmVtYWluZGVyO1xuICAgIC8vIChwdWJsaWMpIFt0aGlzL2EsdGhpcyVhXVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBxID0gbmJpKCk7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuZGl2UmVtVG8oYSwgcSwgcik7XG4gICAgICAgIHJldHVybiBbcSwgcl07XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbiAgICAvLyAocHVibGljKSB0aGlzXmUgJSBtIChIQUMgMTQuODUpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gZnVuY3Rpb24gKGUsIG0pIHtcbiAgICAgICAgdmFyIGkgPSBlLmJpdExlbmd0aCgpO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIHIgPSBuYnYoMSk7XG4gICAgICAgIHZhciB6O1xuICAgICAgICBpZiAoaSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgMTgpIHtcbiAgICAgICAgICAgIGsgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgICAgICAgayA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDE0NCkge1xuICAgICAgICAgICAgayA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA8IDc2OCkge1xuICAgICAgICAgICAgayA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrID0gNjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDgpIHtcbiAgICAgICAgICAgIHogPSBuZXcgQ2xhc3NpYyhtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLmlzRXZlbigpKSB7XG4gICAgICAgICAgICB6ID0gbmV3IEJhcnJldHQobSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJlY29tcHV0YXRpb25cbiAgICAgICAgdmFyIGcgPSBbXTtcbiAgICAgICAgdmFyIG4gPSAzO1xuICAgICAgICB2YXIgazEgPSBrIC0gMTtcbiAgICAgICAgdmFyIGttID0gKDEgPDwgaykgLSAxO1xuICAgICAgICBnWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICAgIHZhciBnMiA9IG5iaSgpO1xuICAgICAgICAgICAgei5zcXJUbyhnWzFdLCBnMik7XG4gICAgICAgICAgICB3aGlsZSAobiA8PSBrbSkge1xuICAgICAgICAgICAgICAgIGdbbl0gPSBuYmkoKTtcbiAgICAgICAgICAgICAgICB6Lm11bFRvKGcyLCBnW24gLSAyXSwgZ1tuXSk7XG4gICAgICAgICAgICAgICAgbiArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBqID0gZS50IC0gMTtcbiAgICAgICAgdmFyIHc7XG4gICAgICAgIHZhciBpczEgPSB0cnVlO1xuICAgICAgICB2YXIgcjIgPSBuYmkoKTtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGkgPSBuYml0cyhlW2pdKSAtIDE7XG4gICAgICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgICAgICAgIGlmIChpID49IGsxKSB7XG4gICAgICAgICAgICAgICAgdyA9IChlW2pdID4+IChpIC0gazEpKSAmIGttO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdyA9IChlW2pdICYgKCgxIDw8IChpICsgMSkpIC0gMSkpIDw8IChrMSAtIGkpO1xuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3IHw9IGVbaiAtIDFdID4+ICh0aGlzLkRCICsgaSAtIGsxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gaztcbiAgICAgICAgICAgIHdoaWxlICgodyAmIDEpID09IDApIHtcbiAgICAgICAgICAgICAgICB3ID4+PSAxO1xuICAgICAgICAgICAgICAgIC0tbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSAtPSBuKSA8IDApIHtcbiAgICAgICAgICAgICAgICBpICs9IHRoaXMuREI7XG4gICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzMSkgeyAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICAgICAgICAgICAgICAgZ1t3XS5jb3B5VG8ocik7XG4gICAgICAgICAgICAgICAgaXMxID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgei5zcXJUbyhyLCByMik7XG4gICAgICAgICAgICAgICAgICAgIHouc3FyVG8ocjIsIHIpO1xuICAgICAgICAgICAgICAgICAgICBuIC09IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSByO1xuICAgICAgICAgICAgICAgICAgICByID0gcjI7XG4gICAgICAgICAgICAgICAgICAgIHIyID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgei5tdWxUbyhyMiwgZ1t3XSwgcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSAwICYmIChlW2pdICYgKDEgPDwgaSkpID09IDApIHtcbiAgICAgICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcbiAgICAgICAgICAgICAgICB0ID0gcjtcbiAgICAgICAgICAgICAgICByID0gcjI7XG4gICAgICAgICAgICAgICAgcjIgPSB0O1xuICAgICAgICAgICAgICAgIGlmICgtLWkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLkRCIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei5yZXZlcnQocik7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnZlcnNlID0gYm5Nb2RJbnZlcnNlO1xuICAgIC8vIChwdWJsaWMpIDEvdGhpcyAlIG0gKEhBQyAxNC42MSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnZlcnNlID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdmFyIGFjID0gbS5pc0V2ZW4oKTtcbiAgICAgICAgaWYgKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHUgPSBtLmNsb25lKCk7XG4gICAgICAgIHZhciB2ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YXIgYSA9IG5idigxKTtcbiAgICAgICAgdmFyIGIgPSBuYnYoMCk7XG4gICAgICAgIHZhciBjID0gbmJ2KDApO1xuICAgICAgICB2YXIgZCA9IG5idigxKTtcbiAgICAgICAgd2hpbGUgKHUuc2lnbnVtKCkgIT0gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHUuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICB1LnJTaGlmdFRvKDEsIHUpO1xuICAgICAgICAgICAgICAgIGlmIChhYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuYWRkVG8odGhpcywgYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnN1YlRvKG0sIGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGEuclNoaWZ0VG8oMSwgYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGIuc3ViVG8obSwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIuclNoaWZ0VG8oMSwgYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAodi5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgIHYuclNoaWZ0VG8oMSwgdik7XG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5pc0V2ZW4oKSB8fCAhZC5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5hZGRUbyh0aGlzLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuc3ViVG8obSwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYy5yU2hpZnRUbygxLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWQuaXNFdmVuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5zdWJUbyhtLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZC5yU2hpZnRUbygxLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdS5zdWJUbyh2LCB1KTtcbiAgICAgICAgICAgICAgICBpZiAoYWMpIHtcbiAgICAgICAgICAgICAgICAgICAgYS5zdWJUbyhjLCBhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYi5zdWJUbyhkLCBiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHYuc3ViVG8odSwgdik7XG4gICAgICAgICAgICAgICAgaWYgKGFjKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuc3ViVG8oYSwgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGQuc3ViVG8oYiwgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLmNvbXBhcmVUbyhtKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5zdWJ0cmFjdChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5zaWdudW0oKSA8IDApIHtcbiAgICAgICAgICAgIGQuYWRkVG8obSwgZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5zaWdudW0oKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkLmFkZChtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbiAgICAvLyAocHVibGljKSB0aGlzXmVcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHAoZSwgbmV3IE51bGxFeHAoKSk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2QgPSBibkdDRDtcbiAgICAvLyAocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciB4ID0gKHRoaXMucyA8IDApID8gdGhpcy5uZWdhdGUoKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFyIHkgPSAoYS5zIDwgMCkgPyBhLm5lZ2F0ZSgpIDogYS5jbG9uZSgpO1xuICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPCAwKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHg7XG4gICAgICAgICAgICB4ID0geTtcbiAgICAgICAgICAgIHkgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgICAgdmFyIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICBpZiAoZyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgZykge1xuICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgICAgICB4LnJTaGlmdFRvKGcsIHgpO1xuICAgICAgICAgICAgeS5yU2hpZnRUbyhnLCB5KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoeC5zaWdudW0oKSA+IDApIHtcbiAgICAgICAgICAgIGlmICgoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkge1xuICAgICAgICAgICAgICAgIHguclNoaWZ0VG8oaSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgPSB5LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB5LnJTaGlmdFRvKGksIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHguY29tcGFyZVRvKHkpID49IDApIHtcbiAgICAgICAgICAgICAgICB4LnN1YlRvKHksIHgpO1xuICAgICAgICAgICAgICAgIHguclNoaWZ0VG8oMSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5LnN1YlRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oMSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgICAgICB5LmxTaGlmdFRvKGcsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG4gICAgLy8gKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgICAgICAgaWYgKHgudCA9PSAxICYmIHhbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvd3ByaW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh4WzBdID09IGxvd3ByaW1lc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHguaXNFdmVuKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpID0gMTtcbiAgICAgICAgd2hpbGUgKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IGxvd3ByaW1lc1tpXTtcbiAgICAgICAgICAgIHZhciBqID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSB7XG4gICAgICAgICAgICAgICAgbSAqPSBsb3dwcmltZXNbaisrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0gPSB4Lm1vZEludChtKTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgICAgIGlmIChtICUgbG93cHJpbWVzW2krK10gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4Lm1pbGxlclJhYmluKHQpO1xuICAgIH07XG4gICAgLy8jZW5kcmVnaW9uIFBVQkxJQ1xuICAgIC8vI3JlZ2lvbiBQUk9URUNURURcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb3B5VG8gPSBibnBDb3B5VG87XG4gICAgLy8gKHByb3RlY3RlZCkgY29weSB0aGlzIHRvIHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbiAocikge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJbaV0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgICAgci5zID0gdGhpcy5zO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG4gICAgLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gaW50ZWdlciB2YWx1ZSB4LCAtRFYgPD0geCA8IERWXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudCA9IDE7XG4gICAgICAgIHRoaXMucyA9ICh4IDwgMCkgPyAtMSA6IDA7XG4gICAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICAgICAgdGhpc1swXSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCA8IC0xKSB7XG4gICAgICAgICAgICB0aGlzWzBdID0geCArIHRoaXMuRFY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnQgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBzdHJpbmcgYW5kIHJhZGl4XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzLCBiKSB7XG4gICAgICAgIHZhciBrO1xuICAgICAgICBpZiAoYiA9PSAxNikge1xuICAgICAgICAgICAgayA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSA4KSB7XG4gICAgICAgICAgICBrID0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDI1Nikge1xuICAgICAgICAgICAgayA9IDg7XG4gICAgICAgICAgICAvKiBieXRlIGFycmF5ICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYiA9PSAyKSB7XG4gICAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDMyKSB7XG4gICAgICAgICAgICBrID0gNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiID09IDQpIHtcbiAgICAgICAgICAgIGsgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mcm9tUmFkaXgocywgYik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ID0gMDtcbiAgICAgICAgdGhpcy5zID0gMDtcbiAgICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1pID0gZmFsc2U7XG4gICAgICAgIHZhciBzaCA9IDA7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHggPSAoayA9PSA4KSA/ICgrc1tpXSkgJiAweGZmIDogaW50QXQocywgaSk7XG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2ggPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNoICsgayA+IHRoaXMuREIpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCAtIDFdIHw9ICh4ICYgKCgxIDw8ICh0aGlzLkRCIC0gc2gpKSAtIDEpKSA8PCBzaDtcbiAgICAgICAgICAgICAgICB0aGlzW3RoaXMudCsrXSA9ICh4ID4+ICh0aGlzLkRCIC0gc2gpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0geCA8PCBzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoICs9IGs7XG4gICAgICAgICAgICBpZiAoc2ggPj0gdGhpcy5EQikge1xuICAgICAgICAgICAgICAgIHNoIC09IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPT0gOCAmJiAoKCtzWzBdKSAmIDB4ODApICE9IDApIHtcbiAgICAgICAgICAgIHRoaXMucyA9IC0xO1xuICAgICAgICAgICAgaWYgKHNoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNbdGhpcy50IC0gMV0gfD0gKCgxIDw8ICh0aGlzLkRCIC0gc2gpKSAtIDEpIDw8IHNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICAgICAgaWYgKG1pKSB7XG4gICAgICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG4gICAgLy8gKHByb3RlY3RlZCkgY2xhbXAgb2ZmIGV4Y2VzcyBoaWdoIHdvcmRzXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5zICYgdGhpcy5ETTtcbiAgICAgICAgd2hpbGUgKHRoaXMudCA+IDAgJiYgdGhpc1t0aGlzLnQgLSAxXSA9PSBjKSB7XG4gICAgICAgICAgICAtLXRoaXMudDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZGxTaGlmdFRvID0gYm5wRExTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG4qREJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJbaSArIG5dID0gdGhpc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IHRoaXMudCArIG47XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRyU2hpZnRUbyA9IGJucERSU2hpZnRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuKkRCXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gZnVuY3Rpb24gKG4sIHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgcltpIC0gbl0gPSB0aGlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IE1hdGgubWF4KHRoaXMudCAtIG4sIDApO1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGZ1bmN0aW9uIChuLCByKSB7XG4gICAgICAgIHZhciBicyA9IG4gJSB0aGlzLkRCO1xuICAgICAgICB2YXIgY2JzID0gdGhpcy5EQiAtIGJzO1xuICAgICAgICB2YXIgYm0gPSAoMSA8PCBjYnMpIC0gMTtcbiAgICAgICAgdmFyIGRzID0gTWF0aC5mbG9vcihuIC8gdGhpcy5EQik7XG4gICAgICAgIHZhciBjID0gKHRoaXMucyA8PCBicykgJiB0aGlzLkRNO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy50IC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJbaSArIGRzICsgMV0gPSAodGhpc1tpXSA+PiBjYnMpIHwgYztcbiAgICAgICAgICAgIGMgPSAodGhpc1tpXSAmIGJtKSA8PCBicztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZHMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcltpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcltkc10gPSBjO1xuICAgICAgICByLnQgPSB0aGlzLnQgKyBkcyArIDE7XG4gICAgICAgIHIucyA9IHRoaXMucztcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBmdW5jdGlvbiAobiwgcikge1xuICAgICAgICByLnMgPSB0aGlzLnM7XG4gICAgICAgIHZhciBkcyA9IE1hdGguZmxvb3IobiAvIHRoaXMuREIpO1xuICAgICAgICBpZiAoZHMgPj0gdGhpcy50KSB7XG4gICAgICAgICAgICByLnQgPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBicyA9IG4gJSB0aGlzLkRCO1xuICAgICAgICB2YXIgY2JzID0gdGhpcy5EQiAtIGJzO1xuICAgICAgICB2YXIgYm0gPSAoMSA8PCBicykgLSAxO1xuICAgICAgICByWzBdID0gdGhpc1tkc10gPj4gYnM7XG4gICAgICAgIGZvciAodmFyIGkgPSBkcyArIDE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgICAgICAgICAgcltpIC0gZHMgLSAxXSB8PSAodGhpc1tpXSAmIGJtKSA8PCBjYnM7XG4gICAgICAgICAgICByW2kgLSBkc10gPSB0aGlzW2ldID4+IGJzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChicyA+IDApIHtcbiAgICAgICAgICAgIHJbdGhpcy50IC0gZHMgLSAxXSB8PSAodGhpcy5zICYgYm0pIDw8IGNicztcbiAgICAgICAgfVxuICAgICAgICByLnQgPSB0aGlzLnQgLSBkcztcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuc3ViVG8gPSBibnBTdWJUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGZ1bmN0aW9uIChhLCByKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB2YXIgbSA9IE1hdGgubWluKGEudCwgdGhpcy50KTtcbiAgICAgICAgd2hpbGUgKGkgPCBtKSB7XG4gICAgICAgICAgICBjICs9IHRoaXNbaV0gLSBhW2ldO1xuICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnQgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgIGMgLT0gYS5zO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnQpIHtcbiAgICAgICAgICAgICAgICBjICs9IHRoaXNbaV07XG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYyArPSB0aGlzLnM7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGEudCkge1xuICAgICAgICAgICAgICAgIGMgLT0gYVtpXTtcbiAgICAgICAgICAgICAgICByW2krK10gPSBjICYgdGhpcy5ETTtcbiAgICAgICAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyAtPSBhLnM7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gKGMgPCAwKSA/IC0xIDogMDtcbiAgICAgICAgaWYgKGMgPCAtMSkge1xuICAgICAgICAgICAgcltpKytdID0gdGhpcy5EViArIGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA+IDApIHtcbiAgICAgICAgICAgIHJbaSsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgci50ID0gaTtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlUbyA9IGJucE11bHRpcGx5VG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKiBhLCByICE9IHRoaXMsYSAoSEFDIDE0LjEyKVxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gZnVuY3Rpb24gKGEsIHIpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmFicygpO1xuICAgICAgICB2YXIgeSA9IGEuYWJzKCk7XG4gICAgICAgIHZhciBpID0geC50O1xuICAgICAgICByLnQgPSBpICsgeS50O1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHJbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB5LnQ7ICsraSkge1xuICAgICAgICAgICAgcltpICsgeC50XSA9IHguYW0oMCwgeVtpXSwgciwgaSwgMCwgeC50KTtcbiAgICAgICAgfVxuICAgICAgICByLnMgPSAwO1xuICAgICAgICByLmNsYW1wKCk7XG4gICAgICAgIGlmICh0aGlzLnMgIT0gYS5zKSB7XG4gICAgICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ociwgcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlVG8gPSBmdW5jdGlvbiAocikge1xuICAgICAgICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gICAgICAgIHZhciBpID0gci50ID0gMiAqIHgudDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC50IC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHguYW0oaSwgeFtpXSwgciwgMiAqIGksIDAsIDEpO1xuICAgICAgICAgICAgaWYgKChyW2kgKyB4LnRdICs9IHguYW0oaSArIDEsIDIgKiB4W2ldLCByLCAyICogaSArIDEsIGMsIHgudCAtIGkgLSAxKSkgPj0geC5EVikge1xuICAgICAgICAgICAgICAgIHJbaSArIHgudF0gLT0geC5EVjtcbiAgICAgICAgICAgICAgICByW2kgKyB4LnQgKyAxXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIudCA+IDApIHtcbiAgICAgICAgICAgIHJbci50IC0gMV0gKz0geC5hbShpLCB4W2ldLCByLCAyICogaSwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgci5zID0gMDtcbiAgICAgICAgci5jbGFtcCgpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtVG8gPSBibnBEaXZSZW1UbztcbiAgICAvLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbiAgICAvLyByICE9IHEsIHRoaXMgIT0gbS4gIHEgb3IgciBtYXkgYmUgbnVsbC5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGZ1bmN0aW9uIChtLCBxLCByKSB7XG4gICAgICAgIHZhciBwbSA9IG0uYWJzKCk7XG4gICAgICAgIGlmIChwbS50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHQgPSB0aGlzLmFicygpO1xuICAgICAgICBpZiAocHQudCA8IHBtLnQpIHtcbiAgICAgICAgICAgIGlmIChxICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxLmZyb21JbnQoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAociAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5VG8ocik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IG5iaSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gbmJpKCk7XG4gICAgICAgIHZhciB0cyA9IHRoaXMucztcbiAgICAgICAgdmFyIG1zID0gbS5zO1xuICAgICAgICB2YXIgbnNoID0gdGhpcy5EQiAtIG5iaXRzKHBtW3BtLnQgLSAxXSk7IC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gICAgICAgIGlmIChuc2ggPiAwKSB7XG4gICAgICAgICAgICBwbS5sU2hpZnRUbyhuc2gsIHkpO1xuICAgICAgICAgICAgcHQubFNoaWZ0VG8obnNoLCByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBtLmNvcHlUbyh5KTtcbiAgICAgICAgICAgIHB0LmNvcHlUbyhyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeXMgPSB5LnQ7XG4gICAgICAgIHZhciB5MCA9IHlbeXMgLSAxXTtcbiAgICAgICAgaWYgKHkwID09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeXQgPSB5MCAqICgxIDw8IHRoaXMuRjEpICsgKCh5cyA+IDEpID8geVt5cyAtIDJdID4+IHRoaXMuRjIgOiAwKTtcbiAgICAgICAgdmFyIGQxID0gdGhpcy5GViAvIHl0O1xuICAgICAgICB2YXIgZDIgPSAoMSA8PCB0aGlzLkYxKSAvIHl0O1xuICAgICAgICB2YXIgZSA9IDEgPDwgdGhpcy5GMjtcbiAgICAgICAgdmFyIGkgPSByLnQ7XG4gICAgICAgIHZhciBqID0gaSAtIHlzO1xuICAgICAgICB2YXIgdCA9IChxID09IG51bGwpID8gbmJpKCkgOiBxO1xuICAgICAgICB5LmRsU2hpZnRUbyhqLCB0KTtcbiAgICAgICAgaWYgKHIuY29tcGFyZVRvKHQpID49IDApIHtcbiAgICAgICAgICAgIHJbci50KytdID0gMTtcbiAgICAgICAgICAgIHIuc3ViVG8odCwgcik7XG4gICAgICAgIH1cbiAgICAgICAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLCB0KTtcbiAgICAgICAgdC5zdWJUbyh5LCB5KTsgLy8gXCJuZWdhdGl2ZVwiIHkgc28gd2UgY2FuIHJlcGxhY2Ugc3ViIHdpdGggYW0gbGF0ZXJcbiAgICAgICAgd2hpbGUgKHkudCA8IHlzKSB7XG4gICAgICAgICAgICB5W3kudCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKC0taiA+PSAwKSB7XG4gICAgICAgICAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgICAgICAgICAgdmFyIHFkID0gKHJbLS1pXSA9PSB5MCkgPyB0aGlzLkRNIDogTWF0aC5mbG9vcihyW2ldICogZDEgKyAocltpIC0gMV0gKyBlKSAqIGQyKTtcbiAgICAgICAgICAgIGlmICgocltpXSArPSB5LmFtKDAsIHFkLCByLCBqLCAwLCB5cykpIDwgcWQpIHsgLy8gVHJ5IGl0IG91dFxuICAgICAgICAgICAgICAgIHkuZGxTaGlmdFRvKGosIHQpO1xuICAgICAgICAgICAgICAgIHIuc3ViVG8odCwgcik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJbaV0gPCAtLXFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHIuc3ViVG8odCwgcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChxICE9IG51bGwpIHtcbiAgICAgICAgICAgIHIuZHJTaGlmdFRvKHlzLCBxKTtcbiAgICAgICAgICAgIGlmICh0cyAhPSBtcykge1xuICAgICAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhxLCBxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByLnQgPSB5cztcbiAgICAgICAgci5jbGFtcCgpO1xuICAgICAgICBpZiAobnNoID4gMCkge1xuICAgICAgICAgICAgci5yU2hpZnRUbyhuc2gsIHIpO1xuICAgICAgICB9IC8vIERlbm9ybWFsaXplIHJlbWFpbmRlclxuICAgICAgICBpZiAodHMgPCAwKSB7XG4gICAgICAgICAgICBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ociwgcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmludkRpZ2l0ID0gYm5wSW52RGlnaXQ7XG4gICAgLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbiAgICAvLyBqdXN0aWZpY2F0aW9uOlxuICAgIC8vICAgICAgICAgeHkgPT0gMSAobW9kIG0pXG4gICAgLy8gICAgICAgICB4eSA9ICAxK2ttXG4gICAgLy8gICB4eSgyLXh5KSA9ICgxK2ttKSgxLWttKVxuICAgIC8vIHhbeSgyLXh5KV0gPSAxLWteMm1eMlxuICAgIC8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbiAgICAvLyBpZiB5IGlzIDEveCBtb2QgbSwgdGhlbiB5KDIteHkpIGlzIDEveCBtb2QgbV4yXG4gICAgLy8gc2hvdWxkIHJlZHVjZSB4IGFuZCB5KDIteHkpIGJ5IG1eMiBhdCBlYWNoIHN0ZXAgdG8ga2VlcCBzaXplIGJvdW5kZWQuXG4gICAgLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmludkRpZ2l0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHggPSB0aGlzWzBdO1xuICAgICAgICBpZiAoKHggJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeSA9IHggJiAzOyAvLyB5ID09IDEveCBtb2QgMl4yXG4gICAgICAgIHkgPSAoeSAqICgyIC0gKHggJiAweGYpICogeSkpICYgMHhmOyAvLyB5ID09IDEveCBtb2QgMl40XG4gICAgICAgIHkgPSAoeSAqICgyIC0gKHggJiAweGZmKSAqIHkpKSAmIDB4ZmY7IC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgICAgICAgeSA9ICh5ICogKDIgLSAoKCh4ICYgMHhmZmZmKSAqIHkpICYgMHhmZmZmKSkpICYgMHhmZmZmOyAvLyB5ID09IDEveCBtb2QgMl4xNlxuICAgICAgICAvLyBsYXN0IHN0ZXAgLSBjYWxjdWxhdGUgaW52ZXJzZSBtb2QgRFYgZGlyZWN0bHk7XG4gICAgICAgIC8vIGFzc3VtZXMgMTYgPCBEQiA8PSAzMiBhbmQgYXNzdW1lcyBhYmlsaXR5IHRvIGhhbmRsZSA0OC1iaXQgaW50c1xuICAgICAgICB5ID0gKHkgKiAoMiAtIHggKiB5ICUgdGhpcy5EVikpICUgdGhpcy5EVjsgLy8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgICAgICAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgICAgICAgcmV0dXJuICh5ID4gMCkgPyB0aGlzLkRWIC0geSA6IC15O1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gYm5wSXNFdmVuO1xuICAgIC8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy50ID4gMCkgPyAodGhpc1swXSAmIDEpIDogdGhpcy5zKSA9PSAwO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZXhwID0gYm5wRXhwO1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXNeZSwgZSA8IDJeMzIsIGRvaW5nIHNxciBhbmQgbXVsIHdpdGggXCJyXCIgKEhBQyAxNC43OSlcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoZSwgeikge1xuICAgICAgICBpZiAoZSA+IDB4ZmZmZmZmZmYgfHwgZSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnRlZ2VyLk9ORTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB2YXIgcjIgPSBuYmkoKTtcbiAgICAgICAgdmFyIGcgPSB6LmNvbnZlcnQodGhpcyk7XG4gICAgICAgIHZhciBpID0gbmJpdHMoZSkgLSAxO1xuICAgICAgICBnLmNvcHlUbyhyKTtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICB6LnNxclRvKHIsIHIyKTtcbiAgICAgICAgICAgIGlmICgoZSAmICgxIDw8IGkpKSA+IDApIHtcbiAgICAgICAgICAgICAgICB6Lm11bFRvKHIyLCBnLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gcjtcbiAgICAgICAgICAgICAgICByID0gcjI7XG4gICAgICAgICAgICAgICAgcjIgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LnJldmVydChyKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNodW5rU2l6ZSA9IGJucENodW5rU2l6ZTtcbiAgICAvLyAocHJvdGVjdGVkKSByZXR1cm4geCBzLnQuIHJeeCA8IERWXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5MTjIgKiB0aGlzLkRCIC8gTWF0aC5sb2cocikpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1JhZGl4ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYiA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSB7XG4gICAgICAgICAgICByZXR1cm4gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG4gICAgICAgIHZhciBhID0gTWF0aC5wb3coYiwgY3MpO1xuICAgICAgICB2YXIgZCA9IG5idihhKTtcbiAgICAgICAgdmFyIHkgPSBuYmkoKTtcbiAgICAgICAgdmFyIHogPSBuYmkoKTtcbiAgICAgICAgdmFyIHIgPSBcIlwiO1xuICAgICAgICB0aGlzLmRpdlJlbVRvKGQsIHksIHopO1xuICAgICAgICB3aGlsZSAoeS5zaWdudW0oKSA+IDApIHtcbiAgICAgICAgICAgIHIgPSAoYSArIHouaW50VmFsdWUoKSkudG9TdHJpbmcoYikuc3Vic3RyKDEpICsgcjtcbiAgICAgICAgICAgIHkuZGl2UmVtVG8oZCwgeSwgeik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHouaW50VmFsdWUoKS50b1N0cmluZyhiKSArIHI7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG4gICAgLy8gKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21SYWRpeCA9IGZ1bmN0aW9uIChzLCBiKSB7XG4gICAgICAgIHRoaXMuZnJvbUludCgwKTtcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgYiA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xuICAgICAgICB2YXIgZCA9IE1hdGgucG93KGIsIGNzKTtcbiAgICAgICAgdmFyIG1pID0gZmFsc2U7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB4ID0gaW50QXQocywgaSk7XG4gICAgICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gXCItXCIgJiYgdGhpcy5zaWdudW0oKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3ID0gYiAqIHcgKyB4O1xuICAgICAgICAgICAgaWYgKCsraiA+PSBjcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LCAwKTtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICB3ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZE11bHRpcGx5KE1hdGgucG93KGIsIGopKTtcbiAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCh3LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWkpIHtcbiAgICAgICAgICAgIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlciA9IGJucEZyb21OdW1iZXI7XG4gICAgLy8gKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gICAgICAgICAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsaW50LFJORylcbiAgICAgICAgICAgIGlmIChhIDwgMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbUludCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLCBjKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGVzdEJpdChhIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgTVNCIHNldFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBvcF9vciwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRXZlbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZEFkZE9mZnNldCgxLCAwKTtcbiAgICAgICAgICAgICAgICB9IC8vIGZvcmNlIG9kZFxuICAgICAgICAgICAgICAgIHdoaWxlICghdGhpcy5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KDIsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuICAgICAgICAgICAgdmFyIHggPSBbXTtcbiAgICAgICAgICAgIHZhciB0ID0gYSAmIDc7XG4gICAgICAgICAgICB4Lmxlbmd0aCA9IChhID4+IDMpICsgMTtcbiAgICAgICAgICAgIGIubmV4dEJ5dGVzKHgpO1xuICAgICAgICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgeFswXSAmPSAoKDEgPDwgdCkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHhbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcm9tU3RyaW5nKHgsIDI1Nik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGZ1bmN0aW9uIChhLCBvcCwgcikge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGY7XG4gICAgICAgIHZhciBtID0gTWF0aC5taW4oYS50LCB0aGlzLnQpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICByW2ldID0gb3AodGhpc1tpXSwgYVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEudCA8IHRoaXMudCkge1xuICAgICAgICAgICAgZiA9IGEucyAmIHRoaXMuRE07XG4gICAgICAgICAgICBmb3IgKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgICAgICAgICByW2ldID0gb3AodGhpc1tpXSwgZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmID0gdGhpcy5zICYgdGhpcy5ETTtcbiAgICAgICAgICAgIGZvciAoaSA9IG07IGkgPCBhLnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHJbaV0gPSBvcChmLCBhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIudCA9IGEudDtcbiAgICAgICAgfVxuICAgICAgICByLnMgPSBvcCh0aGlzLnMsIGEucyk7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGZ1bmN0aW9uIChuLCBvcCkge1xuICAgICAgICB2YXIgciA9IEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKTtcbiAgICAgICAgdGhpcy5iaXR3aXNlVG8ociwgb3AsIHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKyBhXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBmdW5jdGlvbiAoYSwgcikge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBjID0gMDtcbiAgICAgICAgdmFyIG0gPSBNYXRoLm1pbihhLnQsIHRoaXMudCk7XG4gICAgICAgIHdoaWxlIChpIDwgbSkge1xuICAgICAgICAgICAgYyArPSB0aGlzW2ldICsgYVtpXTtcbiAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS50IDwgdGhpcy50KSB7XG4gICAgICAgICAgICBjICs9IGEucztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy50KSB7XG4gICAgICAgICAgICAgICAgYyArPSB0aGlzW2ldO1xuICAgICAgICAgICAgICAgIHJbaSsrXSA9IGMgJiB0aGlzLkRNO1xuICAgICAgICAgICAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBhLnQpIHtcbiAgICAgICAgICAgICAgICBjICs9IGFbaV07XG4gICAgICAgICAgICAgICAgcltpKytdID0gYyAmIHRoaXMuRE07XG4gICAgICAgICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgKz0gYS5zO1xuICAgICAgICB9XG4gICAgICAgIHIucyA9IChjIDwgMCkgPyAtMSA6IDA7XG4gICAgICAgIGlmIChjID4gMCkge1xuICAgICAgICAgICAgcltpKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgLTEpIHtcbiAgICAgICAgICAgIHJbaSsrXSA9IHRoaXMuRFYgKyBjO1xuICAgICAgICB9XG4gICAgICAgIHIudCA9IGk7XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLmRNdWx0aXBseSA9IGJucERNdWx0aXBseTtcbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRNdWx0aXBseSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXNbdGhpcy50XSA9IHRoaXMuYW0oMCwgbiAtIDEsIHRoaXMsIDAsIDAsIHRoaXMudCk7XG4gICAgICAgICsrdGhpcy50O1xuICAgICAgICB0aGlzLmNsYW1wKCk7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzICs9IG4gPDwgdyB3b3JkcywgdGhpcyA+PSAwXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZEFkZE9mZnNldCA9IGZ1bmN0aW9uIChuLCB3KSB7XG4gICAgICAgIGlmIChuID09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy50IDw9IHcpIHtcbiAgICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW3ddICs9IG47XG4gICAgICAgIHdoaWxlICh0aGlzW3ddID49IHRoaXMuRFYpIHtcbiAgICAgICAgICAgIHRoaXNbd10gLT0gdGhpcy5EVjtcbiAgICAgICAgICAgIGlmICgrK3cgPj0gdGhpcy50KSB7XG4gICAgICAgICAgICAgICAgdGhpc1t0aGlzLnQrK10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKyt0aGlzW3ddO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG8gPSBibnBNdWx0aXBseUxvd2VyVG87XG4gICAgLy8gKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG8gPSBmdW5jdGlvbiAoYSwgbiwgcikge1xuICAgICAgICB2YXIgaSA9IE1hdGgubWluKHRoaXMudCArIGEudCwgbik7XG4gICAgICAgIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgICAgICAgci50ID0gaTtcbiAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICByWy0taV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSByLnQgLSB0aGlzLnQ7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgIHJbaSArIHRoaXMudF0gPSB0aGlzLmFtKDAsIGFbaV0sIHIsIGksIDAsIHRoaXMudCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWluKGEudCwgbik7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuYW0oMCwgYVtpXSwgciwgaSwgMCwgbiAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIHIuY2xhbXAoKTtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbiAgICAvLyAocHJvdGVjdGVkKSByID0gXCJ0aGlzICogYVwiIHdpdGhvdXQgbG93ZXIgbiB3b3JkcywgbiA+IDBcbiAgICAvLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlVcHBlclRvID0gZnVuY3Rpb24gKGEsIG4sIHIpIHtcbiAgICAgICAgLS1uO1xuICAgICAgICB2YXIgaSA9IHIudCA9IHRoaXMudCArIGEudCAtIG47XG4gICAgICAgIHIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICByW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBNYXRoLm1heChuIC0gdGhpcy50LCAwKTsgaSA8IGEudDsgKytpKSB7XG4gICAgICAgICAgICByW3RoaXMudCArIGkgLSBuXSA9IHRoaXMuYW0obiAtIGksIGFbaV0sIHIsIDAsIDAsIHRoaXMudCArIGkgLSBuKTtcbiAgICAgICAgfVxuICAgICAgICByLmNsYW1wKCk7XG4gICAgICAgIHIuZHJTaGlmdFRvKDEsIHIpO1xuICAgIH07XG4gICAgLy8gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW50ID0gYm5wTW9kSW50O1xuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkID0gdGhpcy5EViAlIG47XG4gICAgICAgIHZhciByID0gKHRoaXMucyA8IDApID8gbiAtIDEgOiAwO1xuICAgICAgICBpZiAodGhpcy50ID4gMCkge1xuICAgICAgICAgICAgaWYgKGQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHIgPSB0aGlzWzBdICUgbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICByID0gKGQgKiByICsgdGhpc1tpXSkgJSBuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIEJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG4gICAgLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZiBwcm9iYWJseSBwcmltZSAoSEFDIDQuMjQsIE1pbGxlci1SYWJpbilcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5taWxsZXJSYWJpbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBuMSA9IHRoaXMuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICB2YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICBpZiAoayA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBuMS5zaGlmdFJpZ2h0KGspO1xuICAgICAgICB0ID0gKHQgKyAxKSA+PiAxO1xuICAgICAgICBpZiAodCA+IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHQgPSBsb3dwcmltZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhID0gbmJpKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gICAgICAgICAgICAvLyBQaWNrIGJhc2VzIGF0IHJhbmRvbSwgaW5zdGVhZCBvZiBzdGFydGluZyBhdCAyXG4gICAgICAgICAgICBhLmZyb21JbnQobG93cHJpbWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxvd3ByaW1lcy5sZW5ndGgpXSk7XG4gICAgICAgICAgICB2YXIgeSA9IGEubW9kUG93KHIsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGogPSAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqKysgPCBrICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSB5Lm1vZFBvd0ludCgyLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvLyBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBiblNxdWFyZTtcbiAgICAvLyAocHVibGljKSB0aGlzXjJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICAgIHRoaXMuc3F1YXJlVG8ocik7XG4gICAgICAgIHJldHVybiByO1xuICAgIH07XG4gICAgLy8jcmVnaW9uIEFTWU5DXG4gICAgLy8gUHVibGljIEFQSSBtZXRob2RcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2RhID0gZnVuY3Rpb24gKGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4ID0gKHRoaXMucyA8IDApID8gdGhpcy5uZWdhdGUoKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFyIHkgPSAoYS5zIDwgMCkgPyBhLm5lZ2F0ZSgpIDogYS5jbG9uZSgpO1xuICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPCAwKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHg7XG4gICAgICAgICAgICB4ID0geTtcbiAgICAgICAgICAgIHkgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0geC5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgICAgdmFyIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgICBpZiAoZyA8IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgZykge1xuICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGcgPiAwKSB7XG4gICAgICAgICAgICB4LnJTaGlmdFRvKGcsIHgpO1xuICAgICAgICAgICAgeS5yU2hpZnRUbyhnLCB5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXb3JraG9yc2Ugb2YgdGhlIGFsZ29yaXRobSwgZ2V0cyBjYWxsZWQgMjAwIC0gODAwIHRpbWVzIHBlciA1MTIgYml0IGtleWdlbi5cbiAgICAgICAgdmFyIGdjZGExID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKChpID0geC5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbyhpLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkge1xuICAgICAgICAgICAgICAgIHkuclNoaWZ0VG8oaSwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHguc3ViVG8oeSwgeCk7XG4gICAgICAgICAgICAgICAgeC5yU2hpZnRUbygxLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHkuc3ViVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgeS5yU2hpZnRUbygxLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHguc2lnbnVtKCkgPiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChnID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB5LmxTaGlmdFRvKGcsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soeSk7IH0sIDApOyAvLyBlc2NhcGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZ2NkYTEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KGdjZGExLCAxMCk7XG4gICAgfTtcbiAgICAvLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyQXN5bmMgPSBmdW5jdGlvbiAoYSwgYiwgYywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIGlmIChhIDwgMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbUludCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihhLCBjKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudGVzdEJpdChhIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEgLSAxKSwgb3Bfb3IsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0V2ZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBibnBfMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGJucGZuMV8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBibnBfMS5kQWRkT2Zmc2V0KDIsIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm5wXzEuYml0TGVuZ3RoKCkgPiBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibnBfMS5zdWJUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYSAtIDEpLCBibnBfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJucF8xLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKCk7IH0sIDApOyAvLyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYm5wZm4xXzEsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGJucGZuMV8xLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB4ID0gW107XG4gICAgICAgICAgICB2YXIgdCA9IGEgJiA3O1xuICAgICAgICAgICAgeC5sZW5ndGggPSAoYSA+PiAzKSArIDE7XG4gICAgICAgICAgICBiLm5leHRCeXRlcyh4KTtcbiAgICAgICAgICAgIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgICAgIHhbMF0gJj0gKCgxIDw8IHQpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB4WzBdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh4LCAyNTYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQmlnSW50ZWdlcjtcbn0oKSk7XG4vLyNyZWdpb24gUkVEVUNFUlNcbi8vI3JlZ2lvbiBOdWxsRXhwXG52YXIgTnVsbEV4cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOdWxsRXhwKCkge1xuICAgIH1cbiAgICAvLyBOdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0ID0gbk5vcDtcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICAvLyBOdWxsRXhwLnByb3RvdHlwZS5yZXZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgLy8gTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG87XG4gICAgTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgICB4Lm11bHRpcGx5VG8oeSwgcik7XG4gICAgfTtcbiAgICAvLyBOdWxsRXhwLnByb3RvdHlwZS5zcXJUbyA9IG5TcXJUbztcbiAgICBOdWxsRXhwLnByb3RvdHlwZS5zcXJUbyA9IGZ1bmN0aW9uICh4LCByKSB7XG4gICAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgfTtcbiAgICByZXR1cm4gTnVsbEV4cDtcbn0oKSk7XG4vLyBNb2R1bGFyIHJlZHVjdGlvbiB1c2luZyBcImNsYXNzaWNcIiBhbGdvcml0aG1cbnZhciBDbGFzc2ljID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsYXNzaWMobSkge1xuICAgICAgICB0aGlzLm0gPSBtO1xuICAgIH1cbiAgICAvLyBDbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gY0NvbnZlcnQ7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICh4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUucmV2ZXJ0ID0gY1JldmVydDtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xuICAgIC8vIENsYXNzaWMucHJvdG90eXBlLnJlZHVjZSA9IGNSZWR1Y2U7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeC5kaXZSZW1Ubyh0aGlzLm0sIG51bGwsIHgpO1xuICAgIH07XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiAoeCwgeSwgcikge1xuICAgICAgICB4Lm11bHRpcGx5VG8oeSwgcik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgLy8gQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBjU3FyVG87XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBmdW5jdGlvbiAoeCwgcikge1xuICAgICAgICB4LnNxdWFyZVRvKHIpO1xuICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICB9O1xuICAgIHJldHVybiBDbGFzc2ljO1xufSgpKTtcbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIE1vbnRnb21lcnlcbi8vIE1vbnRnb21lcnkgcmVkdWN0aW9uXG52YXIgTW9udGdvbWVyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb250Z29tZXJ5KG0pIHtcbiAgICAgICAgdGhpcy5tID0gbTtcbiAgICAgICAgdGhpcy5tcCA9IG0uaW52RGlnaXQoKTtcbiAgICAgICAgdGhpcy5tcGwgPSB0aGlzLm1wICYgMHg3ZmZmO1xuICAgICAgICB0aGlzLm1waCA9IHRoaXMubXAgPj4gMTU7XG4gICAgICAgIHRoaXMudW0gPSAoMSA8PCAobS5EQiAtIDE1KSkgLSAxO1xuICAgICAgICB0aGlzLm10MiA9IDIgKiBtLnQ7XG4gICAgfVxuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBtb250Q29udmVydDtcbiAgICAvLyB4UiBtb2QgbVxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICB4LmFicygpLmRsU2hpZnRUbyh0aGlzLm0udCwgcik7XG4gICAgICAgIHIuZGl2UmVtVG8odGhpcy5tLCBudWxsLCByKTtcbiAgICAgICAgaWYgKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubS5zdWJUbyhyLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLnJldmVydCA9IG1vbnRSZXZlcnQ7XG4gICAgLy8geC9SIG1vZCBtXG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgICAgeC5jb3B5VG8ocik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IG1vbnRSZWR1Y2U7XG4gICAgLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHdoaWxlICh4LnQgPD0gdGhpcy5tdDIpIHtcbiAgICAgICAgICAgIC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgICAgICAgICAgeFt4LnQrK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgICAgICAgICAgLy8gZmFzdGVyIHdheSBvZiBjYWxjdWxhdGluZyB1MCA9IHhbaV0qbXAgbW9kIERWXG4gICAgICAgICAgICB2YXIgaiA9IHhbaV0gJiAweDdmZmY7XG4gICAgICAgICAgICB2YXIgdTAgPSAoaiAqIHRoaXMubXBsICsgKCgoaiAqIHRoaXMubXBoICsgKHhbaV0gPj4gMTUpICogdGhpcy5tcGwpICYgdGhpcy51bSkgPDwgMTUpKSAmIHguRE07XG4gICAgICAgICAgICAvLyB1c2UgYW0gdG8gY29tYmluZSB0aGUgbXVsdGlwbHktc2hpZnQtYWRkIGludG8gb25lIGNhbGxcbiAgICAgICAgICAgIGogPSBpICsgdGhpcy5tLnQ7XG4gICAgICAgICAgICB4W2pdICs9IHRoaXMubS5hbSgwLCB1MCwgeCwgaSwgMCwgdGhpcy5tLnQpO1xuICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgICAgICAgICB3aGlsZSAoeFtqXSA+PSB4LkRWKSB7XG4gICAgICAgICAgICAgICAgeFtqXSAtPSB4LkRWO1xuICAgICAgICAgICAgICAgIHhbKytqXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHguY2xhbXAoKTtcbiAgICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQsIHgpO1xuICAgICAgICBpZiAoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB7XG4gICAgICAgICAgICB4LnN1YlRvKHRoaXMubSwgeCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIE1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuICAgIC8vIHIgPSBcInh5L1IgbW9kIG1cIjsgeCx5ICE9IHJcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICAvLyBNb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbyA9IG1vbnRTcXJUbztcbiAgICAvLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5zcXJUbyA9IGZ1bmN0aW9uICh4LCByKSB7XG4gICAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbnRnb21lcnk7XG59KCkpO1xuLy8jZW5kcmVnaW9uIE1vbnRnb21lcnlcbi8vI3JlZ2lvbiBCYXJyZXR0XG4vLyBCYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG52YXIgQmFycmV0dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXJyZXR0KG0pIHtcbiAgICAgICAgdGhpcy5tID0gbTtcbiAgICAgICAgLy8gc2V0dXAgQmFycmV0dFxuICAgICAgICB0aGlzLnIyID0gbmJpKCk7XG4gICAgICAgIHRoaXMucTMgPSBuYmkoKTtcbiAgICAgICAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIgKiBtLnQsIHRoaXMucjIpO1xuICAgICAgICB0aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSk7XG4gICAgfVxuICAgIC8vIEJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBiYXJyZXR0Q29udmVydDtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKHgucyA8IDAgfHwgeC50ID4gMiAqIHRoaXMubS50KSB7XG4gICAgICAgICAgICByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgICAgICAgeC5jb3B5VG8ocik7XG4gICAgICAgICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLnJldmVydCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbiAgICAvLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuICAgIEJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHguZHJTaGlmdFRvKHRoaXMubS50IC0gMSwgdGhpcy5yMik7XG4gICAgICAgIGlmICh4LnQgPiB0aGlzLm0udCArIDEpIHtcbiAgICAgICAgICAgIHgudCA9IHRoaXMubS50ICsgMTtcbiAgICAgICAgICAgIHguY2xhbXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm11Lm11bHRpcGx5VXBwZXJUbyh0aGlzLnIyLCB0aGlzLm0udCArIDEsIHRoaXMucTMpO1xuICAgICAgICB0aGlzLm0ubXVsdGlwbHlMb3dlclRvKHRoaXMucTMsIHRoaXMubS50ICsgMSwgdGhpcy5yMik7XG4gICAgICAgIHdoaWxlICh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHtcbiAgICAgICAgICAgIHguZEFkZE9mZnNldCgxLCB0aGlzLm0udCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHguc3ViVG8odGhpcy5yMiwgeCk7XG4gICAgICAgIHdoaWxlICh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHtcbiAgICAgICAgICAgIHguc3ViVG8odGhpcy5tLCB4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBiYXJyZXR0TXVsVG87XG4gICAgLy8gciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uICh4LCB5LCByKSB7XG4gICAgICAgIHgubXVsdGlwbHlUbyh5LCByKTtcbiAgICAgICAgdGhpcy5yZWR1Y2Uocik7XG4gICAgfTtcbiAgICAvLyBCYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGJhcnJldHRTcXJUbztcbiAgICAvLyByID0geF4yIG1vZCBtOyB4ICE9IHJcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5zcXJUbyA9IGZ1bmN0aW9uICh4LCByKSB7XG4gICAgICAgIHguc3F1YXJlVG8ocik7XG4gICAgICAgIHRoaXMucmVkdWNlKHIpO1xuICAgIH07XG4gICAgcmV0dXJuIEJhcnJldHQ7XG59KCkpO1xuLy8jZW5kcmVnaW9uXG4vLyNlbmRyZWdpb24gUkVEVUNFUlNcbi8vIHJldHVybiBuZXcsIHVuc2V0IEJpZ0ludGVnZXJcbmZ1bmN0aW9uIG5iaSgpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpOyB9XG5mdW5jdGlvbiBwYXJzZUJpZ0ludChzdHIsIHIpIHtcbiAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3RyLCByKTtcbn1cbi8vIGFtOiBDb21wdXRlIHdfaiArPSAoeCp0aGlzX2kpLCBwcm9wYWdhdGUgY2Fycmllcyxcbi8vIGMgaXMgaW5pdGlhbCBjYXJyeSwgcmV0dXJucyBmaW5hbCBjYXJyeS5cbi8vIGMgPCAzKmR2YWx1ZSwgeCA8IDIqZHZhbHVlLCB0aGlzX2kgPCBkdmFsdWVcbi8vIFdlIG5lZWQgdG8gc2VsZWN0IHRoZSBmYXN0ZXN0IG9uZSB0aGF0IHdvcmtzIGluIHRoaXMgZW52aXJvbm1lbnQuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgdmFyIHYgPSB4ICogdGhpc1tpKytdICsgd1tqXSArIGM7XG4gICAgICAgIGMgPSBNYXRoLmZsb29yKHYgLyAweDQwMDAwMDApO1xuICAgICAgICB3W2orK10gPSB2ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cbi8vIGFtMiBhdm9pZHMgYSBiaWcgbXVsdC1hbmQtZXh0cmFjdCBjb21wbGV0ZWx5LlxuLy8gTWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDw9IDMwIGJlY2F1c2Ugd2UgZG8gYml0d2lzZSBvcHNcbi8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcbmZ1bmN0aW9uIGFtMihpLCB4LCB3LCBqLCBjLCBuKSB7XG4gICAgdmFyIHhsID0geCAmIDB4N2ZmZjtcbiAgICB2YXIgeGggPSB4ID4+IDE1O1xuICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICB2YXIgbCA9IHRoaXNbaV0gJiAweDdmZmY7XG4gICAgICAgIHZhciBoID0gdGhpc1tpKytdID4+IDE1O1xuICAgICAgICB2YXIgbSA9IHhoICogbCArIGggKiB4bDtcbiAgICAgICAgbCA9IHhsICogbCArICgobSAmIDB4N2ZmZikgPDwgMTUpICsgd1tqXSArIChjICYgMHgzZmZmZmZmZik7XG4gICAgICAgIGMgPSAobCA+Pj4gMzApICsgKG0gPj4+IDE1KSArIHhoICogaCArIChjID4+PiAzMCk7XG4gICAgICAgIHdbaisrXSA9IGwgJiAweDNmZmZmZmZmO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGksIHgsIHcsIGosIGMsIG4pIHtcbiAgICB2YXIgeGwgPSB4ICYgMHgzZmZmO1xuICAgIHZhciB4aCA9IHggPj4gMTQ7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciBsID0gdGhpc1tpXSAmIDB4M2ZmZjtcbiAgICAgICAgdmFyIGggPSB0aGlzW2krK10gPj4gMTQ7XG4gICAgICAgIHZhciBtID0geGggKiBsICsgaCAqIHhsO1xuICAgICAgICBsID0geGwgKiBsICsgKChtICYgMHgzZmZmKSA8PCAxNCkgKyB3W2pdICsgYztcbiAgICAgICAgYyA9IChsID4+IDI4KSArIChtID4+IDE0KSArIHhoICogaDtcbiAgICAgICAgd1tqKytdID0gbCAmIDB4ZmZmZmZmZjtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5pZiAoal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgPT0gXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIikpIHtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMjtcbiAgICBkYml0cyA9IDMwO1xufVxuZWxzZSBpZiAoal9sbSAmJiAobmF2aWdhdG9yLmFwcE5hbWUgIT0gXCJOZXRzY2FwZVwiKSkge1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xO1xuICAgIGRiaXRzID0gMjY7XG59XG5lbHNlIHsgLy8gTW96aWxsYS9OZXRzY2FwZSBzZWVtcyB0byBwcmVmZXIgYW0zXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICAgZGJpdHMgPSAyODtcbn1cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMSA8PCBkYml0cykgLSAxKTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRWID0gKDEgPDwgZGJpdHMpO1xudmFyIEJJX0ZQID0gNTI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsIEJJX0ZQKTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYxID0gQklfRlAgLSBkYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYyID0gMiAqIGRiaXRzIC0gQklfRlA7XG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JDID0gW107XG52YXIgcnI7XG52YXIgdnY7XG5yciA9IFwiMFwiLmNoYXJDb2RlQXQoMCk7XG5mb3IgKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikge1xuICAgIEJJX1JDW3JyKytdID0gdnY7XG59XG5yciA9IFwiYVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IgKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIHtcbiAgICBCSV9SQ1tycisrXSA9IHZ2O1xufVxucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yICh2diA9IDEwOyB2diA8IDM2OyArK3Z2KSB7XG4gICAgQklfUkNbcnIrK10gPSB2djtcbn1cbmZ1bmN0aW9uIGludEF0KHMsIGkpIHtcbiAgICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV07XG4gICAgcmV0dXJuIChjID09IG51bGwpID8gLTEgOiBjO1xufVxuLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuZnVuY3Rpb24gbmJ2KGkpIHtcbiAgICB2YXIgciA9IG5iaSgpO1xuICAgIHIuZnJvbUludChpKTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIHJldHVybnMgYml0IGxlbmd0aCBvZiB0aGUgaW50ZWdlciB4XG5mdW5jdGlvbiBuYml0cyh4KSB7XG4gICAgdmFyIHIgPSAxO1xuICAgIHZhciB0O1xuICAgIGlmICgodCA9IHggPj4+IDE2KSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDE2O1xuICAgIH1cbiAgICBpZiAoKHQgPSB4ID4+IDgpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gODtcbiAgICB9XG4gICAgaWYgKCh0ID0geCA+PiA0KSAhPSAwKSB7XG4gICAgICAgIHggPSB0O1xuICAgICAgICByICs9IDQ7XG4gICAgfVxuICAgIGlmICgodCA9IHggPj4gMikgIT0gMCkge1xuICAgICAgICB4ID0gdDtcbiAgICAgICAgciArPSAyO1xuICAgIH1cbiAgICBpZiAoKHQgPSB4ID4+IDEpICE9IDApIHtcbiAgICAgICAgeCA9IHQ7XG4gICAgICAgIHIgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59XG4vLyBcImNvbnN0YW50c1wiXG5CaWdJbnRlZ2VyLlpFUk8gPSBuYnYoMCk7XG5CaWdJbnRlZ2VyLk9ORSA9IG5idigxKTtcblxuLy8gcHJuZzQuanMgLSB1c2VzIEFyY2ZvdXIgYXMgYSBQUk5HXG52YXIgQXJjZm91ciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcmNmb3VyKCkge1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmogPSAwO1xuICAgICAgICB0aGlzLlMgPSBbXTtcbiAgICB9XG4gICAgLy8gQXJjZm91ci5wcm90b3R5cGUuaW5pdCA9IEFSQzRpbml0O1xuICAgIC8vIEluaXRpYWxpemUgYXJjZm91ciBjb250ZXh0IGZyb20ga2V5LCBhbiBhcnJheSBvZiBpbnRzLCBlYWNoIGZyb20gWzAuLjI1NV1cbiAgICBBcmNmb3VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciB0O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuU1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICAgICAgaiA9IChqICsgdGhpcy5TW2ldICsga2V5W2kgJSBrZXkubGVuZ3RoXSkgJiAyNTU7XG4gICAgICAgICAgICB0ID0gdGhpcy5TW2ldO1xuICAgICAgICAgICAgdGhpcy5TW2ldID0gdGhpcy5TW2pdO1xuICAgICAgICAgICAgdGhpcy5TW2pdID0gdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmogPSAwO1xuICAgIH07XG4gICAgLy8gQXJjZm91ci5wcm90b3R5cGUubmV4dCA9IEFSQzRuZXh0O1xuICAgIEFyY2ZvdXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0O1xuICAgICAgICB0aGlzLmkgPSAodGhpcy5pICsgMSkgJiAyNTU7XG4gICAgICAgIHRoaXMuaiA9ICh0aGlzLmogKyB0aGlzLlNbdGhpcy5pXSkgJiAyNTU7XG4gICAgICAgIHQgPSB0aGlzLlNbdGhpcy5pXTtcbiAgICAgICAgdGhpcy5TW3RoaXMuaV0gPSB0aGlzLlNbdGhpcy5qXTtcbiAgICAgICAgdGhpcy5TW3RoaXMual0gPSB0O1xuICAgICAgICByZXR1cm4gdGhpcy5TWyh0ICsgdGhpcy5TW3RoaXMuaV0pICYgMjU1XTtcbiAgICB9O1xuICAgIHJldHVybiBBcmNmb3VyO1xufSgpKTtcbi8vIFBsdWcgaW4geW91ciBSTkcgY29uc3RydWN0b3IgaGVyZVxuZnVuY3Rpb24gcHJuZ19uZXdzdGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IEFyY2ZvdXIoKTtcbn1cbi8vIFBvb2wgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCBhbmQgZ3JlYXRlciB0aGFuIDMyLlxuLy8gQW4gYXJyYXkgb2YgYnl0ZXMgdGhlIHNpemUgb2YgdGhlIHBvb2wgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpXG52YXIgcm5nX3BzaXplID0gMjU2O1xuXG4vLyBSYW5kb20gbnVtYmVyIGdlbmVyYXRvciAtIHJlcXVpcmVzIGEgUFJORyBiYWNrZW5kLCBlLmcuIHBybmc0LmpzXG52YXIgcm5nX3N0YXRlO1xudmFyIHJuZ19wb29sID0gbnVsbDtcbnZhciBybmdfcHB0cjtcbi8vIEluaXRpYWxpemUgdGhlIHBvb2wgd2l0aCBqdW5rIGlmIG5lZWRlZC5cbmlmIChybmdfcG9vbCA9PSBudWxsKSB7XG4gICAgcm5nX3Bvb2wgPSBbXTtcbiAgICBybmdfcHB0ciA9IDA7XG4gICAgdmFyIHQgPSB2b2lkIDA7XG4gICAgaWYgKHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgLy8gRXh0cmFjdCBlbnRyb3B5ICgyMDQ4IGJpdHMpIGZyb20gUk5HIGlmIGF2YWlsYWJsZVxuICAgICAgICB2YXIgeiA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuICAgICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh6KTtcbiAgICAgICAgZm9yICh0ID0gMDsgdCA8IHoubGVuZ3RoOyArK3QpIHtcbiAgICAgICAgICAgIHJuZ19wb29sW3JuZ19wcHRyKytdID0gelt0XSAmIDI1NTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2UgbW91c2UgZXZlbnRzIGZvciBlbnRyb3B5LCBpZiB3ZSBkbyBub3QgaGF2ZSBlbm91Z2ggZW50cm9weSBieSB0aGUgdGltZVxuICAgIC8vIHdlIG5lZWQgaXQsIGVudHJvcHkgd2lsbCBiZSBnZW5lcmF0ZWQgYnkgTWF0aC5yYW5kb20uXG4gICAgdmFyIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB0aGlzLmNvdW50ID0gdGhpcy5jb3VudCB8fCAwO1xuICAgICAgICBpZiAodGhpcy5jb3VudCA+PSAyNTYgfHwgcm5nX3BwdHIgPj0gcm5nX3BzaXplKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdpbmRvdy5kZXRhY2hFdmVudCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudChcIm9ubW91c2Vtb3ZlXCIsIG9uTW91c2VNb3ZlTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtb3VzZUNvb3JkaW5hdGVzID0gZXYueCArIGV2Lnk7XG4gICAgICAgICAgICBybmdfcG9vbFtybmdfcHB0cisrXSA9IG1vdXNlQ29vcmRpbmF0ZXMgJiAyNTU7XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBGaXJlZm94IHdpbGwgZGVueSBwZXJtaXNzaW9uIHRvIGFjY2VzcyBldmVudCBwcm9wZXJ0aWVzIGZvciBzb21lIHJlYXNvbi4gSWdub3JlLlxuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25Nb3VzZU1vdmVMaXN0ZW5lcl8xLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoXCJvbm1vdXNlbW92ZVwiLCBvbk1vdXNlTW92ZUxpc3RlbmVyXzEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJuZ19nZXRfYnl0ZSgpIHtcbiAgICBpZiAocm5nX3N0YXRlID09IG51bGwpIHtcbiAgICAgICAgcm5nX3N0YXRlID0gcHJuZ19uZXdzdGF0ZSgpO1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBtYXkgbm90IGhhdmUgY29sbGVjdGVkIGVub3VnaCBlbnRyb3B5LiAgSWYgbm90LCBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb21cbiAgICAgICAgd2hpbGUgKHJuZ19wcHRyIDwgcm5nX3BzaXplKSB7XG4gICAgICAgICAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcig2NTUzNiAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gPSByYW5kb20gJiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgcm5nX3N0YXRlLmluaXQocm5nX3Bvb2wpO1xuICAgICAgICBmb3IgKHJuZ19wcHRyID0gMDsgcm5nX3BwdHIgPCBybmdfcG9vbC5sZW5ndGg7ICsrcm5nX3BwdHIpIHtcbiAgICAgICAgICAgIHJuZ19wb29sW3JuZ19wcHRyXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcm5nX3BwdHIgPSAwO1xuICAgIH1cbiAgICAvLyBUT0RPOiBhbGxvdyByZXNlZWRpbmcgYWZ0ZXIgZmlyc3QgcmVxdWVzdFxuICAgIHJldHVybiBybmdfc3RhdGUubmV4dCgpO1xufVxudmFyIFNlY3VyZVJhbmRvbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWN1cmVSYW5kb20oKSB7XG4gICAgfVxuICAgIFNlY3VyZVJhbmRvbS5wcm90b3R5cGUubmV4dEJ5dGVzID0gZnVuY3Rpb24gKGJhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGJhW2ldID0gcm5nX2dldF9ieXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZWN1cmVSYW5kb207XG59KCkpO1xuXG4vLyBEZXBlbmRzIG9uIGpzYm4uanMgYW5kIHJuZy5qc1xuLy8gZnVuY3Rpb24gbGluZWJyayhzLG4pIHtcbi8vICAgdmFyIHJldCA9IFwiXCI7XG4vLyAgIHZhciBpID0gMDtcbi8vICAgd2hpbGUoaSArIG4gPCBzLmxlbmd0aCkge1xuLy8gICAgIHJldCArPSBzLnN1YnN0cmluZyhpLGkrbikgKyBcIlxcblwiO1xuLy8gICAgIGkgKz0gbjtcbi8vICAgfVxuLy8gICByZXR1cm4gcmV0ICsgcy5zdWJzdHJpbmcoaSxzLmxlbmd0aCk7XG4vLyB9XG4vLyBmdW5jdGlvbiBieXRlMkhleChiKSB7XG4vLyAgIGlmKGIgPCAweDEwKVxuLy8gICAgIHJldHVybiBcIjBcIiArIGIudG9TdHJpbmcoMTYpO1xuLy8gICBlbHNlXG4vLyAgICAgcmV0dXJuIGIudG9TdHJpbmcoMTYpO1xuLy8gfVxuZnVuY3Rpb24gcGtjczFwYWQxKHMsIG4pIHtcbiAgICBpZiAobiA8IHMubGVuZ3RoICsgMjIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1lc3NhZ2UgdG9vIGxvbmcgZm9yIFJTQVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBuIC0gcy5sZW5ndGggLSA2O1xuICAgIHZhciBmaWxsZXIgPSBcIlwiO1xuICAgIGZvciAodmFyIGYgPSAwOyBmIDwgbGVuOyBmICs9IDIpIHtcbiAgICAgICAgZmlsbGVyICs9IFwiZmZcIjtcbiAgICB9XG4gICAgdmFyIG0gPSBcIjAwMDFcIiArIGZpbGxlciArIFwiMDBcIiArIHM7XG4gICAgcmV0dXJuIHBhcnNlQmlnSW50KG0sIDE2KTtcbn1cbi8vIFBLQ1MjMSAodHlwZSAyLCByYW5kb20pIHBhZCBpbnB1dCBzdHJpbmcgcyB0byBuIGJ5dGVzLCBhbmQgcmV0dXJuIGEgYmlnaW50XG5mdW5jdGlvbiBwa2NzMXBhZDIocywgbikge1xuICAgIGlmIChuIDwgcy5sZW5ndGggKyAxMSkgeyAvLyBUT0RPOiBmaXggZm9yIHV0Zi04XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNZXNzYWdlIHRvbyBsb25nIGZvciBSU0FcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgYmEgPSBbXTtcbiAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaSA+PSAwICYmIG4gPiAwKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGktLSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7IC8vIGVuY29kZSB1c2luZyB1dGYtOFxuICAgICAgICAgICAgYmFbLS1uXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgPiAxMjcpICYmIChjIDwgMjA0OCkpIHtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIGJhWy0tbl0gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBiYVstLW5dID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhWy0tbl0gPSAwO1xuICAgIHZhciBybmcgPSBuZXcgU2VjdXJlUmFuZG9tKCk7XG4gICAgdmFyIHggPSBbXTtcbiAgICB3aGlsZSAobiA+IDIpIHsgLy8gcmFuZG9tIG5vbi16ZXJvIHBhZFxuICAgICAgICB4WzBdID0gMDtcbiAgICAgICAgd2hpbGUgKHhbMF0gPT0gMCkge1xuICAgICAgICAgICAgcm5nLm5leHRCeXRlcyh4KTtcbiAgICAgICAgfVxuICAgICAgICBiYVstLW5dID0geFswXTtcbiAgICB9XG4gICAgYmFbLS1uXSA9IDI7XG4gICAgYmFbLS1uXSA9IDA7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGJhKTtcbn1cbi8vIFwiZW1wdHlcIiBSU0Ega2V5IGNvbnN0cnVjdG9yXG52YXIgUlNBS2V5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJTQUtleSgpIHtcbiAgICAgICAgdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5lID0gMDtcbiAgICAgICAgdGhpcy5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5wID0gbnVsbDtcbiAgICAgICAgdGhpcy5xID0gbnVsbDtcbiAgICAgICAgdGhpcy5kbXAxID0gbnVsbDtcbiAgICAgICAgdGhpcy5kbXExID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb2VmZiA9IG51bGw7XG4gICAgfVxuICAgIC8vI3JlZ2lvbiBQUk9URUNURURcbiAgICAvLyBwcm90ZWN0ZWRcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmRvUHVibGljID0gUlNBRG9QdWJsaWM7XG4gICAgLy8gUGVyZm9ybSByYXcgcHVibGljIG9wZXJhdGlvbiBvbiBcInhcIjogcmV0dXJuIHheZSAobW9kIG4pXG4gICAgUlNBS2V5LnByb3RvdHlwZS5kb1B1YmxpYyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4Lm1vZFBvd0ludCh0aGlzLmUsIHRoaXMubik7XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmRvUHJpdmF0ZSA9IFJTQURvUHJpdmF0ZTtcbiAgICAvLyBQZXJmb3JtIHJhdyBwcml2YXRlIG9wZXJhdGlvbiBvbiBcInhcIjogcmV0dXJuIHheZCAobW9kIG4pXG4gICAgUlNBS2V5LnByb3RvdHlwZS5kb1ByaXZhdGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAodGhpcy5wID09IG51bGwgfHwgdGhpcy5xID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB4Lm1vZFBvdyh0aGlzLmQsIHRoaXMubik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmUtY2FsY3VsYXRlIGFueSBtaXNzaW5nIENSVCBwYXJhbXNcbiAgICAgICAgdmFyIHhwID0geC5tb2QodGhpcy5wKS5tb2RQb3codGhpcy5kbXAxLCB0aGlzLnApO1xuICAgICAgICB2YXIgeHEgPSB4Lm1vZCh0aGlzLnEpLm1vZFBvdyh0aGlzLmRtcTEsIHRoaXMucSk7XG4gICAgICAgIHdoaWxlICh4cC5jb21wYXJlVG8oeHEpIDwgMCkge1xuICAgICAgICAgICAgeHAgPSB4cC5hZGQodGhpcy5wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geHAuc3VidHJhY3QoeHEpLm11bHRpcGx5KHRoaXMuY29lZmYpLm1vZCh0aGlzLnApLm11bHRpcGx5KHRoaXMucSkuYWRkKHhxKTtcbiAgICB9O1xuICAgIC8vI2VuZHJlZ2lvbiBQUk9URUNURURcbiAgICAvLyNyZWdpb24gUFVCTElDXG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5zZXRQdWJsaWMgPSBSU0FTZXRQdWJsaWM7XG4gICAgLy8gU2V0IHRoZSBwdWJsaWMga2V5IGZpZWxkcyBOIGFuZCBlIGZyb20gaGV4IHN0cmluZ3NcbiAgICBSU0FLZXkucHJvdG90eXBlLnNldFB1YmxpYyA9IGZ1bmN0aW9uIChOLCBFKSB7XG4gICAgICAgIGlmIChOICE9IG51bGwgJiYgRSAhPSBudWxsICYmIE4ubGVuZ3RoID4gMCAmJiBFLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KE4sIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIFJTQSBwdWJsaWMga2V5XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmVuY3J5cHQgPSBSU0FFbmNyeXB0O1xuICAgIC8vIFJldHVybiB0aGUgUEtDUyMxIFJTQSBlbmNyeXB0aW9uIG9mIFwidGV4dFwiIGFzIGFuIGV2ZW4tbGVuZ3RoIGhleCBzdHJpbmdcbiAgICBSU0FLZXkucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgbSA9IHBrY3MxcGFkMih0ZXh0LCAodGhpcy5uLmJpdExlbmd0aCgpICsgNykgPj4gMyk7XG4gICAgICAgIGlmIChtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjID0gdGhpcy5kb1B1YmxpYyhtKTtcbiAgICAgICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGggPSBjLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKChoLmxlbmd0aCAmIDEpID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiICsgaDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5zZXRQcml2YXRlID0gUlNBU2V0UHJpdmF0ZTtcbiAgICAvLyBTZXQgdGhlIHByaXZhdGUga2V5IGZpZWxkcyBOLCBlLCBhbmQgZCBmcm9tIGhleCBzdHJpbmdzXG4gICAgUlNBS2V5LnByb3RvdHlwZS5zZXRQcml2YXRlID0gZnVuY3Rpb24gKE4sIEUsIEQpIHtcbiAgICAgICAgaWYgKE4gIT0gbnVsbCAmJiBFICE9IG51bGwgJiYgTi5sZW5ndGggPiAwICYmIEUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQoTiwgMTYpO1xuICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICAgICAgdGhpcy5kID0gcGFyc2VCaWdJbnQoRCwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgUlNBIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGVFeCA9IFJTQVNldFByaXZhdGVFeDtcbiAgICAvLyBTZXQgdGhlIHByaXZhdGUga2V5IGZpZWxkcyBOLCBlLCBkIGFuZCBDUlQgcGFyYW1zIGZyb20gaGV4IHN0cmluZ3NcbiAgICBSU0FLZXkucHJvdG90eXBlLnNldFByaXZhdGVFeCA9IGZ1bmN0aW9uIChOLCBFLCBELCBQLCBRLCBEUCwgRFEsIEMpIHtcbiAgICAgICAgaWYgKE4gIT0gbnVsbCAmJiBFICE9IG51bGwgJiYgTi5sZW5ndGggPiAwICYmIEUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uID0gcGFyc2VCaWdJbnQoTiwgMTYpO1xuICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICAgICAgdGhpcy5kID0gcGFyc2VCaWdJbnQoRCwgMTYpO1xuICAgICAgICAgICAgdGhpcy5wID0gcGFyc2VCaWdJbnQoUCwgMTYpO1xuICAgICAgICAgICAgdGhpcy5xID0gcGFyc2VCaWdJbnQoUSwgMTYpO1xuICAgICAgICAgICAgdGhpcy5kbXAxID0gcGFyc2VCaWdJbnQoRFAsIDE2KTtcbiAgICAgICAgICAgIHRoaXMuZG1xMSA9IHBhcnNlQmlnSW50KERRLCAxNik7XG4gICAgICAgICAgICB0aGlzLmNvZWZmID0gcGFyc2VCaWdJbnQoQywgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgUlNBIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSU0FLZXkucHJvdG90eXBlLmdlbmVyYXRlID0gUlNBR2VuZXJhdGU7XG4gICAgLy8gR2VuZXJhdGUgYSBuZXcgcmFuZG9tIHByaXZhdGUga2V5IEIgYml0cyBsb25nLCB1c2luZyBwdWJsaWMgZXhwdCBFXG4gICAgUlNBS2V5LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChCLCBFKSB7XG4gICAgICAgIHZhciBybmcgPSBuZXcgU2VjdXJlUmFuZG9tKCk7XG4gICAgICAgIHZhciBxcyA9IEIgPj4gMTtcbiAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQoRSwgMTYpO1xuICAgICAgICB2YXIgZWUgPSBuZXcgQmlnSW50ZWdlcihFLCAxNik7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBuZXcgQmlnSW50ZWdlcihCIC0gcXMsIDEsIHJuZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKGVlKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpID09IDAgJiYgdGhpcy5wLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIHRoaXMucSA9IG5ldyBCaWdJbnRlZ2VyKHFzLCAxLCBybmcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChlZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHRoaXMucS5pc1Byb2JhYmxlUHJpbWUoMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnAuY29tcGFyZVRvKHRoaXMucSkgPD0gMCkge1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5wO1xuICAgICAgICAgICAgICAgIHRoaXMucCA9IHRoaXMucTtcbiAgICAgICAgICAgICAgICB0aGlzLnEgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHAxID0gdGhpcy5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICAgICAgICAgIHZhciBxMSA9IHRoaXMucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICB2YXIgcGhpID0gcDEubXVsdGlwbHkocTEpO1xuICAgICAgICAgICAgaWYgKHBoaS5nY2QoZWUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubiA9IHRoaXMucC5tdWx0aXBseSh0aGlzLnEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZCA9IGVlLm1vZEludmVyc2UocGhpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRtcDEgPSB0aGlzLmQubW9kKHAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRtcTEgPSB0aGlzLmQubW9kKHExKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmID0gdGhpcy5xLm1vZEludmVyc2UodGhpcy5wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUlNBS2V5LnByb3RvdHlwZS5kZWNyeXB0ID0gUlNBRGVjcnlwdDtcbiAgICAvLyBSZXR1cm4gdGhlIFBLQ1MjMSBSU0EgZGVjcnlwdGlvbiBvZiBcImN0ZXh0XCIuXG4gICAgLy8gXCJjdGV4dFwiIGlzIGFuIGV2ZW4tbGVuZ3RoIGhleCBzdHJpbmcgYW5kIHRoZSBvdXRwdXQgaXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgUlNBS2V5LnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGN0ZXh0KSB7XG4gICAgICAgIHZhciBjID0gcGFyc2VCaWdJbnQoY3RleHQsIDE2KTtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmRvUHJpdmF0ZShjKTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBrY3MxdW5wYWQyKG0sICh0aGlzLm4uYml0TGVuZ3RoKCkgKyA3KSA+PiAzKTtcbiAgICB9O1xuICAgIC8vIEdlbmVyYXRlIGEgbmV3IHJhbmRvbSBwcml2YXRlIGtleSBCIGJpdHMgbG9uZywgdXNpbmcgcHVibGljIGV4cHQgRVxuICAgIFJTQUtleS5wcm90b3R5cGUuZ2VuZXJhdGVBc3luYyA9IGZ1bmN0aW9uIChCLCBFLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcm5nID0gbmV3IFNlY3VyZVJhbmRvbSgpO1xuICAgICAgICB2YXIgcXMgPSBCID4+IDE7XG4gICAgICAgIHRoaXMuZSA9IHBhcnNlSW50KEUsIDE2KTtcbiAgICAgICAgdmFyIGVlID0gbmV3IEJpZ0ludGVnZXIoRSwgMTYpO1xuICAgICAgICB2YXIgcnNhID0gdGhpcztcbiAgICAgICAgLy8gVGhlc2UgZnVuY3Rpb25zIGhhdmUgbm9uLWRlc2NyaXB0IG5hbWVzIGJlY2F1c2UgdGhleSB3ZXJlIG9yaWdpbmFsbHkgZm9yKDs7KSBsb29wcy5cbiAgICAgICAgLy8gSSBkb24ndCBrbm93IGFib3V0IGNyeXB0b2dyYXBoeSB0byBnaXZlIHRoZW0gYmV0dGVyIG5hbWVzIHRoYW4gbG9vcDEtNC5cbiAgICAgICAgdmFyIGxvb3AxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvb3A0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChyc2EucC5jb21wYXJlVG8ocnNhLnEpIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByc2EucDtcbiAgICAgICAgICAgICAgICAgICAgcnNhLnAgPSByc2EucTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLnEgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcDEgPSByc2EucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICAgICAgICAgICAgdmFyIHExID0gcnNhLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgICAgIHZhciBwaGkgPSBwMS5tdWx0aXBseShxMSk7XG4gICAgICAgICAgICAgICAgaWYgKHBoaS5nY2QoZWUpLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByc2EubiA9IHJzYS5wLm11bHRpcGx5KHJzYS5xKTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLmQgPSBlZS5tb2RJbnZlcnNlKHBoaSk7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5kbXAxID0gcnNhLmQubW9kKHAxKTtcbiAgICAgICAgICAgICAgICAgICAgcnNhLmRtcTEgPSByc2EuZC5tb2QocTEpO1xuICAgICAgICAgICAgICAgICAgICByc2EuY29lZmYgPSByc2EucS5tb2RJbnZlcnNlKHJzYS5wKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGNhbGxiYWNrKCk7IH0sIDApOyAvLyBlc2NhcGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDEsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbG9vcDMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnNhLnEgPSBuYmkoKTtcbiAgICAgICAgICAgICAgICByc2EucS5mcm9tTnVtYmVyQXN5bmMocXMsIDEsIHJuZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByc2EucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkYShlZSwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCAmJiByc2EucS5pc1Byb2JhYmxlUHJpbWUoMTApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wNCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AzLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGxvb3AyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJzYS5wID0gbmJpKCk7XG4gICAgICAgICAgICAgICAgcnNhLnAuZnJvbU51bWJlckFzeW5jKEIgLSBxcywgMSwgcm5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzYS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2RhKGVlLCBmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwICYmIHJzYS5wLmlzUHJvYmFibGVQcmltZSgxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AzLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcDIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvb3AyLCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChsb29wMSwgMCk7XG4gICAgfTtcbiAgICBSU0FLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAodGV4dCwgZGlnZXN0TWV0aG9kLCBkaWdlc3ROYW1lKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSBnZXREaWdlc3RIZWFkZXIoZGlnZXN0TmFtZSk7XG4gICAgICAgIHZhciBkaWdlc3QgPSBoZWFkZXIgKyBkaWdlc3RNZXRob2QodGV4dCkudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG0gPSBwa2NzMXBhZDEoZGlnZXN0LCB0aGlzLm4uYml0TGVuZ3RoKCkgLyA0KTtcbiAgICAgICAgaWYgKG0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmRvUHJpdmF0ZShtKTtcbiAgICAgICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGggPSBjLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKChoLmxlbmd0aCAmIDEpID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiMFwiICsgaDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUlNBS2V5LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAodGV4dCwgc2lnbmF0dXJlLCBkaWdlc3RNZXRob2QpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUJpZ0ludChzaWduYXR1cmUsIDE2KTtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmRvUHVibGljKGMpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5wYWRkZWQgPSBtLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC9eMWYrMDAvLCBcIlwiKTtcbiAgICAgICAgdmFyIGRpZ2VzdCA9IHJlbW92ZURpZ2VzdEhlYWRlcih1bnBhZGRlZCk7XG4gICAgICAgIHJldHVybiBkaWdlc3QgPT0gZGlnZXN0TWV0aG9kKHRleHQpLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUlNBS2V5O1xufSgpKTtcbi8vIFVuZG8gUEtDUyMxICh0eXBlIDIsIHJhbmRvbSkgcGFkZGluZyBhbmQsIGlmIHZhbGlkLCByZXR1cm4gdGhlIHBsYWludGV4dFxuZnVuY3Rpb24gcGtjczF1bnBhZDIoZCwgbikge1xuICAgIHZhciBiID0gZC50b0J5dGVBcnJheSgpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGIubGVuZ3RoICYmIGJbaV0gPT0gMCkge1xuICAgICAgICArK2k7XG4gICAgfVxuICAgIGlmIChiLmxlbmd0aCAtIGkgIT0gbiAtIDEgfHwgYltpXSAhPSAyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICArK2k7XG4gICAgd2hpbGUgKGJbaV0gIT0gMCkge1xuICAgICAgICBpZiAoKytpID49IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICB3aGlsZSAoKytpIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBiW2ldICYgMjU1O1xuICAgICAgICBpZiAoYyA8IDEyOCkgeyAvLyB1dGYtOCBkZWNvZGVcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjID4gMTkxKSAmJiAoYyA8IDIyNCkpIHtcbiAgICAgICAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDMxKSA8PCA2KSB8IChiW2kgKyAxXSAmIDYzKSk7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAxNSkgPDwgMTIpIHwgKChiW2kgKyAxXSAmIDYzKSA8PCA2KSB8IChiW2kgKyAyXSAmIDYzKSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDQ3I3BhZ2UtNDNcbnZhciBESUdFU1RfSEVBREVSUyA9IHtcbiAgICBtZDI6IFwiMzAyMDMwMGMwNjA4MmE4NjQ4ODZmNzBkMDIwMjA1MDAwNDEwXCIsXG4gICAgbWQ1OiBcIjMwMjAzMDBjMDYwODJhODY0ODg2ZjcwZDAyMDUwNTAwMDQxMFwiLFxuICAgIHNoYTE6IFwiMzAyMTMwMDkwNjA1MmIwZTAzMDIxYTA1MDAwNDE0XCIsXG4gICAgc2hhMjI0OiBcIjMwMmQzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwNDA1MDAwNDFjXCIsXG4gICAgc2hhMjU2OiBcIjMwMzEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMTA1MDAwNDIwXCIsXG4gICAgc2hhMzg0OiBcIjMwNDEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMjA1MDAwNDMwXCIsXG4gICAgc2hhNTEyOiBcIjMwNTEzMDBkMDYwOTYwODY0ODAxNjUwMzA0MDIwMzA1MDAwNDQwXCIsXG4gICAgcmlwZW1kMTYwOiBcIjMwMjEzMDA5MDYwNTJiMjQwMzAyMDEwNTAwMDQxNFwiLFxufTtcbmZ1bmN0aW9uIGdldERpZ2VzdEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIERJR0VTVF9IRUFERVJTW25hbWVdIHx8IFwiXCI7XG59XG5mdW5jdGlvbiByZW1vdmVEaWdlc3RIZWFkZXIoc3RyKSB7XG4gICAgZm9yICh2YXIgbmFtZV8xIGluIERJR0VTVF9IRUFERVJTKSB7XG4gICAgICAgIGlmIChESUdFU1RfSEVBREVSUy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gRElHRVNUX0hFQURFUlNbbmFtZV8xXTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBoZWFkZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHN0ci5zdWJzdHIoMCwgbGVuKSA9PSBoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vLyBSZXR1cm4gdGhlIFBLQ1MjMSBSU0EgZW5jcnlwdGlvbiBvZiBcInRleHRcIiBhcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuLy8gZnVuY3Rpb24gUlNBRW5jcnlwdEI2NCh0ZXh0KSB7XG4vLyAgdmFyIGggPSB0aGlzLmVuY3J5cHQodGV4dCk7XG4vLyAgaWYoaCkgcmV0dXJuIGhleDJiNjQoaCk7IGVsc2UgcmV0dXJuIG51bGw7XG4vLyB9XG4vLyBwdWJsaWNcbi8vIFJTQUtleS5wcm90b3R5cGUuZW5jcnlwdF9iNjQgPSBSU0FFbmNyeXB0QjY0O1xuXG4vKiFcbkNvcHlyaWdodCAoYykgMjAxMSwgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkNvZGUgbGljZW5zZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlOlxuaHR0cDovL2RldmVsb3Blci55YWhvby5jb20veXVpL2xpY2Vuc2UuaHRtbFxudmVyc2lvbjogMi45LjBcbiovXG52YXIgWUFIT08gPSB7fTtcbllBSE9PLmxhbmcgPSB7XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBzZXQgdXAgdGhlIHByb3RvdHlwZSwgY29uc3RydWN0b3IgYW5kIHN1cGVyY2xhc3MgcHJvcGVydGllcyB0b1xuICAgICAqIHN1cHBvcnQgYW4gaW5oZXJpdGFuY2Ugc3RyYXRlZ3kgdGhhdCBjYW4gY2hhaW4gY29uc3RydWN0b3JzIGFuZCBtZXRob2RzLlxuICAgICAqIFN0YXRpYyBtZW1iZXJzIHdpbGwgbm90IGJlIGluaGVyaXRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmMgICB0aGUgb2JqZWN0IHRvIG1vZGlmeVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyYyB0aGUgb2JqZWN0IHRvIGluaGVyaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzICBhZGRpdGlvbmFsIHByb3BlcnRpZXMvbWV0aG9kcyB0byBhZGQgdG8gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjbGFzcyBwcm90b3R5cGUuICBUaGVzZSB3aWxsIG92ZXJyaWRlIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmcgaXRlbXMgb2J0YWluZWQgZnJvbSB0aGUgc3VwZXJjbGFzc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgcHJlc2VudC5cbiAgICAgKi9cbiAgICBleHRlbmQ6IGZ1bmN0aW9uKHN1YmMsIHN1cGVyYywgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghIHN1cGVyYyB8fCAhIHN1YmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllBSE9PLmxhbmcuZXh0ZW5kIGZhaWxlZCwgcGxlYXNlIGNoZWNrIHRoYXQgXCIgK1xuICAgICAgICAgICAgICAgIFwiYWxsIGRlcGVuZGVuY2llcyBhcmUgaW5jbHVkZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICBGLnByb3RvdHlwZSA9IHN1cGVyYy5wcm90b3R5cGU7XG4gICAgICAgIHN1YmMucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICAgICAgc3ViYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJjO1xuICAgICAgICBzdWJjLnN1cGVyY2xhc3MgPSBzdXBlcmMucHJvdG90eXBlO1xuXG4gICAgICAgIGlmIChzdXBlcmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHN1cGVyYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdXBlcmM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICBzdWJjLnByb3RvdHlwZVtpXSA9IG92ZXJyaWRlc1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElFIHdpbGwgbm90IGVudW1lcmF0ZSBuYXRpdmUgZnVuY3Rpb25zIGluIGEgZGVyaXZlZCBvYmplY3QgZXZlbiBpZiB0aGVcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIHdhcyBvdmVycmlkZGVuLiAgVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHNwZWNpZmljIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICogd2UgY2FyZSBhYm91dCBvbiB0aGUgT2JqZWN0IHByb3RvdHlwZS5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBfSUVFbnVtRml4XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByICB0aGUgb2JqZWN0IHRvIHJlY2VpdmUgdGhlIGF1Z21lbnRhdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcyAgdGhlIG9iamVjdCB0aGF0IHN1cHBsaWVzIHRoZSBwcm9wZXJ0aWVzIHRvIGF1Z21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBfSUVFbnVtRml4ID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICBBREQgPSBbXCJ0b1N0cmluZ1wiLCBcInZhbHVlT2ZcIl07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICgvTVNJRS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBfSUVFbnVtRml4ID0gZnVuY3Rpb24ociwgcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IEFERC5sZW5ndGg7IGkgPSBpICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbmFtZSA9IEFERFtpXSwgZiA9IHNbZm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJyAmJiBmICE9IE9iamVjdC5wcm90b3R5cGVbZm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbZm5hbWVdID0gZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHt9ICAgICAgICAgICAgX0lFRW51bUZpeChzdWJjLnByb3RvdHlwZSwgb3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qIGFzbjEtMS4wLjEzLmpzIChjKSAyMDEzLTIwMTcgS2VuamkgVXJ1c2hpbWEgfCBranVyLmdpdGh1Yi5jb20vanNyc2FzaWduL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXdcbiAqIEBuYW1lIGFzbjEtMS4wLmpzXG4gKiBAYXV0aG9yIEtlbmppIFVydXNoaW1hIGtlbmppLnVydXNoaW1hQGdtYWlsLmNvbVxuICogQHZlcnNpb24gYXNuMSAxLjAuMTMgKDIwMTctSnVuLTAyKVxuICogQHNpbmNlIGpzcnNhc2lnbiAyLjFcbiAqIEBsaWNlbnNlIDxhIGhyZWY9XCJodHRwczovL2tqdXIuZ2l0aHViLmlvL2pzcnNhc2lnbi9saWNlbnNlL1wiPk1JVCBMaWNlbnNlPC9hPlxuICovXG5cbi8qKlxuICoga2p1cidzIGNsYXNzIGxpYnJhcnkgbmFtZSBzcGFjZVxuICogPHA+XG4gKiBUaGlzIG5hbWUgc3BhY2UgcHJvdmlkZXMgZm9sbG93aW5nIG5hbWUgc3BhY2VzOlxuICogPHVsPlxuICogPGxpPntAbGluayBLSlVSLmFzbjF9IC0gQVNOLjEgcHJpbWl0aXZlIGhleGFkZWNpbWFsIGVuY29kZXI8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEueDUwOX0gLSBBU04uMSBzdHJ1Y3R1cmUgZm9yIFguNTA5IGNlcnRpZmljYXRlIGFuZCBDUkw8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmNyeXB0b30gLSBKYXZhIENyeXB0b2dyYXBoaWMgRXh0ZW5zaW9uKEpDRSkgc3R5bGUgTWVzc2FnZURpZ2VzdC9TaWduYXR1cmVcbiAqIGNsYXNzIGFuZCB1dGlsaXRpZXM8L2xpPlxuICogPC91bD5cbiAqIDwvcD5cbiAqIE5PVEU6IFBsZWFzZSBpZ25vcmUgbWV0aG9kIHN1bW1hcnkgYW5kIGRvY3VtZW50IG9mIHRoaXMgbmFtZXNwYWNlLiBUaGlzIGNhdXNlZCBieSBhIGJ1ZyBvZiBqc2RvYzIuXG4gKiBAbmFtZSBLSlVSXG4gKiBAbmFtZXNwYWNlIGtqdXIncyBjbGFzcyBsaWJyYXJ5IG5hbWUgc3BhY2VcbiAqL1xudmFyIEtKVVIgPSB7fTtcblxuLyoqXG4gKiBranVyJ3MgQVNOLjEgY2xhc3MgbGlicmFyeSBuYW1lIHNwYWNlXG4gKiA8cD5cbiAqIFRoaXMgaXMgSVRVLVQgWC42OTAgQVNOLjEgREVSIGVuY29kZXIgY2xhc3MgbGlicmFyeSBhbmRcbiAqIGNsYXNzIHN0cnVjdHVyZSBhbmQgbWV0aG9kcyBpcyB2ZXJ5IHNpbWlsYXIgdG9cbiAqIG9yZy5ib3VuY3ljYXN0bGUuYXNuMSBwYWNrYWdlIG9mXG4gKiB3ZWxsIGtub3duIEJvdW5jeUNhc2x0ZSBDcnlwdG9ncmFwaHkgTGlicmFyeS5cbiAqIDxoND5QUk9WSURJTkcgQVNOLjEgUFJJTUlUSVZFUzwvaDQ+XG4gKiBIZXJlIGFyZSBBU04uMSBERVIgcHJpbWl0aXZlIGNsYXNzZXMuXG4gKiA8dWw+XG4gKiA8bGk+MHgwMSB7QGxpbmsgS0pVUi5hc24xLkRFUkJvb2xlYW59PC9saT5cbiAqIDxsaT4weDAyIHtAbGluayBLSlVSLmFzbjEuREVSSW50ZWdlcn08L2xpPlxuICogPGxpPjB4MDMge0BsaW5rIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmd9PC9saT5cbiAqIDxsaT4weDA0IHtAbGluayBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmd9PC9saT5cbiAqIDxsaT4weDA1IHtAbGluayBLSlVSLmFzbjEuREVSTnVsbH08L2xpPlxuICogPGxpPjB4MDYge0BsaW5rIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyfTwvbGk+XG4gKiA8bGk+MHgwYSB7QGxpbmsgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWR9PC9saT5cbiAqIDxsaT4weDBjIHtAbGluayBLSlVSLmFzbjEuREVSVVRGOFN0cmluZ308L2xpPlxuICogPGxpPjB4MTIge0BsaW5rIEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxMyB7QGxpbmsgS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZ308L2xpPlxuICogPGxpPjB4MTQge0BsaW5rIEtKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nfTwvbGk+XG4gKiA8bGk+MHgxNiB7QGxpbmsgS0pVUi5hc24xLkRFUklBNVN0cmluZ308L2xpPlxuICogPGxpPjB4MTcge0BsaW5rIEtKVVIuYXNuMS5ERVJVVENUaW1lfTwvbGk+XG4gKiA8bGk+MHgxOCB7QGxpbmsgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZX08L2xpPlxuICogPGxpPjB4MzAge0BsaW5rIEtKVVIuYXNuMS5ERVJTZXF1ZW5jZX08L2xpPlxuICogPGxpPjB4MzEge0BsaW5rIEtKVVIuYXNuMS5ERVJTZXR9PC9saT5cbiAqIDwvdWw+XG4gKiA8aDQ+T1RIRVIgQVNOLjEgQ0xBU1NFUzwvaDQ+XG4gKiA8dWw+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5BU04xT2JqZWN0fTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ308L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lfTwvbGk+XG4gKiA8bGk+e0BsaW5rIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWR9PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdH08L2xpPlxuICogPC91bD5cbiAqIDxoND5TVUIgTkFNRSBTUEFDRVM8L2g0PlxuICogPHVsPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuY2FkZXN9IC0gQ0FkRVMgbG9uZyB0ZXJtIHNpZ25hdHVyZSBmb3JtYXQ8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuY21zfSAtIENyeXB0b2dyYXBoaWMgTWVzc2FnZSBTeW50YXg8L2xpPlxuICogPGxpPntAbGluayBLSlVSLmFzbjEuY3NyfSAtIENlcnRpZmljYXRlIFNpZ25pbmcgUmVxdWVzdCAoQ1NSL1BLQ1MjMTApPC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLnRzcH0gLSBSRkMgMzE2MSBUaW1lc3RhbXBpbmcgUHJvdG9jb2wgRm9ybWF0PC9saT5cbiAqIDxsaT57QGxpbmsgS0pVUi5hc24xLng1MDl9IC0gUkZDIDUyODAgWC41MDkgY2VydGlmaWNhdGUgYW5kIENSTDwvbGk+XG4gKiA8L3VsPlxuICogPC9wPlxuICogTk9URTogUGxlYXNlIGlnbm9yZSBtZXRob2Qgc3VtbWFyeSBhbmQgZG9jdW1lbnQgb2YgdGhpcyBuYW1lc3BhY2UuXG4gKiBUaGlzIGNhdXNlZCBieSBhIGJ1ZyBvZiBqc2RvYzIuXG4gKiBAbmFtZSBLSlVSLmFzbjFcbiAqIEBuYW1lc3BhY2VcbiAqL1xuaWYgKHR5cGVvZiBLSlVSLmFzbjEgPT0gXCJ1bmRlZmluZWRcIiB8fCAhS0pVUi5hc24xKSBLSlVSLmFzbjEgPSB7fTtcblxuLyoqXG4gKiBBU04xIHV0aWxpdGllcyBjbGFzc1xuICogQG5hbWUgS0pVUi5hc24xLkFTTjFVdGlsXG4gKiBAY2xhc3MgQVNOMSB1dGlsaXRpZXMgY2xhc3NcbiAqIEBzaW5jZSBhc24xIDEuMC4yXG4gKi9cbktKVVIuYXNuMS5BU04xVXRpbCA9IG5ldyBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmludGVnZXJUb0J5dGVIZXggPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHZhciBoID0gaS50b1N0cmluZygxNik7XG4gICAgICAgIGlmICgoaC5sZW5ndGggJSAyKSA9PSAxKSBoID0gJzAnICsgaDtcbiAgICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICB0aGlzLmJpZ0ludFRvTWluVHdvc0NvbXBsZW1lbnRzSGV4ID0gZnVuY3Rpb24oYmlnSW50ZWdlclZhbHVlKSB7XG4gICAgICAgIHZhciBoID0gYmlnSW50ZWdlclZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGguc3Vic3RyKDAsIDEpICE9ICctJykge1xuICAgICAgICAgICAgaWYgKGgubGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghIGgubWF0Y2goL15bMC03XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSAnMDAnICsgaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaFBvcyA9IGguc3Vic3RyKDEpO1xuICAgICAgICAgICAgdmFyIHhvckxlbiA9IGhQb3MubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHhvckxlbiAlIDIgPT0gMSkge1xuICAgICAgICAgICAgICAgIHhvckxlbiArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISBoLm1hdGNoKC9eWzAtN10vKSkge1xuICAgICAgICAgICAgICAgICAgICB4b3JMZW4gKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaE1hc2sgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeG9yTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoTWFzayArPSAnZic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmlNYXNrID0gbmV3IEJpZ0ludGVnZXIoaE1hc2ssIDE2KTtcbiAgICAgICAgICAgIHZhciBiaU5lZyA9IGJpTWFzay54b3IoYmlnSW50ZWdlclZhbHVlKS5hZGQoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgICAgICAgaCA9IGJpTmVnLnRvU3RyaW5nKDE2KS5yZXBsYWNlKC9eLS8sICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCBQRU0gc3RyaW5nIGZyb20gaGV4YWRlY2ltYWwgZGF0YSBhbmQgaGVhZGVyIHN0cmluZ1xuICAgICAqIEBuYW1lIGdldFBFTVN0cmluZ0Zyb21IZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFIZXggaGV4YWRlY2ltYWwgc3RyaW5nIG9mIFBFTSBib2R5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBlbUhlYWRlciBQRU0gaGVhZGVyIHN0cmluZyAoZXguICdSU0EgUFJJVkFURSBLRVknKVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUEVNIGZvcm1hdHRlZCBzdHJpbmcgb2YgaW5wdXQgZGF0YVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgbWV0aG9kIGNvbnZlcnRzIGEgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGEgUEVNIHN0cmluZyB3aXRoXG4gICAgICogYSBzcGVjaWZpZWQgaGVhZGVyLiBJdHMgbGluZSBicmVhayB3aWxsIGJlIENSTEYoXCJcXHJcXG5cIikuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcGVtICA9IEtKVVIuYXNuMS5BU04xVXRpbC5nZXRQRU1TdHJpbmdGcm9tSGV4KCc2MTYxNjEnLCAnUlNBIFBSSVZBVEUgS0VZJyk7XG4gICAgICogLy8gdmFsdWUgb2YgcGVtIHdpbGwgYmU6XG4gICAgICogLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXG4gICAgICogWVdGaFxuICAgICAqIC0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1cbiAgICAgKi9cbiAgICB0aGlzLmdldFBFTVN0cmluZ0Zyb21IZXggPSBmdW5jdGlvbihkYXRhSGV4LCBwZW1IZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIGhleHRvcGVtKGRhdGFIZXgsIHBlbUhlYWRlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIEFTTjFPYmplY3Qgc3BlY2lmZWQgYnkgSlNPTiBwYXJhbWV0ZXJzXG4gICAgICogQG5hbWUgbmV3T2JqZWN0XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtIEpTT04gcGFyYW1ldGVyIHRvIGdlbmVyYXRlIEFTTjFPYmplY3RcbiAgICAgKiBAcmV0dXJuIHtLSlVSLmFzbjEuQVNOMU9iamVjdH0gZ2VuZXJhdGVkIG9iamVjdFxuICAgICAqIEBzaW5jZSBhc24xIDEuMC4zXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogZ2VuZXJhdGUgYW55IEFTTjFPYmplY3Qgc3BlY2lmaWVkIGJ5IEpTT04gcGFyYW1cbiAgICAgKiBpbmNsdWRpbmcgQVNOLjEgcHJpbWl0aXZlIG9yIHN0cnVjdHVyZWQuXG4gICAgICogR2VuZXJhbGx5ICdwYXJhbScgY2FuIGJlIGRlc2NyaWJlZCBhcyBmb2xsb3dzOlxuICAgICAqIDxibG9ja3F1b3RlPlxuICAgICAqIHtUWVBFLU9GLUFTTk9CSjogQVNOMU9CSi1QQVJBTUVURVJ9XG4gICAgICogPC9ibG9ja3F1b3RlPlxuICAgICAqICdUWVBFLU9GLUFTTjFPQkonIGNhbiBiZSBvbmUgb2YgZm9sbG93aW5nIHN5bWJvbHM6XG4gICAgICogPHVsPlxuICAgICAqIDxsaT4nYm9vbCcgLSBERVJCb29sZWFuPC9saT5cbiAgICAgKiA8bGk+J2ludCcgLSBERVJJbnRlZ2VyPC9saT5cbiAgICAgKiA8bGk+J2JpdHN0cicgLSBERVJCaXRTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4nb2N0c3RyJyAtIERFUk9jdGV0U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J251bGwnIC0gREVSTnVsbDwvbGk+XG4gICAgICogPGxpPidvaWQnIC0gREVST2JqZWN0SWRlbnRpZmllcjwvbGk+XG4gICAgICogPGxpPidlbnVtJyAtIERFUkVudW1lcmF0ZWQ8L2xpPlxuICAgICAqIDxsaT4ndXRmOHN0cicgLSBERVJVVEY4U3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J251bXN0cicgLSBERVJOdW1lcmljU3RyaW5nPC9saT5cbiAgICAgKiA8bGk+J3BybnN0cicgLSBERVJQcmludGFibGVTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4ndGVsc3RyJyAtIERFUlRlbGV0ZXhTdHJpbmc8L2xpPlxuICAgICAqIDxsaT4naWE1c3RyJyAtIERFUklBNVN0cmluZzwvbGk+XG4gICAgICogPGxpPid1dGN0aW1lJyAtIERFUlVUQ1RpbWU8L2xpPlxuICAgICAqIDxsaT4nZ2VudGltZScgLSBERVJHZW5lcmFsaXplZFRpbWU8L2xpPlxuICAgICAqIDxsaT4nc2VxJyAtIERFUlNlcXVlbmNlPC9saT5cbiAgICAgKiA8bGk+J3NldCcgLSBERVJTZXQ8L2xpPlxuICAgICAqIDxsaT4ndGFnJyAtIERFUlRhZ2dlZE9iamVjdDwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ld09iamVjdCh7J3BybnN0cic6ICdhYWEnfSk7XG4gICAgICogbmV3T2JqZWN0KHsnc2VxJzogW3snaW50JzogM30sIHsncHJuc3RyJzogJ2FhYSd9XX0pXG4gICAgICogLy8gQVNOLjEgVGFnZ2VkIE9iamVjdFxuICAgICAqIG5ld09iamVjdCh7J3RhZyc6IHsndGFnJzogJ2ExJyxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgJ2V4cGxpY2l0JzogdHJ1ZSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgJ29iaic6IHsnc2VxJzogW3snaW50JzogM30sIHsncHJuc3RyJzogJ2FhYSd9XX19fSk7XG4gICAgICogLy8gbW9yZSBzaW1wbGUgcmVwcmVzZW50YXRpb24gb2YgQVNOLjEgVGFnZ2VkIE9iamVjdFxuICAgICAqIG5ld09iamVjdCh7J3RhZyc6IFsnYTEnLFxuICAgICAqICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAqICAgICAgICAgICAgICAgICAgICB7J3NlcSc6IFtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICB7J2ludCc6IDN9LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHsncHJuc3RyJzogJ2FhYSd9XX1cbiAgICAgKiAgICAgICAgICAgICAgICAgICBdfSk7XG4gICAgICovXG4gICAgdGhpcy5uZXdPYmplY3QgPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgX0tKVVIgPSBLSlVSLFxuICAgICAgICAgICAgX0tKVVJfYXNuMSA9IF9LSlVSLmFzbjEsXG4gICAgICAgICAgICBfREVSQm9vbGVhbiA9IF9LSlVSX2FzbjEuREVSQm9vbGVhbixcbiAgICAgICAgICAgIF9ERVJJbnRlZ2VyID0gX0tKVVJfYXNuMS5ERVJJbnRlZ2VyLFxuICAgICAgICAgICAgX0RFUkJpdFN0cmluZyA9IF9LSlVSX2FzbjEuREVSQml0U3RyaW5nLFxuICAgICAgICAgICAgX0RFUk9jdGV0U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJPY3RldFN0cmluZyxcbiAgICAgICAgICAgIF9ERVJOdWxsID0gX0tKVVJfYXNuMS5ERVJOdWxsLFxuICAgICAgICAgICAgX0RFUk9iamVjdElkZW50aWZpZXIgPSBfS0pVUl9hc24xLkRFUk9iamVjdElkZW50aWZpZXIsXG4gICAgICAgICAgICBfREVSRW51bWVyYXRlZCA9IF9LSlVSX2FzbjEuREVSRW51bWVyYXRlZCxcbiAgICAgICAgICAgIF9ERVJVVEY4U3RyaW5nID0gX0tKVVJfYXNuMS5ERVJVVEY4U3RyaW5nLFxuICAgICAgICAgICAgX0RFUk51bWVyaWNTdHJpbmcgPSBfS0pVUl9hc24xLkRFUk51bWVyaWNTdHJpbmcsXG4gICAgICAgICAgICBfREVSUHJpbnRhYmxlU3RyaW5nID0gX0tKVVJfYXNuMS5ERVJQcmludGFibGVTdHJpbmcsXG4gICAgICAgICAgICBfREVSVGVsZXRleFN0cmluZyA9IF9LSlVSX2FzbjEuREVSVGVsZXRleFN0cmluZyxcbiAgICAgICAgICAgIF9ERVJJQTVTdHJpbmcgPSBfS0pVUl9hc24xLkRFUklBNVN0cmluZyxcbiAgICAgICAgICAgIF9ERVJVVENUaW1lID0gX0tKVVJfYXNuMS5ERVJVVENUaW1lLFxuICAgICAgICAgICAgX0RFUkdlbmVyYWxpemVkVGltZSA9IF9LSlVSX2FzbjEuREVSR2VuZXJhbGl6ZWRUaW1lLFxuICAgICAgICAgICAgX0RFUlNlcXVlbmNlID0gX0tKVVJfYXNuMS5ERVJTZXF1ZW5jZSxcbiAgICAgICAgICAgIF9ERVJTZXQgPSBfS0pVUl9hc24xLkRFUlNldCxcbiAgICAgICAgICAgIF9ERVJUYWdnZWRPYmplY3QgPSBfS0pVUl9hc24xLkRFUlRhZ2dlZE9iamVjdCxcbiAgICAgICAgICAgIF9uZXdPYmplY3QgPSBfS0pVUl9hc24xLkFTTjFVdGlsLm5ld09iamVjdDtcblxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICB0aHJvdyBcImtleSBvZiBwYXJhbSBzaGFsbCBiZSBvbmx5IG9uZS5cIjtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbMF07XG5cbiAgICAgICAgaWYgKFwiOmJvb2w6aW50OmJpdHN0cjpvY3RzdHI6bnVsbDpvaWQ6ZW51bTp1dGY4c3RyOm51bXN0cjpwcm5zdHI6dGVsc3RyOmlhNXN0cjp1dGN0aW1lOmdlbnRpbWU6c2VxOnNldDp0YWc6XCIuaW5kZXhPZihcIjpcIiArIGtleSArIFwiOlwiKSA9PSAtMSlcbiAgICAgICAgICAgIHRocm93IFwidW5kZWZpbmVkIGtleTogXCIgKyBrZXk7XG5cbiAgICAgICAgaWYgKGtleSA9PSBcImJvb2xcIikgICAgcmV0dXJuIG5ldyBfREVSQm9vbGVhbihwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImludFwiKSAgICAgcmV0dXJuIG5ldyBfREVSSW50ZWdlcihwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImJpdHN0clwiKSAgcmV0dXJuIG5ldyBfREVSQml0U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwib2N0c3RyXCIpICByZXR1cm4gbmV3IF9ERVJPY3RldFN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcIm51bGxcIikgICAgcmV0dXJuIG5ldyBfREVSTnVsbChwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcIm9pZFwiKSAgICAgcmV0dXJuIG5ldyBfREVST2JqZWN0SWRlbnRpZmllcihwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcImVudW1cIikgICAgcmV0dXJuIG5ldyBfREVSRW51bWVyYXRlZChwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcInV0ZjhzdHJcIikgcmV0dXJuIG5ldyBfREVSVVRGOFN0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcIm51bXN0clwiKSAgcmV0dXJuIG5ldyBfREVSTnVtZXJpY1N0cmluZyhwYXJhbVtrZXldKTtcbiAgICAgICAgaWYgKGtleSA9PSBcInBybnN0clwiKSAgcmV0dXJuIG5ldyBfREVSUHJpbnRhYmxlU3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwidGVsc3RyXCIpICByZXR1cm4gbmV3IF9ERVJUZWxldGV4U3RyaW5nKHBhcmFtW2tleV0pO1xuICAgICAgICBpZiAoa2V5ID09IFwiaWE1c3RyXCIpICByZXR1cm4gbmV3IF9ERVJJQTVTdHJpbmcocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJ1dGN0aW1lXCIpIHJldHVybiBuZXcgX0RFUlVUQ1RpbWUocGFyYW1ba2V5XSk7XG4gICAgICAgIGlmIChrZXkgPT0gXCJnZW50aW1lXCIpIHJldHVybiBuZXcgX0RFUkdlbmVyYWxpemVkVGltZShwYXJhbVtrZXldKTtcblxuICAgICAgICBpZiAoa2V5ID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbUxpc3QgPSBwYXJhbVtrZXldO1xuICAgICAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFzbjFPYmogPSBfbmV3T2JqZWN0KHBhcmFtTGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGFzbjFPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSU2VxdWVuY2UoeydhcnJheSc6IGF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT0gXCJzZXRcIikge1xuICAgICAgICAgICAgdmFyIHBhcmFtTGlzdCA9IHBhcmFtW2tleV07XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXNuMU9iaiA9IF9uZXdPYmplY3QocGFyYW1MaXN0W2ldKTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYXNuMU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9ERVJTZXQoeydhcnJheSc6IGF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT0gXCJ0YWdcIikge1xuICAgICAgICAgICAgdmFyIHRhZ1BhcmFtID0gcGFyYW1ba2V5XTtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFnUGFyYW0pID09PSAnW29iamVjdCBBcnJheV0nICYmXG4gICAgICAgICAgICAgICAgdGFnUGFyYW0ubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gX25ld09iamVjdCh0YWdQYXJhbVsyXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVGFnZ2VkT2JqZWN0KHt0YWc6IHRhZ1BhcmFtWzBdLFxuICAgICAgICAgICAgICAgICAgICBleHBsaWNpdDogdGFnUGFyYW1bMV0sXG4gICAgICAgICAgICAgICAgICAgIG9iajogb2JqfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBuZXdQYXJhbSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS5leHBsaWNpdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJhbS5leHBsaWNpdCA9IHRhZ1BhcmFtLmV4cGxpY2l0O1xuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS50YWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyYW0udGFnID0gdGFnUGFyYW0udGFnO1xuICAgICAgICAgICAgICAgIGlmICh0YWdQYXJhbS5vYmogPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJvYmogc2hhbGwgYmUgc3BlY2lmaWVkIGZvciAndGFnJy5cIjtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbS5vYmogPSBfbmV3T2JqZWN0KHRhZ1BhcmFtLm9iaik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfREVSVGFnZ2VkT2JqZWN0KG5ld1BhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgZW5jb2RlZCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOMU9iamVjdCBzcGVjaWZlZCBieSBKU09OIHBhcmFtZXRlcnNcbiAgICAgKiBAbmFtZSBqc29uVG9BU04xSEVYXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xVXRpbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtIEpTT04gcGFyYW1ldGVyIHRvIGdlbmVyYXRlIEFTTjFPYmplY3RcbiAgICAgKiBAcmV0dXJuIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04xT2JqZWN0XG4gICAgICogQHNpbmNlIGFzbjEgMS4wLjRcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBcyBmb3IgQVNOLjEgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIEpTT04gb2JqZWN0LFxuICAgICAqIHBsZWFzZSBzZWUge0BsaW5rIG5ld09iamVjdH0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBqc29uVG9BU04xSEVYKHsncHJuc3RyJzogJ2FhYSd9KTtcbiAgICAgKi9cbiAgICB0aGlzLmpzb25Ub0FTTjFIRVggPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgYXNuMU9iaiA9IHRoaXMubmV3T2JqZWN0KHBhcmFtKTtcbiAgICAgICAgcmV0dXJuIGFzbjFPYmouZ2V0RW5jb2RlZEhleCgpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIGdldCBkb3Qgbm90ZWQgb2lkIG51bWJlciBzdHJpbmcgZnJvbSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBPSURcbiAqIEBuYW1lIG9pZEhleFRvSW50XG4gKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gZG90IG5vdGVkIHN0cmluZyBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHNpbmNlIGpzcnNhc2lnbiA0LjguMyBhc24xIDEuMC43XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc3RhdGljIG1ldGhvZCBjb252ZXJ0cyBmcm9tIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZlxuICogQVNOLjEgdmFsdWUgb2Ygb2JqZWN0IGlkZW50aWZpZXIgdG8gb2lkIG51bWJlciBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICogS0pVUi5hc24xLkFTTjFVdGlsLm9pZEhleFRvSW50KCc1NTA0MDYnKSAmcmFycjsgXCIyLjUuNC42XCJcbiAqL1xuS0pVUi5hc24xLkFTTjFVdGlsLm9pZEhleFRvSW50ID0gZnVuY3Rpb24oaGV4KSB7XG4gICAgdmFyIHMgPSBcIlwiO1xuICAgIHZhciBpMDEgPSBwYXJzZUludChoZXguc3Vic3RyKDAsIDIpLCAxNik7XG4gICAgdmFyIGkwID0gTWF0aC5mbG9vcihpMDEgLyA0MCk7XG4gICAgdmFyIGkxID0gaTAxICUgNDA7XG4gICAgdmFyIHMgPSBpMCArIFwiLlwiICsgaTE7XG5cbiAgICB2YXIgYmluYnVmID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIHZhciBiaW4gPSAoXCIwMDAwMDAwMFwiICsgdmFsdWUudG9TdHJpbmcoMikpLnNsaWNlKC0gOCk7XG4gICAgICAgIGJpbmJ1ZiA9IGJpbmJ1ZiArIGJpbi5zdWJzdHIoMSwgNyk7XG4gICAgICAgIGlmIChiaW4uc3Vic3RyKDAsIDEpID09IFwiMFwiKSB7XG4gICAgICAgICAgICB2YXIgYmkgPSBuZXcgQmlnSW50ZWdlcihiaW5idWYsIDIpO1xuICAgICAgICAgICAgcyA9IHMgKyBcIi5cIiArIGJpLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICAgIGJpbmJ1ZiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIGdldCBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllciBmcm9tIGRvdCBub3RlZCBvaWQgdmFsdWVcbiAqIEBuYW1lIG9pZEludFRvSGV4XG4gKiBAbWVtYmVyT2YgS0pVUi5hc24xLkFTTjFVdGlsXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBvaWRTdHJpbmcgZG90IG5vdGVkIHN0cmluZyBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHJldHVybiB7U3RyaW5nfSBoZXhhZGVjaW1hbCB2YWx1ZSBvZiBvYmplY3QgaWRlbnRpZmllclxuICogQHNpbmNlIGpzcnNhc2lnbiA0LjguMyBhc24xIDEuMC43XG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgc3RhdGljIG1ldGhvZCBjb252ZXJ0cyBmcm9tIG9iamVjdCBpZGVudGlmaWVyIHZhbHVlIHN0cmluZy5cbiAqIHRvIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdC5cbiAqIEBleGFtcGxlXG4gKiBLSlVSLmFzbjEuQVNOMVV0aWwub2lkSW50VG9IZXgoXCIyLjUuNC42XCIpICZyYXJyOyBcIjU1MDQwNlwiXG4gKi9cbktKVVIuYXNuMS5BU04xVXRpbC5vaWRJbnRUb0hleCA9IGZ1bmN0aW9uKG9pZFN0cmluZykge1xuICAgIHZhciBpdG94ID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaCA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaC5sZW5ndGggPT0gMSkgaCA9ICcwJyArIGg7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG5cbiAgICB2YXIgcm9pZHRveCA9IGZ1bmN0aW9uKHJvaWQpIHtcbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIocm9pZCwgMTApO1xuICAgICAgICB2YXIgYiA9IGJpLnRvU3RyaW5nKDIpO1xuICAgICAgICB2YXIgcGFkTGVuID0gNyAtIGIubGVuZ3RoICUgNztcbiAgICAgICAgaWYgKHBhZExlbiA9PSA3KSBwYWRMZW4gPSAwO1xuICAgICAgICB2YXIgYlBhZCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbjsgaSsrKSBiUGFkICs9ICcwJztcbiAgICAgICAgYiA9IGJQYWQgKyBiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoIC0gMTsgaSArPSA3KSB7XG4gICAgICAgICAgICB2YXIgYjggPSBiLnN1YnN0cihpLCA3KTtcbiAgICAgICAgICAgIGlmIChpICE9IGIubGVuZ3RoIC0gNykgYjggPSAnMScgKyBiODtcbiAgICAgICAgICAgIGggKz0gaXRveChwYXJzZUludChiOCwgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG5cbiAgICBpZiAoISBvaWRTdHJpbmcubWF0Y2goL15bMC05Ll0rJC8pKSB7XG4gICAgICAgIHRocm93IFwibWFsZm9ybWVkIG9pZCBzdHJpbmc6IFwiICsgb2lkU3RyaW5nO1xuICAgIH1cbiAgICB2YXIgaCA9ICcnO1xuICAgIHZhciBhID0gb2lkU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgdmFyIGkwID0gcGFyc2VJbnQoYVswXSkgKiA0MCArIHBhcnNlSW50KGFbMV0pO1xuICAgIGggKz0gaXRveChpMCk7XG4gICAgYS5zcGxpY2UoMCwgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGggKz0gcm9pZHRveChhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGg7XG59O1xuXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgQWJzdHJhY3QgQVNOLjEgQ2xhc3Nlc1xuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuLyoqXG4gKiBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgZW5jb2RlciBvYmplY3RcbiAqIEBuYW1lIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAY2xhc3MgYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZXIgb2JqZWN0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzTW9kaWZpZWQgZmxhZyB3aGV0aGVyIGludGVybmFsIGRhdGEgd2FzIGNoYW5nZWRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoVExWIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFZcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBoVCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgQVNOLjEgVExWIHRhZyhUKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGhMIGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgbGVuZ3RoKEwpXG4gKiBAcHJvcGVydHkge1N0cmluZ30gaFYgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB2YWx1ZShWKVxuICogQGRlc2NyaXB0aW9uXG4gKi9cbktKVVIuYXNuMS5BU04xT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhWID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgQVNOLjEgVExWIGxlbmd0aChMKSBieXRlcyBmcm9tIFRMViB2YWx1ZShWKVxuICAgICAqIEBuYW1lIGdldExlbmd0aEhleEZyb21WYWx1ZVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuQVNOMU9iamVjdCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgbGVuZ3RoKEwpXG4gICAgICovXG4gICAgdGhpcy5nZXRMZW5ndGhIZXhGcm9tVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhWID09IFwidW5kZWZpbmVkXCIgfHwgdGhpcy5oViA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBcInRoaXMuaFYgaXMgbnVsbCBvciB1bmRlZmluZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaFYubGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcInZhbHVlIGhleCBtdXN0IGJlIGV2ZW4gbGVuZ3RoOiBuPVwiICsgaFYubGVuZ3RoICsgXCIsdj1cIiArIHRoaXMuaFY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSB0aGlzLmhWLmxlbmd0aCAvIDI7XG4gICAgICAgIHZhciBoTiA9IG4udG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaE4ubGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgICAgICAgICBoTiA9IFwiMFwiICsgaE47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPCAxMjgpIHtcbiAgICAgICAgICAgIHJldHVybiBoTjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoTmxlbiA9IGhOLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBpZiAoaE5sZW4gPiAxNSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiQVNOLjEgbGVuZ3RoIHRvbyBsb25nIHRvIHJlcHJlc2VudCBieSA4eDogbiA9IFwiICsgbi50b1N0cmluZygxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGVhZCA9IDEyOCArIGhObGVuO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQudG9TdHJpbmcoMTYpICsgaE47XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZ2V0IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSBUTFYgYnl0ZXNcbiAgICAgKiBAbmFtZSBnZXRFbmNvZGVkSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xT2JqZWN0I1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMVlxuICAgICAqL1xuICAgIHRoaXMuZ2V0RW5jb2RlZEhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5oVExWID09IG51bGwgfHwgdGhpcy5pc01vZGlmaWVkKSB7XG4gICAgICAgICAgICB0aGlzLmhWID0gdGhpcy5nZXRGcmVzaFZhbHVlSGV4KCk7XG4gICAgICAgICAgICB0aGlzLmhMID0gdGhpcy5nZXRMZW5ndGhIZXhGcm9tVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IHRoaXMuaFQgKyB0aGlzLmhMICsgdGhpcy5oVjtcbiAgICAgICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy9hbGVydChcImZpcnN0IHRpbWU6IFwiICsgdGhpcy5oVExWKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oVExWO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnZXQgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB2YWx1ZShWKSBieXRlc1xuICAgICAqIEBuYW1lIGdldFZhbHVlSGV4XG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BU04xT2JqZWN0I1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIFRMViB2YWx1ZShWKSBieXRlc1xuICAgICAqL1xuICAgIHRoaXMuZ2V0VmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRFbmNvZGVkSGV4KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH07XG59O1xuXG4vLyA9PSBCRUdJTiBERVJBYnN0cmFjdFN0cmluZyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cmluZyBjbGFzc2VzXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBjbGFzcyBiYXNlIGNsYXNzIGZvciBBU04uMSBERVIgc3RyaW5nIGNsYXNzZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcyBpbnRlcm5hbCBzdHJpbmcgb2YgdmFsdWVcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5zdHIgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBzdHJpbmc8L2xpPlxuICogPGxpPmhleCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIGhleGFkZWNpbWFsIHN0cmluZzwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbktKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBnZXQgc3RyaW5nIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG9iamVjdFxuICAgICAqIEBuYW1lIGdldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgdmFsdWUgb2YgdGhpcyBzdHJpbmcgb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5nZXRTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgc3RyaW5nXG4gICAgICogQG5hbWUgc2V0U3RyaW5nXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3UyB2YWx1ZSBieSBhIHN0cmluZyB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldFN0cmluZyA9IGZ1bmN0aW9uKG5ld1MpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbmV3UztcbiAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuZXdIZXhTdHJpbmcgdmFsdWUgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gc2V0XG4gICAgICovXG4gICAgdGhpcy5zZXRTdHJpbmdIZXggPSBmdW5jdGlvbihuZXdIZXhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhWO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snc3RyJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zWydzdHInXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaGV4J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmdIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG4vLyA9PSBFTkQgICBERVJBYnN0cmFjdFN0cmluZyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gPT0gQkVHSU4gREVSQWJzdHJhY3RUaW1lID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKipcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZC9VVENUaW1lIGNsYXNzXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lXG4gKiBAY2xhc3MgYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIEdlbmVyYWxpemVkL1VUQ1RpbWUgY2xhc3NcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnMTMwNDMwMjM1OTU5Wid9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuQVNOMU9iamVjdCAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuXG4gICAgLy8gLS0tIFBSSVZBVEUgTUVUSE9EUyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHRoaXMubG9jYWxEYXRlVG9VVEMgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHV0YyA9IGQuZ2V0VGltZSgpICsgKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwKTtcbiAgICAgICAgdmFyIHV0Y0RhdGUgPSBuZXcgRGF0ZSh1dGMpO1xuICAgICAgICByZXR1cm4gdXRjRGF0ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgKiBmb3JtYXQgZGF0ZSBzdHJpbmcgYnkgRGF0YSBvYmplY3RcbiAgICAgKiBAbmFtZSBmb3JtYXREYXRlXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5BYnN0cmFjdFRpbWU7XG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ3V0Yycgb3IgJ2dlbidcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhNaWxsaXMgZmxhZyBmb3Igd2l0aCBtaWxsaXNlY3Rpb25zIG9yIG5vdFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICd3aXRoTWlsbGlzJyBmbGFnIGlzIHN1cHBvcnRlZCBmcm9tIGFzbjEgMS4wLjYuXG4gICAgICovXG4gICAgdGhpcy5mb3JtYXREYXRlID0gZnVuY3Rpb24oZGF0ZU9iamVjdCwgdHlwZSwgd2l0aE1pbGxpcykge1xuICAgICAgICB2YXIgcGFkID0gdGhpcy56ZXJvUGFkZGluZztcbiAgICAgICAgdmFyIGQgPSB0aGlzLmxvY2FsRGF0ZVRvVVRDKGRhdGVPYmplY3QpO1xuICAgICAgICB2YXIgeWVhciA9IFN0cmluZyhkLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICBpZiAodHlwZSA9PSAndXRjJykgeWVhciA9IHllYXIuc3Vic3RyKDIsIDIpO1xuICAgICAgICB2YXIgbW9udGggPSBwYWQoU3RyaW5nKGQuZ2V0TW9udGgoKSArIDEpLCAyKTtcbiAgICAgICAgdmFyIGRheSA9IHBhZChTdHJpbmcoZC5nZXREYXRlKCkpLCAyKTtcbiAgICAgICAgdmFyIGhvdXIgPSBwYWQoU3RyaW5nKGQuZ2V0SG91cnMoKSksIDIpO1xuICAgICAgICB2YXIgbWluID0gcGFkKFN0cmluZyhkLmdldE1pbnV0ZXMoKSksIDIpO1xuICAgICAgICB2YXIgc2VjID0gcGFkKFN0cmluZyhkLmdldFNlY29uZHMoKSksIDIpO1xuICAgICAgICB2YXIgcyA9IHllYXIgKyBtb250aCArIGRheSArIGhvdXIgKyBtaW4gKyBzZWM7XG4gICAgICAgIGlmICh3aXRoTWlsbGlzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGlmIChtaWxsaXMgIT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzTWlsbGlzID0gcGFkKFN0cmluZyhtaWxsaXMpLCAzKTtcbiAgICAgICAgICAgICAgICBzTWlsbGlzID0gc01pbGxpcy5yZXBsYWNlKC9bMF0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIHMgPSBzICsgXCIuXCIgKyBzTWlsbGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzICsgXCJaXCI7XG4gICAgfTtcblxuICAgIHRoaXMuemVyb1BhZGRpbmcgPSBmdW5jdGlvbihzLCBsZW4pIHtcbiAgICAgICAgaWYgKHMubGVuZ3RoID49IGxlbikgcmV0dXJuIHM7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXkobGVuIC0gcy5sZW5ndGggKyAxKS5qb2luKCcwJykgKyBzO1xuICAgIH07XG5cbiAgICAvLyAtLS0gUFVCTElDIE1FVEhPRFMgLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBnZXQgc3RyaW5nIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG9iamVjdFxuICAgICAqIEBuYW1lIGdldFN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHZhbHVlIG9mIHRoaXMgdGltZSBvYmplY3RcbiAgICAgKi9cbiAgICB0aGlzLmdldFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBzdHJpbmdcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3UyB2YWx1ZSBieSBhIHN0cmluZyB0byBzZXQgc3VjaCBsaWtlIFwiMTMwNDMwMjM1OTU5WlwiXG4gICAgICovXG4gICAgdGhpcy5zZXRTdHJpbmcgPSBmdW5jdGlvbihuZXdTKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMucyA9IG5ld1M7XG4gICAgICAgIHRoaXMuaFYgPSBzdG9oZXgobmV3Uyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIERhdGUgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlEYXRlVmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHllYXIgeWVhciBvZiBkYXRlIChleC4gMjAxMylcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG1vbnRoIG1vbnRoIG9mIGRhdGUgYmV0d2VlbiAxIGFuZCAxMiAoZXguIDEyKVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZGF5IGRheSBvZiBtb250aFxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaG91ciBob3VycyBvZiBkYXRlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBtaW4gbWludXRlcyBvZiBkYXRlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzZWMgc2Vjb25kcyBvZiBkYXRlXG4gICAgICovXG4gICAgdGhpcy5zZXRCeURhdGVWYWx1ZSA9IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKSB7XG4gICAgICAgIHZhciBkYXRlT2JqZWN0ID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIsIG1pbiwgc2VjLCAwKSk7XG4gICAgICAgIHRoaXMuc2V0QnlEYXRlKGRhdGVPYmplY3QpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQWJzdHJhY3RUaW1lLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG4vLyA9PSBFTkQgICBERVJBYnN0cmFjdFRpbWUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gPT0gQkVHSU4gREVSQWJzdHJhY3RTdHJ1Y3R1cmVkID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKipcbiAqIGJhc2UgY2xhc3MgZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmVkIGNsYXNzXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXG4gKiBAY2xhc3MgYmFzZSBjbGFzcyBmb3IgQVNOLjEgREVSIHN0cnVjdHVyZWQgY2xhc3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGFzbjFBcnJheSBpbnRlcm5hbCBhcnJheSBvZiBBU04xT2JqZWN0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5BU04xT2JqZWN0IC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhcnJheSBvZiBBU04xT2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlBU04xT2JqZWN0QXJyYXlcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhc24xT2JqZWN0QXJyYXkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5QVNOMU9iamVjdEFycmF5ID0gZnVuY3Rpb24oYXNuMU9iamVjdEFycmF5KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXNuMUFycmF5ID0gYXNuMU9iamVjdEFycmF5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhcHBlbmQgYW4gQVNOMU9iamVjdCB0byBpbnRlcm5hbCBhcnJheVxuICAgICAqIEBuYW1lIGFwcGVuZEFTTjFPYmplY3RcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FTTjFPYmplY3R9IGFzbjFPYmplY3QgdG8gYWRkXG4gICAgICovXG4gICAgdGhpcy5hcHBlbmRBU04xT2JqZWN0ID0gZnVuY3Rpb24oYXNuMU9iamVjdCkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFzbjFBcnJheS5wdXNoKGFzbjFPYmplY3QpO1xuICAgIH07XG5cbiAgICB0aGlzLmFzbjFBcnJheSA9IG5ldyBBcnJheSgpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2FycmF5J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5hc24xQXJyYXkgPSBwYXJhbXNbJ2FycmF5J107XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkFic3RyYWN0U3RydWN0dXJlZCwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgQVNOLjEgT2JqZWN0IENsYXNzZXNcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgQm9vbGVhblxuICogQG5hbWUgS0pVUi5hc24xLkRFUkJvb2xlYW5cbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIEJvb2xlYW5cbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkFTTjFPYmplY3QgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJCb29sZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgS0pVUi5hc24xLkRFUkJvb2xlYW4uc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjAxXCI7XG4gICAgdGhpcy5oVExWID0gXCIwMTAxZmZcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSQm9vbGVhbiwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIEludGVnZXJcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJJbnRlZ2VyXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBJbnRlZ2VyXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuQVNOMU9iamVjdFxuICogQGRlc2NyaXB0aW9uXG4gKiA8YnIvPlxuICogQXMgZm9yIGFyZ3VtZW50ICdwYXJhbXMnIGZvciBjb25zdHJ1Y3RvciwgeW91IGNhbiBzcGVjaWZ5IG9uZSBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+aW50IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGludGVnZXIgdmFsdWU8L2xpPlxuICogPGxpPmJpZ2ludCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBCaWdJbnRlZ2VyIG9iamVjdDwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiAncGFyYW1zJyBjYW4gYmUgb21pdHRlZC5cbiAqL1xuS0pVUi5hc24xLkRFUkludGVnZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSSW50ZWdlci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDJcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBUb20gV3UncyBCaWdJbnRlZ2VyIG9iamVjdFxuICAgICAqIEBuYW1lIHNldEJ5QmlnSW50ZWdlclxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSSW50ZWdlciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0JpZ0ludGVnZXJ9IGJpZ0ludGVnZXJWYWx1ZSB0byBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldEJ5QmlnSW50ZWdlciA9IGZ1bmN0aW9uKGJpZ0ludGVnZXJWYWx1ZSkge1xuICAgICAgICB0aGlzLmhUTFYgPSBudWxsO1xuICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhWID0gS0pVUi5hc24xLkFTTjFVdGlsLmJpZ0ludFRvTWluVHdvc0NvbXBsZW1lbnRzSGV4KGJpZ0ludGVnZXJWYWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBpbnRlZ2VyIHZhbHVlXG4gICAgICogQG5hbWUgc2V0QnlJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJJbnRlZ2VyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbnRlZ2VyIHZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlJbnRlZ2VyID0gZnVuY3Rpb24oaW50VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIoU3RyaW5nKGludFZhbHVlKSwgMTApO1xuICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihiaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBpbnRlZ2VyIHZhbHVlXG4gICAgICogQG5hbWUgc2V0VmFsdWVIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkludGVnZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPGJyLz5cbiAgICAgKiBOT1RFOiBWYWx1ZSBzaGFsbCBiZSByZXByZXNlbnRlZCBieSBtaW5pbXVtIG9jdGV0IGxlbmd0aCBvZlxuICAgICAqIHR3bydzIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoMTIzKTtcbiAgICAgKiBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeydpbnQnOiAxMjN9KTtcbiAgICAgKiBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeydoZXgnOiAnMWZhZCd9KTtcbiAgICAgKi9cbiAgICB0aGlzLnNldFZhbHVlSGV4ID0gZnVuY3Rpb24obmV3SGV4U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaFYgPSBuZXdIZXhTdHJpbmc7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snYmlnaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUJpZ0ludGVnZXIocGFyYW1zWydiaWdpbnQnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snaW50J10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zWydpbnQnXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5SW50ZWdlcihwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVIZXgocGFyYW1zWydoZXgnXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkludGVnZXIsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBlbmNvZGVkIEJpdFN0cmluZyBwcmltaXRpdmVcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIGVuY29kZWQgQml0U3RyaW5nIHByaW1pdGl2ZVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmJpbiAtIHNwZWNpZnkgYmluYXJ5IHN0cmluZyAoZXguICcxMDExMScpPC9saT5cbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgYm9vbGVhbiAoZXguIFt0cnVlLGZhbHNlLHRydWUsdHJ1ZV0pPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGhleGFkZWNpbWFsIHN0cmluZyBvZiBBU04uMSB2YWx1ZShWKSBpbmNsdWRpbmcgdW51c2VkIGJpdHM8L2xpPlxuICogPGxpPm9iaiAtIHNwZWNpZnkge0BsaW5rIEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3R9XG4gKiBhcmd1bWVudCBmb3IgXCJCaXRTdHJpbmcgZW5jYXBzdWxhdGVzXCIgc3RydWN0dXJlLjwvbGk+XG4gKiA8L3VsPlxuICogTk9URTE6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLjxici8+XG4gKiBOT1RFMjogJ29iaicgcGFyYW1ldGVyIGhhdmUgYmVlbiBzdXBwb3J0ZWQgc2luY2VcbiAqIGFzbjEgMS4wLjExLCBqc3JzYXNpZ24gNi4xLjEgKDIwMTYtU2VwLTI1KS48YnIvPlxuICogQGV4YW1wbGVcbiAqIC8vIGRlZmF1bHQgY29uc3RydWN0b3JcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZygpO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIGJpbmFyeSBzdHJpbmdcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7YmluOiBcIjEwMTFcIn0pO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIGJvb2xlYW4gYXJyYXlcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUkJpdFN0cmluZyh7YXJyYXk6IFt0cnVlLGZhbHNlLHRydWUsdHJ1ZV19KTtcbiAqIC8vIGluaXRpYWxpemUgd2l0aCBoZXhhZGVjaW1hbCBzdHJpbmcgKDA0IGlzIHVudXNlZCBiaXRzKVxuICogbyA9IG5ldyBLSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcoe2hleDogXCIwNGJhYzBcIn0pO1xuICogLy8gaW5pdGlhbGl6ZSB3aXRoIEFTTjFVdGlsLm5ld09iamVjdCBhcmd1bWVudCBmb3IgZW5jYXBzdWxhdGVkXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoe29iajoge3NlcTogW3tpbnQ6IDN9LCB7cHJuc3RyOiAnYWFhJ31dfX0pO1xuICogLy8gYWJvdmUgZ2VuZXJhdGVzIGEgQVNOLjEgZGF0YSBsaWtlIHRoaXM6XG4gKiAvLyBCSVQgU1RSSU5HLCBlbmNhcHN1bGF0ZXMge1xuICogLy8gICBTRVFVRU5DRSB7XG4gKiAvLyAgICAgSU5URUdFUiAzXG4gKiAvLyAgICAgUHJpbnRhYmxlU3RyaW5nICdhYWEnXG4gKiAvLyAgICAgfVxuICogLy8gICB9XG4gKi9cbktKVVIuYXNuMS5ERVJCaXRTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhcmFtcy5vYmogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG8gPSBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0KHBhcmFtcy5vYmopO1xuICAgICAgICBwYXJhbXMuaGV4ID0gXCIwMFwiICsgby5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfVxuICAgIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjAzXCI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmcgaW5jbHVkaW5nIHVudXNlZCBiaXRzXG4gICAgICogQG5hbWUgc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld0hleFN0cmluZ0luY2x1ZGluZ1VudXNlZEJpdHNcbiAgICAgKi9cbiAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZ0luY2x1ZGluZ1VudXNlZEJpdHMpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZ0luY2x1ZGluZ1VudXNlZEJpdHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCBBU04uMSB2YWx1ZShWKSBieSB1bnVzZWQgYml0IGFuZCBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRVbnVzZWRCaXRzQW5kSGV4VmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZyNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHVudXNlZEJpdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaFZhbHVlXG4gICAgICovXG4gICAgdGhpcy5zZXRVbnVzZWRCaXRzQW5kSGV4VmFsdWUgPSBmdW5jdGlvbih1bnVzZWRCaXRzLCBoVmFsdWUpIHtcbiAgICAgICAgaWYgKHVudXNlZEJpdHMgPCAwIHx8IDcgPCB1bnVzZWRCaXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBcInVudXNlZCBiaXRzIHNoYWxsIGJlIGZyb20gMCB0byA3OiB1ID0gXCIgKyB1bnVzZWRCaXRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoVW51c2VkQml0cyA9IFwiMFwiICsgdW51c2VkQml0cztcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oViA9IGhVbnVzZWRCaXRzICsgaFZhbHVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzZXQgQVNOLjEgREVSIEJpdFN0cmluZyBieSBiaW5hcnkgc3RyaW5nPGJyLz5cbiAgICAgKiBAbmFtZSBzZXRCeUJpbmFyeVN0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiaW5hcnlTdHJpbmcgYmluYXJ5IHZhbHVlIHN0cmluZyAoaS5lLiAnMTAxMTEnKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEl0cyB1bnVzZWQgYml0cyB3aWxsIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBieSBsZW5ndGggb2ZcbiAgICAgKiAnYmluYXJ5VmFsdWUnLiA8YnIvPlxuICAgICAqIE5PVEU6IFRyYWlsaW5nIHplcm9zICcwJyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAgICAgKiBvLnNldEJ5Qm9vbGVhbkFycmF5KFwiMDEwMTFcIik7XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJpbmFyeVN0cmluZyA9IGZ1bmN0aW9uKGJpbmFyeVN0cmluZykge1xuICAgICAgICBiaW5hcnlTdHJpbmcgPSBiaW5hcnlTdHJpbmcucmVwbGFjZSgvMCskLywgJycpO1xuICAgICAgICB2YXIgdW51c2VkQml0cyA9IDggLSBiaW5hcnlTdHJpbmcubGVuZ3RoICUgODtcbiAgICAgICAgaWYgKHVudXNlZEJpdHMgPT0gOCkgdW51c2VkQml0cyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHVudXNlZEJpdHM7IGkrKykge1xuICAgICAgICAgICAgYmluYXJ5U3RyaW5nICs9ICcwJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGggLSAxOyBpICs9IDgpIHtcbiAgICAgICAgICAgIHZhciBiID0gYmluYXJ5U3RyaW5nLnN1YnN0cihpLCA4KTtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VJbnQoYiwgMikudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKHgubGVuZ3RoID09IDEpIHggPSAnMCcgKyB4O1xuICAgICAgICAgICAgaCArPSB4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSAnMCcgKyB1bnVzZWRCaXRzICsgaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IEFTTi4xIFRMViB2YWx1ZShWKSBieSBhbiBhcnJheSBvZiBib29sZWFuPGJyLz5cbiAgICAgKiBAbmFtZSBzZXRCeUJvb2xlYW5BcnJheVxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVSQml0U3RyaW5nI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGJvb2xlYW5BcnJheSBhcnJheSBvZiBib29sZWFuIChleC4gW3RydWUsIGZhbHNlLCB0cnVlXSlcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBOT1RFOiBUcmFpbGluZyBmYWxzZXMgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBBU04uMSBERVIgT2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKCk7XG4gICAgICogby5zZXRCeUJvb2xlYW5BcnJheShbZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlXSk7XG4gICAgICovXG4gICAgdGhpcy5zZXRCeUJvb2xlYW5BcnJheSA9IGZ1bmN0aW9uKGJvb2xlYW5BcnJheSkge1xuICAgICAgICB2YXIgcyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJvb2xlYW5BcnJheVtpXSA9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnMSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgKz0gJzAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QnlCaW5hcnlTdHJpbmcocyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGFuIGFycmF5IG9mIGZhbHNlcyB3aXRoIHNwZWNpZmllZCBsZW5ndGg8YnIvPlxuICAgICAqIEBuYW1lIG5ld0ZhbHNlQXJyYXlcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkJpdFN0cmluZ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbkxlbmd0aCBsZW5ndGggb2YgYXJyYXkgdG8gZ2VuZXJhdGVcbiAgICAgKiBAcmV0dXJuIHthcnJheX0gYXJyYXkgb2YgYm9vbGVhbiBmYWxzZXNcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGlzIHN0YXRpYyBtZXRob2QgbWF5IGJlIHVzZWZ1bCB0byBpbml0aWFsaXplIGJvb2xlYW4gYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJCaXRTdHJpbmcoKTtcbiAgICAgKiBvLm5ld0ZhbHNlQXJyYXkoMykgJnJhcnI7IFtmYWxzZSwgZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIHRoaXMubmV3RmFsc2VBcnJheSA9IGZ1bmN0aW9uKG5MZW5ndGgpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkobkxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhW2ldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiICYmIHBhcmFtcy50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eWzAtOWEtZl0rJC8pKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhleFZhbHVlSW5jbHVkaW5nVW51c2VkQml0cyhwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2hleCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGV4VmFsdWVJbmNsdWRpbmdVbnVzZWRCaXRzKHBhcmFtc1snaGV4J10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbJ2JpbiddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlCaW5hcnlTdHJpbmcocGFyYW1zWydiaW4nXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1snYXJyYXknXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJ5Qm9vbGVhbkFycmF5KHBhcmFtc1snYXJyYXknXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUkJpdFN0cmluZywgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE9jdGV0U3RyaW5nPGJyLz5cbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgT2N0ZXRTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBBU04uMSBPY3RldFN0cmluZyBzaW1wbGUgdHlwZS48YnIvPlxuICogU3VwcG9ydGVkIFwicGFyYW1zXCIgYXR0cmlidXRlcyBhcmU6XG4gKiA8dWw+XG4gKiA8bGk+c3RyIC0gdG8gc2V0IGEgc3RyaW5nIGFzIGEgdmFsdWU8L2xpPlxuICogPGxpPmhleCAtIHRvIHNldCBhIGhleGFkZWNpbWFsIHN0cmluZyBhcyBhIHZhbHVlPC9saT5cbiAqIDxsaT5vYmogLSB0byBzZXQgYSBlbmNhcHN1bGF0ZWQgQVNOLjEgdmFsdWUgYnkgSlNPTiBvYmplY3RcbiAqIHdoaWNoIGlzIGRlZmluZWQgaW4ge0BsaW5rIEtKVVIuYXNuMS5BU04xVXRpbC5uZXdPYmplY3R9PC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFOiBBIHBhcmFtZXRlciAnb2JqJyBoYXZlIGJlZW4gc3VwcG9ydGVkXG4gKiBmb3IgXCJPQ1RFVCBTVFJJTkcsIGVuY2Fwc3VsYXRlc1wiIHN0cnVjdHVyZS5cbiAqIHNpbmNlIGFzbjEgMS4wLjExLCBqc3JzYXNpZ24gNi4xLjEgKDIwMTYtU2VwLTI1KS5cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICogQGV4YW1wbGVcbiAqIC8vIGRlZmF1bHQgY29uc3RydWN0b3JcbiAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9jdGV0U3RyaW5nKCk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggc3RyaW5nXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZyh7c3RyOiBcImFhYVwifSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggaGV4YWRlY2ltYWwgc3RyaW5nXG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZyh7aGV4OiBcIjYxNjE2MVwifSk7XG4gKiAvLyBpbml0aWFsaXplIHdpdGggQVNOMVV0aWwubmV3T2JqZWN0IGFyZ3VtZW50XG4gKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZyh7b2JqOiB7c2VxOiBbe2ludDogM30sIHtwcm5zdHI6ICdhYWEnfV19fSk7XG4gKiAvLyBhYm92ZSBnZW5lcmF0ZXMgYSBBU04uMSBkYXRhIGxpa2UgdGhpczpcbiAqIC8vIE9DVEVUIFNUUklORywgZW5jYXBzdWxhdGVzIHtcbiAqIC8vICAgU0VRVUVOQ0Uge1xuICogLy8gICAgIElOVEVHRVIgM1xuICogLy8gICAgIFByaW50YWJsZVN0cmluZyAnYWFhJ1xuICogLy8gICAgIH1cbiAqIC8vICAgfVxuICovXG5LSlVSLmFzbjEuREVST2N0ZXRTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhcmFtcy5vYmogIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIG8gPSBLSlVSLmFzbjEuQVNOMVV0aWwubmV3T2JqZWN0KHBhcmFtcy5vYmopO1xuICAgICAgICBwYXJhbXMuaGV4ID0gby5nZXRFbmNvZGVkSGV4KCk7XG4gICAgfVxuICAgIEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIwNFwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJPY3RldFN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBOdWxsXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSTnVsbFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgTnVsbFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuQVNOMU9iamVjdCAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUk51bGwgPSBmdW5jdGlvbigpIHtcbiAgICBLSlVSLmFzbjEuREVSTnVsbC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiMDVcIjtcbiAgICB0aGlzLmhUTFYgPSBcIjA1MDBcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSTnVsbCwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIE9iamVjdElkZW50aWZpZXJcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBPYmplY3RJZGVudGlmaWVyXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnb2lkJzogJzIuNS40LjUnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5BU04xT2JqZWN0XG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5vaWQgLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBvaWQgc3RyaW5nIChleC4gMi41LjQuMTMpPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICovXG5LSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHZhciBpdG94ID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgaCA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoaC5sZW5ndGggPT0gMSkgaCA9ICcwJyArIGg7XG4gICAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgdmFyIHJvaWR0b3ggPSBmdW5jdGlvbihyb2lkKSB7XG4gICAgICAgIHZhciBoID0gJyc7XG4gICAgICAgIHZhciBiaSA9IG5ldyBCaWdJbnRlZ2VyKHJvaWQsIDEwKTtcbiAgICAgICAgdmFyIGIgPSBiaS50b1N0cmluZygyKTtcbiAgICAgICAgdmFyIHBhZExlbiA9IDcgLSBiLmxlbmd0aCAlIDc7XG4gICAgICAgIGlmIChwYWRMZW4gPT0gNykgcGFkTGVuID0gMDtcbiAgICAgICAgdmFyIGJQYWQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRMZW47IGkrKykgYlBhZCArPSAnMCc7XG4gICAgICAgIGIgPSBiUGFkICsgYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aCAtIDE7IGkgKz0gNykge1xuICAgICAgICAgICAgdmFyIGI4ID0gYi5zdWJzdHIoaSwgNyk7XG4gICAgICAgICAgICBpZiAoaSAhPSBiLmxlbmd0aCAtIDcpIGI4ID0gJzEnICsgYjg7XG4gICAgICAgICAgICBoICs9IGl0b3gocGFyc2VJbnQoYjgsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9O1xuXG4gICAgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuaFQgPSBcIjA2XCI7XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdmFsdWUgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmdcbiAgICAgKiBAbmFtZSBzZXRWYWx1ZUhleFxuICAgICAqIEBtZW1iZXJPZiBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllciNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3SGV4U3RyaW5nIGhleGFkZWNpbWFsIHZhbHVlIG9mIE9JRCBieXRlc1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVIZXggPSBmdW5jdGlvbihuZXdIZXhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5oViA9IG5ld0hleFN0cmluZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgT0lEIHN0cmluZzxici8+XG4gICAgICogQG5hbWUgc2V0VmFsdWVPaWRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9pZFN0cmluZyBPSUQgc3RyaW5nIChleC4gMi41LjQuMTMpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBvID0gbmV3IEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyKCk7XG4gICAgICogby5zZXRWYWx1ZU9pZFN0cmluZyhcIjIuNS40LjEzXCIpO1xuICAgICAqL1xuICAgIHRoaXMuc2V0VmFsdWVPaWRTdHJpbmcgPSBmdW5jdGlvbihvaWRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCEgb2lkU3RyaW5nLm1hdGNoKC9eWzAtOS5dKyQvKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJtYWxmb3JtZWQgb2lkIHN0cmluZzogXCIgKyBvaWRTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGggPSAnJztcbiAgICAgICAgdmFyIGEgPSBvaWRTdHJpbmcuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGkwID0gcGFyc2VJbnQoYVswXSkgKiA0MCArIHBhcnNlSW50KGFbMV0pO1xuICAgICAgICBoICs9IGl0b3goaTApO1xuICAgICAgICBhLnNwbGljZSgwLCAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBoICs9IHJvaWR0b3goYVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oVExWID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5oViA9IGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIE9JRCBuYW1lXG4gICAgICogQG5hbWUgc2V0VmFsdWVOYW1lXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJPYmplY3RJZGVudGlmaWVyI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvaWROYW1lIE9JRCBuYW1lIChleC4gJ3NlcnZlckF1dGgnKVxuICAgICAqIEBzaW5jZSAxLjAuMVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE9JRCBuYW1lIHNoYWxsIGJlIGRlZmluZWQgaW4gJ0tKVVIuYXNuMS54NTA5Lk9JRC5uYW1lMm9pZExpc3QnLlxuICAgICAqIE90aGVyd2lzZSByYWlzZSBlcnJvci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG8gPSBuZXcgS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIoKTtcbiAgICAgKiBvLnNldFZhbHVlTmFtZShcInNlcnZlckF1dGhcIik7XG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZU5hbWUgPSBmdW5jdGlvbihvaWROYW1lKSB7XG4gICAgICAgIHZhciBvaWQgPSBLSlVSLmFzbjEueDUwOS5PSUQubmFtZTJvaWQob2lkTmFtZSk7XG4gICAgICAgIGlmIChvaWQgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlT2lkU3RyaW5nKG9pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIkRFUk9iamVjdElkZW50aWZpZXIgb2lkTmFtZSB1bmRlZmluZWQ6IFwiICsgb2lkTmFtZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5tYXRjaCgvXlswLTJdLlswLTkuXSskLykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlT2lkU3RyaW5nKHBhcmFtcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVOYW1lKHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLm9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlT2lkU3RyaW5nKHBhcmFtcy5vaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5oZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUhleChwYXJhbXMuaGV4KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMubmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlTmFtZShwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUk9iamVjdElkZW50aWZpZXIsIEtKVVIuYXNuMS5BU04xT2JqZWN0KTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBFbnVtZXJhdGVkXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSRW51bWVyYXRlZFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgRW51bWVyYXRlZFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPmludCAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBpbnRlZ2VyIHZhbHVlPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICogQGV4YW1wbGVcbiAqIG5ldyBLSlVSLmFzbjEuREVSRW51bWVyYXRlZCgxMjMpO1xuICogbmV3IEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkKHtpbnQ6IDEyM30pO1xuICogbmV3IEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkKHtoZXg6ICcxZmFkJ30pO1xuICovXG5LSlVSLmFzbjEuREVSRW51bWVyYXRlZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkLnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmhUID0gXCIwYVwiO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IFRvbSBXdSdzIEJpZ0ludGVnZXIgb2JqZWN0XG4gICAgICogQG5hbWUgc2V0QnlCaWdJbnRlZ2VyXG4gICAgICogQG1lbWJlck9mIEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkI1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7QmlnSW50ZWdlcn0gYmlnSW50ZWdlclZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlCaWdJbnRlZ2VyID0gZnVuY3Rpb24oYmlnSW50ZWdlclZhbHVlKSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaFYgPSBLSlVSLmFzbjEuQVNOMVV0aWwuYmlnSW50VG9NaW5Ud29zQ29tcGxlbWVudHNIZXgoYmlnSW50ZWdlclZhbHVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGludGVnZXIgdmFsdWVcbiAgICAgKiBAbmFtZSBzZXRCeUludGVnZXJcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbnRlZ2VyIHZhbHVlIHRvIHNldFxuICAgICAqL1xuICAgIHRoaXMuc2V0QnlJbnRlZ2VyID0gZnVuY3Rpb24oaW50VmFsdWUpIHtcbiAgICAgICAgdmFyIGJpID0gbmV3IEJpZ0ludGVnZXIoU3RyaW5nKGludFZhbHVlKSwgMTApO1xuICAgICAgICB0aGlzLnNldEJ5QmlnSW50ZWdlcihiaSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBpbnRlZ2VyIHZhbHVlXG4gICAgICogQG5hbWUgc2V0VmFsdWVIZXhcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkVudW1lcmF0ZWQjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhleGFkZWNpbWFsIHN0cmluZyBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPGJyLz5cbiAgICAgKiBOT1RFOiBWYWx1ZSBzaGFsbCBiZSByZXByZXNlbnRlZCBieSBtaW5pbXVtIG9jdGV0IGxlbmd0aCBvZlxuICAgICAqIHR3bydzIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdGhpcy5zZXRWYWx1ZUhleCA9IGZ1bmN0aW9uKG5ld0hleFN0cmluZykge1xuICAgICAgICB0aGlzLmhWID0gbmV3SGV4U3RyaW5nO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ2ludCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlJbnRlZ2VyKHBhcmFtc1snaW50J10pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5zZXRCeUludGVnZXIocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zWydoZXgnXSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KHBhcmFtc1snaGV4J10pO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJFbnVtZXJhdGVkLCBLSlVSLmFzbjEuQVNOMU9iamVjdCk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVVRGOFN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUlVURjhTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFVURjhTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJVVEY4U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlVURjhTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMGNcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVVRGOFN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBOdW1lcmljU3RyaW5nXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgTnVtZXJpY1N0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUk51bWVyaWNTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSTnVtZXJpY1N0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxMlwiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJOdW1lcmljU3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFByaW50YWJsZVN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZ1xuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgUHJpbnRhYmxlU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJ2FhYSd9KVxuICogQGV4dGVuZHMgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nXG4gKiBAZGVzY3JpcHRpb25cbiAqIEBzZWUgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nIC0gc3VwZXJjbGFzc1xuICovXG5LSlVSLmFzbjEuREVSUHJpbnRhYmxlU3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlByaW50YWJsZVN0cmluZy5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxM1wiO1xufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJQcmludGFibGVTdHJpbmcsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgVGVsZXRleFN0cmluZ1xuICogQG5hbWUgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFRlbGV0ZXhTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnYWFhJ30pXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmdcbiAqIEBkZXNjcmlwdGlvblxuICogQHNlZSBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcgLSBzdXBlcmNsYXNzXG4gKi9cbktKVVIuYXNuMS5ERVJUZWxldGV4U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlRlbGV0ZXhTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMTRcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVGVsZXRleFN0cmluZywgS0pVUi5hc24xLkRFUkFic3RyYWN0U3RyaW5nKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBJQTVTdHJpbmdcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJJQTVTdHJpbmdcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIElBNVN0cmluZ1xuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIGFzc29jaWF0aXZlIGFycmF5IG9mIHBhcmFtZXRlcnMgKGV4LiB7J3N0cic6ICdhYWEnfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZ1xuICogQGRlc2NyaXB0aW9uXG4gKiBAc2VlIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cmluZyAtIHN1cGVyY2xhc3NcbiAqL1xuS0pVUi5hc24xLkRFUklBNVN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJJQTVTdHJpbmcuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMTZcIjtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSSUE1U3RyaW5nLCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJpbmcpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFVUQ1RpbWVcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJVVENUaW1lXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBVVENUaW1lXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgYXNzb2NpYXRpdmUgYXJyYXkgb2YgcGFyYW1ldGVycyAoZXguIHsnc3RyJzogJzEzMDQzMDIzNTk1OVonfSlcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWVcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPnN0ciAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIHN0cmluZyAoZXguJzEzMDQzMDIzNTk1OVonKTwvbGk+XG4gKiA8bGk+aGV4IC0gc3BlY2lmeSBpbml0aWFsIEFTTi4xIHZhbHVlKFYpIGJ5IGEgaGV4YWRlY2ltYWwgc3RyaW5nPC9saT5cbiAqIDxsaT5kYXRlIC0gc3BlY2lmeSBEYXRlIG9iamVjdC48L2xpPlxuICogPC91bD5cbiAqIE5PVEU6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICogPGg0PkVYQU1QTEVTPC9oND5cbiAqIEBleGFtcGxlXG4gKiBkMSA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSgpO1xuICogZDEuc2V0U3RyaW5nKCcxMzA0MzAxMjU5NTlaJyk7XG4gKlxuICogZDIgPSBuZXcgS0pVUi5hc24xLkRFUlVUQ1RpbWUoeydzdHInOiAnMTMwNDMwMTI1OTU5Wid9KTtcbiAqIGQzID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKHsnZGF0ZSc6IG5ldyBEYXRlKERhdGUuVVRDKDIwMTUsIDAsIDMxLCAwLCAwLCAwLCAwKSl9KTtcbiAqIGQ0ID0gbmV3IEtKVVIuYXNuMS5ERVJVVENUaW1lKCcxMzA0MzAxMjU5NTlaJyk7XG4gKi9cbktKVVIuYXNuMS5ERVJVVENUaW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlVUQ1RpbWUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmFtcyk7XG4gICAgdGhpcy5oVCA9IFwiMTdcIjtcblxuICAgIC8qKlxuICAgICAqIHNldCB2YWx1ZSBieSBhIERhdGUgb2JqZWN0PGJyLz5cbiAgICAgKiBAbmFtZSBzZXRCeURhdGVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUlVUQ1RpbWUjXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtEYXRlfSBkYXRlT2JqZWN0IERhdGUgb2JqZWN0IHRvIHNldCBBU04uMSB2YWx1ZShWKVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbyA9IG5ldyBLSlVSLmFzbjEuREVSVVRDVGltZSgpO1xuICAgICAqIG8uc2V0QnlEYXRlKG5ldyBEYXRlKFwiMjAxNi8xMi8zMVwiKSk7XG4gICAgICovXG4gICAgdGhpcy5zZXRCeURhdGUgPSBmdW5jdGlvbihkYXRlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0ZSA9IGRhdGVPYmplY3Q7XG4gICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICd1dGMnKTtcbiAgICAgICAgdGhpcy5oViA9IHN0b2hleCh0aGlzLnMpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGUgPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdGhpcy5zID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLmZvcm1hdERhdGUodGhpcy5kYXRlLCAndXRjJyk7XG4gICAgICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyYW1zLnN0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMuc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIgJiYgcGFyYW1zLm1hdGNoKC9eWzAtOV17MTJ9WiQvKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmcocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nSGV4KHBhcmFtcy5oZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5kYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QnlEYXRlKHBhcmFtcy5kYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSVVRDVGltZSwgS0pVUi5hc24xLkRFUkFic3RyYWN0VGltZSk7XG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vKipcbiAqIGNsYXNzIGZvciBBU04uMSBERVIgR2VuZXJhbGl6ZWRUaW1lXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lXG4gKiBAY2xhc3MgY2xhc3MgZm9yIEFTTi4xIERFUiBHZW5lcmFsaXplZFRpbWVcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwYXJhbWV0ZXJzIChleC4geydzdHInOiAnMjAxMzA0MzAyMzU5NTlaJ30pXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHdpdGhNaWxsaXMgZmxhZyB0byBzaG93IG1pbGxpc2Vjb25kcyBvciBub3RcbiAqIEBleHRlbmRzIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWVcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIEFzIGZvciBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSBvbmUgb2ZcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogPHVsPlxuICogPGxpPnN0ciAtIHNwZWNpZnkgaW5pdGlhbCBBU04uMSB2YWx1ZShWKSBieSBhIHN0cmluZyAoZXguJzIwMTMwNDMwMjM1OTU5WicpPC9saT5cbiAqIDxsaT5oZXggLSBzcGVjaWZ5IGluaXRpYWwgQVNOLjEgdmFsdWUoVikgYnkgYSBoZXhhZGVjaW1hbCBzdHJpbmc8L2xpPlxuICogPGxpPmRhdGUgLSBzcGVjaWZ5IERhdGUgb2JqZWN0LjwvbGk+XG4gKiA8bGk+bWlsbGlzIC0gc3BlY2lmeSBmbGFnIHRvIHNob3cgbWlsbGlzZWNvbmRzIChmcm9tIDEuMC42KTwvbGk+XG4gKiA8L3VsPlxuICogTk9URTE6ICdwYXJhbXMnIGNhbiBiZSBvbWl0dGVkLlxuICogTk9URTI6ICd3aXRoTWlsbGlzJyBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgZnJvbSBhc24xIDEuMC42LlxuICovXG5LSlVSLmFzbjEuREVSR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIxOFwiO1xuICAgIHRoaXMud2l0aE1pbGxpcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGEgRGF0ZSBvYmplY3RcbiAgICAgKiBAbmFtZSBzZXRCeURhdGVcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUkdlbmVyYWxpemVkVGltZSNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVPYmplY3QgRGF0ZSBvYmplY3QgdG8gc2V0IEFTTi4xIHZhbHVlKFYpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBXaGVuIHlvdSBzcGVjaWZ5IFVUQyB0aW1lLCB1c2UgJ0RhdGUuVVRDJyBtZXRob2QgbGlrZSB0aGlzOjxici8+XG4gICAgICogbzEgPSBuZXcgREVSVVRDVGltZSgpO1xuICAgICAqIG8xLnNldEJ5RGF0ZShkYXRlKTtcbiAgICAgKlxuICAgICAqIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygyMDE1LCAwLCAzMSwgMjMsIDU5LCA1OSwgMCkpOyAjMjAxNUpBTjMxIDIzOjU5OjU5XG4gICAgICovXG4gICAgdGhpcy5zZXRCeURhdGUgPSBmdW5jdGlvbihkYXRlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNNb2RpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0ZSA9IGRhdGVPYmplY3Q7XG4gICAgICAgIHRoaXMucyA9IHRoaXMuZm9ybWF0RGF0ZSh0aGlzLmRhdGUsICdnZW4nLCB0aGlzLndpdGhNaWxsaXMpO1xuICAgICAgICB0aGlzLmhWID0gc3RvaGV4KHRoaXMucyk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnMgPSB0aGlzLmZvcm1hdERhdGUodGhpcy5kYXRlLCAnZ2VuJywgdGhpcy53aXRoTWlsbGlzKTtcbiAgICAgICAgICAgIHRoaXMuaFYgPSBzdG9oZXgodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oVjtcbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXMuc3RyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaW5nKHBhcmFtcy5zdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMubWF0Y2goL15bMC05XXsxNH1aJC8pKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmluZyhwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5oZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpbmdIZXgocGFyYW1zLmhleCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRCeURhdGUocGFyYW1zLmRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWlsbGlzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLndpdGhNaWxsaXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbllBSE9PLmxhbmcuZXh0ZW5kKEtKVVIuYXNuMS5ERVJHZW5lcmFsaXplZFRpbWUsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFRpbWUpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFNlcXVlbmNlXG4gKiBAbmFtZSBLSlVSLmFzbjEuREVSU2VxdWVuY2VcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFNlcXVlbmNlXG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXQgZWxlbWVudHMgb2YgY29udGVudDwvbGk+XG4gKiA8L3VsPlxuICogTk9URTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuXG4gKi9cbktKVVIuYXNuMS5ERVJTZXF1ZW5jZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIEtKVVIuYXNuMS5ERVJTZXF1ZW5jZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICB0aGlzLmhUID0gXCIzMFwiO1xuICAgIHRoaXMuZ2V0RnJlc2hWYWx1ZUhleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXNuMUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXNuMU9iaiA9IHRoaXMuYXNuMUFycmF5W2ldO1xuICAgICAgICAgICAgaCArPSBhc24xT2JqLmdldEVuY29kZWRIZXgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhWID0gaDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSU2VxdWVuY2UsIEtKVVIuYXNuMS5ERVJBYnN0cmFjdFN0cnVjdHVyZWQpO1xuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLyoqXG4gKiBjbGFzcyBmb3IgQVNOLjEgREVSIFNldFxuICogQG5hbWUgS0pVUi5hc24xLkRFUlNldFxuICogQGNsYXNzIGNsYXNzIGZvciBBU04uMSBERVIgU2V0XG4gKiBAZXh0ZW5kcyBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkXG4gKiBAZGVzY3JpcHRpb25cbiAqIDxici8+XG4gKiBBcyBmb3IgYXJndW1lbnQgJ3BhcmFtcycgZm9yIGNvbnN0cnVjdG9yLCB5b3UgY2FuIHNwZWNpZnkgb25lIG9mXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIDx1bD5cbiAqIDxsaT5hcnJheSAtIHNwZWNpZnkgYXJyYXkgb2YgQVNOMU9iamVjdCB0byBzZXQgZWxlbWVudHMgb2YgY29udGVudDwvbGk+XG4gKiA8bGk+c29ydGZsYWcgLSBmbGFnIGZvciBzb3J0IChkZWZhdWx0OiB0cnVlKS4gQVNOLjEgQkVSIGlzIG5vdCBzb3J0ZWQgaW4gJ1NFVCBPRicuPC9saT5cbiAqIDwvdWw+XG4gKiBOT1RFMTogJ3BhcmFtcycgY2FuIGJlIG9taXR0ZWQuPGJyLz5cbiAqIE5PVEUyOiBzb3J0ZmxhZyBpcyBzdXBwb3J0ZWQgc2luY2UgMS4wLjUuXG4gKi9cbktKVVIuYXNuMS5ERVJTZXQgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICBLSlVSLmFzbjEuREVSU2V0LnN1cGVyY2xhc3MuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgIHRoaXMuaFQgPSBcIjMxXCI7XG4gICAgdGhpcy5zb3J0RmxhZyA9IHRydWU7IC8vIGl0ZW0gc2hhbGwgYmUgc29ydGVkIG9ubHkgaW4gQVNOLjEgREVSXG4gICAgdGhpcy5nZXRGcmVzaFZhbHVlSGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hc24xQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhc24xT2JqID0gdGhpcy5hc24xQXJyYXlbaV07XG4gICAgICAgICAgICBhLnB1c2goYXNuMU9iai5nZXRFbmNvZGVkSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNvcnRGbGFnID09IHRydWUpIGEuc29ydCgpO1xuICAgICAgICB0aGlzLmhWID0gYS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuc29ydGZsYWcgIT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgcGFyYW1zLnNvcnRmbGFnID09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zb3J0RmxhZyA9IGZhbHNlO1xuICAgIH1cbn07XG5ZQUhPTy5sYW5nLmV4dGVuZChLSlVSLmFzbjEuREVSU2V0LCBLSlVSLmFzbjEuREVSQWJzdHJhY3RTdHJ1Y3R1cmVkKTtcblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8qKlxuICogY2xhc3MgZm9yIEFTTi4xIERFUiBUYWdnZWRPYmplY3RcbiAqIEBuYW1lIEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3RcbiAqIEBjbGFzcyBjbGFzcyBmb3IgQVNOLjEgREVSIFRhZ2dlZE9iamVjdFxuICogQGV4dGVuZHMgS0pVUi5hc24xLkFTTjFPYmplY3RcbiAqIEBkZXNjcmlwdGlvblxuICogPGJyLz5cbiAqIFBhcmFtZXRlciAndGFnTm9OZXgnIGlzIEFTTi4xIHRhZyhUKSB2YWx1ZSBmb3IgdGhpcyBvYmplY3QuXG4gKiBGb3IgZXhhbXBsZSwgaWYgeW91IGZpbmQgJ1sxXScgdGFnIGluIGEgQVNOLjEgZHVtcCxcbiAqICd0YWdOb0hleCcgd2lsbCBiZSAnYTEnLlxuICogPGJyLz5cbiAqIEFzIGZvciBvcHRpb25hbCBhcmd1bWVudCAncGFyYW1zJyBmb3IgY29uc3RydWN0b3IsIHlvdSBjYW4gc3BlY2lmeSAqQU5ZKiBvZlxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiA8dWw+XG4gKiA8bGk+ZXhwbGljaXQgLSBzcGVjaWZ5IHRydWUgaWYgdGhpcyBpcyBleHBsaWNpdCB0YWcgb3RoZXJ3aXNlIGZhbHNlXG4gKiAgICAgKGRlZmF1bHQgaXMgJ3RydWUnKS48L2xpPlxuICogPGxpPnRhZyAtIHNwZWNpZnkgdGFnIChkZWZhdWx0IGlzICdhMCcgd2hpY2ggbWVhbnMgWzBdKTwvbGk+XG4gKiA8bGk+b2JqIC0gc3BlY2lmeSBBU04xT2JqZWN0IHdoaWNoIGlzIHRhZ2dlZDwvbGk+XG4gKiA8L3VsPlxuICogQGV4YW1wbGVcbiAqIGQxID0gbmV3IEtKVVIuYXNuMS5ERVJVVEY4U3RyaW5nKHsnc3RyJzonYSd9KTtcbiAqIGQyID0gbmV3IEtKVVIuYXNuMS5ERVJUYWdnZWRPYmplY3QoeydvYmonOiBkMX0pO1xuICogaGV4ID0gZDIuZ2V0RW5jb2RlZEhleCgpO1xuICovXG5LSlVSLmFzbjEuREVSVGFnZ2VkT2JqZWN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdC5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5oVCA9IFwiYTBcIjtcbiAgICB0aGlzLmhWID0gJyc7XG4gICAgdGhpcy5pc0V4cGxpY2l0ID0gdHJ1ZTtcbiAgICB0aGlzLmFzbjFPYmplY3QgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHZhbHVlIGJ5IGFuIEFTTjFPYmplY3RcbiAgICAgKiBAbmFtZSBzZXRTdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRXhwbGljaXRGbGFnIGZsYWcgZm9yIGV4cGxpY2l0L2ltcGxpY2l0IHRhZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gdGFnTm9IZXggaGV4YWRlY2ltYWwgc3RyaW5nIG9mIEFTTi4xIHRhZ1xuICAgICAqIEBwYXJhbSB7QVNOMU9iamVjdH0gYXNuMU9iamVjdCBBU04uMSB0byBlbmNhcHN1bGF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2V0QVNOMU9iamVjdCA9IGZ1bmN0aW9uKGlzRXhwbGljaXRGbGFnLCB0YWdOb0hleCwgYXNuMU9iamVjdCkge1xuICAgICAgICB0aGlzLmhUID0gdGFnTm9IZXg7XG4gICAgICAgIHRoaXMuaXNFeHBsaWNpdCA9IGlzRXhwbGljaXRGbGFnO1xuICAgICAgICB0aGlzLmFzbjFPYmplY3QgPSBhc24xT2JqZWN0O1xuICAgICAgICBpZiAodGhpcy5pc0V4cGxpY2l0KSB7XG4gICAgICAgICAgICB0aGlzLmhWID0gdGhpcy5hc24xT2JqZWN0LmdldEVuY29kZWRIZXgoKTtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oViA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhUTFYgPSBhc24xT2JqZWN0LmdldEVuY29kZWRIZXgoKTtcbiAgICAgICAgICAgIHRoaXMuaFRMViA9IHRoaXMuaFRMVi5yZXBsYWNlKC9eLi4vLCB0YWdOb0hleCk7XG4gICAgICAgICAgICB0aGlzLmlzTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldEZyZXNoVmFsdWVIZXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFY7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXNbJ3RhZyddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaFQgPSBwYXJhbXNbJ3RhZyddO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zWydleHBsaWNpdCddICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNFeHBsaWNpdCA9IHBhcmFtc1snZXhwbGljaXQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc1snb2JqJ10gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5hc24xT2JqZWN0ID0gcGFyYW1zWydvYmonXTtcbiAgICAgICAgICAgIHRoaXMuc2V0QVNOMU9iamVjdCh0aGlzLmlzRXhwbGljaXQsIHRoaXMuaFQsIHRoaXMuYXNuMU9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuWUFIT08ubGFuZy5leHRlbmQoS0pVUi5hc24xLkRFUlRhZ2dlZE9iamVjdCwgS0pVUi5hc24xLkFTTjFPYmplY3QpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBKU0VuY3J5cHRSU0FLZXkgdGhhdCBleHRlbmRzIFRvbSBXdSdzIFJTQSBrZXkgb2JqZWN0LlxuICogVGhpcyBvYmplY3QgaXMganVzdCBhIGRlY29yYXRvciBmb3IgcGFyc2luZyB0aGUga2V5IHBhcmFtZXRlclxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBrZXkgLSBUaGUga2V5IGluIHN0cmluZyBmb3JtYXQsIG9yIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiB0aGUgcGFyYW1ldGVycyBuZWVkZWQgdG8gYnVpbGQgYSBSU0FLZXkgb2JqZWN0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKU0VuY3J5cHRSU0FLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTRW5jcnlwdFJTQUtleSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU0VuY3J5cHRSU0FLZXkoa2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8vIENhbGwgdGhlIHN1cGVyIGNvbnN0cnVjdG9yLlxuICAgICAgICAvLyAgUlNBS2V5LmNhbGwodGhpcyk7XG4gICAgICAgIC8vIElmIGEga2V5IGtleSB3YXMgcHJvdmlkZWQuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBzdHJpbmcuLi5cbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyc2VLZXkoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEpTRW5jcnlwdFJTQUtleS5oYXNQcml2YXRlS2V5UHJvcGVydHkoa2V5KSB8fFxuICAgICAgICAgICAgICAgIEpTRW5jcnlwdFJTQUtleS5oYXNQdWJsaWNLZXlQcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZXMgZm9yIHRoZSBrZXkuXG4gICAgICAgICAgICAgICAgX3RoaXMucGFyc2VQcm9wZXJ0aWVzRnJvbShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHBhcnNlIGEgcGVtIGVuY29kZWQgc3RyaW5nIGNvbnRhaW5pbmcgYm90aCBhIHB1YmxpYyBvciBwcml2YXRlIGtleS5cbiAgICAgKiBUaGUgbWV0aG9kIHdpbGwgdHJhbnNsYXRlIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcgaW4gYSBkZXIgZW5jb2RlZCBzdHJpbmcgYW5kXG4gICAgICogd2lsbCBwYXJzZSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleSBwYXJhbWV0ZXJzLiBUaGlzIG1ldGhvZCBhY2NlcHRzIHB1YmxpYyBrZXlcbiAgICAgKiBpbiB0aGUgcnNhZW5jcnlwdGlvbiBwa2NzICMxIGZvcm1hdCAob2lkOiAxLjIuODQwLjExMzU0OS4xLjEuMSkuXG4gICAgICpcbiAgICAgKiBAdG9kbyBDaGVjayBob3cgbWFueSByc2EgZm9ybWF0cyB1c2UgdGhlIHNhbWUgZm9ybWF0IG9mIHBrY3MgIzEuXG4gICAgICpcbiAgICAgKiBUaGUgZm9ybWF0IGlzIGRlZmluZWQgYXM6XG4gICAgICogUHVibGljS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAgICogICBQdWJsaWNLZXkgICAgICAgQklUIFNUUklOR1xuICAgICAqIH1cbiAgICAgKiBXaGVyZSBBbGdvcml0aG1JZGVudGlmaWVyIGlzOlxuICAgICAqIEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBPQkpFQ1QgSURFTlRJRklFUiwgICAgIHRoZSBPSUQgb2YgdGhlIGVuYyBhbGdvcml0aG1cbiAgICAgKiAgIHBhcmFtZXRlcnMgICAgICBBTlkgREVGSU5FRCBCWSBhbGdvcml0aG0gT1BUSU9OQUwgKE5VTEwgZm9yIFBLQ1MgIzEpXG4gICAgICogfVxuICAgICAqIGFuZCBQdWJsaWNLZXkgaXMgYSBTRVFVRU5DRSBlbmNhcHN1bGF0ZWQgaW4gYSBCSVQgU1RSSU5HXG4gICAgICogUlNBUHVibGljS2V5IDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBtb2R1bHVzICAgICAgICAgICBJTlRFR0VSLCAgLS0gblxuICAgICAqICAgcHVibGljRXhwb25lbnQgICAgSU5URUdFUiAgIC0tIGVcbiAgICAgKiB9XG4gICAgICogaXQncyBwb3NzaWJsZSB0byBleGFtaW5lIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGtleXMgb2J0YWluZWQgZnJvbSBvcGVuc3NsIHVzaW5nXG4gICAgICogYW4gYXNuLjEgZHVtcGVyIGFzIHRoZSBvbmUgdXNlZCBoZXJlIHRvIHBhcnNlIHRoZSBjb21wb25lbnRzOiBodHRwOi8vbGFwby5pdC9hc24xanMvXG4gICAgICogQGFyZ3VtZW50IHtzdHJpbmd9IHBlbSB0aGUgcGVtIGVuY29kZWQgc3RyaW5nLCBjYW4gaW5jbHVkZSB0aGUgQkVHSU4vRU5EIGhlYWRlci9mb290ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUucGFyc2VLZXkgPSBmdW5jdGlvbiAocGVtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbW9kdWx1cyA9IDA7XG4gICAgICAgICAgICB2YXIgcHVibGljX2V4cG9uZW50ID0gMDtcbiAgICAgICAgICAgIHZhciByZUhleCA9IC9eXFxzKig/OlswLTlBLUZhLWZdWzAtOUEtRmEtZl1cXHMqKSskLztcbiAgICAgICAgICAgIHZhciBkZXIgPSByZUhleC50ZXN0KHBlbSkgPyBIZXguZGVjb2RlKHBlbSkgOiBCYXNlNjQudW5hcm1vcihwZW0pO1xuICAgICAgICAgICAgdmFyIGFzbjEgPSBBU04xLmRlY29kZShkZXIpO1xuICAgICAgICAgICAgLy8gRml4ZXMgYSBidWcgd2l0aCBPcGVuU1NMIDEuMCsgcHJpdmF0ZSBrZXlzXG4gICAgICAgICAgICBpZiAoYXNuMS5zdWIubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgYXNuMSA9IGFzbjEuc3ViWzJdLnN1YlswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICAgICAgICAgICAgbW9kdWx1cyA9IGFzbjEuc3ViWzFdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMubiA9IHBhcnNlQmlnSW50KG1vZHVsdXMsIDE2KTtcbiAgICAgICAgICAgICAgICBwdWJsaWNfZXhwb25lbnQgPSBhc24xLnN1YlsyXS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBwYXJzZUludChwdWJsaWNfZXhwb25lbnQsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpdmF0ZV9leHBvbmVudCA9IGFzbjEuc3ViWzNdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMuZCA9IHBhcnNlQmlnSW50KHByaXZhdGVfZXhwb25lbnQsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWUxID0gYXNuMS5zdWJbNF0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5wID0gcGFyc2VCaWdJbnQocHJpbWUxLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIHByaW1lMiA9IGFzbjEuc3ViWzVdLmdldEhleFN0cmluZ1ZhbHVlKCk7IC8vIGJpZ2ludFxuICAgICAgICAgICAgICAgIHRoaXMucSA9IHBhcnNlQmlnSW50KHByaW1lMiwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudDEgPSBhc24xLnN1Yls2XS5nZXRIZXhTdHJpbmdWYWx1ZSgpOyAvLyBiaWdpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmRtcDEgPSBwYXJzZUJpZ0ludChleHBvbmVudDEsIDE2KTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQyID0gYXNuMS5zdWJbN10uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5kbXExID0gcGFyc2VCaWdJbnQoZXhwb25lbnQyLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gYXNuMS5zdWJbOF0uZ2V0SGV4U3RyaW5nVmFsdWUoKTsgLy8gYmlnaW50XG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmZiA9IHBhcnNlQmlnSW50KGNvZWZmaWNpZW50LCAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhc24xLnN1Yi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgcHVibGljIGtleS5cbiAgICAgICAgICAgICAgICB2YXIgYml0X3N0cmluZyA9IGFzbjEuc3ViWzFdO1xuICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IGJpdF9zdHJpbmcuc3ViWzBdO1xuICAgICAgICAgICAgICAgIG1vZHVsdXMgPSBzZXF1ZW5jZS5zdWJbMF0uZ2V0SGV4U3RyaW5nVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm4gPSBwYXJzZUJpZ0ludChtb2R1bHVzLCAxNik7XG4gICAgICAgICAgICAgICAgcHVibGljX2V4cG9uZW50ID0gc2VxdWVuY2Uuc3ViWzFdLmdldEhleFN0cmluZ1ZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lID0gcGFyc2VJbnQocHVibGljX2V4cG9uZW50LCAxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlIHJzYSBwYXJhbWV0ZXJzIGluIGEgaGV4IGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIGtleS5cbiAgICAgKlxuICAgICAqIFRoZSB0cmFuc2xhdGlvbiBmb2xsb3cgdGhlIEFTTi4xIG5vdGF0aW9uIDpcbiAgICAgKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gICAgICogICB2ZXJzaW9uICAgICAgICAgICBWZXJzaW9uLFxuICAgICAqICAgbW9kdWx1cyAgICAgICAgICAgSU5URUdFUiwgIC0tIG5cbiAgICAgKiAgIHB1YmxpY0V4cG9uZW50ICAgIElOVEVHRVIsICAtLSBlXG4gICAgICogICBwcml2YXRlRXhwb25lbnQgICBJTlRFR0VSLCAgLS0gZFxuICAgICAqICAgcHJpbWUxICAgICAgICAgICAgSU5URUdFUiwgIC0tIHBcbiAgICAgKiAgIHByaW1lMiAgICAgICAgICAgIElOVEVHRVIsICAtLSBxXG4gICAgICogICBleHBvbmVudDEgICAgICAgICBJTlRFR0VSLCAgLS0gZCBtb2QgKHAxKVxuICAgICAqICAgZXhwb25lbnQyICAgICAgICAgSU5URUdFUiwgIC0tIGQgbW9kIChxLTEpXG4gICAgICogICBjb2VmZmljaWVudCAgICAgICBJTlRFR0VSLCAgLS0gKGludmVyc2Ugb2YgcSkgbW9kIHBcbiAgICAgKiB9XG4gICAgICogQHJldHVybnMge3N0cmluZ30gIERFUiBFbmNvZGVkIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIHJzYSBwcml2YXRlIGtleVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5LnByb3RvdHlwZS5nZXRQcml2YXRlQmFzZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogMCB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMubiB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBpbnQ6IHRoaXMuZSB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMuZCB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMucCB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMucSB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMuZG1wMSB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMuZG1xMSB9KSxcbiAgICAgICAgICAgICAgICBuZXcgS0pVUi5hc24xLkRFUkludGVnZXIoeyBiaWdpbnQ6IHRoaXMuY29lZmYgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNlcSA9IG5ldyBLSlVSLmFzbjEuREVSU2VxdWVuY2Uob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBzZXEuZ2V0RW5jb2RlZEhleCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYmFzZTY0IChwZW0pIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgREVSIGVuY29kZWQgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiB3aXRob3V0IGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHJpdmF0ZUJhc2VLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0UHJpdmF0ZUJhc2VLZXkoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgcnNhIHBhcmFtZXRlcnMgaW4gYSBoZXggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSByc2EgcHVibGljIGtleS5cbiAgICAgKiBUaGUgcmVwcmVzZW50YXRpb24gZm9sbG93IHRoZSBBU04uMSBub3RhdGlvbiA6XG4gICAgICogUHVibGljS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICAgICAqICAgYWxnb3JpdGhtICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAgICogICBQdWJsaWNLZXkgICAgICAgQklUIFNUUklOR1xuICAgICAqIH1cbiAgICAgKiBXaGVyZSBBbGdvcml0aG1JZGVudGlmaWVyIGlzOlxuICAgICAqIEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IFNFUVVFTkNFIHtcbiAgICAgKiAgIGFsZ29yaXRobSAgICAgICBPQkpFQ1QgSURFTlRJRklFUiwgICAgIHRoZSBPSUQgb2YgdGhlIGVuYyBhbGdvcml0aG1cbiAgICAgKiAgIHBhcmFtZXRlcnMgICAgICBBTlkgREVGSU5FRCBCWSBhbGdvcml0aG0gT1BUSU9OQUwgKE5VTEwgZm9yIFBLQ1MgIzEpXG4gICAgICogfVxuICAgICAqIGFuZCBQdWJsaWNLZXkgaXMgYSBTRVFVRU5DRSBlbmNhcHN1bGF0ZWQgaW4gYSBCSVQgU1RSSU5HXG4gICAgICogUlNBUHVibGljS2V5IDo6PSBTRVFVRU5DRSB7XG4gICAgICogICBtb2R1bHVzICAgICAgICAgICBJTlRFR0VSLCAgLS0gblxuICAgICAqICAgcHVibGljRXhwb25lbnQgICAgSU5URUdFUiAgIC0tIGVcbiAgICAgKiB9XG4gICAgICogQHJldHVybnMge3N0cmluZ30gREVSIEVuY29kZWQgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcnNhIHB1YmxpYyBrZXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljQmFzZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcnN0X3NlcXVlbmNlID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XG4gICAgICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVST2JqZWN0SWRlbnRpZmllcih7IG9pZDogXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSTnVsbCgpXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2Vjb25kX3NlcXVlbmNlID0gbmV3IEtKVVIuYXNuMS5ERVJTZXF1ZW5jZSh7XG4gICAgICAgICAgICBhcnJheTogW1xuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGJpZ2ludDogdGhpcy5uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBLSlVSLmFzbjEuREVSSW50ZWdlcih7IGludDogdGhpcy5lIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYml0X3N0cmluZyA9IG5ldyBLSlVSLmFzbjEuREVSQml0U3RyaW5nKHtcbiAgICAgICAgICAgIGhleDogXCIwMFwiICsgc2Vjb25kX3NlcXVlbmNlLmdldEVuY29kZWRIZXgoKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNlcSA9IG5ldyBLSlVSLmFzbjEuREVSU2VxdWVuY2Uoe1xuICAgICAgICAgICAgYXJyYXk6IFtcbiAgICAgICAgICAgICAgICBmaXJzdF9zZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICBiaXRfc3RyaW5nXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VxLmdldEVuY29kZWRIZXgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGJhc2U2NCAocGVtKSBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIERFUiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFB1YmxpY0Jhc2VLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBoZXgyYjY0KHRoaXMuZ2V0UHVibGljQmFzZUtleSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHdyYXAgdGhlIHN0cmluZyBpbiBibG9jayBvZiB3aWR0aCBjaGFycy4gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHJzYSBrZXlzIGlzIDY0XG4gICAgICogY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBwZW0gZW5jb2RlZCBzdHJpbmcgd2l0aG91dCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9NjRdIC0gdGhlIGxlbmd0aCB0aGUgc3RyaW5nIGhhcyB0byBiZSB3cmFwcGVkIGF0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS53b3Jkd3JhcCA9IGZ1bmN0aW9uIChzdHIsIHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGggfHwgNjQ7XG4gICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWdleCA9IFwiKC57MSxcIiArIHdpZHRoICsgXCJ9KSggK3wkXFxuPyl8KC57MSxcIiArIHdpZHRoICsgXCJ9KVwiO1xuICAgICAgICByZXR1cm4gc3RyLm1hdGNoKFJlZ0V4cChyZWdleCwgXCJnXCIpKS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHBlbSBlbmNvZGVkIHByaXZhdGUga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBlbSBlbmNvZGVkIHByaXZhdGUga2V5IHdpdGggaGVhZGVyL2Zvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkucHJvdG90eXBlLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrZXkgPSBcIi0tLS0tQkVHSU4gUlNBIFBSSVZBVEUgS0VZLS0tLS1cXG5cIjtcbiAgICAgICAga2V5ICs9IEpTRW5jcnlwdFJTQUtleS53b3Jkd3JhcCh0aGlzLmdldFByaXZhdGVCYXNlS2V5QjY0KCkpICsgXCJcXG5cIjtcbiAgICAgICAga2V5ICs9IFwiLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS1cIjtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBwZW0gZW5jb2RlZCBwdWJsaWMga2V5XG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHBlbSBlbmNvZGVkIHB1YmxpYyBrZXkgd2l0aCBoZWFkZXIvZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUuZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gXCItLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcblwiO1xuICAgICAgICBrZXkgKz0gSlNFbmNyeXB0UlNBS2V5LndvcmR3cmFwKHRoaXMuZ2V0UHVibGljQmFzZUtleUI2NCgpKSArIFwiXFxuXCI7XG4gICAgICAgIGtleSArPSBcIi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLVwiO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgbmVjZXNzYXJ5IHBhcmFtZXRlcnMgdG8gcG9wdWxhdGUgdGhlIHJzYSBtb2R1bHVzXG4gICAgICogYW5kIHB1YmxpYyBleHBvbmVudCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1heSBjb250YWluIHRoZSB0d28gcHVibGljIGtleVxuICAgICAqIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIGJvdGggdGhlIG1vZHVsdXMgYW5kIHRoZSBwdWJsaWMgZXhwb25lbnRcbiAgICAgKiBwcm9wZXJ0aWVzIChuIGFuZCBlKVxuICAgICAqIEB0b2RvIGNoZWNrIGZvciB0eXBlcyBvZiBuIGFuZCBlLiBOIHNob3VsZCBiZSBhIHBhcnNlYWJsZSBiaWdJbnQgb2JqZWN0LCBFIHNob3VsZFxuICAgICAqIGJlIGEgcGFyc2VhYmxlIGludGVnZXIgbnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBKU0VuY3J5cHRSU0FLZXkuaGFzUHVibGljS2V5UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICAgICAgcmV0dXJuIChvYmouaGFzT3duUHJvcGVydHkoXCJuXCIpICYmXG4gICAgICAgICAgICBvYmouaGFzT3duUHJvcGVydHkoXCJlXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBvYmplY3QgY29udGFpbnMgQUxMIHRoZSBwYXJhbWV0ZXJzIG9mIGFuIFJTQSBrZXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmo9e31dIC0gQW4gb2JqZWN0IHRoYXQgbWF5IGNvbnRhaW4gbmluZSByc2Ega2V5XG4gICAgICogcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgY29udGFpbnMgYWxsIHRoZSBwYXJhbWV0ZXJzIG5lZWRlZFxuICAgICAqIEB0b2RvIGNoZWNrIGZvciB0eXBlcyBvZiB0aGUgcGFyYW1ldGVycyBhbGwgdGhlIHBhcmFtZXRlcnMgYnV0IHRoZSBwdWJsaWMgZXhwb25lbnRcbiAgICAgKiBzaG91bGQgYmUgcGFyc2VhYmxlIGJpZ2ludCBvYmplY3RzLCB0aGUgcHVibGljIGV4cG9uZW50IHNob3VsZCBiZSBhIHBhcnNlYWJsZSBpbnRlZ2VyIG51bWJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSlNFbmNyeXB0UlNBS2V5Lmhhc1ByaXZhdGVLZXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgb2JqID0gb2JqIHx8IHt9O1xuICAgICAgICByZXR1cm4gKG9iai5oYXNPd25Qcm9wZXJ0eShcIm5cIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImVcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImRcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcInBcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcInFcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImRtcDFcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImRtcTFcIikgJiZcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShcImNvZWZmXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBwcm9wZXJ0aWVzIG9mIG9iaiBpbiB0aGUgY3VycmVudCByc2Egb2JqZWN0LiBPYmogc2hvdWxkIEFUIExFQVNUXG4gICAgICogaW5jbHVkZSB0aGUgbW9kdWx1cyBhbmQgcHVibGljIGV4cG9uZW50IChuLCBlKSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IGNvbnRhaW5pbmcgcnNhIHBhcmFtZXRlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEpTRW5jcnlwdFJTQUtleS5wcm90b3R5cGUucGFyc2VQcm9wZXJ0aWVzRnJvbSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdGhpcy5uID0gb2JqLm47XG4gICAgICAgIHRoaXMuZSA9IG9iai5lO1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KFwiZFwiKSkge1xuICAgICAgICAgICAgdGhpcy5kID0gb2JqLmQ7XG4gICAgICAgICAgICB0aGlzLnAgPSBvYmoucDtcbiAgICAgICAgICAgIHRoaXMucSA9IG9iai5xO1xuICAgICAgICAgICAgdGhpcy5kbXAxID0gb2JqLmRtcDE7XG4gICAgICAgICAgICB0aGlzLmRtcTEgPSBvYmouZG1xMTtcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBvYmouY29lZmY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU0VuY3J5cHRSU0FLZXk7XG59KFJTQUtleSkpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMgPSB7fV0gLSBBbiBvYmplY3QgdG8gY3VzdG9taXplIEpTRW5jcnlwdCBiZWhhdmlvdXJcbiAqIHBvc3NpYmxlIHBhcmFtZXRlcnMgYXJlOlxuICogLSBkZWZhdWx0X2tleV9zaXplICAgICAgICB7bnVtYmVyfSAgZGVmYXVsdDogMTAyNCB0aGUga2V5IHNpemUgaW4gYml0XG4gKiAtIGRlZmF1bHRfcHVibGljX2V4cG9uZW50IHtzdHJpbmd9ICBkZWZhdWx0OiAnMDEwMDAxJyB0aGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBleHBvbmVudFxuICogLSBsb2cgICAgICAgICAgICAgICAgICAgICB7Ym9vbGVhbn0gZGVmYXVsdDogZmFsc2Ugd2hldGhlciBsb2cgd2Fybi9lcnJvciBvciBub3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSlNFbmNyeXB0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTRW5jcnlwdChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmRlZmF1bHRfa2V5X3NpemUgPSBwYXJzZUludChvcHRpb25zLmRlZmF1bHRfa2V5X3NpemUsIDEwKSB8fCAxMDI0O1xuICAgICAgICB0aGlzLmRlZmF1bHRfcHVibGljX2V4cG9uZW50ID0gb3B0aW9ucy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCB8fCBcIjAxMDAwMVwiOyAvLyA2NTUzNyBkZWZhdWx0IG9wZW5zc2wgcHVibGljIGV4cG9uZW50IGZvciByc2Ega2V5IHR5cGVcbiAgICAgICAgdGhpcy5sb2cgPSBvcHRpb25zLmxvZyB8fCBmYWxzZTtcbiAgICAgICAgLy8gVGhlIHByaXZhdGUgYW5kIHB1YmxpYyBrZXkuXG4gICAgICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHNldCB0aGUgcnNhIGtleSBwYXJhbWV0ZXIgKG9uZSBtZXRob2QgaXMgZW5vdWdoIHRvIHNldCBib3RoIHRoZSBwdWJsaWNcbiAgICAgKiBhbmQgdGhlIHByaXZhdGUga2V5LCBzaW5jZSB0aGUgcHJpdmF0ZSBrZXkgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgcGFyYW1lbnRlcnMpXG4gICAgICogTG9nIGEgd2FybmluZyBpZiBsb2dzIGFyZSBlbmFibGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXkgdGhlIHBlbSBlbmNvZGVkIHN0cmluZyBvciBhbiBvYmplY3QgKHdpdGggb3Igd2l0aG91dCBoZWFkZXIvZm9vdGVyKVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNldEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nICYmIHRoaXMua2V5KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBIGtleSB3YXMgYWxyZWFkeSBzZXQsIG92ZXJyaWRpbmcgZXhpc3RpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5ID0gbmV3IEpTRW5jcnlwdFJTQUtleShrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBzZXRLZXksIGZvciBhcGkgY29tcGF0aWJpbGl0eVxuICAgICAqIEBzZWUgc2V0S2V5XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChwcml2a2V5KSB7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUga2V5LlxuICAgICAgICB0aGlzLnNldEtleShwcml2a2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3Igc2V0S2V5LCBmb3IgYXBpIGNvbXBhdGliaWxpdHlcbiAgICAgKiBAc2VlIHNldEtleVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnNldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChwdWJrZXkpIHtcbiAgICAgICAgLy8gU2V0cyB0aGUgcHVibGljIGtleS5cbiAgICAgICAgdGhpcy5zZXRLZXkocHVia2V5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3IgUlNBS2V5IG9iamVjdCdzIGRlY3J5cHQsIGRlY3J5cHQgdGhlIHN0cmluZyB1c2luZyB0aGUgcHJpdmF0ZVxuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHJzYSBrZXkgb2JqZWN0LiBOb3RlIHRoYXQgaWYgdGhlIG9iamVjdCB3YXMgbm90IHNldCB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBvbiB0aGUgZmx5IChieSB0aGUgZ2V0S2V5IG1ldGhvZCkgdXNpbmcgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIGluIHRoZSBKU0VuY3J5cHQgY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIGJhc2U2NCBlbmNvZGVkIGNyeXB0ZWQgc3RyaW5nIHRvIGRlY3J5cHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkZWNyeXB0ZWQgc3RyaW5nXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBkZWNyeXB0ZWQgc3RyaW5nLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZGVjcnlwdChiNjR0b2hleChzdHIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJveHkgbWV0aG9kIGZvciBSU0FLZXkgb2JqZWN0J3MgZW5jcnlwdCwgZW5jcnlwdCB0aGUgc3RyaW5nIHVzaW5nIHRoZSBwdWJsaWNcbiAgICAgKiBjb21wb25lbnRzIG9mIHRoZSByc2Ega2V5IG9iamVjdC4gTm90ZSB0aGF0IGlmIHRoZSBvYmplY3Qgd2FzIG5vdCBzZXQgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogb24gdGhlIGZseSAoYnkgdGhlIGdldEtleSBtZXRob2QpIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBpbiB0aGUgSlNFbmNyeXB0IGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVuY3J5cHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlbmNyeXB0ZWQgc3RyaW5nIGVuY29kZWQgaW4gYmFzZTY0XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBlbmNyeXB0ZWQgc3RyaW5nLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhleDJiNjQodGhpcy5nZXRLZXkoKS5lbmNyeXB0KHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm94eSBtZXRob2QgZm9yIFJTQUtleSBvYmplY3QncyBzaWduLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBzaWduXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnZXN0TWV0aG9kIGhhc2ggbWV0aG9kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRpZ2VzdE5hbWUgdGhlIG5hbWUgb2YgdGhlIGhhc2ggYWxnb3JpdGhtXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgc2lnbmF0dXJlIGVuY29kZWQgaW4gYmFzZTY0XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIChzdHIsIGRpZ2VzdE1ldGhvZCwgZGlnZXN0TmFtZSkge1xuICAgICAgICAvLyByZXR1cm4gdGhlIFJTQSBzaWduYXR1cmUgb2YgJ3N0cicgaW4gJ2hleCcgZm9ybWF0LlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhleDJiNjQodGhpcy5nZXRLZXkoKS5zaWduKHN0ciwgZGlnZXN0TWV0aG9kLCBkaWdlc3ROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFByb3h5IG1ldGhvZCBmb3IgUlNBS2V5IG9iamVjdCdzIHZlcmlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdmVyaWZ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIGVuY29kZWQgaW4gYmFzZTY0IHRvIGNvbXBhcmUgdGhlIHN0cmluZyB0b1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRpZ2VzdE1ldGhvZCBoYXNoIG1ldGhvZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGRhdGEgYW5kIHNpZ25hdHVyZSBtYXRjaFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChzdHIsIHNpZ25hdHVyZSwgZGlnZXN0TWV0aG9kKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgZGVjcnlwdGVkICdkaWdlc3QnIG9mIHRoZSBzaWduYXR1cmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS52ZXJpZnkoc3RyLCBiNjR0b2hleChzaWduYXR1cmUpLCBkaWdlc3RNZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXR0ZXIgZm9yIHRoZSBjdXJyZW50IEpTRW5jcnlwdFJTQUtleSBvYmplY3QuIElmIGl0IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IG9iamVjdFxuICAgICAqIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWRcbiAgICAgKiBAcGFyYW0ge2NhbGxiYWNrfSBbY2JdIHRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgaWYgd2Ugd2FudCB0aGUga2V5IHRvIGJlIGdlbmVyYXRlZFxuICAgICAqIGluIGFuIGFzeW5jIGZhc2hpb25cbiAgICAgKiBAcmV0dXJucyB7SlNFbmNyeXB0UlNBS2V5fSB0aGUgSlNFbmNyeXB0UlNBS2V5IG9iamVjdFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSBuZXcgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIC8vIEdldCBhIG5ldyBwcml2YXRlIGtleS5cbiAgICAgICAgICAgIHRoaXMua2V5ID0gbmV3IEpTRW5jcnlwdFJTQUtleSgpO1xuICAgICAgICAgICAgaWYgKGNiICYmIHt9LnRvU3RyaW5nLmNhbGwoY2IpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleS5nZW5lcmF0ZUFzeW5jKHRoaXMuZGVmYXVsdF9rZXlfc2l6ZSwgdGhpcy5kZWZhdWx0X3B1YmxpY19leHBvbmVudCwgY2IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBrZXkuXG4gICAgICAgICAgICB0aGlzLmtleS5nZW5lcmF0ZSh0aGlzLmRlZmF1bHRfa2V5X3NpemUsIHRoaXMuZGVmYXVsdF9wdWJsaWNfZXhwb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleVxuICAgICAqIElmIHRoZSBrZXkgZG9lc24ndCBleGlzdHMgYSBuZXcga2V5IHdpbGwgYmUgY3JlYXRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleSBXSVRIIGhlYWRlciBhbmQgZm9vdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIEpTRW5jcnlwdC5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQcml2YXRlS2V5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBJZiB0aGUga2V5IGRvZXNuJ3QgZXhpc3RzIGEgbmV3IGtleSB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBwZW0gZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkgV0lUSE9VVCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldFByaXZhdGVLZXlCNjQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJpdmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGtleS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KCkuZ2V0UHJpdmF0ZUJhc2VLZXlCNjQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgV0lUSCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQdWJsaWNLZXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBlbSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAgICogSWYgdGhlIGtleSBkb2Vzbid0IGV4aXN0cyBhIG5ldyBrZXkgd2lsbCBiZSBjcmVhdGVkXG4gICAgICogQHJldHVybnMge3N0cmluZ30gcGVtIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgV0lUSE9VVCBoZWFkZXIgYW5kIGZvb3RlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBKU0VuY3J5cHQucHJvdG90eXBlLmdldFB1YmxpY0tleUI2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBwcml2YXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMga2V5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRLZXkoKS5nZXRQdWJsaWNCYXNlS2V5QjY0KCk7XG4gICAgfTtcbiAgICBKU0VuY3J5cHQudmVyc2lvbiA9IFwiMy4wLjAtcmMuMVwiO1xuICAgIHJldHVybiBKU0VuY3J5cHQ7XG59KCkpO1xuXG53aW5kb3cuSlNFbmNyeXB0ID0gSlNFbmNyeXB0O1xuXG5leHBvcnRzLkpTRW5jcnlwdCA9IEpTRW5jcnlwdDtcbmV4cG9ydHMuZGVmYXVsdCA9IEpTRW5jcnlwdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG5cbi8vIFRoaXMgd2lsbCBiZSBhIHByb3BlciBpdGVyYWJsZSAnTWFwJyBpbiBlbmdpbmVzIHRoYXQgc3VwcG9ydCBpdCxcbi8vIG9yIGEgZmFrZXktZmFrZSBQc2V1ZG9NYXAgaW4gb2xkZXIgdmVyc2lvbnMuXG52YXIgTWFwID0gcmVxdWlyZSgncHNldWRvbWFwJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbnZhciBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbi8vIHVzZSBzeW1ib2xzIGlmIHBvc3NpYmxlLCBvdGhlcndpc2UganVzdCBfcHJvcHNcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb2Nlc3MuZW52Ll9ub2RlTFJVQ2FjaGVGb3JjZU5vU3ltYm9sICE9PSAnMSdcbnZhciBtYWtlU3ltYm9sXG5pZiAoaGFzU3ltYm9sKSB7XG4gIG1ha2VTeW1ib2wgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIFN5bWJvbChrZXkpXG4gIH1cbn0gZWxzZSB7XG4gIG1ha2VTeW1ib2wgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICdfJyArIGtleVxuICB9XG59XG5cbnZhciBNQVggPSBtYWtlU3ltYm9sKCdtYXgnKVxudmFyIExFTkdUSCA9IG1ha2VTeW1ib2woJ2xlbmd0aCcpXG52YXIgTEVOR1RIX0NBTENVTEFUT1IgPSBtYWtlU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbnZhciBBTExPV19TVEFMRSA9IG1ha2VTeW1ib2woJ2FsbG93U3RhbGUnKVxudmFyIE1BWF9BR0UgPSBtYWtlU3ltYm9sKCdtYXhBZ2UnKVxudmFyIERJU1BPU0UgPSBtYWtlU3ltYm9sKCdkaXNwb3NlJylcbnZhciBOT19ESVNQT1NFX09OX1NFVCA9IG1ha2VTeW1ib2woJ25vRGlzcG9zZU9uU2V0JylcbnZhciBMUlVfTElTVCA9IG1ha2VTeW1ib2woJ2xydUxpc3QnKVxudmFyIENBQ0hFID0gbWFrZVN5bWJvbCgnY2FjaGUnKVxuXG5mdW5jdGlvbiBuYWl2ZUxlbmd0aCAoKSB7IHJldHVybiAxIH1cblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5mdW5jdGlvbiBMUlVDYWNoZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVQ2FjaGUpKSB7XG4gICAgcmV0dXJuIG5ldyBMUlVDYWNoZShvcHRpb25zKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHZhciBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heFxuICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gIGlmICghbWF4IHx8XG4gICAgICAhKHR5cGVvZiBtYXggPT09ICdudW1iZXInKSB8fFxuICAgICAgbWF4IDw9IDApIHtcbiAgICB0aGlzW01BWF0gPSBJbmZpbml0eVxuICB9XG5cbiAgdmFyIGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgaWYgKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGxjID0gbmFpdmVMZW5ndGhcbiAgfVxuICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxjXG5cbiAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwXG4gIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gIHRoaXMucmVzZXQoKVxufVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ21heCcsIHtcbiAgc2V0OiBmdW5jdGlvbiAobUwpIHtcbiAgICBpZiAoIW1MIHx8ICEodHlwZW9mIG1MID09PSAnbnVtYmVyJykgfHwgbUwgPD0gMCkge1xuICAgICAgbUwgPSBJbmZpbml0eVxuICAgIH1cbiAgICB0aGlzW01BWF0gPSBtTFxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYXVxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnYWxsb3dTdGFsZScsIHtcbiAgc2V0OiBmdW5jdGlvbiAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbWF4QWdlJywge1xuICBzZXQ6IGZ1bmN0aW9uIChtQSkge1xuICAgIGlmICghbUEgfHwgISh0eXBlb2YgbUEgPT09ICdudW1iZXInKSB8fCBtQSA8IDApIHtcbiAgICAgIG1BID0gMFxuICAgIH1cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2xlbmd0aENhbGN1bGF0b3InLCB7XG4gIHNldDogZnVuY3Rpb24gKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuICAgIH1cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSlcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnaXRlbUNvdW50Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgdmFyIHByZXYgPSB3YWxrZXIucHJldlxuICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgIHdhbGtlciA9IHByZXZcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RlcCAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSB7XG4gIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSB7XG4gICAgICBoaXQgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cbiAgaWYgKGhpdCkge1xuICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZilcbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICB2YXIgbmV4dCA9IHdhbGtlci5uZXh0XG4gICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgd2Fsa2VyID0gbmV4dFxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrLmtleVxuICB9LCB0aGlzKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrLnZhbHVlXG4gIH0sIHRoaXMpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXNbRElTUE9TRV0gJiZcbiAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgIHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChmdW5jdGlvbiAoaGl0KSB7XG4gICAgaWYgKCFpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9XG4gICAgfVxuICB9LCB0aGlzKS50b0FycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgcmV0dXJuIGhcbiAgfSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXBMcnUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAobiwgb3B0cykge1xuICB2YXIgc3RyID0gJ0xSVUNhY2hlIHsnXG4gIHZhciBleHRyYXMgPSBmYWxzZVxuXG4gIHZhciBhcyA9IHRoaXNbQUxMT1dfU1RBTEVdXG4gIGlmIChhcykge1xuICAgIHN0ciArPSAnXFxuICBhbGxvd1N0YWxlOiB0cnVlJ1xuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBtYXggPSB0aGlzW01BWF1cbiAgaWYgKG1heCAmJiBtYXggIT09IEluZmluaXR5KSB7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgc3RyICs9ICcsJ1xuICAgIH1cbiAgICBzdHIgKz0gJ1xcbiAgbWF4OiAnICsgdXRpbC5pbnNwZWN0KG1heCwgb3B0cylcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgbWF4QWdlID0gdGhpc1tNQVhfQUdFXVxuICBpZiAobWF4QWdlKSB7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgc3RyICs9ICcsJ1xuICAgIH1cbiAgICBzdHIgKz0gJ1xcbiAgbWF4QWdlOiAnICsgdXRpbC5pbnNwZWN0KG1heEFnZSwgb3B0cylcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgbGMgPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXVxuICBpZiAobGMgJiYgbGMgIT09IG5haXZlTGVuZ3RoKSB7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgc3RyICs9ICcsJ1xuICAgIH1cbiAgICBzdHIgKz0gJ1xcbiAgbGVuZ3RoOiAnICsgdXRpbC5pbnNwZWN0KHRoaXNbTEVOR1RIXSwgb3B0cylcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgZGlkRmlyc3QgPSBmYWxzZVxuICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGRpZEZpcnN0KSB7XG4gICAgICBzdHIgKz0gJyxcXG4gICdcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4dHJhcykge1xuICAgICAgICBzdHIgKz0gJyxcXG4nXG4gICAgICB9XG4gICAgICBkaWRGaXJzdCA9IHRydWVcbiAgICAgIHN0ciArPSAnXFxuICAnXG4gICAgfVxuICAgIHZhciBrZXkgPSB1dGlsLmluc3BlY3QoaXRlbS5rZXkpLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4gICcpXG4gICAgdmFyIHZhbCA9IHsgdmFsdWU6IGl0ZW0udmFsdWUgfVxuICAgIGlmIChpdGVtLm1heEFnZSAhPT0gbWF4QWdlKSB7XG4gICAgICB2YWwubWF4QWdlID0gaXRlbS5tYXhBZ2VcbiAgICB9XG4gICAgaWYgKGxjICE9PSBuYWl2ZUxlbmd0aCkge1xuICAgICAgdmFsLmxlbmd0aCA9IGl0ZW0ubGVuZ3RoXG4gICAgfVxuICAgIGlmIChpc1N0YWxlKHRoaXMsIGl0ZW0pKSB7XG4gICAgICB2YWwuc3RhbGUgPSB0cnVlXG4gICAgfVxuXG4gICAgdmFsID0gdXRpbC5pbnNwZWN0KHZhbCwgb3B0cykuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJylcbiAgICBzdHIgKz0ga2V5ICsgJyA9PiAnICsgdmFsXG4gIH0pXG5cbiAgaWYgKGRpZEZpcnN0IHx8IGV4dHJhcykge1xuICAgIHN0ciArPSAnXFxuJ1xuICB9XG4gIHN0ciArPSAnfSdcblxuICByZXR1cm4gc3RyXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgdmFyIG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gIHZhciBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gIGlmICh0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSlcbiAgICB2YXIgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKSB7XG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGl0ZW0ubm93ID0gbm93XG4gICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICBpdGVtLmxlbmd0aCA9IGxlblxuICAgIHRoaXMuZ2V0KGtleSlcbiAgICB0cmltKHRoaXMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSlcblxuICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpXG4gIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gIHRyaW0odGhpcylcbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gIHZhciBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICBpZiAoIW5vZGUpIHJldHVybiBudWxsXG4gIGRlbCh0aGlzLCBub2RlKVxuICByZXR1cm4gbm9kZS52YWx1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xuICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGFycikge1xuICAvLyByZXNldCB0aGUgY2FjaGVcbiAgdGhpcy5yZXNldCgpXG5cbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgZm9yICh2YXIgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgIHZhciBoaXQgPSBhcnJbbF1cbiAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgIGlmIChleHBpcmVzQXQgPT09IDApIHtcbiAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXNbQ0FDSEVdLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBnZXQoc2VsZiwga2V5LCBmYWxzZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0IChzZWxmLCBrZXksIGRvVXNlKSB7XG4gIHZhciBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGl0KSBoaXQgPSBoaXQudmFsdWVcbiAgfVxuICByZXR1cm4gaGl0XG59XG5cbmZ1bmN0aW9uIGlzU3RhbGUgKHNlbGYsIGhpdCkge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIHN0YWxlID0gZmFsc2VcbiAgdmFyIGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICBpZiAoaGl0Lm1heEFnZSkge1xuICAgIHN0YWxlID0gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgfSBlbHNlIHtcbiAgICBzdGFsZSA9IHNlbGZbTUFYX0FHRV0gJiYgKGRpZmYgPiBzZWxmW01BWF9BR0VdKVxuICB9XG4gIHJldHVybiBzdGFsZVxufVxuXG5mdW5jdGlvbiB0cmltIChzZWxmKSB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKHZhciB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsO1xuICAgICAgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgdmFyIHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVsIChzZWxmLCBub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoc2VsZltESVNQT1NFXSkge1xuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgfVxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbi8vIGNsYXNzeSwgc2luY2UgVjggcHJlZmVycyBwcmVkaWN0YWJsZSBvYmplY3RzLlxuZnVuY3Rpb24gRW50cnkgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgdGhpcy5rZXkgPSBrZXlcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMubm93ID0gbm93XG4gIHRoaXMubWF4QWdlID0gbWF4QWdlIHx8IDBcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIFByb21pc2VXaW5kb3dcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWVyY2llci9wcm9taXNlLXdpbmRvd1xuICogQGlnbm9yZVxuICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgcm9vdCA9IHdpbmRvdyxcbiAgICAgIHByb3RvdHlwZSxcbiAgICAgIGh0bWwgPSByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAvKipcbiAgICogTWVyZ2UgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgbWVyZ2UoIHRhcmdldCBbLCBvYmplY3QxIF0gWywgb2JqZWN0TiBdIClcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgQW4gb2JqZWN0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBuZXcgcHJvcGVydGllcyBpZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsIG9iamVjdHMgYXJlIHBhc3NlZCBpbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdDEgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0TiBBbiBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW4uXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZmlyc3Qgb2JqZWN0LlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIGV4dGVuZGVkID0gYXJndW1lbnRzWzBdLCBrZXksIGk7XG4gICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGV4dGVuZGVkW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgcHNldWRvLXVuaXF1ZSBTdHJpbmdcbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIHBzZXVkby11bmlxdWUgc3RyaW5nIHByZWZpeGVkIHdpdGggdGhlIGdpdmVuIHByZWZpeCwgaWYgYW55LlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZVN0cmluZyhwcmVmaXgpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBcIi1cIiArIE1hdGguZmxvb3IoMTBlMTIgKiBNYXRoLnJhbmRvbSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHJvbWlzZVdpbmRvdyBvYmplY3RcbiAgICpcbiAgICogRHVyaW5nIHRoZSBsaWZlY3ljbGUgb2YgdGhpcyBvYmplY3QsIHBvcHVwIHdpbmRvd3MgY2FuIGJlIG9wZW5lZCwgY2xvc2VkLFxuICAgKiBhbmQgcmVvcGVuZWQgYWdhaW4uIEhvd2V2ZXIsIGl0J1xuICAgKlxuICAgKiBJbnN0YW5jaWF0aW5nIHRoaXMgcHJvdG90eXBlIGRvZXMgbm90IGltbWVkaWF0ZWx5IG9wZW5zIGEgbmV3IHBvcHVwIHdpbmRvdy5cbiAgICogVG8gb3BlbiB0aGUgd2luZG93LCB1c2UgYG9wZW4oKWAgb24gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICB1cmkgICAgICAgICAgICAgICAgICAgIERlc3RpbmF0aW9uIFVSSVxuICAgKiBAcGFyYW0ge09iamVjdH0gICBjb25maWcgICAgICAgICAgICAgICAgIENvbmZpZ3VyYXRpb24gb2JqZWN0LiBTZWUgZGVzY3JpcHRpb24gYmVsb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvbmZpZy53aWR0aCAgICAgICAgICAgV2lkdGggb2YgdGhlIHBvcHVwIHdpbmRvdy4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZG9jdW1lbnQgd2lkdGguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSAgIGNvbmZpZy5oZWlnaHQgICAgICAgICAgSGVpZ2h0IG9mIHRoZSBwb3B1cCB3aW5kb3cuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50IGhlaWdodC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29uZmlnLnByb21pc2VQcm92aWRlciBQcm9taXNlIHByb3ZpZGVyLiBTaG91bGQgcmV0dXJuIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgMyBmaWVsZHM6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcHJvbWlzZWAge1Byb21pc2V9ICBhIG5ldyBQcm9taXNlIG9iamVjdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYHJlc29sdmVgIHtGdW5jdGlvbn0gdGhlIG1ldGhvZCB0byByZXNvbHZlIHRoZSBnaXZlbiBQcm9taXNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBgcmVqZWN0YCAge0Z1bmN0aW9ufSB0aGUgbWV0aG9kIHRvIHJlamVjdCB0aGUgZ2l2ZW4gUHJvbWlzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcub25Qb3N0TWVzc2FnZSAgIEhhbmRsZXIgZm9yIHJlY2VpdmluZyBhIHBvc3RNZXNzYWdlIGZyb20gdGhlIG9wZW5lZCB3aW5kb3cuIERlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiByZXNvbHZlcyB0aGUgcHJvbWlzZSB3aXRoIHRoZSBkYXRhIHBhc3NlZCBpbiB0aGUgcG9zdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsIGV4Y2VwdCBpZiB0aGlzIGRhdGEgY29udGFpbnMgYW4gYGVycm9yYCBmaWVsZC4gSW4gdGhpcyBjYXNlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHJlamVjdHMgdGhlIFByb21pc2Ugd2l0aCB0aGUgdmFsdWUgb2YgdGhhdCBmaWVsZC4gSW4gYWxsIGNhc2VzLCBjbG9zZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgcG9wdXAgd2luZG93LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcub25Qb3N0TWVzc2FnZS5ldmVudCBFdmVudCBUaGUgcG9zdE1lc3NhZ2UgZXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9ICAgY29uZmlnLndhdGNoZXJEZWxheSAgICBUaGVyZSBpcyBubyBwcm9ncmFtbWF0aWMgd2F5IG9mIGtub3dpbmcgd2hlbiBhIHBvcHVwIHdpbmRvdyBpcyBjbG9zZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZWl0aGVyIG1hbnVhbGx5IG9yIHByb2dyYW1hdGljYWxseSkuIEZvciB0aGlzIHJlYXNvbiwgZXZlcnkgdGltZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2VXaW5kb3cgb3BlbnMgYSBwb3B1cCwgYSBuZXcgd2F0Y2hlciBpcyBjcmVhdGVkLiBUaGUgd2F0Y2hlciBjaGVja3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWd1bGFybHkgaWYgdGhlIHdpbmRvdyBpcyBzdGlsbCBvcGVuLiBUaGlzIHZhbHVlIGRlZmluZXMgYXQgd2hpY2hcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCB0aGlzIGNoZWNrIGlzIGRvbmUuIERlZmF1bHRzIHRvIDEwMG1zLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gICBjb25maWcud2luZG93TmFtZSAgICAgIE5hbWUgdG8gYmUgZ2ludmVuIHRvIHRoZSBwb3B1cCB3aW5kb3cuIFNlZSBgd2luZG93Lm9wZW5gIHJlZmVyZW5jZXMgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy4gSWYgYG51bGxgLCBhIHJhbmRvbSBuYW1lIGlzIGdlbmVyYXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9ICAgY29uZmlnLndpbmRvdyAgICAgICAgICBPYmplY3QgY29udGFpbmluZyB3aW5kb3cgY29uZmlndXJhdGlvbiBzZXR0aW5ncy4gU2Nyb2xsYmFycyBhcmUgZW5hYmxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IGRlZmF1bHQuIEFsbCBgd2luZG93Lm9wZW5gIHB0aW9ucyBhcmUgYWNjZXB0ZWQsIGJ1dCBwbGVhc2Ugbm90ZSB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFueSBvZiB0aGVtIGhhdmUgbm8gZWZmZWN0IGluIG1vc3QgbW9kZXJuIGJyb3dzZXJzLiBTZWVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L29wZW4gZm9yIG1vcmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcub25DbG9zZSAgICAgICAgIEZ1bmN0aW9uIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgcG9wdXAgaXMgYmVpbmcgY2xvc2VkIChlaXRoZXIgYWZ0ZXIgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3QgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCwgb3Igd2luZG93IGhhcyBiZWVuIGNsb3NlZCBieSB1c2VyLCBvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAuY2xvc2UoKWAgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC4gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjbG9zZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9wdXAgd2luZG93IGJ5IGNhbGxpbmcgYHRoaXMuX3dpbmRvdy5jbG9zZSgpYCkuXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBjb25maWcub3JpZ2luUmVnZXhwICAgICAgUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyB0aGUgb3JpZ2luIHBhcnQgb2YgYW4gVVJJLiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBuZXcgUmVnRXhwKCdeW146Lz9dKzovL1teL10qJylgLiBJZiBkb2Vzbid0IG1hdGNoIChleDogcmVsYXRpdmUgVVJJcyksXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlIGBsb2NhdGlvbi5vcmlnaW5gLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFByb21pc2VXaW5kb3codXJpLCBjb25maWcpIHtcbiAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICB0aGlzLmNvbmZpZyA9IGV4dGVuZCh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuICAgIHRoaXMuY29uZmlnLndpbmRvd05hbWUgPSB0aGlzLmNvbmZpZy53aW5kb3dOYW1lIHx8IGdlbmVyYXRlVW5pcXVlU3RyaW5nKCdwcm9taXNlLXdpbmRvdy0nKTtcbiAgICB0aGlzLl9vblBvc3RNZXNzYWdlID0gdGhpcy5fb25Qb3N0TWVzc2FnZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIFByb21pc2UgcHJvdmlkZXIgZnJvbSBhIFByb21pc2UvQSsgY29uc3RydWN0b3IgdG8gYmUgdXNlZCB3aXRoXG4gICAqIGBjb25maWcucHJvbWlzZVByb3ZpZGVyYC5cbiAgICpcbiAgICogICAgIG5ldyBQcm9taXNlV2luZG93KC4uLiwge1xuICAgKiAgICAgICAuLi4sXG4gICAqICAgICAgIHByb21pc2VQcm92aWRlcjogUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihNeUN1c3RvbVByb21pc2UpXG4gICAqICAgICB9KTtcbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IEN1c3RvbVByb21pc2UgUHJvbWlzZS9BKyBjb250cnVjdG9yXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIGEgcHJvbWlzZSBwcm92aWRlclxuICAgKiBAc3RhdGljXG4gICAqL1xuICBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyID0gZnVuY3Rpb24gZ2V0QVBsdXNQcm9taXNlUHJvdmlkZXIoQ3VzdG9tUHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwcm9taXNlUHJvdmlkZXIoKSB7XG4gICAgICB2YXIgbW9kdWxlID0ge307XG4gICAgICBtb2R1bGUucHJvbWlzZSA9IG5ldyBDdXN0b21Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBtb2R1bGUucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIG1vZHVsZS5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvcjpcbiAgICpcbiAgICogICAgIG5ldyBQcm9taXNlV2luZG93KHVyaSwgY29uZmlnKS5vcGVuKClcbiAgICpcbiAgICogVXNlIHRoaXMgbWV0aG9kIG9ubHkgaWYgeW91IG5ldmVyIG5lZWQgdG8gY2xvc2UgdGhlIHdpbmRvdyBwcm9ncmFtYXRpY2FsbHkuXG4gICAqIElmIHlvdSBkbywgcGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBjbGFzc2ljIHdheTpcbiAgICpcbiAgICogICAgIHZhciB3ID0gbmV3IFByb21pc2VXaW5kb3codXJpLCBjb25maWcpXG4gICAqICAgICB3Lm9wZW4oKTtcbiAgICogICAgIC8vIC4uLlxuICAgKiAgICAgdy5jbG9zZSgpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgUHJvbWlzZSBlcXVpdmFsZW50IHRvIHRoZSBvbmUgcmV0dXJuZWQgYnkgYG9wZW4oKWBcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgUHJvbWlzZVdpbmRvdy5vcGVuID0gZnVuY3Rpb24gb3Blbih1cmksIGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVdpbmRvdyh1cmksIGNvbmZpZykub3BlbigpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZyA9IHtcbiAgICB3aWR0aDogaHRtbC5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGh0bWwuY2xpZW50SGVpZ2h0LFxuICAgIHdpbmRvdzoge1xuICAgICAgc2Nyb2xsYmFyczogdHJ1ZVxuICAgIH0sXG4gICAgd2F0Y2hlckRlbGF5OiAxMDAsXG4gICAgcHJvbWlzZVByb3ZpZGVyOiBudWxsLFxuICAgIG9uUG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIG9uUG9zdE1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLmVycm9yKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChldmVudC5kYXRhLmVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoZXZlbnQuZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSxcbiAgICB3aW5kb3dOYW1lOiBudWxsLFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fd2luZG93LmNsb3NlKCk7XG4gICAgfSxcbiAgICBvcmlnaW5SZWdleHA6IG5ldyBSZWdFeHAoJ15bXjovP10rOi8vW14vXSonKVxuICB9O1xuXG4gIC8vIENvbmZpZ3VyZSBkZWZhdWx0IFByb21pc2UgcHJvdmlkZXIgZnJvbSBjdXJyZW50IGludmlyb25tZW50XG4gIGlmIChyb290LlByb21pc2UpIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihyb290LlByb21pc2UpO1xuICB9XG4gIGVsc2UgaWYgKHJvb3QuUlNWUCkge1xuICAgIFByb21pc2VXaW5kb3cuZGVmYXVsdENvbmZpZy5wcm9taXNlUHJvdmlkZXIgPSBQcm9taXNlV2luZG93LmdldEFQbHVzUHJvbWlzZVByb3ZpZGVyKHJvb3QuUlNWUC5Qcm9taXNlKTtcbiAgfVxuICBlbHNlIGlmIChyb290LlEpIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gUHJvbWlzZVdpbmRvdy5nZXRBUGx1c1Byb21pc2VQcm92aWRlcihyb290LlEuUHJvbWlzZSk7XG4gIH1cbiAgZWxzZSBpZiAocm9vdC5qUXVlcnkpIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gZnVuY3Rpb24gcHJvbWlzZVByb3ZpZGVyKCkge1xuICAgICAgdmFyIGRlZmVycmVkID0gcm9vdC5qUXVlcnkuRGVmZXJyZWQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IGRlZmVycmVkLnByb21pc2UoKSxcbiAgICAgICAgcmVzb2x2ZTogZGVmZXJyZWQucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBkZWZlcnJlZC5yZWplY3RcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBQcm9taXNlV2luZG93LmRlZmF1bHRDb25maWcucHJvbWlzZVByb3ZpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJvbWlzZVByb3ZpZGVyIGluIFByb21pc2VXaW5kb3cgY29uZmlndXJhdGlvbicpO1xuICAgIH07XG4gIH1cblxuICBwcm90b3R5cGUgPSBQcm9taXNlV2luZG93LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHZhbHVlIGlzIGEgYm9vbGVhbiwgYGZhbHNlYCBvdGhlcndpc2VcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9pc0Jvb2xlYW4gPSBmdW5jdGlvbiBfaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYSBjb25maWcgdmFsdWUgaW50byBhIHZhbHVlIGNvbXBhdGlibGUgd2l0aCBgd2luZG93Lm9wZW5gLlxuICAgKiBJZiB2YWx1ZSBpcyBhIGJvb2xlYW4sIGNvbnZlcnQgaXQgdG8gJ3llcycgb3IgJ25vJywgb3RoZXJ3aXNlIHNpbXBseVxuICAgKiBjYXN0cyBpdCBpbnRvIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbnZlcnRlZCB2YWx1ZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90b3R5cGUuX3NlcmlhbGl6ZUZlYXR1cmVWYWx1ZSA9IGZ1bmN0aW9uIF9zZXJpYWxpemVGZWF0dXJlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyAneWVzJyA6ICdubyc7XG4gICAgfVxuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxlZnQgYW5kIHRvcCBwb3NpdGlvbiBpbiB0aGUgc2NyZWVuIGZvciBhIHJlY3RhbmdsZSwgdGFraW5nXG4gICAqIGR1YWwtc2NyZWVuIHBvc2l0aW9uIGludG8gYWNjb3VudFxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEByZXR1cm4ge09iamVjdH0gcG9zaXRpb24gQSBuZXcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSwgY2VudGVyZWRcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3NpdGlvbi5sZWZ0IFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlcmVkIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBvc2l0aW9uLnRvcCBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXJlZCByZWN0YW5nbGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBwb3NpdGlvbi53aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNlbnRlcmVkIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBvc2l0aW9uLmhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBjZW50ZXJlZCByZWN0YW5nbGVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9nZXRDZW50ZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gX2dldENlbnRlcmVkUG9zaXRpb24od2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBkdWFsU2NyZWVuTGVmdCA9IHJvb3Quc2NyZWVuTGVmdCAhPT0gdW5kZWZpbmVkID8gcm9vdC5zY3JlZW5MZWZ0IDogc2NyZWVuLmxlZnQsXG4gICAgICAgIGR1YWxTY3JlZW5Ub3AgPSByb290LnNjcmVlblRvcCAhPT0gdW5kZWZpbmVkID8gcm9vdC5zY3JlZW5Ub3AgOiBzY3JlZW4udG9wLFxuICAgICAgICB3ID0gcm9vdC5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGggfHwgc2NyZWVuLndpZHRoLFxuICAgICAgICBoID0gcm9vdC5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodCB8fCBzY3JlZW4uaGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6ICh3IC8gMikgLSAod2lkdGggLyAyKSArIGR1YWxTY3JlZW5MZWZ0LFxuICAgICAgdG9wOiAgKGggLyAyKSAtIChoZWlnaHQgLyAyKSArIGR1YWxTY3JlZW5Ub3AsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB3aW5kb3cgZmVhdHVyZXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgd2luZG93IGZlYXR1cmVzIGNvbXBhdGlibGUgd2l0aCBgd2luZG93Lm9wZW5gXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiBfZ2V0RmVhdHVyZXMoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuX2dldENlbnRlcmVkUG9zaXRpb24odGhpcy5jb25maWcud2lkdGgsIHRoaXMuY29uZmlnLmhlaWdodCk7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29uZmlnLndpbmRvdykge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLndpbmRvdy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5jb25maWcud2luZG93W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZylcbiAgICAgIC5tYXAoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBrZXkgKyAnPScgKyB0aGlzLl9zZXJpYWxpemVGZWF0dXJlVmFsdWUoa2V5LCBjb25maWdba2V5XSk7IH0uYmluZCh0aGlzKSlcbiAgICAgIC5qb2luKCcsJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUHJvbWlzZSwgdXNpbmcgYGNvbmZpZy5wcm9taXNlUHJvdmlkZXJgLCBhbmQgc2F2ZSByZWplY3QgYW5kXG4gICAqIHJlc29sdmUgbWV0aG9kcyBmb3IgbGF0ZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgdGhlIG5ldyBQcm9taXNlIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBjb25maWd1cmVkXG4gICAqICAgICAgICAgICAgICAgICAgIFByb21pc2UgUHJvdmlkZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fY3JlYXRlUHJvbWlzZSA9IGZ1bmN0aW9uIF9jcmVhdGVQcm9taXNlKCkge1xuICAgIHZhciBtb2R1bGUgPSB0aGlzLmNvbmZpZy5wcm9taXNlUHJvdmlkZXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlID0gbW9kdWxlLnJlc29sdmU7XG4gICAgdGhpcy5fcmVqZWN0ID0gbW9kdWxlLnJlamVjdDtcbiAgICByZXR1cm4gbW9kdWxlLnByb21pc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSB3aW5kb3cgaXMgYWxpdmUgb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB3aW5kb3cgaXMgYWxpdmUsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5faXNXaW5kb3dBbGl2ZSA9IGZ1bmN0aW9uIF9pc1dpbmRvd0FsaXZlKCkge1xuICAgIHJldHVybiB0aGlzLl93aW5kb3cgJiYgIXRoaXMuX3dpbmRvdy5jbG9zZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcG9wdXAgd2luZG93IHdhdGNoZXIuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fc3RhcnRXYXRjaGVyID0gZnVuY3Rpb24gX3N0YXJ0V2F0Y2hlcigpIHtcbiAgICBpZiAodGhpcy5fd2F0Y2hlclJ1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2F0Y2hlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fd2F0Y2hlciA9IHJvb3Quc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuX3dhdGNoZXJSdW5uaW5nICYmICF0aGlzLl9pc1dpbmRvd0FsaXZlKCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5jb25maWcud2F0Y2hlckRlbGF5KTtcbiAgICB0aGlzLl93YXRjaGVyUnVubmluZyA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSBwb3B1cCB3aW5kb3cgd2F0Y2hlci5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdG90eXBlLl9zdG9wV2F0Y2hlciA9IGZ1bmN0aW9uIF9zdG9wV2F0Y2hlcigpIHtcbiAgICBpZiAoIXRoaXMuX3dhdGNoZXJSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhdGNoZXIgaXMgYWxyZWFkeSBzdG9wcGVkJyk7XG4gICAgfVxuICAgIHRoaXMuX3dhdGNoZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgcm9vdC5jbGVhckludGVydmFsKHRoaXMuX3dhdGNoZXIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmb3IgcG9zdCBtZXNzYWdlIGV2ZW50cy4gSWYgYW5kIG9ubHkgb2YgdGhlIGV2ZW50IGhhcyBiZWVuXG4gICAqIGdlbmVyYXRlZCBmcm9tIHRoZSBvcGVuZWQgcG9wdXAgd2luZG93LCBpdCBwcm9wYWdhdGVzIGl0IHRvIHRoZSBjb25maWd1cmVkXG4gICAqIHBvc3QgbWVzc2FnZSBoYW5kbGVyIChgY29uZmlnLm9uUG9zdE1lc3NhZ2VgKS5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIHBvc3RNZXNzYWdlIGV2ZW50XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHByb3RvdHlwZS5fb25Qb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIF9vblBvc3RNZXNzYWdlKGV2ZW50KSB7XG4gICAgdmFyIGV4cGVjdGVkT3JpZ2luTWF0Y2hlcyA9IHRoaXMuY29uZmlnLm9yaWdpblJlZ2V4cC5leGVjKHRoaXMudXJpKTtcbiAgICB2YXIgZXhwZWN0ZWRPcmlnaW4gPSBleHBlY3RlZE9yaWdpbk1hdGNoZXMgJiYgZXhwZWN0ZWRPcmlnaW5NYXRjaGVzWzBdIHx8IGxvY2F0aW9uLm9yaWdpbjtcbiAgICBpZiAodGhpcy5fd2luZG93ID09PSBldmVudC5zb3VyY2UgJiYgZXZlbnQub3JpZ2luID09PSBleHBlY3RlZE9yaWdpbikge1xuICAgICAgdGhpcy5jb25maWcub25Qb3N0TWVzc2FnZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIFVSSVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJpIFRoZSBuZXcgVVJJXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgd2luZG93IGlzIG9wZW5cbiAgICogQHJldHVybiB7UHJvbWlzZVdpbmRvd30gUmV0dXJucyB0aGlzIG9iamVjdCB0byBhbGxvdyBjaGFpbmluZ1xuICAgKi9cbiAgcHJvdG90eXBlLnNldFVSSSA9IGZ1bmN0aW9uIHNldFVSSSh1cmkpIHtcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2hhbmdlIHRoZSBVUkkgd2hpbGUgdGhlIHdpbmRvdyBpcyBvcGVuJyk7XG4gICAgfVxuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcGVucyBhIG5ldyBwb3B1cCB3aW5kb3cuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSBuZXcgYFByb21pc2VgIG9iamVjdC4gVGhpcyBwcm9taXNlIHdpbGwgYmU6XG4gICAqICAgICAgICAgICAgICAgICAgIC0gcmVqZWN0ZWQgd2l0aCBgXCJibG9ja2VkXCJgIG1lc3NhZ2UgaWYgdGhlIHBvcHVwIHdpbmRvd1xuICAgKiAgICAgICAgICAgICAgICAgICAgIGRvZXMgbm90IG9wZW4gZm9yIGFueSByZWFzb24gKHBvcHVwIGJsb2NrZXIsIGV0Yy4uLilcbiAgICogICAgICAgICAgICAgICAgICAgLSByZWplY3RlZCB3aXRoIGBcImNsb3NlZFwiYCBpZiBjbG9zZWQgZWl0aGVyIG1hbnVhbGx5IGJ5XG4gICAqICAgICAgICAgICAgICAgICAgICAgdGhlIHVzZXIsIG9yIHByb2dyYW1hdGljYWxseVxuICAgKiAgICAgICAgICAgICAgICAgICAtIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuIGVycm9yIGlmIHRoZSB3ZWIgcGFnZSBvcGVuZWQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9wdXAgc2VuZHMgYSBwb3N0IG1lc3NhZ2Ugd2l0aCBhIGBlcnJvcmAgZGF0YSBmaWVsZC5cbiAgICogICAgICAgICAgICAgICAgICAgLSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiBkYXRhIGlmIHRoZSB3ZWIgcGFnZSBvcGVuZWQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICB0aGUgcG9wdXAgc2VuZHMgYSBwb3N0IG1lc3NhZ2Ugd2l0aG91dCBhIGBlcnJvcmAgZGF0YVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGZpZWxkLlxuICAgKi9cbiAgcHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbmRvdyBpcyBhbHJlYWR5IG9wZW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl93aW5kb3dPcGVuID0gdHJ1ZTtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2NyZWF0ZVByb21pc2UoKTtcbiAgICB0aGlzLl93aW5kb3cgPSByb290Lm9wZW4oXG4gICAgICB0aGlzLnVyaSxcbiAgICAgIHRoaXMuY29uZmlnLndpbmRvd05hbWUsXG4gICAgICB0aGlzLl9nZXRGZWF0dXJlcygpXG4gICAgKTtcbiAgICBpZiAoIXRoaXMuX3dpbmRvdykge1xuICAgICAgdGhpcy5fcmVqZWN0KFwiYmxvY2tlZFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uUG9zdE1lc3NhZ2UsIHRydWUpO1xuICAgICAgdGhpcy5fc3RhcnRXYXRjaGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHBvcHVwIHdpbmRvdy5cbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5kb3cgaXMgYWxyZWFkeSBjbG9zZWQnKTtcbiAgICB9XG4gICAgdGhpcy5fc3RvcFdhdGNoZXIoKTtcbiAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uUG9zdE1lc3NhZ2UpO1xuICAgIGlmICh0aGlzLl9pc1dpbmRvd0FsaXZlKCkpIHtcbiAgICAgIHRoaXMuY29uZmlnLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcmVqZWN0KFwiY2xvc2VkXCIpO1xuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgdGhpcy5fd2luZG93T3BlbiA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgd2luZG93IGlzIG9wZW4gb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB3aW5kb3cgaXMgb3BlbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpbmRvd09wZW47XG4gIH07XG5cbiAgLy8gRXhwb3J0cyBQcm9taXNlV2luZG93IHRvIHRoZSBnbG9iYWwgc2NvcGVcbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdwcm9taXNlLXdpbmRvdycsIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIFByb21pc2VXaW5kb3cgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlV2luZG93O1xuICB9IGVsc2Uge1xuICAgIHJvb3QuUHJvbWlzZVdpbmRvdyA9IFByb21pc2VXaW5kb3c7XG4gIH1cbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxufSkoKTtcbiIsImlmIChwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lID09PSAncHNldWRvbWFwJyAmJlxuICAgIHByb2Nlc3MuZW52Lm5wbV9saWZlY3ljbGVfc2NyaXB0ID09PSAndGVzdCcpXG4gIHByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQID0gJ3RydWUnXG5cbmlmICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmICFwcm9jZXNzLmVudi5URVNUX1BTRVVET01BUCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IE1hcFxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BzZXVkb21hcCcpXG59XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gUHNldWRvTWFwXG5cbmZ1bmN0aW9uIFBzZXVkb01hcCAoc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQc2V1ZG9NYXApKSAvLyB3aHl5eXl5eXlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgUHNldWRvTWFwIHJlcXVpcmVzICduZXcnXCIpXG5cbiAgdGhpcy5jbGVhcigpXG5cbiAgaWYgKHNldCkge1xuICAgIGlmICgoc2V0IGluc3RhbmNlb2YgUHNldWRvTWFwKSB8fFxuICAgICAgICAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXQgaW5zdGFuY2VvZiBNYXApKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXQpKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKGt2KSB7XG4gICAgICAgIHRoaXMuc2V0KGt2WzBdLCBrdlsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgT2JqZWN0LmtleXModGhpcy5fZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnc2l6ZScpXG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLl9kYXRhW2tdLnZhbHVlLCB0aGlzLl9kYXRhW2tdLmtleSlcbiAgfSwgdGhpcylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoaykge1xuICByZXR1cm4gISFmaW5kKHRoaXMuX2RhdGEsIGspXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGspIHtcbiAgdmFyIHJlcyA9IGZpbmQodGhpcy5fZGF0YSwgaylcbiAgcmV0dXJuIHJlcyAmJiByZXMudmFsdWVcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaywgdikge1xuICBzZXQodGhpcy5fZGF0YSwgaywgdilcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICBpZiAocmVzKSB7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFbcmVzLl9pbmRleF1cbiAgICB0aGlzLl9kYXRhLnNpemUtLVxuICB9XG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBkYXRhLnNpemUgPSAwXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfZGF0YScsIHtcbiAgICB2YWx1ZTogZGF0YSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQc2V1ZG9NYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuKSB7fSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnZhbHVlcyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmtleXMgPVxuUHNldWRvTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9ycyBhcmUgbm90IGltcGxlbWVudGVkIGluIHRoaXMgdmVyc2lvbicpXG59XG5cbi8vIEVpdGhlciBpZGVudGljYWwsIG9yIGJvdGggTmFOXG5mdW5jdGlvbiBzYW1lIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYlxufVxuXG5mdW5jdGlvbiBFbnRyeSAoaywgdiwgaSkge1xuICB0aGlzLmtleSA9IGtcbiAgdGhpcy52YWx1ZSA9IHZcbiAgdGhpcy5faW5kZXggPSBpXG59XG5cbmZ1bmN0aW9uIGZpbmQgKGRhdGEsIGspIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpXG4gICAgICByZXR1cm4gZGF0YVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0IChkYXRhLCBrLCB2KSB7XG4gIGZvciAodmFyIGkgPSAwLCBzID0gJ18nICsgaywga2V5ID0gcztcbiAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgICAga2V5ID0gcyArIGkrKykge1xuICAgIGlmIChzYW1lKGRhdGFba2V5XS5rZXksIGspKSB7XG4gICAgICBkYXRhW2tleV0udmFsdWUgPSB2XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgZGF0YS5zaXplKytcbiAgZGF0YVtrZXldID0gbmV3IEVudHJ5KGssIHYsIGtleSlcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0XG5cbllhbGxpc3QuTm9kZSA9IE5vZGVcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdFxuXG5mdW5jdGlvbiBZYWxsaXN0IChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKVxuICB9XG5cbiAgc2VsZi50YWlsID0gbnVsbFxuICBzZWxmLmhlYWQgPSBudWxsXG4gIHNlbGYubGVuZ3RoID0gMFxuXG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpXG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuICB2YXIgcHJldiA9IG5vZGUucHJldlxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbmV4dFxuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS1cbiAgbm9kZS5uZXh0ID0gbnVsbFxuICBub2RlLnByZXYgPSBudWxsXG4gIG5vZGUubGlzdCA9IG51bGxcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuIiwiaW1wb3J0IERpc2NvdXJzZUF1dGggZnJvbSAnLi9kaXNjb3Vyc2VBdXRoJztcbmltcG9ydCBEaXNjb3Vyc2VDbGllbnQgZnJvbSAnLi9kaXNjb3Vyc2VDbGllbnQnO1xuaW1wb3J0IFByb21pc2VXaW5kb3cgZnJvbSAncHJvbWlzZS13aW5kb3cnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2Uge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVxdWlyZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5fZm9ybWF0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLmF1dGggPSBuZXcgRGlzY291cnNlQXV0aCh0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IERpc2NvdXJzZUNsaWVudCh0aGlzLm9wdGlvbnMuYXBpQmFzZVVybCk7XG4gIH1cblxuICBhc3luYyBpbml0KCkge1xuICAgIGF3YWl0IHRoaXMuYXV0aC5pbml0KCk7XG4gIH1cblxuICBfcmVxdWlyZU9wdGlvbnMob3B0aW9ucykge1xuICAgIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICh0eXBlb2Ygb3B0aW9ucy5hcHBOYW1lID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLmFwcE5hbWUubGVuZ3RoID4gMCkgfHxcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5hcHBOYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgKHR5cGVvZiBvcHRpb25zLmFwaUJhc2VVcmwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuYXBpQmFzZVVybC5sZW5ndGggPiAwKSB8fFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLmFwaUJhc2VVcmwgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAob3B0aW9ucy5zY29wZXMgaW5zdGFuY2VvZiBBcnJheSAmJiBvcHRpb25zLnNjb3Blcy5sZW5ndGggPiAwKSB8fFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLnNjb3BlcyBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5Jyk7XG4gIH1cblxuICBfZm9ybWF0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkT3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gICAgZm9ybWF0dGVkT3B0aW9ucy5hcGlCYXNlVXJsID0gb3B0aW9ucy5hcGlCYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgZm9ybWF0dGVkT3B0aW9ucy5zY29wZXMgPSBvcHRpb25zLnNjb3Blcy5qb2luKCcsJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlZE9wdGlvbnM7XG4gIH1cblxuICBnZXRBcGlCYXNlVXJsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXBpQmFzZVVybDtcbiAgfVxuXG4gIGFzeW5jIGxvZ2luKCkge1xuICAgIGlmIChhd2FpdCB0aGlzLmlzTG9nZ2VkSW4oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2VXaW5kb3cub3Blbihhd2FpdCB0aGlzLmF1dGguX2dldExvZ2luVXJsKCksIHtcbiAgICAgIHdpZHRoOiA3MDAsXG4gICAgICBoZWlnaHQ6IDY1MCxcbiAgICAgIG9yaWdpblJlZ2V4cDogbmV3IFJlZ0V4cCgnXicgKyBsb2NhdGlvbi5vcmlnaW4pXG4gICAgfSkudGhlbihhc3luYyBkYXRhID0+IHtcbiAgICAgIGF3YWl0IHRoaXMuY2xpZW50Ll9zZXRVc2VyQXBpS2V5KGRhdGEucmVzdWx0LmtleSk7XG4gICAgICBhd2FpdCB0aGlzLl9yZWZyZXNoQ3VycmVudFVzZXIoKTtcbiAgICB9LFxuXG4gICAgLy8gRXJyb3JcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIHN3aXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICBkaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGlzY291cnNlTG9naW5DYW5jZWxlZCcpKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHBvcHVwIHdpbmRvdyBjbG9zZWQgYnkgdGhlIHVzZXInKTtcbiAgICAgICAgY2FzZSAnYmxvY2tlZCc6XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Rpc2NvdXJzZUxvZ2luQmxvY2tlZCcpKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHBvcHVwIHdpbmRvdyBibG9ja2VkIGJ5IHRoZSBicm93c2VyJyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiBwb3B1cCB3aW5kb3cgcmV0dXJuZWQgYW4gZXJyb3I6ICcsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KS50aGVuKCgpID0+IGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dnZWRJbicpKSk7XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKSB7XG4gICAgYXdhaXQgdGhpcy5jbGllbnQuX2RvTG9nb3V0KHRoaXMuZ2V0Q3VycmVudFVzZXJOYW1lKCkpO1xuICAgIHRoaXMuYXV0aC5fY2xlYXJBdXRoRGF0YSgpO1xuICAgIGRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkaXNjb3Vyc2VMb2dnZWRPdXQnKSk7XG4gIH1cblxuICBhc3luYyBnZXRDdXJyZW50U2Vzc2lvblVzZXIoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2xpZW50Ll9nZXRDYWxsUmVzdWx0KCcvc2Vzc2lvbi9jdXJyZW50Lmpzb24nLCAnY3VycmVudF91c2VyJywgdHJ1ZSk7XG4gIH1cblxuICBhc3luYyBpc0xvZ2dlZEluKCkge1xuICAgIGlmICghdGhpcy5hdXRoLl9oYXNVc2VyQXBpS2V5KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaEN1cnJlbnRVc2VyKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJyZW50VXNlcicpKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VXNlcigpICYmIHRoaXMuZ2V0Q3VycmVudFVzZXIoKVsndXNlcm5hbWUnXTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VySWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFVzZXIoKSAmJiB0aGlzLmdldEN1cnJlbnRVc2VyKClbJ2lkJ107XG4gIH1cblxuICBnZXRDdXJyZW50VXNlckRpc3BsYXlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRVc2VyKCkgJiYgdGhpcy5nZXRDdXJyZW50VXNlcigpWyduYW1lJ107XG4gIH1cblxuICBpc0N1cnJlbnRVc2VyU2lsZW5jZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFVzZXIoKSAmJiAhdGhpcy5nZXRDdXJyZW50VXNlcigpWydjYW5fY3JlYXRlX3RvcGljJ107XG4gIH1cblxuICBnZXRDdXJyZW50VXNlckF2YXRhclVybChzaXplKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudFVzZXIoKSAmJiBbXG4gICAgICB0aGlzLm9wdGlvbnMuYXBpQmFzZVVybCxcbiAgICAgIHRoaXMuZ2V0Q3VycmVudFVzZXIoKVsnYXZhdGFyX3RlbXBsYXRlJ10ucmVwbGFjZSgne3NpemV9JywgKHNpemUgfHwgMTEwKSlcbiAgICBdLmpvaW4oJy8nKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRVc2VyTm90aWZpY2F0aW9uc1VybCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VXNlcigpICYmIFtcbiAgICAgIHRoaXMub3B0aW9ucy5hcGlCYXNlVXJsLFxuICAgICAgJ3UnLFxuICAgICAgdGhpcy5nZXRDdXJyZW50VXNlck5hbWUoKSxcbiAgICAgICdub3RpZmljYXRpb25zJ1xuICAgIF0uam9pbignLycpO1xuICB9XG5cbiAgYXN5bmMgX3JlZnJlc2hDdXJyZW50VXNlcigpIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRVc2VyJywgSlNPTi5zdHJpbmdpZnkoYXdhaXQgdGhpcy5nZXRDdXJyZW50U2Vzc2lvblVzZXIoKSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ291dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgbG9nZ2VkIGluLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldExhdGVzdFBvc3RzKGRlc2NlbmRpbmcpIHtcbiAgICBsZXQgcG9zdHM7XG5cbiAgICB0cnkge1xuICAgICAgcG9zdHMgPSBhd2FpdCB0aGlzLmNsaWVudC5fZ2V0Q2FsbFJlc3VsdCgnL3Bvc3RzLmpzb24nLCAnbGF0ZXN0X3Bvc3RzJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgIHBvc3RzID0gcG9zdHMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0cy5maWx0ZXIocG9zdCA9PiBwb3N0LnBvc3RfdHlwZSA9PT0gMSk7XG4gIH1cblxuICBhc3luYyBnZXRQb3N0c0luVG9waWModG9waWNJZCwgZGVzY2VuZGluZywgbm9jYWNoZSA9IGZhbHNlKSB7XG4gICAgbGV0IHBvc3RzID0gYXdhaXQgdGhpcy5jbGllbnQuX2dldENhbGxSZXN1bHQoJy90LycgKyB0b3BpY0lkICsgJy9wb3N0cy5qc29uP2luY2x1ZGVfcmF3PXRydWUnLFxuICAgICAgJ3Bvc3Rfc3RyZWFtLnBvc3RzJywgbm9jYWNoZSk7XG5cbiAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgcG9zdHMgPSBwb3N0cy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3RzLmZpbHRlcihwb3N0ID0+IHBvc3QucG9zdF90eXBlID09PSAxKTtcbiAgfVxuXG4gIGFzeW5jIGdldFRvcGljKHRvcGljSWQsIGRlc2NlbmRpbmcsIG5vY2FjaGUgPSBmYWxzZSkge1xuICAgIGxldCB0b3BpYyA9IGF3YWl0IHRoaXMuY2xpZW50Ll9nZXRDYWxsUmVzdWx0KCcvdC8nICsgdG9waWNJZCArICcuanNvbj9pbmNsdWRlX3Jhdz10cnVlJywgZmFsc2UsIG5vY2FjaGUpO1xuXG4gICAgdG9waWMucG9zdF9zdHJlYW0ucG9zdHMgPSB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cy5maWx0ZXIocG9zdCA9PiBwb3N0LnBvc3RfdHlwZSA9PT0gMSk7XG5cbiAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgdG9waWMucG9zdF9zdHJlYW0ucG9zdHMgPSB0b3BpYy5wb3N0X3N0cmVhbS5wb3N0cy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvcGljO1xuICB9XG5cbiAgYXN5bmMgZ2V0UHVibGljVXNlckZpZWxkcyh1c2VybmFtZSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC5fZ2V0Q2FsbFJlc3VsdCgnL3UvJyArIHVzZXJuYW1lICsgJy5qc29uP3N0YXRzPWZhbHNlJywgJ3VzZXIudXNlcl9maWVsZHMnKTtcbiAgfVxuXG4gIGFzeW5jIGdldFB1YmxpY1VzZXJGaWVsZCh1c2VybmFtZSwgZmllbGQpIHtcbiAgICBjb25zdCB1c2VyRmllbGRzID0gYXdhaXQgdGhpcy5nZXRQdWJsaWNVc2VyRmllbGRzKHVzZXJuYW1lKTtcblxuICAgIHJldHVybiB1c2VyRmllbGRzICYmIHVzZXJGaWVsZHNbZmllbGRdO1xuICB9XG5cbiAgYXN5bmMgcG9zdE1lc3NhZ2UodG9waWNJZCwgbWVzc2FnZSkge1xuICAgIHRoaXMuY2xpZW50Ll9jaGVja1VzZXJBcGlLZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuX3Bvc3RDYWxsUmVzdWx0KCcvcG9zdHMuanNvbicsIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgdG9waWNfaWQ6IHRvcGljSWQsXG4gICAgICByYXc6IG1lc3NhZ2VcbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgfSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICByZXNwb25zZS5oaWRkZW4gJiYgUHJvbWlzZS5yZWplY3QocmVzcG9uc2UuaGlkZGVuX3JlYXNvbl9pZCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4gUHJvbWlzZS5yZWplY3QoZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcnMpKTtcbiAgfVxuXG4gIGFzeW5jIGxpa2VQb3N0KHBvc3RJZCkge1xuICAgIHRoaXMuY2xpZW50Ll9jaGVja1VzZXJBcGlLZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jbGllbnQuX3Bvc3RDYWxsUmVzdWx0KCcvcG9zdF9hY3Rpb25zJywge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICBpZDogcG9zdElkLFxuICAgICAgcG9zdF9hY3Rpb25fdHlwZV9pZDogMlxuICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB9KS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlKS5jYXRjaChlcnJvciA9PiBQcm9taXNlLnJlamVjdChlcnJvci5yZXNwb25zZS5kYXRhLmVycm9ycykpO1xuICB9XG5cbiAgYXN5bmMgdW5kb0xpa2VQb3N0KHBvc3RJZCkge1xuICAgIHRoaXMuY2xpZW50Ll9jaGVja1VzZXJBcGlLZXkoKTtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuY2xpZW50Lmluc3RhbmNlLmRlbGV0ZSgnL3Bvc3RfYWN0aW9ucy8nICsgcG9zdElkLCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgICAgICBwb3N0X2FjdGlvbl90eXBlX2lkOiAnMidcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICAgIH1cbiAgICB9KSkuZGF0YTtcbiAgfVxufVxuXG53aW5kb3cuRGlzY291cnNlID0gRGlzY291cnNlO1xuIiwiaW1wb3J0IEtleU1hbmFnZXIgZnJvbSAnLi9rZXlNYW5hZ2VyJztcbmltcG9ydCBVUkxTZWFyY2hQYXJhbXMgZnJvbSAnQHVuZ2FwL3VybC1zZWFyY2gtcGFyYW1zJzsgLy8gcG9seWZpbGxcbi8vIGltcG9ydCBNb2JpbGVEZXRlY3QgZnJvbSAnbW9iaWxlLWRldGVjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpc2NvdXJzZUF1dGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5hcHBJZCA9IHRoaXMuX3NsdWdpZnkob3B0aW9ucy5hcHBOYW1lKTtcbiAgICB0aGlzLmttID0gbmV3IEtleU1hbmFnZXIodGhpcy5hcHBJZCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGFzeW5jIGluaXQoKSB7XG4gICAgYXdhaXQgdGhpcy5rbS5nZXRLZXlzKCk7XG4gICAgdGhpcy5faGFzVXNlckFwaUtleSgpIHx8IHRoaXMuX21hbmFnZVBheWxvYWQoKTtcbiAgfVxuXG4gIF9oYXNVc2VyQXBpS2V5KCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9hcGlfa2V5JykgIT09IG51bGw7XG4gIH1cblxuICBhc3luYyBfZ2V0TG9naW5VcmwoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgICBhcHBsaWNhdGlvbl9uYW1lOiB0aGlzLm9wdGlvbnMuYXBwTmFtZSxcbiAgICAgIHB1YmxpY19rZXk6IGF3YWl0IHRoaXMua20uZ2V0UHVibGljS2V5KCksXG4gICAgICBub25jZTogdGhpcy5fZ2VuZXJhdGVTdG9yZWRSYW5kb20oJ25vbmNlJyksXG4gICAgICBjbGllbnRfaWQ6IHRoaXMuX2dldFN0b3JlZFJhbmRvbSgnY2xpZW50SWQnKSB8fCB0aGlzLl9nZW5lcmF0ZVN0b3JlZFJhbmRvbSgnY2xpZW50SWQnKSxcbiAgICAgIGF1dGhfcmVkaXJlY3Q6IGxvY2F0aW9uLmhyZWYsXG4gICAgICBzY29wZXM6IHRoaXMub3B0aW9ucy5zY29wZXNcbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXBpQmFzZVVybCArICcvdXNlci1hcGkta2V5L25ldz8nICsgdGhpcy5fc2VyaWFsaXplUGFyYW1zKHBhcmFtcyk7XG4gIH1cblxuICBfc2VyaWFsaXplUGFyYW1zKHBhcmFtcykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXJhbXMpXG4gICAgICAubWFwKChrKSA9PiBlbmNvZGVVUklDb21wb25lbnQoaykgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tdKSlcbiAgICAgIC5qb2luKCcmJyk7XG4gIH07XG5cbiAgX2dlbmVyYXRlU3RvcmVkUmFuZG9tKG5hbWUpIHtcbiAgICBjb25zdCBzdG9yZWRSYW5kb20gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMik7XG5cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmFwcElkICsgJ18nICsgbmFtZSwgc3RvcmVkUmFuZG9tKTtcbiAgICByZXR1cm4gc3RvcmVkUmFuZG9tO1xuICB9XG5cbiAgX2dldFN0b3JlZFJhbmRvbShuYW1lKSB7XG4gICAgY29uc3Qgc3RvcmVkUmFuZG9tID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5hcHBJZCArICdfJyArIG5hbWUpO1xuXG4gICAgcmV0dXJuIHN0b3JlZFJhbmRvbTtcbiAgfVxuXG4gIF9yZW1vdmVTdG9yZWRSYW5kb20obmFtZSkge1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuYXBwSWQgKyAnXycgKyBuYW1lKTtcbiAgfVxuXG4gIF9nZXRVc2VyQXBpS2V5KCkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9hcGlfa2V5Jyk7XG4gIH1cblxuICBfY2xlYXJBdXRoRGF0YSgpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcl9hcGlfa2V5Jyk7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2N1cnJlbnRVc2VyJyk7XG4gICAgdGhpcy5fcmVtb3ZlU3RvcmVkUmFuZG9tKCdjbGllbnRJZCcpO1xuICB9XG5cbiAgX21hbmFnZVBheWxvYWQoKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoIHx8IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNwbGl0KCc/JylbMV0pO1xuXG4gICAgaWYgKHVybC5oYXMoJ3BheWxvYWQnKSAmJiBvcGVuZXIpIHtcbiAgICAgIHRoaXMua20uZGVjcnlwdFBheWxvYWQodXJsLmdldCgncGF5bG9hZCcpKS50aGVuKHBheWxvYWRPYmplY3QgPT4ge1xuICAgICAgICBwYXlsb2FkT2JqZWN0Lm5vbmNlID09PSB0aGlzLl9nZXRTdG9yZWRSYW5kb20oJ25vbmNlJykgfHxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXR1cm5lZCBwYXlsb2FkIGlzIGludmFsaWQuJyk7XG4gICAgICAgIHBheWxvYWRPYmplY3QuYXBpID09PSA0IHx8XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBBUEkgdmVyc2lvbjogJyArIHBheWxvYWRPYmplY3QuYXBpICsgJy4gRGlzY291cnNlLWpzIHdvcmtzIHdpdGggQVBJIHZlcnNpb24gMy4nKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJfYXBpX2tleScsIHBheWxvYWRPYmplY3Qua2V5KTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RvcmVkUmFuZG9tKCdub25jZScpO1xuICAgICAgICBvcGVuZXIucG9zdE1lc3NhZ2UoeyByZXN1bHQ6IHBheWxvYWRPYmplY3QgfSwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB2YXIgbWQgPSBuZXcgTW9iaWxlRGV0ZWN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIF9zbHVnaWZ5KHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC50b1N0cmluZygpLnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICctJylcbiAgICAgIC5yZXBsYWNlKC9bXlxcd1xcLV0rL2csICcnKVxuICAgICAgLnJlcGxhY2UoL1xcLVxcLSsvZywgJy0nKVxuICAgICAgLnJlcGxhY2UoL14tKy8sICcnKVxuICAgICAgLnJlcGxhY2UoLy0rJC8sICcnKTtcbiAgfVxufVxuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IGNhY2hlQWRhcHRlckVuaGFuY2VyLCB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlciB9IGZyb20gJ2F4aW9zLWV4dGVuc2lvbnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXNjb3Vyc2VDbGllbnQge1xuICBjb25zdHJ1Y3RvcihhcGlCYXNlVXJsKSB7XG4gICAgdGhpcy5hcGlCYXNlVXJsID0gYXBpQmFzZVVybDtcbiAgICB0aGlzLmluc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IHRoaXMuYXBpQmFzZVVybCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBhZGFwdGVyOiB0aHJvdHRsZUFkYXB0ZXJFbmhhbmNlcihcbiAgICAgICAgY2FjaGVBZGFwdGVyRW5oYW5jZXIoYXhpb3MuZGVmYXVsdHMuYWRhcHRlciksXG4gICAgICAgIHsgdGhyZXNob2xkOiA1MDAgfSAvLyAxMjAgcmVxcy9taW5cbiAgICAgIClcbiAgICB9KTtcblxuICAgIHRoaXMuX3NldFVzZXJBcGlLZXkobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfYXBpX2tleScpKTtcbiAgfVxuXG4gIGFzeW5jIF9nZXRDYWxsUmVzdWx0KGVuZHBvaW50LCBwcm9wLCBub2NhY2hlID0gZmFsc2UpIHtcbiAgICBsZXQgcmVzcG9uc2U7XG5cbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSAoYXdhaXQgdGhpcy5pbnN0YW5jZS5nZXQoZW5kcG9pbnQsIHsgZm9yY2VVcGRhdGU6IG5vY2FjaGUgfSkpLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHJlc3BvbnNlID0gcHJvcC5zcGxpdCgnLicpLnJlZHVjZSgocmV0dXJuZWRSZXNwb25zZSwgY3VycmVudFByb3ApID0+XG4gICAgICAgIHJldHVybmVkUmVzcG9uc2VbY3VycmVudFByb3BdLCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgYXN5bmMgX3Bvc3RDYWxsUmVzdWx0KGVuZHBvaW50LCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLmluc3RhbmNlLnBvc3QoZW5kcG9pbnQsIHBheWxvYWQpKS5kYXRhO1xuICB9XG5cbiAgYXN5bmMgX3NldFVzZXJBcGlLZXkodXNlckFwaUtleSkge1xuICAgIGlmICghdXNlckFwaUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmluc3RhbmNlLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydVc2VyLUFwaS1LZXknXSA9IHVzZXJBcGlLZXk7XG4gICAgYXdhaXQgdGhpcy5fc2V0Q3NyZlRva2VuKCk7XG4gIH1cblxuICBhc3luYyBfc2V0Q3NyZlRva2VuKCkge1xuICAgIHRoaXMuaW5zdGFuY2UuZGVmYXVsdHMuaGVhZGVycy5jb21tb25bJ1gtQ1NSRi1Ub2tlbiddID0gYXdhaXQgdGhpcy5fZ2V0Q2FsbFJlc3VsdCgnL3Nlc3Npb24vY3NyZi5qc29uJywgJ2NzcmYnKTtcbiAgfVxuXG4gIF9jaGVja1VzZXJBcGlLZXkoKSB7XG4gICAgdGhpcy5pbnN0YW5jZS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnVXNlci1BcGktS2V5J10gfHwgdGhyb3cgbmV3IEVycm9yKCdVc2VyIEFQSSBrZXkgbm90IHNldCcpO1xuICB9XG5cbiAgYXN5bmMgX2RvTG9nb3V0KHVzZXJuYW1lKSB7XG4gICAgdGhpcy5fY2hlY2tVc2VyQXBpS2V5KCk7XG4gICAgYXdhaXQgdGhpcy5pbnN0YW5jZS5kZWxldGUoJy9zZXNzaW9uLycgKyB1c2VybmFtZSk7XG4gICAgYXdhaXQgdGhpcy5pbnN0YW5jZS5wb3N0KCcvdXNlci1hcGkta2V5L3Jldm9rZScpO1xuICAgIGRlbGV0ZSB0aGlzLmluc3RhbmNlLmRlZmF1bHRzLmhlYWRlcnMuY29tbW9uWydVc2VyLUFwaS1LZXknXTtcbiAgICBkZWxldGUgdGhpcy5pbnN0YW5jZS5kZWZhdWx0cy5oZWFkZXJzLmNvbW1vblsnWC1DU1JGLVRva2VuJ107XG4gIH1cbn1cbiIsImxldCBmb3JnZSA9IHJlcXVpcmUoJy4vdmVuZG9yL2ZvcmdlLXBraScpO1xuXG5leHBvcnQgZGVmYXVsdCAoKCkgPT4ge1xuICBjb25zdCBnZW5lcmF0ZSA9IChhcHBJZCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmb3JnZS5yc2EuZ2VuZXJhdGVLZXlQYWlyKHtcbiAgICAgICAgd29ya2VyU2NyaXB0OiAnL3ByaW1lLXdvcmtlci5taW4uanMnXG4gICAgICB9LFxuICAgICAgKGVycm9yLCBnZW5lcmF0ZWRLZXlwYWlyKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlZEtleXBhaXIgPyAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleXBhaXIgPSB7XG4gICAgICAgICAgICBwdWJsaWM6IGZvcmdlLnBraS5wdWJsaWNLZXlUb1BlbShnZW5lcmF0ZWRLZXlwYWlyLnB1YmxpY0tleSwgNzIpLnJlcGxhY2UoL1xcci9nLCAnJyksXG4gICAgICAgICAgICBwcml2YXRlOiBmb3JnZS5wa2kucHJpdmF0ZUtleVRvUGVtKGdlbmVyYXRlZEtleXBhaXIucHJpdmF0ZUtleSwgNzIpLnJlcGxhY2UoL1xcci9nLCAnJylcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXBwSWQgKyAnX3B1YmxpY0tleScsIGtleXBhaXIucHVibGljKTtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhcHBJZCArICdfcHJpdmF0ZUtleScsIGtleXBhaXIucHJpdmF0ZSk7XG4gICAgICAgICAgcmVzb2x2ZShrZXlwYWlyKTtcbiAgICAgICAgfSkoKSA6IHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4geyBnZW5lcmF0ZSB9O1xufSkoKTtcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihhcHBJZCkge1xuICAgIHRoaXMuYXBwSWQgPSBhcHBJZDtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlTmV3S2V5cGFpcigpIHtcbiAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgLypcbiAgICAgICAgd2VicGFja0NodW5rTmFtZTogXCJrZXlHZW5lcmF0b3JcIixcbiAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICovXG4gICAgICAnLi9rZXlHZW5lcmF0b3InKS50aGVuKCh7IGRlZmF1bHQ6IGtleUdlbmVyYXRvciB9KSA9PiB7XG4gICAgICByZXR1cm4ga2V5R2VuZXJhdG9yLmdlbmVyYXRlKHRoaXMuYXBwSWQpLnRoZW4oKGtleXBhaXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGtleXBhaXI7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEtleXNGcm9tU3RvcmFnZSgpIHx8IGF3YWl0IHRoaXMuZ2VuZXJhdGVOZXdLZXlwYWlyKCk7XG4gIH1cblxuICByZWFkS2V5c0Zyb21TdG9yYWdlKCkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuYXBwSWQgKyAnX3B1YmxpY0tleScpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmFwcElkICsgJ19wcml2YXRlS2V5Jyk7XG5cbiAgICByZXR1cm4gKHB1YmxpY0tleSAmJiBwcml2YXRlS2V5KSA/XG4gICAgICB7XG4gICAgICAgIHB1YmxpYzogcHVibGljS2V5LFxuICAgICAgICBwcml2YXRlOiBwcml2YXRlS2V5XG4gICAgICB9IDogbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldFB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0S2V5cygpKVsncHVibGljJ107XG4gIH1cblxuICBhc3luYyBnZXRQcml2YXRlS2V5KCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXRLZXlzKCkpWydwcml2YXRlJ107XG4gIH1cblxuICBhc3luYyBkZWNyeXB0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZUtleSgpLnRoZW4ocHJpdmF0ZUtleSA9PiB7XG4gICAgICByZXR1cm4gaW1wb3J0KFxuICAgICAgICAvKlxuICAgICAgICAgIHdlYnBhY2tDaHVua05hbWU6IFwianNlbmNyeXB0XCIsXG4gICAgICAgICAgd2VicGFja1ByZWxvYWQ6IHRydWVcbiAgICAgICAgKi9cbiAgICAgICAgJ2pzZW5jcnlwdCcpLnRoZW4oKHsgZGVmYXVsdDogSnNlbmNyeXB0IH0pID0+IHtcbiAgICAgICAgY29uc3QganNlbmNyeXB0ID0gbmV3IEpzZW5jcnlwdCgpO1xuXG4gICAgICAgIGpzZW5jcnlwdC5zZXRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc2VuY3J5cHQuZGVjcnlwdChwYXlsb2FkKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImZvcmdlXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgYmFzZU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuLy8gZGVmaW5lIGlzQXJyYXlcbnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJcbnV0aWwuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcblxuLy8gZGVmaW5lIGlzQXJyYXlCdWZmZXJWaWV3XG51dGlsLmlzQXJyYXlCdWZmZXJWaWV3ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAmJiB1dGlsLmlzQXJyYXlCdWZmZXIoeC5idWZmZXIpICYmIHguYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBFbnN1cmUgYSBiaXRzIHBhcmFtIGlzIDgsIDE2LCAyNCwgb3IgMzIuIFVzZWQgdG8gdmFsaWRhdGUgaW5wdXQgZm9yXG4gKiBhbGdvcml0aG1zIHdoZXJlIGJpdCBtYW5pcHVsYXRpb24sIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIGFuZC9vciBhbGdvcml0aG1cbiAqIGRlc2lnbiBvbmx5IGFsbG93IGZvciBieXRlIG9wZXJhdGlvbnMgb2YgYSBsaW1pdGVkIHNpemUuXG4gKlxuICogQHBhcmFtIG4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogVGhyb3cgRXJyb3IgaWYgbiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCaXRzUGFyYW0obikge1xuICBpZighKG4gPT09IDggfHwgbiA9PT0gMTYgfHwgbiA9PT0gMjQgfHwgbiA9PT0gMzIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IDgsIDE2LCAyNCwgb3IgMzIgYml0cyBzdXBwb3J0ZWQ6ICcgKyBuKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBzZXQgQnl0ZUJ1ZmZlciB0byBiZXN0IGF2YWlsYWJsZSBiYWNraW5nXG51dGlsLkJ5dGVCdWZmZXIgPSBCeXRlU3RyaW5nQnVmZmVyO1xuXG4vKiogQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBiaW5hcnkgc3RyaW5nIGJhY2tlZCBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBieXRlcyB0byB3cmFwIChlaXRoZXIgZW5jb2RlZCBhcyBzdHJpbmcsIG9uZSBieXRlIHBlclxuICogICAgICAgICAgY2hhcmFjdGVyLCBvciBhcyBhbiBBcnJheUJ1ZmZlciBvciBUeXBlZCBBcnJheSkuXG4gKi9cbmZ1bmN0aW9uIEJ5dGVTdHJpbmdCdWZmZXIoYikge1xuICAvLyBUT0RPOiB1cGRhdGUgdG8gbWF0Y2ggRGF0YUJ1ZmZlciBBUElcblxuICAvLyB0aGUgZGF0YSBpbiB0aGlzIGJ1ZmZlclxuICB0aGlzLmRhdGEgPSAnJztcbiAgLy8gdGhlIHBvaW50ZXIgZm9yIHJlYWRpbmcgZnJvbSB0aGlzIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSAwO1xuXG4gIGlmKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuZGF0YSA9IGI7XG4gIH0gZWxzZSBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYikgfHwgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKSkge1xuICAgIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGIgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb252ZXJ0IG5hdGl2ZSBidWZmZXIgdG8gZm9yZ2UgYnVmZmVyXG4gICAgICAvLyBGSVhNRTogc3VwcG9ydCBuYXRpdmUgYnVmZmVycyBpbnRlcm5hbGx5IGluc3RlYWRcbiAgICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5wdXRCeXRlKGFycltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihiIGluc3RhbmNlb2YgQnl0ZVN0cmluZ0J1ZmZlciB8fFxuICAgICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgYi5yZWFkID09PSAnbnVtYmVyJykpIHtcbiAgICAvLyBjb3B5IGV4aXN0aW5nIGJ1ZmZlclxuICAgIHRoaXMuZGF0YSA9IGIuZGF0YTtcbiAgICB0aGlzLnJlYWQgPSBiLnJlYWQ7XG4gIH1cblxuICAvLyB1c2VkIGZvciB2OCBvcHRpbWl6YXRpb25cbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xufVxudXRpbC5CeXRlU3RyaW5nQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyogTm90ZTogVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIFY4LWJhc2VkIGJyb3dzZXJzLiBXaGVuIFY4IGNvbmNhdGVuYXRlc1xuICBhIHN0cmluZywgdGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkIGxvZ2ljYWxseSB1c2luZyBhIFwiY29ucyBzdHJpbmdcIiBvclxuICBcImNvbnN0cnVjdGVkL2NvbmNhdGVuYXRlZCBzdHJpbmdcIi4gVGhlc2UgY29udGFpbmVycyBrZWVwIHJlZmVyZW5jZXMgdG8gb25lXG4gIGFub3RoZXIgYW5kIGNhbiByZXN1bHQgaW4gdmVyeSBsYXJnZSBtZW1vcnkgdXNhZ2UuIEZvciBleGFtcGxlLCBpZiBhIDJNQlxuICBzdHJpbmcgaXMgY29uc3RydWN0ZWQgYnkgY29uY2F0ZW5hdGluZyA0IGJ5dGVzIHRvZ2V0aGVyIGF0IGEgdGltZSwgdGhlXG4gIG1lbW9yeSB1c2FnZSB3aWxsIGJlIH40NE1COyBzbyB+MjJ4IGluY3JlYXNlLiBUaGUgc3RyaW5ncyBhcmUgb25seSBqb2luZWRcbiAgdG9nZXRoZXIgd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyaW5nIHRoZWlyIGpvaW5pbmcgdGFrZXMgcGxhY2UsIHN1Y2ggYXNcbiAgc3Vic3RyKCkuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYWRkaW5nIGRhdGEgdG8gdGhpcyBidWZmZXIgdG8gZW5zdXJlXG4gIHRoZXNlIHR5cGVzIG9mIHN0cmluZ3MgYXJlIHBlcmlvZGljYWxseSBqb2luZWQgdG8gcmVkdWNlIHRoZSBtZW1vcnlcbiAgZm9vdHByaW50LiAqL1xudmFyIF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCA9IDQwOTY7XG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nID0gZnVuY3Rpb24oeCkge1xuICB0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCArPSB4O1xuICBpZih0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCA+IF9NQVhfQ09OU1RSVUNURURfU1RSSU5HX0xFTkdUSCkge1xuICAgIC8vIHRoaXMgc3Vic3RyKCkgc2hvdWxkIGNhdXNlIHRoZSBjb25zdHJ1Y3RlZCBzdHJpbmcgdG8gam9pblxuICAgIHRoaXMuZGF0YS5zdWJzdHIoMCwgMSk7XG4gICAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyIE4gdGltZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyBvZiB2YWx1ZSBiIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gIHZhciBkID0gdGhpcy5kYXRhO1xuICB3aGlsZShuID4gMCkge1xuICAgIGlmKG4gJiAxKSB7XG4gICAgICBkICs9IGI7XG4gICAgfVxuICAgIG4gPj4+PSAxO1xuICAgIGlmKG4gPiAwKSB7XG4gICAgICBiICs9IGI7XG4gICAgfVxuICB9XG4gIHRoaXMuZGF0YSA9IGQ7XG4gIHRoaXMuX29wdGltaXplQ29uc3RydWN0ZWRTdHJpbmcobik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgKGFzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcpIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdGhpcy5kYXRhICs9IGJ5dGVzO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKGJ5dGVzLmxlbmd0aCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgVVRGLTE2IGVuY29kZWQgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyh1dGlsLmVuY29kZVV0Zjgoc3RyKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAxNiAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYW4gbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgYnl0ZXMgPSAnJztcbiAgZG8ge1xuICAgIG4gLT0gODtcbiAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IG4pICYgMHhGRik7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgLy8gcHV0SW50IGNoZWNrcyBuXG4gIGlmKGkgPCAwKSB7XG4gICAgaSArPSAyIDw8IChuIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KGksIG4pO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBnaXZlbiBidWZmZXIgaW50byB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIHRoZSBidWZmZXIgdG8gcHV0IGludG8gdGhpcyBvbmUuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnVmZmVyLmdldEJ5dGVzKCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBmcm9tIHRoaXMgYnVmZmVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IDEuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MTYgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAyLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQxNi5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCAyNCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDMpKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNik7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSA8PCAyNCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgY2VpbChuLzgpLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgaW50byBhIFVURi04IHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIFVURi04IHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZihjb3VudCkge1xuICAgIC8vIHJlYWQgY291bnQgYnl0ZXNcbiAgICBjb3VudCA9IE1hdGgubWluKHRoaXMubGVuZ3RoKCksIGNvdW50KTtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpO1xuICAgIHRoaXMucmVhZCArPSBjb3VudDtcbiAgfSBlbHNlIGlmKGNvdW50ID09PSAwKSB7XG4gICAgcnZhbCA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgYWxsIGJ5dGVzLCBvcHRpbWl6ZSB0byBvbmx5IGNvcHkgd2hlbiBuZWVkZWRcbiAgICBydmFsID0gKHRoaXMucmVhZCA9PT0gMCkgPyB0aGlzLmRhdGEgOiB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgYnl0ZXMgZnJvbSB0aGlzIGJ1ZmZlciB3aXRob3V0IG1vZGlmeWluZ1xuICogdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byBnZXQsIG9taXQgdG8gZ2V0IGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgc3RyaW5nIGZ1bGwgb2YgVVRGLTggZW5jb2RlZCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgcmV0dXJuICh0eXBlb2YoY291bnQpID09PSAndW5kZWZpbmVkJyA/XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCkgOlxuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnN1YnN0cigwLCB0aGlzLnJlYWQgKyBpKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShiKSArXG4gICAgdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQgKyBpICsgMSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aCAtIDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb3B5LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB1dGlsLmNyZWF0ZUJ1ZmZlcih0aGlzLmRhdGEpO1xuICBjLnJlYWQgPSB0aGlzLnJlYWQ7XG4gIHJldHVybiBjO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9ICcnO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvcnRlbnMgdGhpcyBidWZmZXIgYnkgdHJpbWluZyBieXRlcyBvZmYgb2YgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byB0cmltIG9mZi5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkLCBsZW4pO1xuICB0aGlzLnJlYWQgPSAwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYiA9IHRoaXMuZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgVVRGLTE2IHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtMTYgc3RyaW5nLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvQmluYXJ5U3RyaW5nIGJhY2tpbmcgKi9cblxuLyoqIEJ1ZmZlciB3L1VJbnQ4QXJyYXkgYmFja2luZyAqL1xuXG4vKipcbiAqIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxuICpcbiAqIENvbnN0cnVjdG9yIGZvciBhbiBBcnJheUJ1ZmZlci1iYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogVGhlIGJ1ZmZlciBtYXkgYmUgY29uc3RydWN0ZWQgZnJvbSBhIHN0cmluZywgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBhXG4gKiBUeXBlZEFycmF5LlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIGdpdmVuLCBpdHMgZW5jb2Rpbmcgc2hvdWxkIGJlIHByb3ZpZGVkIGFzIGFuIG9wdGlvbixcbiAqIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gJ2JpbmFyeScuIEEgJ2JpbmFyeScgc3RyaW5nIGlzIGVuY29kZWQgc3VjaFxuICogdGhhdCBlYWNoIGNoYXJhY3RlciBpcyBvbmUgYnl0ZSBpbiBsZW5ndGggYW5kIHNpemUuXG4gKlxuICogSWYgYW4gQXJyYXlCdWZmZXIsIERhdGFWaWV3LCBvciBUeXBlZEFycmF5IGlzIGdpdmVuLCBpdCB3aWxsIGJlIHVzZWRcbiAqICpkaXJlY3RseSogd2l0aG91dCBhbnkgY29weWluZy4gTm90ZSB0aGF0LCBpZiBhIHdyaXRlIHRvIHRoZSBidWZmZXIgcmVxdWlyZXNcbiAqIG1vcmUgc3BhY2UsIHRoZSBidWZmZXIgd2lsbCBhbGxvY2F0ZSBhIG5ldyBiYWNraW5nIEFycmF5QnVmZmVyIHRvXG4gKiBhY2NvbW1vZGF0ZS4gVGhlIHN0YXJ0aW5nIHJlYWQgYW5kIHdyaXRlIG9mZnNldHMgZm9yIHRoZSBidWZmZXIgbWF5IGJlXG4gKiBnaXZlbiBhcyBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBbYl0gdGhlIGluaXRpYWwgYnl0ZXMgZm9yIHRoaXMgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3JlYWRPZmZzZXRdIHRoZSBzdGFydGluZyByZWFkIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IDApLlxuICogICAgICAgICAgW3dyaXRlT2Zmc2V0XSB0aGUgc3RhcnRpbmcgd3JpdGUgb2Zmc2V0IHRvIHVzZSAoZGVmYXVsdDogdGhlXG4gKiAgICAgICAgICAgIGxlbmd0aCBvZiB0aGUgZmlyc3QgcGFyYW1ldGVyKS5cbiAqICAgICAgICAgIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IHRvXG4gKiAgICAgICAgICAgIGFjY29tbW9kYXRlIHdyaXRlcyAoZGVmYXVsdDogMTAyNCkuXG4gKiAgICAgICAgICBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyAoJ2JpbmFyeScsICd1dGY4JywgJ3V0ZjE2JywgJ2hleCcpIGZvciB0aGVcbiAqICAgICAgICAgICAgZmlyc3QgcGFyYW1ldGVyLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICovXG5mdW5jdGlvbiBEYXRhQnVmZmVyKGIsIG9wdGlvbnMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvaW50ZXJzIGZvciByZWFkIGZyb20vd3JpdGUgdG8gYnVmZmVyXG4gIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZE9mZnNldCB8fCAwO1xuICB0aGlzLmdyb3dTaXplID0gb3B0aW9ucy5ncm93U2l6ZSB8fCAxMDI0O1xuXG4gIHZhciBpc0FycmF5QnVmZmVyID0gdXRpbC5pc0FycmF5QnVmZmVyKGIpO1xuICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSB1dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpO1xuICBpZihpc0FycmF5QnVmZmVyIHx8IGlzQXJyYXlCdWZmZXJWaWV3KSB7XG4gICAgLy8gdXNlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgaWYoaXNBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgcmVhZC93cml0ZSBvZmZzZXQgYmFzZWQgb24gdGhlIHR5cGUgb2Ygdmlld1xuICAgICAgLy8gb3Igc3BlY2lmeSB0aGF0IHRoaXMgbXVzdCBiZSBkb25lIGluIHRoZSBvcHRpb25zIC4uLiB0aGF0IHRoZVxuICAgICAgLy8gb2Zmc2V0cyBhcmUgYnl0ZS1iYXNlZFxuICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIHRoaXMud3JpdGUgPSAoJ3dyaXRlT2Zmc2V0JyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMud3JpdGVPZmZzZXQgOiB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBlbXB0eSBhcnJheSBidWZmZXIgYW5kIGFkZCBhbnkgZ2l2ZW4gYnl0ZXMgdXNpbmcgcHV0Qnl0ZXNcbiAgdGhpcy5kYXRhID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIHRoaXMud3JpdGUgPSAwO1xuXG4gIGlmKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5wdXRCeXRlcyhiKTtcbiAgfVxuXG4gIGlmKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMud3JpdGUgPSBvcHRpb25zLndyaXRlT2Zmc2V0O1xuICB9XG59XG51dGlsLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xufTtcblxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoaXMgYnVmZmVyIGlzIGVtcHR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGJ1ZmZlciBpcyBlbXB0eSwgZmFsc2UgaWYgbm90LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbi8qKlxuICogRW5zdXJlcyB0aGlzIGJ1ZmZlciBoYXMgZW5vdWdoIGVtcHR5IHNwYWNlIHRvIGFjY29tbW9kYXRlIHRoZSBnaXZlbiBudW1iZXJcbiAqIG9mIGJ5dGVzLiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgbWF5IGJlIGdpdmVuIHRoYXQgaW5kaWNhdGVzIGEgbWluaW11bVxuICogYW1vdW50IHRvIGdyb3cgdGhlIGJ1ZmZlciBpZiBuZWNlc3NhcnkuIElmIHRoZSBwYXJhbWV0ZXIgaXMgbm90IGdpdmVuLFxuICogdGhlIGJ1ZmZlciB3aWxsIGJlIGdyb3duIGJ5IHNvbWUgcHJldmlvdXNseS1zcGVjaWZpZWQgZGVmYXVsdCBhbW91bnRcbiAqIG9yIGhldXJpc3RpYy5cbiAqXG4gKiBAcGFyYW0gYW1vdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gYWNjb21tb2RhdGUuXG4gKiBAcGFyYW0gW2dyb3dTaXplXSB0aGUgbWluaW11bSBhbW91bnQsIGluIGJ5dGVzLCB0byBncm93IHRoZSBidWZmZXIgYnkgaWZcbiAqICAgICAgICAgIG5lY2Vzc2FyeS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGFtb3VudCwgZ3Jvd1NpemUpIHtcbiAgaWYodGhpcy5sZW5ndGgoKSA+PSBhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncm93U2l6ZSA9IE1hdGgubWF4KGdyb3dTaXplIHx8IHRoaXMuZ3Jvd1NpemUsIGFtb3VudCk7XG5cbiAgLy8gZ3JvdyBidWZmZXJcbiAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KFxuICAgIHRoaXMuZGF0YS5idWZmZXIsIHRoaXMuZGF0YS5ieXRlT2Zmc2V0LCB0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7XG4gIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aCgpICsgZ3Jvd1NpemUpO1xuICBkc3Quc2V0KHNyYyk7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QuYnVmZmVyKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KHRoaXMud3JpdGUrKywgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0aGlzLmRhdGEuc2V0VWludDgoYik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYnl0ZXMgaW4gdGhpcyBidWZmZXIuIFRoZSBieXRlcyBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcsIGFuXG4gKiBBcnJheUJ1ZmZlciwgYSBEYXRhVmlldywgb3IgYSBUeXBlZEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gcHV0LlxuICogQHBhcmFtIFtlbmNvZGluZ10gdGhlIGVuY29kaW5nIGZvciB0aGUgZmlyc3QgcGFyYW1ldGVyICgnYmluYXJ5JywgJ3V0ZjgnLFxuICogICAgICAgICAgJ3V0ZjE2JywgJ2hleCcpLCBpZiBpdCBpcyBhIHN0cmluZyAoZGVmYXVsdDogJ2JpbmFyeScpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYodXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgbGVuID0gc3JjLmJ5dGVMZW5ndGggLSBzcmMuYnl0ZU9mZnNldDtcbiAgICB0aGlzLmFjY29tbW9kYXRlKGxlbik7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyKTtcbiAgICBkc3Quc2V0KHNyYywgdGhpcy53cml0ZSk7XG4gICAgdGhpcy53cml0ZSArPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGJ5dGVzIGlzIGEgdXRpbC5EYXRhQnVmZmVyIG9yIGVxdWl2YWxlbnRcbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkRhdGFCdWZmZXIgfHxcbiAgICAodHlwZW9mIGJ5dGVzID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBieXRlcy5yZWFkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYnl0ZXMud3JpdGUgPT09ICdudW1iZXInICYmXG4gICAgdXRpbC5pc0FycmF5QnVmZmVyVmlldyhieXRlcy5kYXRhKSkpIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMuZGF0YS5ieXRlTGVuZ3RoLCBieXRlcy5yZWFkLCBieXRlcy5sZW5ndGgoKSk7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGRzdCA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgdGhpcy53cml0ZSk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZihieXRlcyBpbnN0YW5jZW9mIHV0aWwuQnl0ZVN0cmluZ0J1ZmZlcikge1xuICAgIC8vIGNvcHkgYmluYXJ5IHN0cmluZyBhbmQgcHJvY2VzcyBhcyB0aGUgc2FtZSBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYmVsb3dcbiAgICBieXRlcyA9IGJ5dGVzLmRhdGE7XG4gICAgZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgfVxuXG4gIC8vIHN0cmluZyBjb252ZXJzaW9uXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ2JpbmFyeSc7XG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgdmlldztcblxuICAgIC8vIGRlY29kZSBmcm9tIHN0cmluZ1xuICAgIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYnl0ZXMubGVuZ3RoIC8gMikpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5oZXguZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZihlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDQpICogMyk7XG4gICAgICB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUoYnl0ZXMsIHZpZXcsIHRoaXMud3JpdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTggYnl0ZXNcbiAgICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAvLyBlbmNvZGUgYXMgVVRGLTggdGhlbiBkZWNvZGUgc3RyaW5nIGFzIHJhdyBiaW5hcnlcbiAgICAgIGJ5dGVzID0gdXRpbC5lbmNvZGVVdGY4KGJ5dGVzKTtcbiAgICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgLy8gb25lIGJ5dGUgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGgpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5yYXcuZGVjb2RlKHZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIHRleHQgYXMgVVRGLTE2IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICAgIC8vIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyXG4gICAgICB0aGlzLmFjY29tbW9kYXRlKGJ5dGVzLmxlbmd0aCAqIDIpO1xuICAgICAgdmlldyA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC50ZXh0LnV0ZjE2LmVuY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxuXG4gIHRocm93IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMucHV0Qnl0ZXMoYnVmZmVyKTtcbiAgYnVmZmVyLmNsZWFyKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc3RyaW5nIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZyAoZGVmYXVsdDogJ3V0ZjE2JykuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCAndXRmMTYnKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDE2LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDE2LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpID4+IDggJiAweEZGRkYpO1xuICB0aGlzLmRhdGEuc2V0SW50OCh0aGlzLndyaXRlLCBpID4+IDE2ICYgMHhGRik7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGEuc2V0SW50MzIodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDI0LWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDI0LWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGksIHRydWUpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdGhpcy5hY2NvbW1vZGF0ZShuIC8gOCk7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSsrLCAoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLiBUd28nc1xuICogY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBuLWJpdCBpbnRlZ2VyLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkICsgMikpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQsIHRydWUpO1xuICB0aGlzLnJlYWQgKz0gMjtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MjQgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSAzLlxuICpcbiAqIEByZXR1cm4gdGhlIHVpbnQyNC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCkgXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQgKyAxLCB0cnVlKSA8PCA4KTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDQ7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGVcbiAqIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICAvLyBUT0RPOiBVc2UgKHJ2YWwgKiAweDEwMCkgaWYgYWRkaW5nIHN1cHBvcnQgZm9yIDMzIHRvIDUzIGJpdHMuXG4gICAgcnZhbCA9IChydmFsIDw8IDgpICsgdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspO1xuICAgIG4gLT0gODtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLCB1c2luZ1xuICogdHdvJ3MgY29tcGxlbWVudCwgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRTaWduZWRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIC8vIGdldEludCBjaGVja3MgblxuICB2YXIgeCA9IHRoaXMuZ2V0SW50KG4pO1xuICB2YXIgbWF4ID0gMiA8PCAobiAtIDIpO1xuICBpZih4ID49IG1heCkge1xuICAgIHggLT0gbWF4IDw8IDE7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuXG4vKipcbiAqIFJlYWRzIGJ5dGVzIG91dCBpbnRvIGEgVVRGLTggc3RyaW5nIGFuZCBjbGVhcnMgdGhlbSBmcm9tIHRoZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCwgdW5kZWZpbmVkIG9yIG51bGwgZm9yIGFsbC5cbiAqXG4gKiBAcmV0dXJuIGEgVVRGLTggc3RyaW5nIG9mIGJ5dGVzLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlIHRoaXMgbWV0aG9kLCBpdCBpcyBwb29ybHkgbmFtZWQgYW5kXG4gIC8vIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScpIHJlcGxhY2VzIGl0XG4gIC8vIGFkZCBhIHRvVHlwZWRBcnJheSgpL3RvQXJyYXlCdWZmZXIoKSBmdW5jdGlvblxuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dCBtb2RpZnlpbmdcbiAqIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIFVURi04IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkLCBhZGQgXCJnZXRTdHJpbmcoKVwiXG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCArIGkpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnNldEF0ID0gZnVuY3Rpb24oaSwgYikge1xuICB0aGlzLmRhdGEuc2V0VWludDgoaSwgYik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGJ5dGUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBsYXN0IGJ5dGUuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUgLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgdXRpbC5EYXRhQnVmZmVyKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDb21wYWN0cyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5yZWFkID4gMCkge1xuICAgIHZhciBzcmMgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLnJlYWQpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShzcmMuYnl0ZUxlbmd0aCk7XG4gICAgZHN0LnNldChzcmMpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhkc3QpO1xuICAgIHRoaXMud3JpdGUgLT0gdGhpcy5yZWFkO1xuICAgIHRoaXMucmVhZCA9IDA7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHRoaXMud3JpdGUgPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHJldHVybiBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9ICcnO1xuICBmb3IodmFyIGkgPSB0aGlzLnJlYWQ7IGkgPCB0aGlzLmRhdGEuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuZ2V0VWludDgoaSk7XG4gICAgaWYoYiA8IDE2KSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBiLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgdG8gYSBzdHJpbmcsIHVzaW5nIHRoZSBnaXZlbiBlbmNvZGluZy4gSWYgbm9cbiAqIGVuY29kaW5nIGlzIGdpdmVuLCAndXRmOCcgKFVURi04KSBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyB0byB1c2U6ICdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnLFxuICogICAgICAgICAgJ2Jhc2U2NCcgKGRlZmF1bHQ6ICd1dGY4JykuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgdGhpcy5yZWFkLCB0aGlzLmxlbmd0aCgpKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gZW5jb2RlIHRvIHN0cmluZ1xuICBpZihlbmNvZGluZyA9PT0gJ2JpbmFyeScgfHwgZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LnJhdy5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmhleC5lbmNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUodmlldyk7XG4gIH1cblxuICAvLyBkZWNvZGUgdG8gdGV4dFxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgcmV0dXJuIHV0aWwudGV4dC51dGY4LmRlY29kZSh2aWV3KTtcbiAgfVxuICBpZihlbmNvZGluZyA9PT0gJ3V0ZjE2Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmMTYuZGVjb2RlKHZpZXcpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xufTtcblxuLyoqIEVuZCBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgYnVmZmVyIHRoYXQgc3RvcmVzIGJ5dGVzLiBBIHZhbHVlIG1heSBiZSBnaXZlbiB0byBwdXQgaW50byB0aGVcbiAqIGJ1ZmZlciB0aGF0IGlzIGVpdGhlciBhIHN0cmluZyBvZiBieXRlcyBvciBhIFVURi0xNiBzdHJpbmcgdGhhdCB3aWxsXG4gKiBiZSBlbmNvZGVkIHVzaW5nIFVURi04ICh0byBkbyB0aGUgbGF0dGVyLCBzcGVjaWZ5ICd1dGY4JyBhcyB0aGUgZW5jb2RpbmcpLlxuICpcbiAqIEBwYXJhbSBbaW5wdXRdIHRoZSBieXRlcyB0byB3cmFwIChhcyBhIHN0cmluZykgb3IgYSBVVEYtMTYgc3RyaW5nIHRvIGVuY29kZVxuICogICAgICAgICAgYXMgVVRGLTguXG4gKiBAcGFyYW0gW2VuY29kaW5nXSAoZGVmYXVsdDogJ3JhdycsIG90aGVyOiAndXRmOCcpLlxuICovXG51dGlsLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGlucHV0LCBlbmNvZGluZykge1xuICAvLyBUT0RPOiBkZXByZWNhdGUsIHVzZSBuZXcgQnl0ZUJ1ZmZlcigpIGluc3RlYWRcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCAncmF3JztcbiAgaWYoaW5wdXQgIT09IHVuZGVmaW5lZCAmJiBlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgaW5wdXQgPSB1dGlsLmVuY29kZVV0ZjgoaW5wdXQpO1xuICB9XG4gIHJldHVybiBuZXcgdXRpbC5CeXRlQnVmZmVyKGlucHV0KTtcbn07XG5cbi8qKlxuICogRmlsbHMgYSBzdHJpbmcgd2l0aCBhIHBhcnRpY3VsYXIgdmFsdWUuIElmIHlvdSB3YW50IHRoZSBzdHJpbmcgdG8gYmUgYSBieXRlXG4gKiBzdHJpbmcsIHBhc3MgaW4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGVCeXRlKS5cbiAqXG4gKiBAcGFyYW0gYyB0aGUgY2hhcmFjdGVyIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoLCB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICogICAgICAgICAgdG8gZmlsbCB0aGUgc3RyaW5nIHdpdGggYSBieXRlIHZhbHVlLlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHZhbHVlIGMgdG8gZmlsbCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbGxlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZmlsbFN0cmluZyA9IGZ1bmN0aW9uKGMsIG4pIHtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgcyArPSBjO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYyArPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBwZXIgYnl0ZSBYT1IgYmV0d2VlbiB0d28gYnl0ZSBzdHJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYVxuICogc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzMSBmaXJzdCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gczIgc2Vjb25kIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gWE9SLlxuICpcbiAqIEByZXR1cm4gdGhlIFhPUidkIHJlc3VsdC5cbiAqL1xudXRpbC54b3JCeXRlcyA9IGZ1bmN0aW9uKHMxLCBzMiwgbikge1xuICB2YXIgczMgPSAnJztcbiAgdmFyIGIgPSAnJztcbiAgdmFyIHQgPSAnJztcbiAgdmFyIGkgPSAwO1xuICB2YXIgYyA9IDA7XG4gIGZvcig7IG4gPiAwOyAtLW4sICsraSkge1xuICAgIGIgPSBzMS5jaGFyQ29kZUF0KGkpIF4gczIuY2hhckNvZGVBdChpKTtcbiAgICBpZihjID49IDEwKSB7XG4gICAgICBzMyArPSB0O1xuICAgICAgdCA9ICcnO1xuICAgICAgYyA9IDA7XG4gICAgfVxuICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiKTtcbiAgICArK2M7XG4gIH1cbiAgczMgKz0gdDtcbiAgcmV0dXJuIHMzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5oZXhUb0J5dGVzID0gZnVuY3Rpb24oaGV4KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmRlY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBydmFsID0gJyc7XG4gIHZhciBpID0gMDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEgPT0gMSkge1xuICAgIC8vIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgY29udmVydCBmaXJzdCBjaGFyYWN0ZXIgYWxvbmVcbiAgICBpID0gMTtcbiAgICBydmFsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4WzBdLCAxNikpO1xuICB9XG4gIC8vIGNvbnZlcnQgMiBjaGFyYWN0ZXJzICgxIGJ5dGUpIGF0IGEgdGltZVxuICBmb3IoOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gaGV4LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5ieXRlc1RvSGV4ID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5oZXguZW5jb2RlIGluc3RlYWQuXCJcbiAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKS50b0hleCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiAzMi1iaXQgaW50ZWdlciB0byA0LWJpZy1lbmRpYW4gYnl0ZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGkgdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBzdHJpbmcuXG4gKi9cbnV0aWwuaW50MzJUb0J5dGVzID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLy8gYmFzZTY0IGNoYXJhY3RlcnMsIHJldmVyc2UgbWFwcGluZ1xudmFyIF9iYXNlNjQgPVxuICAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xudmFyIF9iYXNlNjRJZHggPSBbXG4vKjQzIC00MyA9IDAqL1xuLyonKycsICAxLCAgMiwgIDMsJy8nICovXG4gICA2MiwgLTEsIC0xLCAtMSwgNjMsXG5cbi8qJzAnLCcxJywnMicsJzMnLCc0JywnNScsJzYnLCc3JywnOCcsJzknICovXG4gICA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA1OCwgNTksIDYwLCA2MSxcblxuLyoxNSwgMTYsIDE3LCc9JywgMTksIDIwLCAyMSAqL1xuICAtMSwgLTEsIC0xLCA2NCwgLTEsIC0xLCAtMSxcblxuLyo2NSAtIDQzID0gMjIqL1xuLyonQScsJ0InLCdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsICovXG4gICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLFxuXG4vKidOJywnTycsJ1AnLCdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJyAqL1xuICAgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsXG5cbi8qOTEgLSA0MyA9IDQ4ICovXG4vKjQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMgKi9cbiAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcblxuLyo5NyAtIDQzID0gNTQqL1xuLyonYScsJ2InLCdjJywnZCcsJ2UnLCdmJywnZycsJ2gnLCdpJywnaicsJ2snLCdsJywnbScgKi9cbiAgIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LFxuXG4vKiduJywnbycsJ3AnLCdxJywncicsJ3MnLCd0JywndScsJ3YnLCd3JywneCcsJ3knLCd6JyAqL1xuICAgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsIDQ5LCA1MCwgNTFcbl07XG5cbi8vIGJhc2U1OCBjaGFyYWN0ZXJzIChCaXRjb2luIGFscGhhYmV0KVxudmFyIF9iYXNlNTggPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG5cbi8qKlxuICogQmFzZTY0IGVuY29kZXMgYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJpbmFyeSBlbmNvZGVkIHN0cmluZyBvZiBieXRlcyB0byBiYXNlNjQtZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dC5cbiAqL1xudXRpbC5lbmNvZGU2NCA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuYmFzZTY0LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHZhciBsaW5lID0gJyc7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMiA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcbiAgICBjaHIzID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQgZGVjb2RlcyBhIHN0cmluZyBpbnRvIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlNjQtZW5jb2RlZCBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuZGVjb2RlNjQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgaW5zdGVhZC5cIlxuXG4gIC8vIHJlbW92ZSBhbGwgbm9uLWJhc2U2NCBjaGFyYWN0ZXJzXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csICcnKTtcblxuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCkpO1xuICAgIGlmKGVuYzMgIT09IDY0KSB7XG4gICAgICAvLyBkZWNvZGVkIGF0IGxlYXN0IDIgYnl0ZXNcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFVURi04IGVuY29kZXMgdGhlIGdpdmVuIFVURi0xNiBlbmNvZGVkIHN0cmluZyAoYSBzdGFuZGFyZCBKYXZhU2NyaXB0XG4gKiBzdHJpbmcpLiBOb24tQVNDSUkgY2hhcmFjdGVycyB3aWxsIGJlIGVuY29kZWQgYXMgbXVsdGlwbGUgYnl0ZXMgYWNjb3JkaW5nXG4gKiB0byBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFVURi04IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmVuY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIFVURi04IGVuY29kZWQgc3RyaW5nIGludG8gYSBVVEYtMTYgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgVVRGLTE2IGVuY29kZWQgc3RyaW5nIChzdGFuZGFyZCBKYXZhU2NyaXB0IHN0cmluZykuXG4gKi9cbnV0aWwuZGVjb2RlVXRmOCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn07XG5cbi8vIGJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyB0b29sc1xuLy8gRklYTUU6IEV4cGVyaW1lbnRhbC4gRG8gbm90IHVzZSB5ZXQuXG51dGlsLmJpbmFyeSA9IHtcbiAgcmF3OiB7fSxcbiAgaGV4OiB7fSxcbiAgYmFzZTY0OiB7fSxcbiAgYmFzZTU4OiB7fSxcbiAgYmFzZU4gOiB7XG4gICAgZW5jb2RlOiBiYXNlTi5lbmNvZGUsXG4gICAgZGVjb2RlOiBiYXNlTi5kZWNvZGVcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgVWludDhBcnJheSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy4gVGhpcyBlbmNvZGluZyB1c2VzXG4gKiBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1IGZvciBlYWNoIGNoYXJhY3Rlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5iaW5hcnkucmF3LmVuY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgYmluYXJ5LWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5kZWNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSAnYmluYXJ5JyBzdHJpbmcsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVHlwZWRBcnJheSwgb3JcbiAqIEJ5dGVCdWZmZXIgYXMgYSBzdHJpbmcgb2YgaGV4YWRlY2ltYWwgY2hhcmFjdGVycy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYmluYXJ5LmhleC5lbmNvZGUgPSB1dGlsLmJ5dGVzVG9IZXg7XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleC1lbmNvZGVkIHN0cmluZyB0byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGhleCB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5oZXguZGVjb2RlID0gZnVuY3Rpb24oaGV4LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBpID0gMCwgaiA9IG9mZnNldDtcbiAgaWYoaGV4Lmxlbmd0aCAmIDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgb3V0W2orK10gPSBwYXJzZUludChoZXhbMF0sIDE2KTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIEJhc2U2NC1lbmNvZGVzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2U2NC1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5ieXRlTGVuZ3RoKSB7XG4gICAgY2hyMSA9IGlucHV0W2krK107XG4gICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgY2hyMyA9IGlucHV0W2krK107XG5cbiAgICAvLyBlbmNvZGUgNCBjaGFyYWN0ZXIgZ3JvdXBcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KGNocjEgPj4gMik7XG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpKTtcbiAgICBpZihpc05hTihjaHIyKSkge1xuICAgICAgbGluZSArPSAnPT0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpKTtcbiAgICAgIGxpbmUgKz0gaXNOYU4oY2hyMykgPyAnPScgOiBfYmFzZTY0LmNoYXJBdChjaHIzICYgNjMpO1xuICAgIH1cblxuICAgIGlmKG1heGxpbmUgJiYgbGluZS5sZW5ndGggPiBtYXhsaW5lKSB7XG4gICAgICBvdXRwdXQgKz0gbGluZS5zdWJzdHIoMCwgbWF4bGluZSkgKyAnXFxyXFxuJztcbiAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cihtYXhsaW5lKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0ICs9IGxpbmU7XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQgc3RyaW5nLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDQpICogMyk7XG4gIH1cblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0O1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG5cbiAgd2hpbGUoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgIGVuYzEgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmMyID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMyA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzQgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcblxuICAgIG91dFtqKytdID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRbaisrXSA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuICAgICAgaWYoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgLy8gZGVjb2RlZCAzIGJ5dGVzXG4gICAgICAgIG91dFtqKytdID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSByZXN1bHQgaXMgdGhlIGV4YWN0IGRlY29kZWQgbGVuZ3RoXG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQuc3ViYXJyYXkoMCwgaik7XG59O1xuXG4vLyBhZGQgc3VwcG9ydCBmb3IgYmFzZTU4IGVuY29kaW5nL2RlY29kaW5nIHdpdGggQml0Y29pbiBhbHBoYWJldFxudXRpbC5iaW5hcnkuYmFzZTU4LmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBtYXhsaW5lKSB7XG4gIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlTi5lbmNvZGUoaW5wdXQsIF9iYXNlNTgsIG1heGxpbmUpO1xufTtcbnV0aWwuYmluYXJ5LmJhc2U1OC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZGVjb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG5cbi8vIHRleHQgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC50ZXh0ID0ge1xuICB1dGY4OiB7fSxcbiAgdXRmMTY6IHt9XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtOCBpbiBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwudGV4dC51dGY4LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgc3RyID0gdXRpbC5lbmNvZGVVdGY4KHN0cik7XG4gIHZhciBvdXQgPSBvdXRwdXQ7XG4gIGlmKCFvdXQpIHtcbiAgICBvdXQgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgfVxuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaisrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi04IGNvbnRlbnRzIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgVWludDhBcnJheSB0byBkZWNvZGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0aW5nIHN0cmluZy5cbiAqL1xudXRpbC50ZXh0LnV0ZjguZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWwuZGVjb2RlVXRmOChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKSk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBhcyBVVEYtMTYgaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmMTYuZW5jb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCAqIDIpO1xuICB9XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KG91dC5idWZmZXIpO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGogPSBvZmZzZXQ7XG4gIHZhciBrID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmlld1trKytdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaiArPSAyO1xuICB9XG4gIHJldHVybiBvdXRwdXQgPyAoaiAtIG9mZnNldCkgOiBvdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIFVURi0xNiBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGYxNi5kZWNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnl0ZXMuYnVmZmVyKSk7XG59O1xuXG4vKipcbiAqIERlZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSB0byByZXR1cm4gb25seSByYXcgZGVmbGF0ZSBkYXRhLCBmYWxzZSB0byBpbmNsdWRlIHpsaWJcbiAqICAgICAgICAgIGhlYWRlciBhbmQgdHJhaWxlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLlxuICovXG51dGlsLmRlZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgYnl0ZXMgPSB1dGlsLmRlY29kZTY0KGFwaS5kZWZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsKTtcblxuICAvLyBzdHJpcCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnlcbiAgaWYocmF3KSB7XG4gICAgLy8gemxpYiBoZWFkZXIgaXMgMiBieXRlcyAoQ01GLEZMRykgd2hlcmUgRkxHIGluZGljYXRlcyB0aGF0XG4gICAgLy8gdGhlcmUgaXMgYSA0LWJ5dGUgRElDVCAoYWxkZXItMzIpIGJsb2NrIGJlZm9yZSB0aGUgZGF0YSBpZlxuICAgIC8vIGl0cyA1dGggYml0IGlzIHNldFxuICAgIHZhciBzdGFydCA9IDI7XG4gICAgdmFyIGZsZyA9IGJ5dGVzLmNoYXJDb2RlQXQoMSk7XG4gICAgaWYoZmxnICYgMHgyMCkge1xuICAgICAgc3RhcnQgPSA2O1xuICAgIH1cbiAgICAvLyB6bGliIHRyYWlsZXIgaXMgNCBieXRlcyBvZiBhZGxlci0zMlxuICAgIGJ5dGVzID0gYnl0ZXMuc3Vic3RyaW5nKHN0YXJ0LCBieXRlcy5sZW5ndGggLSA0KTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogSW5mbGF0ZXMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgYSBmbGFzaCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLlxuICogQHBhcmFtIGJ5dGVzIHRoZSBkYXRhLlxuICogQHBhcmFtIHJhdyB0cnVlIGlmIHRoZSBpbmNvbWluZyBkYXRhIGhhcyBubyB6bGliIGhlYWRlciBvciB0cmFpbGVyIGFuZCBpc1xuICogICAgICAgICAgcmF3IERFRkxBVEUgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbmZsYXRlZCBkYXRhIGFzIGEgc3RyaW5nLCBudWxsIG9uIGVycm9yLlxuICovXG51dGlsLmluZmxhdGUgPSBmdW5jdGlvbihhcGksIGJ5dGVzLCByYXcpIHtcbiAgLy8gVE9ETzogYWRkIHpsaWIgaGVhZGVyIGFuZCB0cmFpbGVyIGlmIG5lY2Vzc2FyeS9wb3NzaWJsZVxuICB2YXIgcnZhbCA9IGFwaS5pbmZsYXRlKHV0aWwuZW5jb2RlNjQoYnl0ZXMpKS5ydmFsO1xuICByZXR1cm4gKHJ2YWwgPT09IG51bGwpID8gbnVsbCA6IHV0aWwuZGVjb2RlNjQocnZhbCk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzdG9yYWdlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gb2JqIHRoZSBzdG9yYWdlIG9iamVjdCwgbnVsbCB0byByZW1vdmUuXG4gKi9cbnZhciBfc2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQsIG9iaikge1xuICBpZighYXBpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gIH1cblxuICB2YXIgcnZhbDtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgcnZhbCA9IGFwaS5yZW1vdmVJdGVtKGlkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBqc29uLWVuY29kZSBhbmQgYmFzZTY0LWVuY29kZSBvYmplY3RcbiAgICBvYmogPSB1dGlsLmVuY29kZTY0KEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICAgIHJ2YWwgPSBhcGkuc2V0SXRlbShpZCwgb2JqKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBwb3RlbnRpYWwgZmxhc2ggZXJyb3JcbiAgaWYodHlwZW9mKHJ2YWwpICE9PSAndW5kZWZpbmVkJyAmJiBydmFsLnJ2YWwgIT09IHRydWUpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgZXJyb3IubmFtZSA9IHJ2YWwuZXJyb3IubmFtZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHN0b3JhZ2Ugb2JqZWN0IGVudHJ5IG9yIG51bGwgaWYgbm9uZSBleGlzdHMuXG4gKi9cbnZhciBfZ2V0U3RvcmFnZU9iamVjdCA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgLy8gZ2V0IHRoZSBleGlzdGluZyBlbnRyeVxuICB2YXIgcnZhbCA9IGFwaS5nZXRJdGVtKGlkKTtcblxuICAvKiBOb3RlOiBXZSBjaGVjayBhcGkuaW5pdCBiZWNhdXNlIHdlIGNhbid0IGRvIChhcGkgPT0gbG9jYWxTdG9yYWdlKVxuICAgIG9uIElFIGJlY2F1c2Ugb2YgXCJDbGFzcyBkb2Vzbid0IHN1cHBvcnQgQXV0b21hdGlvblwiIGV4Y2VwdGlvbi4gT25seVxuICAgIHRoZSBmbGFzaCBhcGkgaGFzIGFuIGluaXQgbWV0aG9kIHNvIHRoaXMgd29ya3MgdG9vLCBidXQgd2UgbmVlZCBhXG4gICAgYmV0dGVyIHNvbHV0aW9uIGluIHRoZSBmdXR1cmUuICovXG5cbiAgLy8gZmxhc2ggcmV0dXJucyBpdGVtIHdyYXBwZWQgaW4gYW4gb2JqZWN0LCBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gIGlmKGFwaS5pbml0KSB7XG4gICAgaWYocnZhbC5ydmFsID09PSBudWxsKSB7XG4gICAgICBpZihydmFsLmVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihydmFsLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5pZCA9IHJ2YWwuZXJyb3IuaWQ7XG4gICAgICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgLy8gbm8gZXJyb3IsIGJ1dCBhbHNvIG5vIGl0ZW1cbiAgICAgIHJ2YWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsID0gcnZhbC5ydmFsO1xuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBkZWNvZGluZ1xuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgLy8gYmFzZTY0LWRlY29kZSBhbmQganNvbi1kZWNvZGUgZGF0YVxuICAgIHJ2YWwgPSBKU09OLnBhcnNlKHV0aWwuZGVjb2RlNjQocnZhbCkpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFN0b3JlcyBhbiBpdGVtIGluIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKi9cbnZhciBfc2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgZGF0YSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogPT09IG51bGwpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3RvcmFnZSBvYmplY3RcbiAgICBvYmogPSB7fTtcbiAgfVxuICAvLyB1cGRhdGUga2V5XG4gIG9ialtrZXldID0gZGF0YTtcblxuICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnZhciBfZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIHJ2YWwgPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIHJldHVybiBkYXRhIGF0IGtleVxuICAgIHJ2YWwgPSAoa2V5IGluIHJ2YWwpID8gcnZhbFtrZXldIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKi9cbnZhciBfcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSkge1xuICAvLyBnZXQgc3RvcmFnZSBvYmplY3RcbiAgdmFyIG9iaiA9IF9nZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQpO1xuICBpZihvYmogIT09IG51bGwgJiYga2V5IGluIG9iaikge1xuICAgIC8vIHJlbW92ZSBrZXlcbiAgICBkZWxldGUgb2JqW2tleV07XG5cbiAgICAvLyBzZWUgaWYgZW50cnkgaGFzIG5vIGtleXMgcmVtYWluaW5nXG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmKGVtcHR5KSB7XG4gICAgICAvLyByZW1vdmUgZW50cnkgZW50aXJlbHkgaWYgbm8ga2V5cyBhcmUgbGVmdFxuICAgICAgb2JqID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc3RvcmFnZSBvYmplY3RcbiAgICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqL1xudmFyIF9jbGVhckl0ZW1zID0gZnVuY3Rpb24oYXBpLCBpZCkge1xuICBfc2V0U3RvcmFnZU9iamVjdChhcGksIGlkLCBudWxsKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBzdG9yYWdlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBmdW5jIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIGxvY2F0aW9uIHRoZSBsb2NhdGlvbiBhcmd1bWVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXG4gKi9cbnZhciBfY2FsbFN0b3JhZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIGxvY2F0aW9uKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBkZWZhdWx0IHN0b3JhZ2UgdHlwZXNcbiAgaWYodHlwZW9mKGxvY2F0aW9uKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhdGlvbiA9IFsnd2ViJywgJ2ZsYXNoJ107XG4gIH1cblxuICAvLyBhcHBseSBzdG9yYWdlIHR5cGVzIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAgdmFyIHR5cGU7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciBleGNlcHRpb24gPSBudWxsO1xuICBmb3IodmFyIGlkeCBpbiBsb2NhdGlvbikge1xuICAgIHR5cGUgPSBsb2NhdGlvbltpZHhdO1xuICAgIHRyeSB7XG4gICAgICBpZih0eXBlID09PSAnZmxhc2gnIHx8IHR5cGUgPT09ICdib3RoJykge1xuICAgICAgICBpZihhcmdzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGFzaCBsb2NhbCBzdG9yYWdlIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSAodHlwZSA9PT0gJ2ZsYXNoJyk7XG4gICAgICB9XG4gICAgICBpZih0eXBlID09PSAnd2ViJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgYXJnc1swXSA9IGxvY2FsU3RvcmFnZTtcbiAgICAgICAgcnZhbCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgIGV4Y2VwdGlvbiA9IGV4O1xuICAgIH1cbiAgICBpZihkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZighZG9uZSkge1xuICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFRoZSBhdmFpbGFibGUgdHlwZXMgb2YgbG9jYWwgc3RvcmFnZSBpbmNsdWRlICdmbGFzaCcsICd3ZWInLCBhbmQgJ2JvdGgnLlxuICpcbiAqIFRoZSB0eXBlICdmbGFzaCcgcmVmZXJzIHRvIGZsYXNoIGxvY2FsIHN0b3JhZ2UgKFNoYXJlZE9iamVjdCkuIEluIG9yZGVyXG4gKiB0byB1c2UgZmxhc2ggbG9jYWwgc3RvcmFnZSwgdGhlICdhcGknIHBhcmFtZXRlciBtdXN0IGJlIHZhbGlkLiBUaGUgdHlwZVxuICogJ3dlYicgcmVmZXJzIHRvIFdlYlN0b3JhZ2UsIGlmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHR5cGUgJ2JvdGgnXG4gKiByZWZlcnMgdG8gc3RvcmluZyB1c2luZyBib3RoICdmbGFzaCcgYW5kICd3ZWInLCBub3QganVzdCBvbmUgb3IgdGhlXG4gKiBvdGhlci5cbiAqXG4gKiBUaGUgbG9jYXRpb24gYXJyYXkgc2hvdWxkIGxpc3QgdGhlIHN0b3JhZ2UgdHlwZXMgdG8gdXNlIGluIG9yZGVyIG9mXG4gKiBwcmVmZXJlbmNlOlxuICpcbiAqIFsnZmxhc2gnXTogZmxhc2ggb25seSBzdG9yYWdlXG4gKiBbJ3dlYiddOiB3ZWIgb25seSBzdG9yYWdlXG4gKiBbJ2JvdGgnXTogdHJ5IHRvIHN0b3JlIGluIGJvdGhcbiAqIFsnZmxhc2gnLCd3ZWInXTogc3RvcmUgaW4gZmxhc2ggZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnd2ViJ1xuICogWyd3ZWInLCdmbGFzaCddOiBzdG9yZSBpbiB3ZWIgZmlyc3QsIGJ1dCBpZiBub3QgYXZhaWxhYmxlLCAnZmxhc2gnXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IGRlZmF1bHRzIHRvOiBbJ3dlYicsICdmbGFzaCddXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlLCBudWxsIHRvIHVzZSBvbmx5IFdlYlN0b3JhZ2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBkYXRhIHRoZSBkYXRhIGZvciB0aGUgaXRlbSAoYW55IGphdmFzY3JpcHQgb2JqZWN0L3ByaW1pdGl2ZSkuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLnNldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9zZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGl0ZW0uXG4gKi9cbnV0aWwuZ2V0SXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgcmV0dXJuIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9nZXRJdGVtLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIG9uIGxvY2FsIGRpc2suXG4gKlxuICogU2V0IHNldEl0ZW0oKSBmb3IgZGV0YWlscyBvbiBzdG9yYWdlIHR5cGVzLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5yZW1vdmVJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfcmVtb3ZlSXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbG9jYWwgZGlzayBzdG9yYWdlIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIElELlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UgaWYgZmxhc2ggaXMgYXZhaWxhYmxlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwuY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQsIGxvY2F0aW9uKSB7XG4gIF9jYWxsU3RvcmFnZUZ1bmN0aW9uKF9jbGVhckl0ZW1zLCBhcmd1bWVudHMsIGxvY2F0aW9uKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIHRoZSBzY2hlbWUsIGhvc3QsIGFuZCBwb3J0IGZyb20gYW4gaHR0cChzKSB1cmwuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgdXJsIHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgdXJsIG9iamVjdCBvciBudWxsIGlmIHRoZSB1cmwgaXMgaW52YWxpZC5cbiAqL1xudXRpbC5wYXJzZVVybCA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBGSVhNRTogdGhpcyByZWdleCBsb29rcyBhIGJpdCBicm9rZW5cbiAgdmFyIHJlZ2V4ID0gL14oaHR0cHM/KTpcXC9cXC8oW146Jl5cXC9dKik6PyhcXGQqKSguKikkL2c7XG4gIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gIHZhciBtID0gcmVnZXguZXhlYyhzdHIpO1xuICB2YXIgdXJsID0gKG0gPT09IG51bGwpID8gbnVsbCA6IHtcbiAgICBmdWxsOiBzdHIsXG4gICAgc2NoZW1lOiBtWzFdLFxuICAgIGhvc3Q6IG1bMl0sXG4gICAgcG9ydDogbVszXSxcbiAgICBwYXRoOiBtWzRdXG4gIH07XG4gIGlmKHVybCkge1xuICAgIHVybC5mdWxsSG9zdCA9IHVybC5ob3N0O1xuICAgIGlmKHVybC5wb3J0KSB7XG4gICAgICBpZih1cmwucG9ydCAhPT0gODAgJiYgdXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH0gZWxzZSBpZih1cmwucG9ydCAhPT0gNDQzICYmIHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsLmZ1bGxIb3N0ICs9ICc6JyArIHVybC5wb3J0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cCcpIHtcbiAgICAgIHVybC5wb3J0ID0gODA7XG4gICAgfSBlbHNlIGlmKHVybC5zY2hlbWUgPT09ICdodHRwcycpIHtcbiAgICAgIHVybC5wb3J0ID0gNDQzO1xuICAgIH1cbiAgICB1cmwuZnVsbCA9IHVybC5zY2hlbWUgKyAnOi8vJyArIHVybC5mdWxsSG9zdDtcbiAgfVxuICByZXR1cm4gdXJsO1xufTtcblxuLyogU3RvcmFnZSBmb3IgcXVlcnkgdmFyaWFibGVzICovXG52YXIgX3F1ZXJ5VmFyaWFibGVzID0gbnVsbDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aW5kb3cgbG9jYXRpb24gcXVlcnkgdmFyaWFibGVzLiBRdWVyeSBpcyBwYXJzZWQgb24gdGhlIGZpcnN0XG4gKiBjYWxsIGFuZCB0aGUgc2FtZSBvYmplY3QgaXMgcmV0dXJuZWQgb24gc3Vic2VxdWVudCBjYWxscy4gVGhlIG1hcHBpbmdcbiAqIGlzIGZyb20ga2V5cyB0byBhbiBhcnJheSBvZiB2YWx1ZXMuIFBhcmFtZXRlcnMgd2l0aG91dCB2YWx1ZXMgd2lsbCBoYXZlXG4gKiBhbiBvYmplY3Qga2V5IHNldCBidXQgbm8gdmFsdWUgYWRkZWQgdG8gdGhlIHZhbHVlIGFycmF5LiBWYWx1ZXMgYXJlXG4gKiB1bmVzY2FwZWQuXG4gKlxuICogLi4uP2sxPXYxJmsyPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxPXYyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCIsIFwidjJcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazI6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl0sXG4gKiAgIFwiazJcIjogW11cbiAqIH1cbiAqXG4gKiAuLi4/azE9djEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW1widjFcIl1cbiAqIH1cbiAqXG4gKiAuLi4/azEmazE6XG4gKiB7XG4gKiAgIFwiazFcIjogW11cbiAqIH1cbiAqXG4gKiBAcGFyYW0gcXVlcnkgdGhlIHF1ZXJ5IHN0cmluZyB0byBwYXJzZSAob3B0aW9uYWwsIGRlZmF1bHQgdG8gY2FjaGVkXG4gKiAgICAgICAgICByZXN1bHRzIGZyb20gcGFyc2luZyB3aW5kb3cgbG9jYXRpb24gc2VhcmNoIHF1ZXJ5KS5cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCBtYXBwaW5nIGtleXMgdG8gdmFyaWFibGVzLlxuICovXG51dGlsLmdldFF1ZXJ5VmFyaWFibGVzID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24ocSkge1xuICAgIHZhciBydmFsID0ge307XG4gICAgdmFyIGt2cGFpcnMgPSBxLnNwbGl0KCcmJyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGt2cGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBrdnBhaXJzW2ldLmluZGV4T2YoJz0nKTtcbiAgICAgIHZhciBrZXk7XG4gICAgICB2YXIgdmFsO1xuICAgICAgaWYocG9zID4gMCkge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICB2YWwgPSBrdnBhaXJzW2ldLnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGt2cGFpcnNbaV07XG4gICAgICAgIHZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZighKGtleSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2tleV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIC8vIGRpc2FsbG93IG92ZXJyaWRpbmcgb2JqZWN0IHByb3RvdHlwZSBrZXlzXG4gICAgICBpZighKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSAmJiB2YWwgIT09IG51bGwpIHtcbiAgICAgICAgcnZhbFtrZXldLnB1c2godW5lc2NhcGUodmFsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gICB2YXIgcnZhbDtcbiAgIGlmKHR5cGVvZihxdWVyeSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgIC8vIHNldCBjYWNoZWQgdmFyaWFibGVzIGlmIG5lZWRlZFxuICAgICBpZihfcXVlcnlWYXJpYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICBpZih0eXBlb2Yod2luZG93KSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgICAvLyBwYXJzZSB3aW5kb3cgc2VhcmNoIHF1ZXJ5XG4gICAgICAgICAgX3F1ZXJ5VmFyaWFibGVzID0gcGFyc2Uod2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcXVlcnkgdmFyaWFibGVzIGF2YWlsYWJsZVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHt9O1xuICAgICAgIH1cbiAgICAgfVxuICAgICBydmFsID0gX3F1ZXJ5VmFyaWFibGVzO1xuICAgfSBlbHNlIHtcbiAgICAgLy8gcGFyc2UgZ2l2ZW4gcXVlcnlcbiAgICAgcnZhbCA9IHBhcnNlKHF1ZXJ5KTtcbiAgIH1cbiAgIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBmcmFnbWVudCBpbnRvIGEgcGF0aCBhbmQgcXVlcnkuIFRoaXMgbWV0aG9kIHdpbGwgdGFrZSBhIFVSSVxuICogZnJhZ21lbnQgYW5kIGJyZWFrIGl0IHVwIGFzIGlmIGl0IHdlcmUgdGhlIG1haW4gVVJJLiBGb3IgZXhhbXBsZTpcbiAqICAgIC9iYXIvYmF6P2E9MSZiPTJcbiAqIHJlc3VsdHMgaW46XG4gKiAgICB7XG4gKiAgICAgICBwYXRoOiBbXCJiYXJcIiwgXCJiYXpcIl0sXG4gKiAgICAgICBxdWVyeToge1wiazFcIjogW1widjFcIl0sIFwiazJcIjogW1widjJcIl19XG4gKiAgICB9XG4gKlxuICogQHJldHVybiBvYmplY3Qgd2l0aCBhIHBhdGggYXJyYXkgYW5kIHF1ZXJ5IG9iamVjdC5cbiAqL1xudXRpbC5wYXJzZUZyYWdtZW50ID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgLy8gZGVmYXVsdCB0byB3aG9sZSBmcmFnbWVudFxuICB2YXIgZnAgPSBmcmFnbWVudDtcbiAgdmFyIGZxID0gJyc7XG4gIC8vIHNwbGl0IGludG8gcGF0aCBhbmQgcXVlcnkgaWYgcG9zc2libGUgYXQgdGhlIGZpcnN0ICc/J1xuICB2YXIgcG9zID0gZnJhZ21lbnQuaW5kZXhPZignPycpO1xuICBpZihwb3MgPiAwKSB7XG4gICAgZnAgPSBmcmFnbWVudC5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICBmcSA9IGZyYWdtZW50LnN1YnN0cmluZyhwb3MgKyAxKTtcbiAgfVxuICAvLyBzcGxpdCBwYXRoIGJhc2VkIG9uICcvJyBhbmQgaWdub3JlIGZpcnN0IGVsZW1lbnQgaWYgZW1wdHlcbiAgdmFyIHBhdGggPSBmcC5zcGxpdCgnLycpO1xuICBpZihwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aFswXSA9PT0gJycpIHtcbiAgICBwYXRoLnNoaWZ0KCk7XG4gIH1cbiAgLy8gY29udmVydCBxdWVyeSBpbnRvIG9iamVjdFxuICB2YXIgcXVlcnkgPSAoZnEgPT09ICcnKSA/IHt9IDogdXRpbC5nZXRRdWVyeVZhcmlhYmxlcyhmcSk7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoU3RyaW5nOiBmcCxcbiAgICBxdWVyeVN0cmluZzogZnEsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnlcbiAgfTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSByZXF1ZXN0IG91dCBvZiBhIFVSSS1saWtlIHJlcXVlc3Qgc3RyaW5nLiBUaGlzIGlzIGludGVuZGVkIHRvXG4gKiBiZSB1c2VkIHdoZXJlIGEgZnJhZ21lbnQgaWQgKGFmdGVyIGEgVVJJICcjJykgaXMgcGFyc2VkIGFzIGEgVVJJIHdpdGhcbiAqIHBhdGggYW5kIHF1ZXJ5IHBhcnRzLiBUaGUgc3RyaW5nIHNob3VsZCBoYXZlIGEgcGF0aCBiZWdpbm5pbmcgYW5kXG4gKiBkZWxpbWl0ZWQgYnkgJy8nIGFuZCBvcHRpb25hbCBxdWVyeSBwYXJhbWV0ZXJzIGZvbGxvd2luZyBhICc/Jy4gVGhlXG4gKiBxdWVyeSBzaG91bGQgYmUgYSBzdGFuZGFyZCBVUkwgc2V0IG9mIGtleSB2YWx1ZSBwYWlycyBkZWxpbWl0ZWQgYnlcbiAqICcmJy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRoZSBpbml0aWFsICcvJyBvbiB0aGUgcGF0aCBpcyBub3RcbiAqIHJlcXVpcmVkLiBUaGUgcmVxdWVzdCBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgQVBJLCAoZnVsbHkgZGVzY3JpYmVkXG4gKiBpbiB0aGUgbWV0aG9kIGNvZGUpOlxuICogICAge1xuICogICAgICAgcGF0aDogPHRoZSBwYXRoIHN0cmluZyBwYXJ0Pi5cbiAqICAgICAgIHF1ZXJ5OiA8dGhlIHF1ZXJ5IHN0cmluZyBwYXJ0PixcbiAqICAgICAgIGdldFBhdGgoaSk6IGdldCBwYXJ0IG9yIGFsbCBvZiB0aGUgc3BsaXQgcGF0aCBhcnJheSxcbiAqICAgICAgIGdldFF1ZXJ5KGssIGkpOiBnZXQgcGFydCBvciBhbGwgb2YgYSBxdWVyeSBrZXkgYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeUxhc3QoaywgX2RlZmF1bHQpOiBnZXQgbGFzdCBlbGVtZW50IG9mIGEgcXVlcnkga2V5IGFycmF5LlxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICovXG51dGlsLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxU3RyaW5nKSB7XG4gIHZhciBmcmFnID0gdXRpbC5wYXJzZUZyYWdtZW50KHJlcVN0cmluZyk7XG4gIHZhciByZXEgPSB7XG4gICAgLy8gZnVsbCBwYXRoIHN0cmluZ1xuICAgIHBhdGg6IGZyYWcucGF0aFN0cmluZyxcbiAgICAvLyBmdWxsIHF1ZXJ5IHN0cmluZ1xuICAgIHF1ZXJ5OiBmcmFnLnF1ZXJ5U3RyaW5nLFxuICAgIC8qKlxuICAgICAqIEdldCBwYXRoIG9yIGVsZW1lbnQgaW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHBhdGggaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHBhdGggb3IgcGFydCBvZiBwYXRoIGlmIGkgcHJvdmlkZWQuXG4gICAgICovXG4gICAgZ2V0UGF0aDogZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuICh0eXBlb2YoaSkgPT09ICd1bmRlZmluZWQnKSA/IGZyYWcucGF0aCA6IGZyYWcucGF0aFtpXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCBxdWVyeSwgdmFsdWVzIGZvciBhIGtleSwgb3IgdmFsdWUgZm9yIGEga2V5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGsgb3B0aW9uYWwgcXVlcnkga2V5LlxuICAgICAqIEBwYXJhbSBpIG9wdGlvbmFsIHF1ZXJ5IGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRRdWVyeTogZnVuY3Rpb24oaywgaSkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICBpZih0eXBlb2YoaykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IGZyYWcucXVlcnlba107XG4gICAgICAgIGlmKHJ2YWwgJiYgdHlwZW9mKGkpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICBydmFsID0gcnZhbFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcbiAgICBnZXRRdWVyeUxhc3Q6IGZ1bmN0aW9uKGssIF9kZWZhdWx0KSB7XG4gICAgICB2YXIgcnZhbDtcbiAgICAgIHZhciB2YWxzID0gcmVxLmdldFF1ZXJ5KGspO1xuICAgICAgaWYodmFscykge1xuICAgICAgICBydmFsID0gdmFsc1t2YWxzLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnZhbCA9IF9kZWZhdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIFVSSSBvdXQgb2YgYSBwYXRoLCBhbiBvYmplY3Qgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzLCBhbmQgYVxuICogZnJhZ21lbnQuIFVzZXMgalF1ZXJ5LnBhcmFtKCkgaW50ZXJuYWxseSBmb3IgcXVlcnkgc3RyaW5nIGNyZWF0aW9uLlxuICogSWYgdGhlIHBhdGggaXMgYW4gYXJyYXksIGl0IHdpbGwgYmUgam9pbmVkIHdpdGggJy8nLlxuICpcbiAqIEBwYXJhbSBwYXRoIHN0cmluZyBwYXRoIG9yIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gcXVlcnkgb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycy4gKG9wdGlvbmFsKVxuICogQHBhcmFtIGZyYWdtZW50IGZyYWdtZW50IHN0cmluZy4gKG9wdGlvbmFsKVxuICpcbiAqIEByZXR1cm4gc3RyaW5nIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlTGluayA9IGZ1bmN0aW9uKHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCkge1xuICAvLyBqb2luIHBhdGggcGFydHMgaWYgbmVlZGVkXG4gIHBhdGggPSBqUXVlcnkuaXNBcnJheShwYXRoKSA/IHBhdGguam9pbignLycpIDogcGF0aDtcblxuICB2YXIgcXN0ciA9IGpRdWVyeS5wYXJhbShxdWVyeSB8fCB7fSk7XG4gIGZyYWdtZW50ID0gZnJhZ21lbnQgfHwgJyc7XG4gIHJldHVybiBwYXRoICtcbiAgICAoKHFzdHIubGVuZ3RoID4gMCkgPyAoJz8nICsgcXN0cikgOiAnJykgK1xuICAgICgoZnJhZ21lbnQubGVuZ3RoID4gMCkgPyAoJyMnICsgZnJhZ21lbnQpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb2xsb3dzIGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBzZXQgYSB2YWx1ZS5cbiAqIElmIGEga2V5IGRvZXMgbm90IGV4aXN0IG9yIGl0J3MgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgY3JlYXRlIGFuXG4gKiBvYmplY3QgaW4gaXQncyBwbGFjZS4gVGhpcyBjYW4gYmUgZGVzdHJ1Y3RpdmUgdG8gYSBvYmplY3QgdHJlZSBpZlxuICogbGVhZiBub2RlcyBhcmUgZ2l2ZW4gYXMgbm9uLWZpbmFsIHBhdGgga2V5cy5cbiAqIFVzZWQgdG8gYXZvaWQgZXhjZXB0aW9ucyBmcm9tIG1pc3NpbmcgcGFydHMgb2YgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgc3RhcnRpbmcgb2JqZWN0LlxuICogQHBhcmFtIGtleXMgYW4gYXJyYXkgb2Ygc3RyaW5nIGtleXMuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldC5cbiAqL1xudXRpbC5zZXRQYXRoID0gZnVuY3Rpb24ob2JqZWN0LCBrZXlzLCB2YWx1ZSkge1xuICAvLyBuZWVkIHRvIHN0YXJ0IGF0IGFuIG9iamVjdFxuICBpZih0eXBlb2Yob2JqZWN0KSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZShpIDwgbGVuKSB7XG4gICAgICB2YXIgbmV4dCA9IGtleXNbaSsrXTtcbiAgICAgIGlmKGkgPT0gbGVuKSB7XG4gICAgICAgIC8vIGxhc3RcbiAgICAgICAgb2JqZWN0W25leHRdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIHZhciBoYXNOZXh0ID0gKG5leHQgaW4gb2JqZWN0KTtcbiAgICAgICAgaWYoIWhhc05leHQgfHxcbiAgICAgICAgICAoaGFzTmV4dCAmJiB0eXBlb2Yob2JqZWN0W25leHRdKSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgKGhhc05leHQgJiYgb2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgIG9iamVjdFtuZXh0XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtuZXh0XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9sbG93cyBhIHBhdGggb2Yga2V5cyBkZWVwIGludG8gYW4gb2JqZWN0IGhpZXJhcmNoeSBhbmQgcmV0dXJuIGEgdmFsdWUuXG4gKiBJZiBhIGtleSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGFuIG9iamVjdCBpbiBpdCdzIHBsYWNlLlxuICogVXNlZCB0byBhdm9pZCBleGNlcHRpb25zIGZyb20gbWlzc2luZyBwYXJ0cyBvZiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBzdGFydGluZyBvYmplY3QuXG4gKiBAcGFyYW0ga2V5cyBhbiBhcnJheSBvZiBzdHJpbmcga2V5cy5cbiAqIEBwYXJhbSBfZGVmYXVsdCB2YWx1ZSB0byByZXR1cm4gaWYgcGF0aCBub3QgZm91bmQuXG4gKlxuICogQHJldHVybiB0aGUgdmFsdWUgYXQgdGhlIHBhdGggaWYgZm91bmQsIGVsc2UgZGVmYXVsdCBpZiBnaXZlbiwgZWxzZVxuICogICAgICAgICB1bmRlZmluZWQuXG4gKi9cbnV0aWwuZ2V0UGF0aCA9IGZ1bmN0aW9uKG9iamVjdCwga2V5cywgX2RlZmF1bHQpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gIHZhciBoYXNOZXh0ID0gdHJ1ZTtcbiAgd2hpbGUoaGFzTmV4dCAmJiBpIDwgbGVuICYmXG4gICAgdHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0ID0ga2V5c1tpKytdO1xuICAgIGhhc05leHQgPSBuZXh0IGluIG9iamVjdDtcbiAgICBpZihoYXNOZXh0KSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgfVxuICB9XG4gIHJldHVybiAoaGFzTmV4dCA/IG9iamVjdCA6IF9kZWZhdWx0KTtcbn07XG5cbi8qKlxuICogRm9sbG93IGEgcGF0aCBvZiBrZXlzIGRlZXAgaW50byBhbiBvYmplY3QgaGllcmFyY2h5IGFuZCBkZWxldGUgdGhlXG4gKiBsYXN0IG9uZS4gSWYgYSBrZXkgZG9lcyBub3QgZXhpc3QsIGRvIG5vdGhpbmcuXG4gKiBVc2VkIHRvIGF2b2lkIGV4Y2VwdGlvbnMgZnJvbSBtaXNzaW5nIHBhcnRzIG9mIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgdGhlIHN0YXJ0aW5nIG9iamVjdC5cbiAqIEBwYXJhbSBrZXlzIGFuIGFycmF5IG9mIHN0cmluZyBrZXlzLlxuICovXG51dGlsLmRlbGV0ZVBhdGggPSBmdW5jdGlvbihvYmplY3QsIGtleXMpIHtcbiAgLy8gbmVlZCB0byBzdGFydCBhdCBhbiBvYmplY3RcbiAgaWYodHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgdmFyIG5leHQgPSBrZXlzW2krK107XG4gICAgICBpZihpID09IGxlbikge1xuICAgICAgICAvLyBsYXN0XG4gICAgICAgIGRlbGV0ZSBvYmplY3RbbmV4dF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3JlXG4gICAgICAgIGlmKCEobmV4dCBpbiBvYmplY3QpIHx8XG4gICAgICAgICAgKHR5cGVvZihvYmplY3RbbmV4dF0pICE9PSAnb2JqZWN0JykgfHxcbiAgICAgICAgICAob2JqZWN0W25leHRdID09PSBudWxsKSkge1xuICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBUYWtlbiBmcm9tOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QtZnJvbS1qc29uLzY3OTkzNyM2Nzk5MzdcbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2hlY2suXG4gKi9cbnV0aWwuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgd2l0aCBzaW1wbGUgcHJpbnRmLXN0eWxlIGludGVycG9sYXRpb24uXG4gKlxuICogJSU6IGxpdGVyYWwgJyUnXG4gKiAlcywlbzogY29udmVydCBuZXh0IGFyZ3VtZW50IGludG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGZvcm1hdCB0aGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSAuLi4gYXJndW1lbnRzIHRvIGludGVycG9sYXRlIGludG8gdGhlIGZvcm1hdCBzdHJpbmcuXG4gKi9cbnV0aWwuZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gIHZhciByZSA9IC8lLi9nO1xuICAvLyBjdXJyZW50IG1hdGNoXG4gIHZhciBtYXRjaDtcbiAgLy8gY3VycmVudCBwYXJ0XG4gIHZhciBwYXJ0O1xuICAvLyBjdXJyZW50IGFyZyBpbmRleFxuICB2YXIgYXJnaSA9IDA7XG4gIC8vIGNvbGxlY3RlZCBwYXJ0cyB0byByZWNvbWJpbmUgbGF0ZXJcbiAgdmFyIHBhcnRzID0gW107XG4gIC8vIGxhc3QgaW5kZXggZm91bmRcbiAgdmFyIGxhc3QgPSAwO1xuICAvLyBsb29wIHdoaWxlIG1hdGNoZXMgcmVtYWluXG4gIHdoaWxlKChtYXRjaCA9IHJlLmV4ZWMoZm9ybWF0KSkpIHtcbiAgICBwYXJ0ID0gZm9ybWF0LnN1YnN0cmluZyhsYXN0LCByZS5sYXN0SW5kZXggLSAyKTtcbiAgICAvLyBkb24ndCBhZGQgZW1wdHkgc3RyaW5ncyAoaWUsIHBhcnRzIGJldHdlZW4gJXMlcylcbiAgICBpZihwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGxhc3QgPSByZS5sYXN0SW5kZXg7XG4gICAgLy8gc3dpdGNoIG9uICUgY29kZVxuICAgIHZhciBjb2RlID0gbWF0Y2hbMF1bMV07XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICBjYXNlICdvJzpcbiAgICAgIC8vIGNoZWNrIGlmIGVub3VnaCBhcmd1bWVudHMgd2VyZSBnaXZlblxuICAgICAgaWYoYXJnaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChhcmd1bWVudHNbYXJnaSsrICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaCgnPD8+Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBGSVhNRTogZG8gcHJvcGVyIGZvcm1hdGluZyBmb3IgbnVtYmVycywgZXRjXG4gICAgLy9jYXNlICdmJzpcbiAgICAvL2Nhc2UgJ2QnOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcGFydHMucHVzaCgnJScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcnRzLnB1c2goJzwlJyArIGNvZGUgKyAnPz4nKTtcbiAgICB9XG4gIH1cbiAgLy8gYWRkIHRyYWlsaW5nIHBhcnQgb2YgZm9ybWF0IHN0cmluZ1xuICBwYXJ0cy5wdXNoKGZvcm1hdC5zdWJzdHJpbmcobGFzdCkpO1xuICByZXR1cm4gcGFydHMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0NS9qYXZhc2NyaXB0LW51bWJlcmZvcm1hdC0tcG9ydGVkLWZyb20tcGhwL1xuICovXG51dGlsLmZvcm1hdE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciwgZGVjaW1hbHMsIGRlY19wb2ludCwgdGhvdXNhbmRzX3NlcCkge1xuICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxuICAvLyArICAgb3JpZ2luYWwgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBNaWNoYWVsIFdoaXRlIChodHRwOi8vY3Jlc3RpZGcuY29tKVxuICAvLyArICAgICBidWdmaXggYnk6IEJlbmphbWluIEx1cHRvblxuICAvLyArICAgICBidWdmaXggYnk6IEFsbGFuIEplbnNlbiAoaHR0cDovL3d3dy53aW50ZXJuZXQubm8pXG4gIC8vICsgICAgcmV2aXNlZCBieTogSm9uYXMgUmFvbmkgU29hcmVzIFNpbHZhIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyAqICAgICBleGFtcGxlIDE6IG51bWJlcl9mb3JtYXQoMTIzNC41Njc4LCAyLCAnLicsICcnKTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAxMjM0LjU3XG5cbiAgdmFyIG4gPSBudW1iZXIsIGMgPSBpc05hTihkZWNpbWFscyA9IE1hdGguYWJzKGRlY2ltYWxzKSkgPyAyIDogZGVjaW1hbHM7XG4gIHZhciBkID0gZGVjX3BvaW50ID09PSB1bmRlZmluZWQgPyAnLCcgOiBkZWNfcG9pbnQ7XG4gIHZhciB0ID0gdGhvdXNhbmRzX3NlcCA9PT0gdW5kZWZpbmVkID9cbiAgICcuJyA6IHRob3VzYW5kc19zZXAsIHMgPSBuIDwgMCA/ICctJyA6ICcnO1xuICB2YXIgaSA9IHBhcnNlSW50KChuID0gTWF0aC5hYnMoK24gfHwgMCkudG9GaXhlZChjKSksIDEwKSArICcnO1xuICB2YXIgaiA9IChpLmxlbmd0aCA+IDMpID8gaS5sZW5ndGggJSAzIDogMDtcbiAgcmV0dXJuIHMgKyAoaiA/IGkuc3Vic3RyKDAsIGopICsgdCA6ICcnKSArXG4gICAgaS5zdWJzdHIoaikucmVwbGFjZSgvKFxcZHszfSkoPz1cXGQpL2csICckMScgKyB0KSArXG4gICAgKGMgPyBkICsgTWF0aC5hYnMobiAtIGkpLnRvRml4ZWQoYykuc2xpY2UoMikgOiAnJyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgYSBieXRlIHNpemUuXG4gKlxuICogaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNTk0OS9mb3JtYXQtaHVtYW5pemUtZmlsZS1ieXRlLXNpemUtcHJlc2VudGF0aW9uLWluLWphdmFzY3JpcHQvXG4gKi9cbnV0aWwuZm9ybWF0U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYoc2l6ZSA+PSAxMDczNzQxODI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDczNzQxODI0LCAyLCAnLicsICcnKSArICcgR2lCJztcbiAgfSBlbHNlIGlmKHNpemUgPj0gMTA0ODU3Nikge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA0ODU3NiwgMiwgJy4nLCAnJykgKyAnIE1pQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwMjQpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwMjQsIDApICsgJyBLaUInO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplLCAwKSArICcgYnl0ZXMnO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBvciBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSA0LWJ5dGUgSVB2NiBvciAxNi1ieXRlIElQdjYgYWRkcmVzcyBvciBudWxsIGlmIHRoZSBhZGRyZXNzIGNhbid0XG4gKiAgICAgICAgIGJlIHBhcnNlZC5cbiAqL1xudXRpbC5ieXRlc0Zyb21JUCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlmKGlwLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc0Zyb21JUHY0KGlwKTtcbiAgfVxuICBpZihpcC5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NihpcCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NCBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NCA9IGZ1bmN0aW9uKGlwKSB7XG4gIGlwID0gaXAuc3BsaXQoJy4nKTtcbiAgaWYoaXAubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbnVtID0gcGFyc2VJbnQoaXBbaV0sIDEwKTtcbiAgICBpZihpc05hTihudW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5wdXRCeXRlKG51bSk7XG4gIH1cbiAgcmV0dXJuIGIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW50byBieXRlcyAoaW4gbmV0d29yayBvcmRlcikuXG4gKlxuICogQHBhcmFtIGlwIHRoZSBJUHY2IGFkZHJlc3MgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSAxNi1ieXRlIGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndCBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVB2NiA9IGZ1bmN0aW9uKGlwKSB7XG4gIHZhciBibGFua3MgPSAwO1xuICBpcCA9IGlwLnNwbGl0KCc6JykuZmlsdGVyKGZ1bmN0aW9uKGUpIHtcbiAgICBpZihlLmxlbmd0aCA9PT0gMCkgKytibGFua3M7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICB2YXIgemVyb3MgPSAoOCAtIGlwLmxlbmd0aCArIGJsYW5rcykgKiAyO1xuICB2YXIgYiA9IHV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICBpZighaXBbaV0gfHwgaXBbaV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBiLmZpbGxXaXRoQnl0ZSgwLCB6ZXJvcyk7XG4gICAgICB6ZXJvcyA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGJ5dGVzID0gdXRpbC5oZXhUb0J5dGVzKGlwW2ldKTtcbiAgICBpZihieXRlcy5sZW5ndGggPCAyKSB7XG4gICAgICBiLnB1dEJ5dGUoMCk7XG4gICAgfVxuICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciAxNi1ieXRlcyBpbnRvXG4gKiBhbiBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmUgaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiA0IG9yIDE2IGJ5dGVzLFxuICogICAgICAgICByZXNwZWN0aXZlbHksIGFyZSBnaXZlbiwgb3RoZXJ3aXNlIG51bGwuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgaWYoYnl0ZXMubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjQoYnl0ZXMpO1xuICB9XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICByZXR1cm4gdXRpbC5ieXRlc1RvSVB2NihieXRlcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDQtYnl0ZXMgaW50byBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpcCA9IFtdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpcC5wdXNoKGJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICB9XG4gIHJldHVybiBpcC5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIDE2LWJ5dGVzIGludG8gYW4gSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiBUaGUgYnl0ZXMgbXVzdCBiZVxuICogaW4gbmV0d29yayBvcmRlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgSVB2MTYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9yIG51bGwgZm9yIGFuIGludmFsaWQgIyBvZiBieXRlcy5cbiAqL1xudXRpbC5ieXRlc1RvSVB2NiA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgdmFyIHplcm9Hcm91cHMgPSBbXTtcbiAgdmFyIHplcm9NYXhHcm91cCA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBoZXggPSB1dGlsLmJ5dGVzVG9IZXgoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0pO1xuICAgIC8vIGNhbm9uaWNhbGl6ZSB6ZXJvIHJlcHJlc2VudGF0aW9uXG4gICAgd2hpbGUoaGV4WzBdID09PSAnMCcgJiYgaGV4ICE9PSAnMCcpIHtcbiAgICAgIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGlmKGhleCA9PT0gJzAnKSB7XG4gICAgICB2YXIgbGFzdCA9IHplcm9Hcm91cHNbemVyb0dyb3Vwcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpZHggPSBpcC5sZW5ndGg7XG4gICAgICBpZighbGFzdCB8fCBpZHggIT09IGxhc3QuZW5kICsgMSkge1xuICAgICAgICB6ZXJvR3JvdXBzLnB1c2goe3N0YXJ0OiBpZHgsIGVuZDogaWR4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LmVuZCA9IGlkeDtcbiAgICAgICAgaWYoKGxhc3QuZW5kIC0gbGFzdC5zdGFydCkgPlxuICAgICAgICAgICh6ZXJvR3JvdXBzW3plcm9NYXhHcm91cF0uZW5kIC0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLnN0YXJ0KSkge1xuICAgICAgICAgIHplcm9NYXhHcm91cCA9IHplcm9Hcm91cHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpcC5wdXNoKGhleCk7XG4gIH1cbiAgaWYoemVyb0dyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGdyb3VwID0gemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdO1xuICAgIC8vIG9ubHkgc2hvcnRlbiBncm91cCBvZiBsZW5ndGggPiAwXG4gICAgaWYoZ3JvdXAuZW5kIC0gZ3JvdXAuc3RhcnQgPiAwKSB7XG4gICAgICBpcC5zcGxpY2UoZ3JvdXAuc3RhcnQsIGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ICsgMSwgJycpO1xuICAgICAgaWYoZ3JvdXAuc3RhcnQgPT09IDApIHtcbiAgICAgICAgaXAudW5zaGlmdCgnJyk7XG4gICAgICB9XG4gICAgICBpZihncm91cC5lbmQgPT09IDcpIHtcbiAgICAgICAgaXAucHVzaCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpcC5qb2luKCc6Jyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHByb2Nlc3NlcyB0aGF0IGNhbiBiZSBydW4gY29uY3VycmVudGx5LiBJZlxuICogY3JlYXRpbmcgV2ViIFdvcmtlcnMsIGtlZXAgaW4gbWluZCB0aGF0IHRoZSBtYWluIEphdmFTY3JpcHQgcHJvY2VzcyBuZWVkc1xuICogaXRzIG93biBjb3JlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIHVwZGF0ZSB0cnVlIHRvIGZvcmNlIGFuIHVwZGF0ZSAobm90IHVzZSB0aGUgY2FjaGVkIHZhbHVlKS5cbiAqIEBwYXJhbSBjYWxsYmFjayhlcnIsIG1heCkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnV0aWwuZXN0aW1hdGVDb3JlcyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoJ2NvcmVzJyBpbiB1dGlsICYmICFvcHRpb25zLnVwZGF0ZSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICdoYXJkd2FyZUNvbmN1cnJlbmN5JyBpbiBuYXZpZ2F0b3IgJiZcbiAgICBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSA+IDApIHtcbiAgICB1dGlsLmNvcmVzID0gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gd29ya2VycyBub3QgYXZhaWxhYmxlXG4gICAgdXRpbC5jb3JlcyA9IDE7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG4gIGlmKHR5cGVvZiBCbG9iID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNhbid0IGVzdGltYXRlLCBkZWZhdWx0IHRvIDJcbiAgICB1dGlsLmNvcmVzID0gMjtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cblxuICAvLyBjcmVhdGUgd29ya2VyIGNvbmN1cnJlbmN5IGVzdGltYXRpb24gY29kZSBhcyBibG9iXG4gIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBydW4gd29ya2VyIGZvciA0IG1zXG4gICAgICAgIHZhciBzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBldCA9IHN0ICsgNDtcbiAgICAgICAgd2hpbGUoRGF0ZS5ub3coKSA8IGV0KTtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7c3Q6IHN0LCBldDogZXR9KTtcbiAgICAgIH0pO1xuICAgIH0udG9TdHJpbmcoKSxcbiAgJykoKSddLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfSkpO1xuXG4gIC8vIHRha2UgNSBzYW1wbGVzIHVzaW5nIDE2IHdvcmtlcnNcbiAgc2FtcGxlKFtdLCA1LCAxNik7XG5cbiAgZnVuY3Rpb24gc2FtcGxlKG1heCwgc2FtcGxlcywgbnVtV29ya2Vycykge1xuICAgIGlmKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIGdldCBvdmVybGFwIGF2ZXJhZ2VcbiAgICAgIHZhciBhdmcgPSBNYXRoLmZsb29yKG1heC5yZWR1Y2UoZnVuY3Rpb24oYXZnLCB4KSB7XG4gICAgICAgIHJldHVybiBhdmcgKyB4O1xuICAgICAgfSwgMCkgLyBtYXgubGVuZ3RoKTtcbiAgICAgIHV0aWwuY29yZXMgPSBNYXRoLm1heCgxLCBhdmcpO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVXJsKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgICB9XG4gICAgbWFwKG51bVdvcmtlcnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgbWF4LnB1c2gocmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpKTtcbiAgICAgIHNhbXBsZShtYXgsIHNhbXBsZXMgLSAxLCBudW1Xb3JrZXJzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcChudW1Xb3JrZXJzLCBjYWxsYmFjaykge1xuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXN1bHRzLnB1c2goZS5kYXRhKTtcbiAgICAgICAgaWYocmVzdWx0cy5sZW5ndGggPT09IG51bVdvcmtlcnMpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3b3JrZXJzLnB1c2god29ya2VyKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5wb3N0TWVzc2FnZShpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWR1Y2UobnVtV29ya2VycywgcmVzdWx0cykge1xuICAgIC8vIGZpbmQgb3ZlcmxhcHBpbmcgdGltZSB3aW5kb3dzXG4gICAgdmFyIG92ZXJsYXBzID0gW107XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IG51bVdvcmtlcnM7ICsrbikge1xuICAgICAgdmFyIHIxID0gcmVzdWx0c1tuXTtcbiAgICAgIHZhciBvdmVybGFwID0gb3ZlcmxhcHNbbl0gPSBbXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgICAgaWYobiA9PT0gaSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByMiA9IHJlc3VsdHNbaV07XG4gICAgICAgIGlmKChyMS5zdCA+IHIyLnN0ICYmIHIxLnN0IDwgcjIuZXQpIHx8XG4gICAgICAgICAgKHIyLnN0ID4gcjEuc3QgJiYgcjIuc3QgPCByMS5ldCkpIHtcbiAgICAgICAgICBvdmVybGFwLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZ2V0IG1heGltdW0gb3ZlcmxhcHMgLi4uIGRvbid0IGluY2x1ZGUgb3ZlcmxhcHBpbmcgd29ya2VyIGl0c2VsZlxuICAgIC8vIGFzIHRoZSBtYWluIEpTIHByb2Nlc3Mgd2FzIGFsc28gYmVpbmcgc2NoZWR1bGVkIGR1cmluZyB0aGUgd29yayBhbmRcbiAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSB0aGUgZXN0aW1hdGUgYW55d2F5XG4gICAgcmV0dXJuIG92ZXJsYXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIG92ZXJsYXApIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIG92ZXJsYXAubGVuZ3RoKTtcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBbiBBUEkgZm9yIHN0b3JpbmcgZGF0YSB1c2luZyB0aGUgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmVcbiAqIGZvcm1hdCB1c2luZyBERVIgKERpc3Rpbmd1aXNoZWQgRW5jb2RpbmcgUnVsZXMpIGVuY29kaW5nLiBUaGlzIGVuY29kaW5nIGlzXG4gKiBjb21tb25seSB1c2VkIHRvIHN0b3JlIGRhdGEgZm9yIFBLSSwgaS5lLiBYLjUwOSBDZXJ0aWZpY2F0ZXMsIGFuZCB0aGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBleGlzdHMgZm9yIHRoYXQgcHVycG9zZS5cbiAqXG4gKiBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZSAoQVNOLjEpIGlzIHVzZWQgdG8gZGVmaW5lIHRoZSBhYnN0cmFjdFxuICogc3ludGF4IG9mIGluZm9ybWF0aW9uIHdpdGhvdXQgcmVzdHJpY3RpbmcgdGhlIHdheSB0aGUgaW5mb3JtYXRpb24gaXMgZW5jb2RlZFxuICogZm9yIHRyYW5zbWlzc2lvbi4gSXQgcHJvdmlkZXMgYSBzdGFuZGFyZCB0aGF0IGFsbG93cyBmb3Igb3BlbiBzeXN0ZW1zXG4gKiBjb21tdW5pY2F0aW9uLiBBU04uMSBkZWZpbmVzIHRoZSBzeW50YXggb2YgaW5mb3JtYXRpb24gZGF0YSBhbmQgYSBudW1iZXIgb2ZcbiAqIHNpbXBsZSBkYXRhIHR5cGVzIGFzIHdlbGwgYXMgYSBub3RhdGlvbiBmb3IgZGVzY3JpYmluZyB0aGVtIGFuZCBzcGVjaWZ5aW5nXG4gKiB2YWx1ZXMgZm9yIHRoZW0uXG4gKlxuICogVGhlIFJTQSBhbGdvcml0aG0gY3JlYXRlcyBwdWJsaWMgYW5kIHByaXZhdGUga2V5cyB0aGF0IGFyZSBvZnRlbiBzdG9yZWQgaW5cbiAqIFguNTA5IG9yIFBLQ1MjWCBmb3JtYXRzIC0tIHdoaWNoIHVzZSBBU04uMSAoZW5jb2RlZCBpbiBERVIgZm9ybWF0KS4gVGhpc1xuICogY2xhc3MgcHJvdmlkZXMgdGhlIG1vc3QgYmFzaWMgZnVuY3Rpb25hbGl0eSByZXF1aXJlZCB0byBzdG9yZSBhbmQgbG9hZCBEU0FcbiAqIGtleXMgdGhhdCBhcmUgZW5jb2RlZCBhY2NvcmRpbmcgdG8gQVNOLjEuXG4gKlxuICogVGhlIG1vc3QgY29tbW9uIGJpbmFyeSBlbmNvZGluZ3MgZm9yIEFTTi4xIGFyZSBCRVIgKEJhc2ljIEVuY29kaW5nIFJ1bGVzKVxuICogYW5kIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykuIERFUiBpcyBqdXN0IGEgc3Vic2V0IG9mIEJFUiB0aGF0XG4gKiBoYXMgc3RyaWN0ZXIgcmVxdWlyZW1lbnRzIGZvciBob3cgZGF0YSBtdXN0IGJlIGVuY29kZWQuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgaGFzIGEgdGFnIChhIGJ5dGUgaWRlbnRpZnlpbmcgdGhlIEFTTi4xIHN0cnVjdHVyZSB0eXBlKVxuICogYW5kIGEgYnl0ZSBhcnJheSBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgQVNOMSBzdHJ1Y3R1cmUgd2hpY2ggbWF5IGJlIGRhdGEgb3IgYVxuICogbGlzdCBvZiBBU04uMSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEVhY2ggQVNOLjEgc3RydWN0dXJlIHVzaW5nIEJFUiBpcyAoVGFnLUxlbmd0aC1WYWx1ZSk6XG4gKlxuICogfCBieXRlIDAgfCBieXRlcyBYIHwgYnl0ZXMgWSB8XG4gKiB8LS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS1cbiAqIHwgIHRhZyAgIHwgbGVuZ3RoICB8ICB2YWx1ZSAgfFxuICpcbiAqIEFTTi4xIGFsbG93cyBmb3IgdGFncyB0byBiZSBvZiBcIkhpZ2gtdGFnLW51bWJlciBmb3JtXCIgd2hpY2ggYWxsb3dzIGEgdGFnIHRvXG4gKiBiZSB0d28gb3IgbW9yZSBvY3RldHMsIGJ1dCB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBjbGFzcy4gQSB0YWcgaXNcbiAqIG9ubHkgMSBieXRlLiBCaXRzIDEtNSBnaXZlIHRoZSB0YWcgbnVtYmVyIChpZSB0aGUgZGF0YSB0eXBlIHdpdGhpbiBhXG4gKiBwYXJ0aWN1bGFyICdjbGFzcycpLCA2IGluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgQVNOLjEgdmFsdWUgaXNcbiAqIGNvbnN0cnVjdGVkIGZyb20gb3RoZXIgQVNOLjEgdmFsdWVzLCBhbmQgYml0cyA3IGFuZCA4IGdpdmUgdGhlICdjbGFzcycuIElmXG4gKiBiaXRzIDcgYW5kIDggYXJlIGJvdGggemVybywgdGhlIGNsYXNzIGlzIFVOSVZFUlNBTC4gSWYgb25seSBiaXQgNyBpcyBzZXQsXG4gKiB0aGVuIHRoZSBjbGFzcyBpcyBBUFBMSUNBVElPTi4gSWYgb25seSBiaXQgOCBpcyBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzXG4gKiBDT05URVhUX1NQRUNJRklDLiBJZiBib3RoIGJpdHMgNyBhbmQgOCBhcmUgc2V0LCB0aGVuIHRoZSBjbGFzcyBpcyBQUklWQVRFLlxuICogVGhlIHRhZyBudW1iZXJzIGZvciB0aGUgZGF0YSB0eXBlcyBmb3IgdGhlIGNsYXNzIFVOSVZFUlNBTCBhcmUgbGlzdGVkIGJlbG93OlxuICpcbiAqIFVOSVZFUlNBTCAwIFJlc2VydmVkIGZvciB1c2UgYnkgdGhlIGVuY29kaW5nIHJ1bGVzXG4gKiBVTklWRVJTQUwgMSBCb29sZWFuIHR5cGVcbiAqIFVOSVZFUlNBTCAyIEludGVnZXIgdHlwZVxuICogVU5JVkVSU0FMIDMgQml0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA0IE9jdGV0c3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCA1IE51bGwgdHlwZVxuICogVU5JVkVSU0FMIDYgT2JqZWN0IGlkZW50aWZpZXIgdHlwZVxuICogVU5JVkVSU0FMIDcgT2JqZWN0IGRlc2NyaXB0b3IgdHlwZVxuICogVU5JVkVSU0FMIDggRXh0ZXJuYWwgdHlwZSBhbmQgSW5zdGFuY2Utb2YgdHlwZVxuICogVU5JVkVSU0FMIDkgUmVhbCB0eXBlXG4gKiBVTklWRVJTQUwgMTAgRW51bWVyYXRlZCB0eXBlXG4gKiBVTklWRVJTQUwgMTEgRW1iZWRkZWQtcGR2IHR5cGVcbiAqIFVOSVZFUlNBTCAxMiBVVEY4U3RyaW5nIHR5cGVcbiAqIFVOSVZFUlNBTCAxMyBSZWxhdGl2ZSBvYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgMTQtMTUgUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBlZGl0aW9uc1xuICogVU5JVkVSU0FMIDE2IFNlcXVlbmNlIGFuZCBTZXF1ZW5jZS1vZiB0eXBlc1xuICogVU5JVkVSU0FMIDE3IFNldCBhbmQgU2V0LW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTgtMjIsIDI1LTMwIENoYXJhY3RlciBzdHJpbmcgdHlwZXNcbiAqIFVOSVZFUlNBTCAyMy0yNCBUaW1lIHR5cGVzXG4gKlxuICogVGhlIGxlbmd0aCBvZiBhbiBBU04uMSBzdHJ1Y3R1cmUgaXMgc3BlY2lmaWVkIGFmdGVyIHRoZSB0YWcgaWRlbnRpZmllci5cbiAqIFRoZXJlIGlzIGEgZGVmaW5pdGUgZm9ybSBhbmQgYW4gaW5kZWZpbml0ZSBmb3JtLiBUaGUgaW5kZWZpbml0ZSBmb3JtIG1heVxuICogYmUgdXNlZCBpZiB0aGUgZW5jb2RpbmcgaXMgY29uc3RydWN0ZWQgYW5kIG5vdCBhbGwgaW1tZWRpYXRlbHkgYXZhaWxhYmxlLlxuICogVGhlIGluZGVmaW5pdGUgZm9ybSBpcyBlbmNvZGVkIHVzaW5nIGEgbGVuZ3RoIGJ5dGUgd2l0aCBvbmx5IHRoZSA4dGggYml0XG4gKiBzZXQuIFRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdGVkIG9iamVjdCBpcyBtYXJrZWQgdXNpbmcgZW5kLW9mLWNvbnRlbnRzXG4gKiBvY3RldHMgKHR3byB6ZXJvIGJ5dGVzKS5cbiAqXG4gKiBUaGUgZGVmaW5pdGUgZm9ybSBsb29rcyBsaWtlIHRoaXM6XG4gKlxuICogVGhlIGxlbmd0aCBtYXkgdGFrZSB1cCAxIG9yIG1vcmUgYnl0ZXMsIGl0IGRlcGVuZHMgb24gdGhlIGxlbmd0aCBvZiB0aGVcbiAqIHZhbHVlIG9mIHRoZSBBU04uMSBzdHJ1Y3R1cmUuIERFUiBlbmNvZGluZyByZXF1aXJlcyB0aGF0IGlmIHRoZSBBU04uMVxuICogc3RydWN0dXJlIGhhcyBhIHZhbHVlIHRoYXQgaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAxMjcsIG1vcmUgdGhhbiAxIGJ5dGVcbiAqIHdpbGwgYmUgdXNlZCB0byBzdG9yZSBpdHMgbGVuZ3RoLCBvdGhlcndpc2UganVzdCBvbmUgYnl0ZSB3aWxsIGJlIHVzZWQuXG4gKiBUaGlzIGlzIHN0cmljdC5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGxlc3MgdGhhbiAxMjcsIDEgb2N0ZXRcbiAqIChieXRlKSBpcyB1c2VkIHRvIHN0b3JlIHRoZSBcInNob3J0IGZvcm1cIiBsZW5ndGguIFRoZSA4dGggYml0IGhhcyBhIHZhbHVlIG9mXG4gKiAwIGluZGljYXRpbmcgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBhbmQgbm90IFwibG9uZyBmb3JtXCIgYW5kIGJpdHMgNy0xXG4gKiBnaXZlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEuIChUaGUgOHRoIGJpdCBpcyB0aGUgbGVmdC1tb3N0LCBtb3N0IHNpZ25pZmljYW50XG4gKiBiaXQ6IGFsc28ga25vd24gYXMgYmlnIGVuZGlhbiBvciBuZXR3b3JrIGZvcm1hdCkuXG4gKlxuICogSW4gdGhlIGNhc2UgdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZSBBU04uMSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gMTI3LCAyIHRvXG4gKiAxMjcgb2N0ZXRzIChieXRlcykgYXJlIHVzZWQgdG8gc3RvcmUgdGhlIFwibG9uZyBmb3JtXCIgbGVuZ3RoLiBUaGUgZmlyc3RcbiAqIGJ5dGUncyA4dGggYml0IGlzIHNldCB0byAxIHRvIGluZGljYXRlIHRoZSBsZW5ndGggaXMgXCJsb25nIGZvcm0uXCIgQml0cyA3LTFcbiAqIGdpdmUgdGhlIG51bWJlciBvZiBhZGRpdGlvbmFsIG9jdGV0cy4gQWxsIGZvbGxvd2luZyBvY3RldHMgYXJlIGluIGJhc2UgMjU2XG4gKiB3aXRoIHRoZSBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0ICh0eXBpY2FsIGJpZy1lbmRpYW4gYmluYXJ5IHVuc2lnbmVkXG4gKiBpbnRlZ2VyIHN0b3JhZ2UpLiBTbywgZm9yIGluc3RhbmNlLCBpZiB0aGUgbGVuZ3RoIG9mIGEgdmFsdWUgd2FzIDI1NywgdGhlXG4gKiBmaXJzdCBieXRlIHdvdWxkIGJlIHNldCB0bzpcbiAqXG4gKiAxMDAwMDAxMCA9IDEzMCA9IDB4ODIuXG4gKlxuICogVGhpcyBpbmRpY2F0ZXMgdGhlcmUgYXJlIDIgb2N0ZXRzIChiYXNlIDI1NikgZm9yIHRoZSBsZW5ndGguIFRoZSBzZWNvbmQgYW5kXG4gKiB0aGlyZCBieXRlcyAodGhlIG9jdGV0cyBqdXN0IG1lbnRpb25lZCkgd291bGQgc3RvcmUgdGhlIGxlbmd0aCBpbiBiYXNlIDI1NjpcbiAqXG4gKiBvY3RldCAyOiAwMDAwMDAwMSA9IDEgKiAyNTZeMSA9IDI1NlxuICogb2N0ZXQgMzogMDAwMDAwMDEgPSAxICogMjU2XjAgPSAxXG4gKiB0b3RhbCA9IDI1N1xuICpcbiAqIFRoZSBhbGdvcml0aG0gZm9yIGNvbnZlcnRpbmcgYSBqcyBpbnRlZ2VyIHZhbHVlIG9mIDI1NyB0byBiYXNlLTI1NiBpczpcbiAqXG4gKiB2YXIgdmFsdWUgPSAyNTc7XG4gKiB2YXIgYnl0ZXMgPSBbXTtcbiAqIGJ5dGVzWzBdID0gKHZhbHVlID4+PiA4KSAmIDB4RkY7IC8vIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdFxuICogYnl0ZXNbMV0gPSB2YWx1ZSAmIDB4RkY7ICAgICAgICAvLyBsZWFzdCBzaWduaWZpY2FudCBieXRlIGxhc3RcbiAqXG4gKiBPbiB0aGUgQVNOLjEgVU5JVkVSU0FMIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIHR5cGU6XG4gKlxuICogQW4gT0lEIGNhbiBiZSB3cml0dGVuIGxpa2U6IFwidmFsdWUxLnZhbHVlMi52YWx1ZTMuLi52YWx1ZU5cIlxuICpcbiAqIFRoZSBERVIgZW5jb2RpbmcgcnVsZXM6XG4gKlxuICogVGhlIGZpcnN0IGJ5dGUgaGFzIHRoZSB2YWx1ZSA0MCAqIHZhbHVlMSArIHZhbHVlMi5cbiAqIFRoZSBmb2xsb3dpbmcgYnl0ZXMsIGlmIGFueSwgZW5jb2RlIHRoZSByZW1haW5pbmcgdmFsdWVzLiBFYWNoIHZhbHVlIGlzXG4gKiBlbmNvZGVkIGluIGJhc2UgMTI4LCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0IGZpcnN0IChiaWcgZW5kaWFuKSwgd2l0aCBhc1xuICogZmV3IGRpZ2l0cyBhcyBwb3NzaWJsZSwgYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiBlYWNoIGJ5dGUgc2V0XG4gKiB0byAxIGV4Y2VwdCB0aGUgbGFzdCBpbiBlYWNoIHZhbHVlJ3MgZW5jb2RpbmcuIEZvciBleGFtcGxlOiBHaXZlbiB0aGVcbiAqIE9JRCBcIjEuMi44NDAuMTEzNTQ5XCIsIGl0cyBERVIgZW5jb2RpbmcgaXMgKHJlbWVtYmVyIGVhY2ggYnl0ZSBleGNlcHQgdGhlXG4gKiBsYXN0IG9uZSBpbiBlYWNoIGVuY29kaW5nIGlzIE9SJ2Qgd2l0aCAweDgwKTpcbiAqXG4gKiBieXRlIDE6IDQwICogMSArIDIgPSA0MiA9IDB4MkEuXG4gKiBieXRlcyAyLTM6IDEyOCAqIDYgKyA3MiA9IDg0MCA9IDYgNzIgPSA2IDcyID0gMHgwNjQ4ID0gMHg4NjQ4XG4gKiBieXRlcyA0LTY6IDE2Mzg0ICogNiArIDEyOCAqIDExOSArIDEzID0gNiAxMTkgMTMgPSAweDA2NzcwRCA9IDB4ODZGNzBEXG4gKlxuICogVGhlIGZpbmFsIHZhbHVlIGlzOiAweDJBODY0ODg2RjcwRC5cbiAqIFRoZSBmdWxsIE9JRCAoaW5jbHVkaW5nIEFTTi4xIHRhZyBhbmQgbGVuZ3RoIG9mIDYgYnl0ZXMpIGlzOlxuICogMHgwNjA2MkE4NjQ4ODZGNzBEXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLyogQVNOLjEgQVBJICovXG52YXIgYXNuMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYXNuMSA9IGZvcmdlLmFzbjEgfHwge307XG5cbi8qKlxuICogQVNOLjEgY2xhc3Nlcy5cbiAqL1xuYXNuMS5DbGFzcyA9IHtcbiAgVU5JVkVSU0FMOiAgICAgICAgMHgwMCxcbiAgQVBQTElDQVRJT046ICAgICAgMHg0MCxcbiAgQ09OVEVYVF9TUEVDSUZJQzogMHg4MCxcbiAgUFJJVkFURTogICAgICAgICAgMHhDMFxufTtcblxuLyoqXG4gKiBBU04uMSB0eXBlcy4gTm90IGFsbCB0eXBlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24sIG9ubHlcbiAqIHRob3NlIG5lY2Vzc2FyeSB0byBpbXBsZW1lbnQgYSBzaW1wbGUgUEtJIGFyZSBpbXBsZW1lbnRlZC5cbiAqL1xuYXNuMS5UeXBlID0ge1xuICBOT05FOiAgICAgICAgICAgICAwLFxuICBCT09MRUFOOiAgICAgICAgICAxLFxuICBJTlRFR0VSOiAgICAgICAgICAyLFxuICBCSVRTVFJJTkc6ICAgICAgICAzLFxuICBPQ1RFVFNUUklORzogICAgICA0LFxuICBOVUxMOiAgICAgICAgICAgICA1LFxuICBPSUQ6ICAgICAgICAgICAgICA2LFxuICBPREVTQzogICAgICAgICAgICA3LFxuICBFWFRFUk5BTDogICAgICAgICA4LFxuICBSRUFMOiAgICAgICAgICAgICA5LFxuICBFTlVNRVJBVEVEOiAgICAgIDEwLFxuICBFTUJFRERFRDogICAgICAgIDExLFxuICBVVEY4OiAgICAgICAgICAgIDEyLFxuICBST0lEOiAgICAgICAgICAgIDEzLFxuICBTRVFVRU5DRTogICAgICAgIDE2LFxuICBTRVQ6ICAgICAgICAgICAgIDE3LFxuICBQUklOVEFCTEVTVFJJTkc6IDE5LFxuICBJQTVTVFJJTkc6ICAgICAgIDIyLFxuICBVVENUSU1FOiAgICAgICAgIDIzLFxuICBHRU5FUkFMSVpFRFRJTUU6IDI0LFxuICBCTVBTVFJJTkc6ICAgICAgIDMwXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhZ0NsYXNzIHRoZSB0YWcgY2xhc3MgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gdHlwZSB0aGUgZGF0YSB0eXBlICh0YWcgbnVtYmVyKSBmb3IgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBjb25zdHJ1Y3RlZCB0cnVlIGlmIHRoZSBhc24xIG9iamVjdCBpcyBpbiBjb25zdHJ1Y3RlZCBmb3JtLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3IgdGhlIG9iamVjdCwgaWYgaXQgaXMgbm90IGNvbnN0cnVjdGVkLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYml0U3RyaW5nQ29udGVudHNdIHRoZSBwbGFpbiBCSVQgU1RSSU5HIGNvbnRlbnQgaW5jbHVkaW5nIHBhZGRpbmdcbiAqICAgICAgICAgICAgYnl0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jcmVhdGUgPSBmdW5jdGlvbih0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8qIEFuIGFzbjEgb2JqZWN0IGhhcyBhIHRhZ0NsYXNzLCBhIHR5cGUsIGEgY29uc3RydWN0ZWQgZmxhZywgYW5kIGFcbiAgICB2YWx1ZS4gVGhlIHZhbHVlJ3MgdHlwZSBkZXBlbmRzIG9uIHRoZSBjb25zdHJ1Y3RlZCBmbGFnLiBJZlxuICAgIGNvbnN0cnVjdGVkLCBpdCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG90aGVyIGFzbjEgb2JqZWN0cy4gSWYgbm90LFxuICAgIGl0IHdpbGwgY29udGFpbiB0aGUgQVNOLjEgdmFsdWUgYXMgYW4gYXJyYXkgb2YgYnl0ZXMgZm9ybWF0dGVkXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBBU04uMSBkYXRhIHR5cGUuICovXG5cbiAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG1wLnB1c2godmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBvYmogPSB7XG4gICAgdGFnQ2xhc3M6IHRhZ0NsYXNzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29uc3RydWN0ZWQ6IGNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBjb25zdHJ1Y3RlZCB8fCBmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xuICBpZihvcHRpb25zICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb3B0aW9ucykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICBvYmouYml0U3RyaW5nQ29udGVudHMgPSBvcHRpb25zLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgIC8vIFRPRE86IGFkZCByZWFkb25seSBmbGFnIHRvIGF2b2lkIHRoaXMgb3ZlcmhlYWRcbiAgICAvLyBzYXZlIGNvcHkgdG8gZGV0ZWN0IGNoYW5nZXNcbiAgICBvYmoub3JpZ2luYWwgPSBhc24xLmNvcHkob2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW4gYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvcHkgb3B0aW9uczpcbiAqICAgICAgICAgIFtleGNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gbm90IGNvcHkgYml0U3RyaW5nQ29udGVudHNcbiAqXG4gKiBAcmV0dXJuIHRoZSBhIGNvcHkgb2YgdGhlIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmNvcHkgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGNvcHk7XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICBjb3B5ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgY29weS5wdXNoKGFzbjEuY29weShvYmpbaV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29weSA9IHtcbiAgICB0YWdDbGFzczogb2JqLnRhZ0NsYXNzLFxuICAgIHR5cGU6IG9iai50eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBvYmouY29uc3RydWN0ZWQsXG4gICAgY29tcG9zZWQ6IG9iai5jb21wb3NlZCxcbiAgICB2YWx1ZTogYXNuMS5jb3B5KG9iai52YWx1ZSwgb3B0aW9ucylcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAhb3B0aW9ucy5leGNsdWRlQml0U3RyaW5nQ29udGVudHMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgY29weS5iaXRTdHJpbmdDb250ZW50cyA9IG9iai5iaXRTdHJpbmdDb250ZW50cztcbiAgfVxuICByZXR1cm4gY29weTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgYXNuMSBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBOb3RlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcnVuIGluIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIG9iajEgdGhlIGZpcnN0IGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIG9iajIgdGhlIHNlY29uZCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gY29tcGFyZSBvcHRpb25zOlxuICogICAgICAgICAgW2luY2x1ZGVCaXRTdHJpbmdDb250ZW50c10gdHJ1ZSB0byBjb21wYXJlIGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBhc24xIG9iamVjdHMgYXJlIGVxdWFsLlxuICovXG5hc24xLmVxdWFscyA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShvYmoyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKCFhc24xLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgIT09IHR5cGVvZiBvYmoyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIH1cblxuICB2YXIgZXF1YWwgPSBvYmoxLnRhZ0NsYXNzID09PSBvYmoyLnRhZ0NsYXNzICYmXG4gICAgb2JqMS50eXBlID09PSBvYmoyLnR5cGUgJiZcbiAgICBvYmoxLmNvbnN0cnVjdGVkID09PSBvYmoyLmNvbnN0cnVjdGVkICYmXG4gICAgb2JqMS5jb21wb3NlZCA9PT0gb2JqMi5jb21wb3NlZCAmJlxuICAgIGFzbjEuZXF1YWxzKG9iajEudmFsdWUsIG9iajIudmFsdWUpO1xuICBpZihvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgZXF1YWwgPSBlcXVhbCAmJiAob2JqMS5iaXRTdHJpbmdDb250ZW50cyA9PT0gb2JqMi5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH1cblxuICByZXR1cm4gZXF1YWw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGIgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIGJ5dGUgYnVmZmVyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdFxuICogICAgICAgICAgbGVuZ3RoIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbmFzbjEuZ2V0QmVyVmFsdWVMZW5ndGggPSBmdW5jdGlvbihiKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIHZhciBiMiA9IGIuZ2V0Qnl0ZSgpO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgbGVuZ3RoID0gYi5nZXRJbnQoKGIyICYgMHg3RikgPDwgMyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJ5dGUgYnVmZmVyIGhhcyBlbm91Z2ggYnl0ZXMuIFRocm93cyBhbiBFcnJvciBpZiBub3QuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgbXVzdCBoYXZlLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbikge1xuICBpZihuID4gcmVtYWluaW5nKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHBhcnNlIERFUi4nKTtcbiAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgZXJyb3IucmVxdWVzdGVkID0gbjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbnZhciBfZ2V0VmFsdWVMZW5ndGggPSBmdW5jdGlvbihieXRlcywgcmVtYWluaW5nKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIC8vIGZyb21EZXIgYWxyZWFkeSBjaGVja2VkIHRoYXQgdGhpcyBieXRlIGV4aXN0c1xuICB2YXIgYjIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIHJlbWFpbmluZy0tO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgdmFyIGxvbmdGb3JtQnl0ZXMgPSBiMiAmIDB4N0Y7XG4gICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIGxvbmdGb3JtQnl0ZXMpO1xuICAgIGxlbmd0aCA9IGJ5dGVzLmdldEludChsb25nRm9ybUJ5dGVzIDw8IDMpO1xuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHdpbGwgb25seSBoYXBwZW4gZm9yIDMyIGJpdCBnZXRJbnQgd2l0aCBoaWdoIGJpdCBzZXRcbiAgaWYobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgbGVuZ3RoOiAnICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogQHBhcmFtIFtvcHRpb25zXSBvYmplY3Qgd2l0aCBvcHRpb25zIG9yIGJvb2xlYW4gc3RyaWN0IGZsYWdcbiAqICAgICAgICAgIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZGVjb2RlQml0U3RyaW5nc10gdHJ1ZSB0byBhdHRlbXB0IHRvIGRlY29kZSB0aGUgY29udGVudCBvZlxuICogICAgICAgICAgICBCSVQgU1RSSU5HcyAobm90IE9DVEVUIFNUUklOR3MpIHVzaW5nIHN0cmljdCBtb2RlLiBOb3RlIHRoYXRcbiAqICAgICAgICAgICAgd2l0aG91dCBzY2hlbWEgc3VwcG9ydCB0byB1bmRlcnN0YW5kIHRoZSBkYXRhIGNvbnRleHQgdGhpcyBjYW5cbiAqICAgICAgICAgICAgZXJyb25lb3VzbHkgZGVjb2RlIHZhbHVlcyB0aGF0IGhhcHBlbiB0byBiZSB2YWxpZCBBU04uMS4gVGhpc1xuICogICAgICAgICAgICBmbGFnIHdpbGwgYmUgZGVwcmVjYXRlZCBvciByZW1vdmVkIGFzIHNvb24gYXMgc2NoZW1hIHN1cHBvcnQgaXNcbiAqICAgICAgICAgICAgYXZhaWxhYmxlLiAoZGVmYXVsdDogdHJ1ZSlcbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuZnJvbURlciA9IGZ1bmN0aW9uKGJ5dGVzLCBvcHRpb25zKSB7XG4gIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmKCEoJ3N0cmljdCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgaWYoISgnZGVjb2RlQml0U3RyaW5ncycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgPSB0cnVlO1xuICB9XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHJldHVybiBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb3NlZCA9IF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgc3ViT3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHVzZWQ7XG4gICAgICAgIGlmKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIHVzZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGFsbCBkZWNvZGVkIGFuZCB0aGUgY2xhc3MgaW5kaWNhdGVzIFVOSVZFUlNBTCBvclxuICAgICAgICAvLyBDT05URVhUX1NQRUNJRklDIHRoZW4gYXNzdW1lIHdlJ3ZlIGdvdCBhbiBlbmNhcHN1bGF0ZWQgQVNOLjEgb2JqZWN0XG4gICAgICAgIHZhciB0YyA9IGNvbXBvc2VkLnRhZ0NsYXNzO1xuICAgICAgICBpZih1c2VkID09PSBsZW5ndGggJiZcbiAgICAgICAgICAodGMgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8IHRjID09PSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbY29tcG9zZWRdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc3RvcmUgcmVhZCBwb3NpdGlvblxuICAgICAgYnl0ZXMucmVhZCA9IHNhdmVkUmVhZDtcbiAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhc24xIG5vdCBjb25zdHJ1Y3RlZCBvciBjb21wb3NlZCwgZ2V0IHJhdyB2YWx1ZVxuICAgIC8vIFRPRE86IGRvIERFUiB0byBPSUQgY29udmVyc2lvbiBhbmQgdmljZS12ZXJzYSBpbiAudG9EZXI/XG5cbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29uc3RydWN0ZWQgQVNOLjEgb2JqZWN0IG9mIGluZGVmaW5pdGUgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgICAgLy8gYmUgbGVuaWVudCBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgICBmb3IoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMikge1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXMuZ2V0SW50MTYoKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGJ5dGVzLmdldEJ5dGVzKGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyAgbnVsbCA6IHtcbiAgICBiaXRTdHJpbmdDb250ZW50czogYml0U3RyaW5nQ29udGVudHNcbiAgfTtcblxuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhc24xIG9iamVjdFxuICByZXR1cm4gYXNuMS5jcmVhdGUodGFnQ2xhc3MsIHR5cGUsIGNvbnN0cnVjdGVkLCB2YWx1ZSwgYXNuMU9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhc24xIG9iamVjdCB0byBhIGJ1ZmZlciBvZiBieXRlcyBpbiBERVIgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhc24xIHRoZSBhc24xIG9iamVjdCB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ1ZmZlciBvZiBieXRlcy5cbiAqL1xuYXNuMS50b0RlciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGJ1aWxkIHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IG9iai50YWdDbGFzcyB8IG9iai50eXBlO1xuXG4gIC8vIGZvciBzdG9yaW5nIHRoZSBBU04uMSB2YWx1ZVxuICB2YXIgdmFsdWUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIHVzZSBCSVQgU1RSSU5HIGNvbnRlbnRzIGlmIGF2YWlsYWJsZSBhbmQgZGF0YSBub3QgY2hhbmdlZFxuICB2YXIgdXNlQml0U3RyaW5nQ29udGVudHMgPSBmYWxzZTtcbiAgaWYoJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IHRydWU7XG4gICAgaWYob2JqLm9yaWdpbmFsKSB7XG4gICAgICB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGFzbjEuZXF1YWxzKG9iaiwgb2JqLm9yaWdpbmFsKTtcbiAgICB9XG4gIH1cblxuICBpZih1c2VCaXRTdHJpbmdDb250ZW50cykge1xuICAgIHZhbHVlLnB1dEJ5dGVzKG9iai5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH0gZWxzZSBpZihvYmouY29tcG9zZWQpIHtcbiAgICAvLyBpZiBjb21wb3NlZCwgdXNlIGVhY2ggY2hpbGQgYXNuMSBvYmplY3QncyBERVIgYnl0ZXMgYXMgdmFsdWVcbiAgICAvLyB0dXJuIG9uIDZ0aCBiaXQgKDB4MjAgPSAzMikgdG8gaW5kaWNhdGUgYXNuMSBpcyBjb25zdHJ1Y3RlZFxuICAgIC8vIGZyb20gb3RoZXIgYXNuMSBvYmplY3RzXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkKSB7XG4gICAgICBiMSB8PSAweDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0eXBlIGlzIGEgYml0IHN0cmluZywgYWRkIHVudXNlZCBiaXRzIG9mIDB4MDBcbiAgICAgIHZhbHVlLnB1dEJ5dGUoMHgwMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGFsbCBvZiB0aGUgY2hpbGQgREVSIGJ5dGVzIHRvZ2V0aGVyXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUucHV0QnVmZmVyKGFzbjEudG9EZXIob2JqLnZhbHVlW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhc24xLnZhbHVlIGRpcmVjdGx5XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUucHV0SW50MTYob2JqLnZhbHVlLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICAgICAgLy8gVE9ETzogc2hvdWxkIGFsbCBsZWFkaW5nIGJ5dGVzIGJlIHN0cmlwcGVkIHZzIGp1c3Qgb25lP1xuICAgICAgLy8gLi4gZXggJzAwIDAwIDAxJyA9PiAnMDEnP1xuICAgICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSICYmXG4gICAgICAgIG9iai52YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAoKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAwKSB8fFxuICAgICAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDApID09PSAweEZGICYmXG4gICAgICAgIChvYmoudmFsdWUuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICAgICAgdmFsdWUucHV0Qnl0ZXMob2JqLnZhbHVlLnN1YnN0cigxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCB0YWcgYnl0ZVxuICBieXRlcy5wdXRCeXRlKGIxKTtcblxuICAvLyB1c2UgXCJzaG9ydCBmb3JtXCIgZW5jb2RpbmdcbiAgaWYodmFsdWUubGVuZ3RoKCkgPD0gMTI3KSB7XG4gICAgLy8gb25lIGJ5dGUgZGVzY3JpYmVzIHRoZSBsZW5ndGhcbiAgICAvLyBiaXQgOCA9IDAgYW5kIGJpdHMgNy0xID0gbGVuZ3RoXG4gICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZS5sZW5ndGgoKSAmIDB4N0YpO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBcImxvbmcgZm9ybVwiIGVuY29kaW5nXG4gICAgLy8gMiB0byAxMjcgYnl0ZXMgZGVzY3JpYmUgdGhlIGxlbmd0aFxuICAgIC8vIGZpcnN0IGJ5dGU6IGJpdCA4ID0gMSBhbmQgYml0cyA3LTEgPSAjIG9mIGFkZGl0aW9uYWwgYnl0ZXNcbiAgICAvLyBvdGhlciBieXRlczogbGVuZ3RoIGluIGJhc2UgMjU2LCBiaWctZW5kaWFuXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCgpO1xuICAgIHZhciBsZW5CeXRlcyA9ICcnO1xuICAgIGRvIHtcbiAgICAgIGxlbkJ5dGVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuICYgMHhGRik7XG4gICAgICBsZW4gPSBsZW4gPj4+IDg7XG4gICAgfSB3aGlsZShsZW4gPiAwKTtcblxuICAgIC8vIHNldCBmaXJzdCBieXRlIHRvICMgYnl0ZXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIGFuZCB0dXJuIG9uXG4gICAgLy8gYml0IDggdG8gaW5kaWNhdGUgbG9uZy1mb3JtIGxlbmd0aCBpcyB1c2VkXG4gICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5sZW5ndGggfCAweDgwKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGxlbmd0aCBieXRlcyBpbiByZXZlcnNlIHNpbmNlIHRoZXkgd2VyZSBnZW5lcmF0ZWRcbiAgICAvLyBsaXR0bGUgZW5kaWFuIGFuZCB3ZSBuZWVkIGJpZyBlbmRpYW5cbiAgICBmb3IodmFyIGkgPSBsZW5CeXRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYnl0ZXMucHV0Qnl0ZShsZW5CeXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb25jYXRlbmF0ZSB2YWx1ZSBieXRlc1xuICBieXRlcy5wdXRCdWZmZXIodmFsdWUpO1xuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZyB0byBhIGJ5dGUgYnVmZmVyLiBUaGUgYnl0ZSBidWZmZXJcbiAqIGNvbnRhaW5zIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvciBsZW5ndGggYnl0ZXMuXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgYnVmZmVyLlxuICovXG5hc24xLm9pZFRvRGVyID0gZnVuY3Rpb24ob2lkKSB7XG4gIC8vIHNwbGl0IE9JRCBpbnRvIGluZGl2aWR1YWwgdmFsdWVzXG4gIHZhciB2YWx1ZXMgPSBvaWQuc3BsaXQoJy4nKTtcbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyBmaXJzdCBieXRlIGlzIDQwICogdmFsdWUxICsgdmFsdWUyXG4gIGJ5dGVzLnB1dEJ5dGUoNDAgKiBwYXJzZUludCh2YWx1ZXNbMF0sIDEwKSArIHBhcnNlSW50KHZhbHVlc1sxXSwgMTApKTtcbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIGxhc3QsIHZhbHVlQnl0ZXMsIHZhbHVlLCBiO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gcHJvZHVjZSB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyBob3cgbWFueVxuICAgIC8vIGJ5dGVzIGl0IHdpbGwgdGFrZSB0byBzdG9yZSB0aGUgdmFsdWVcbiAgICBsYXN0ID0gdHJ1ZTtcbiAgICB2YWx1ZUJ5dGVzID0gW107XG4gICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZXNbaV0sIDEwKTtcbiAgICBkbyB7XG4gICAgICBiID0gdmFsdWUgJiAweDdGO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA+Pj4gNztcbiAgICAgIC8vIGlmIHZhbHVlIGlzIG5vdCBsYXN0LCB0aGVuIHR1cm4gb24gOHRoIGJpdFxuICAgICAgaWYoIWxhc3QpIHtcbiAgICAgICAgYiB8PSAweDgwO1xuICAgICAgfVxuICAgICAgdmFsdWVCeXRlcy5wdXNoKGIpO1xuICAgICAgbGFzdCA9IGZhbHNlO1xuICAgIH0gd2hpbGUodmFsdWUgPiAwKTtcblxuICAgIC8vIGFkZCB2YWx1ZSBieXRlcyBpbiByZXZlcnNlIChuZWVkcyB0byBiZSBpbiBiaWcgZW5kaWFuKVxuICAgIGZvcih2YXIgbiA9IHZhbHVlQnl0ZXMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGJ5dGVzLnB1dEJ5dGUodmFsdWVCeXRlc1tuXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGFuIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy4gVGhlXG4gKiBieXRlIGJ1ZmZlciBzaG91bGQgY29udGFpbiBvbmx5IHRoZSBERVItZW5jb2RlZCB2YWx1ZSwgbm90IGFueSB0YWcgb3JcbiAqIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIE9JRCBkb3Qtc2VwYXJhdGVkIHN0cmluZy5cbiAqL1xuYXNuMS5kZXJUb09pZCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHZhciBvaWQ7XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgdmFyIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIG9pZCA9IE1hdGguZmxvb3IoYiAvIDQwKSArICcuJyArIChiICUgNDApO1xuXG4gIC8vIG90aGVyIGJ5dGVzIGFyZSBlYWNoIHZhbHVlIGluIGJhc2UgMTI4IHdpdGggOHRoIGJpdCBzZXQgZXhjZXB0IGZvclxuICAvLyB0aGUgbGFzdCBieXRlIGZvciBlYWNoIHZhbHVlXG4gIHZhciB2YWx1ZSA9IDA7XG4gIHdoaWxlKGJ5dGVzLmxlbmd0aCgpID4gMCkge1xuICAgIGIgPSBieXRlcy5nZXRCeXRlKCk7XG4gICAgdmFsdWUgPSB2YWx1ZSA8PCA3O1xuICAgIC8vIG5vdCB0aGUgbGFzdCBieXRlIGZvciB0aGUgdmFsdWVcbiAgICBpZihiICYgMHg4MCkge1xuICAgICAgdmFsdWUgKz0gYiAmIDB4N0Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxhc3QgYnl0ZVxuICAgICAgb2lkICs9ICcuJyArICh2YWx1ZSArIGIpO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvaWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVVRDVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogTm90ZTogR2VuZXJhbGl6ZWRUaW1lIGhhcyA0IGRpZ2l0cyBmb3IgdGhlIHllYXIgYW5kIGlzIHVzZWQgZm9yIFguNTA5XG4gKiBkYXRlcyBwYXN0IDIwNDkuIFBhcnNpbmcgdGhhdCBzdHJ1Y3R1cmUgaGFzbid0IGJlZW4gaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSB1dGMgdGhlIFVUQ1RpbWUgdmFsdWUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkYXRlLlxuICovXG5hc24xLnV0Y1RpbWVUb0RhdGUgPSBmdW5jdGlvbih1dGMpIHtcbiAgLyogVGhlIGZvbGxvd2luZyBmb3JtYXRzIGNhbiBiZSB1c2VkOlxuXG4gICAgWVlNTUREaGhtbVpcbiAgICBZWU1NRERoaG1tK2hoJ21tJ1xuICAgIFlZTU1ERGhobW0taGgnbW0nXG4gICAgWVlNTUREaGhtbXNzWlxuICAgIFlZTU1ERGhobW1zcytoaCdtbSdcbiAgICBZWU1NRERoaG1tc3MtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCB0d28gZGlnaXRzIG9mIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgLy8gaWYgWVkgPj0gNTAgdXNlIDE5eHgsIGlmIFlZIDwgNTAgdXNlIDIweHhcbiAgdmFyIHllYXIgPSBwYXJzZUludCh1dGMuc3Vic3RyKDAsIDIpLCAxMCk7XG4gIHllYXIgPSAoeWVhciA+PSA1MCkgPyAxOTAwICsgeWVhciA6IDIwMDAgKyB5ZWFyO1xuICB2YXIgTU0gPSBwYXJzZUludCh1dGMuc3Vic3RyKDIsIDIpLCAxMCkgLSAxOyAvLyB1c2UgMC0xMSBmb3IgbW9udGhcbiAgdmFyIEREID0gcGFyc2VJbnQodXRjLnN1YnN0cig0LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludCh1dGMuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoOCwgMiksIDEwKTtcbiAgdmFyIHNzID0gMDtcblxuICAvLyBub3QganVzdCBZWU1NRERoaG1tWlxuICBpZih1dGMubGVuZ3RoID4gMTEpIHtcbiAgICAvLyBnZXQgY2hhcmFjdGVyIGFmdGVyIG1pbnV0ZXNcbiAgICB2YXIgYyA9IHV0Yy5jaGFyQXQoMTApO1xuICAgIHZhciBlbmQgPSAxMDtcblxuICAgIC8vIHNlZSBpZiBzZWNvbmRzIGFyZSBwcmVzZW50XG4gICAgaWYoYyAhPT0gJysnICYmIGMgIT09ICctJykge1xuICAgICAgLy8gZ2V0IHNlY29uZHNcbiAgICAgIHNzID0gcGFyc2VJbnQodXRjLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgICAgIGVuZCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBkYXRlXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgTU0sIEREKTtcbiAgZGF0ZS5zZXRVVENIb3VycyhoaCwgbW0sIHNzLCAwKTtcblxuICBpZihlbmQpIHtcbiAgICAvLyBnZXQgKy8tIGFmdGVyIGVuZCBvZiB0aW1lXG4gICAgYyA9IHV0Yy5jaGFyQXQoZW5kKTtcbiAgICBpZihjID09PSAnKycgfHwgYyA9PT0gJy0nKSB7XG4gICAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgMSwgMiksIDEwKTtcbiAgICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHZhciBvZmZzZXQgPSBoaG9mZnNldCAqIDYwICsgbW1vZmZzZXQ7XG4gICAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAgIC8vIGFwcGx5IG9mZnNldFxuICAgICAgaWYoYyA9PT0gJysnKSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSAtIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGdlbnRpbWUgdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlID0gZnVuY3Rpb24oZ2VudGltZSkge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWVlZTU1EREhITU1TU1xuICAgIFlZWVlNTURESEhNTVNTLmZmZlxuICAgIFlZWVlNTURESEhNTVNTWlxuICAgIFlZWVlNTURESEhNTVNTLmZmZlpcbiAgICBZWVlZTU1EREhITU1TUytoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYraGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MtaGgnbW0nXG4gICAgWVlZWU1NRERISE1NU1MuZmZmLWhoJ21tJ1xuXG4gICAgV2hlcmU6XG5cbiAgICBZWVlZIGlzIHRoZSB5ZWFyXG4gICAgTU0gaXMgdGhlIG1vbnRoICgwMSB0byAxMilcbiAgICBERCBpcyB0aGUgZGF5ICgwMSB0byAzMSlcbiAgICBoaCBpcyB0aGUgaG91ciAoMDAgdG8gMjMpXG4gICAgbW0gYXJlIHRoZSBtaW51dGVzICgwMCB0byA1OSlcbiAgICBzcyBhcmUgdGhlIHNlY29uZHMgKDAwIHRvIDU5KVxuICAgIC5mZmYgaXMgdGhlIHNlY29uZCBmcmFjdGlvbiwgYWNjdXJhdGUgdG8gdGhyZWUgZGVjaW1hbCBwbGFjZXNcbiAgICBaIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgR01ULCArIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXNcbiAgICBsYXRlciB0aGFuIEdNVCwgYW5kIC0gaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBlYXJsaWVyIHRoYW4gR01UXG4gICAgaGgnIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIGhvdXJzXG4gICAgbW0nIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IGZyb20gR01UIGluIG1pbnV0ZXMgKi9cbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gIHZhciBZWVlZID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMCwgNCksIDEwKTtcbiAgdmFyIE1NID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoNCwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig2LCAyKSwgMTApO1xuICB2YXIgaGggPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgbW0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMCwgMiksIDEwKTtcbiAgdmFyIHNzID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoMTIsIDIpLCAxMCk7XG4gIHZhciBmZmYgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIGlzVVRDID0gZmFsc2U7XG5cbiAgaWYoZ2VudGltZS5jaGFyQXQoZ2VudGltZS5sZW5ndGggLSAxKSA9PT0gJ1onKSB7XG4gICAgaXNVVEMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVuZCA9IGdlbnRpbWUubGVuZ3RoIC0gNSwgYyA9IGdlbnRpbWUuY2hhckF0KGVuZCk7XG4gIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAvLyBnZXQgaG91cnMrbWludXRlcyBvZmZzZXRcbiAgICB2YXIgaGhvZmZzZXQgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgIHZhciBtbW9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDQsIDIpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICBvZmZzZXQgKj0gNjAwMDA7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBpZihjID09PSAnKycpIHtcbiAgICAgIG9mZnNldCAqPSAtMTtcbiAgICB9XG5cbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICAvLyBjaGVjayBmb3Igc2Vjb25kIGZyYWN0aW9uXG4gIGlmKGdlbnRpbWUuY2hhckF0KDE0KSA9PT0gJy4nKSB7XG4gICAgZmZmID0gcGFyc2VGbG9hdChnZW50aW1lLnN1YnN0cigxNCksIDEwKSAqIDEwMDA7XG4gIH1cblxuICBpZihpc1VUQykge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG5cbiAgICAvLyBhcHBseSBvZmZzZXRcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBvZmZzZXQpO1xuICB9IGVsc2Uge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoWVlZWSwgTU0sIEREKTtcbiAgICBkYXRlLnNldEhvdXJzKGhoLCBtbSwgc3MsIGZmZik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkYXRlIHRvIGEgVVRDVGltZSB2YWx1ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gQ29udmVydGluZyB0byBhIEdlbmVyYWxpemVkVGltZSBoYXNuJ3QgYmVlblxuICogaW1wbGVtZW50ZWQgeWV0LlxuICpcbiAqIEBwYXJhbSBkYXRlIHRoZSBkYXRlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgVVRDVGltZSB2YWx1ZS5cbiAqL1xuYXNuMS5kYXRlVG9VdGNUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWU1NRERoaG1tc3NaXG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgZm9ybWF0LnB1c2goKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKS5zdWJzdHIoMikpO1xuICBmb3JtYXQucHVzaCgnJyArIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDSG91cnMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENNaW51dGVzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDU2Vjb25kcygpKTtcblxuICAvLyBlbnN1cmUgMiBkaWdpdHMgYXJlIHVzZWQgZm9yIGVhY2ggZm9ybWF0IGVudHJ5XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBmb3JtYXQubGVuZ3RoOyArK2kpIHtcbiAgICBpZihmb3JtYXRbaV0ubGVuZ3RoIDwgMikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gZm9ybWF0W2ldO1xuICB9XG4gIHJ2YWwgKz0gJ1onO1xuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBHZW5lcmFsaXplZFRpbWUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBHZW5lcmFsaXplZFRpbWUgdmFsdWUgYXMgYSBzdHJpbmcuXG4gKi9cbmFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lID0gZnVuY3Rpb24oZGF0ZSkge1xuICAvLyBUT0RPOiB2YWxpZGF0ZTsgY3VycmVudGx5IGFzc3VtZXMgcHJvcGVyIGZvcm1hdFxuICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIHZhciBydmFsID0gJyc7XG5cbiAgLy8gY3JlYXRlIGZvcm1hdCBZWVlZTU1EREhITU1TU1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgamF2YXNjcmlwdCBpbnRlZ2VyIHRvIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYmUgdXNlZFxuICogYXMgdGhlIHZhbHVlIGZvciBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIHggdGhlIGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEuaW50ZWdlclRvRGVyID0gZnVuY3Rpb24oeCkge1xuICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIGlmKHggPj0gLTB4ODAgJiYgeCA8IDB4ODApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgOCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwICYmIHggPCAweDgwMDApIHtcbiAgICByZXR1cm4gcnZhbC5wdXRTaWduZWRJbnQoeCwgMTYpO1xuICB9XG4gIGlmKHggPj0gLTB4ODAwMDAwICYmIHggPCAweDgwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAyNCk7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAwMCAmJiB4IDwgMHg4MDAwMDAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAzMik7XG4gIH1cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIGVycm9yLmludGVnZXIgPSB4O1xuICB0aHJvdyBlcnJvcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBhIGphdmFzY3JpcHQgaW50ZWdlci4gVGhpcyBpc1xuICogdHlwaWNhbGx5IHVzZWQgdG8gZGVjb2RlIHRoZSB2YWx1ZSBvZiBhbiBJTlRFR0VSIHR5cGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG5hc24xLmRlclRvSW50ZWdlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIHdyYXAgaW4gYnVmZmVyIGlmIG5lZWRlZFxuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcyk7XG4gIH1cblxuICB2YXIgbiA9IGJ5dGVzLmxlbmd0aCgpICogODtcbiAgaWYobiA+IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlZ2VyIHRvbyBsYXJnZTsgbWF4IGlzIDMyLWJpdHMuJyk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzLmdldFNpZ25lZEludChuKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGdpdmVuIEFTTi4xIG9iamVjdCBpcyBhdCBsZWFzdCBhIHN1cGVyIHNldCBvZiB0aGVcbiAqIGdpdmVuIEFTTi4xIHN0cnVjdHVyZS4gT25seSB0YWcgY2xhc3NlcyBhbmQgdHlwZXMgYXJlIGNoZWNrZWQuIEFuXG4gKiBvcHRpb25hbCBtYXAgbWF5IGFsc28gYmUgcHJvdmlkZWQgdG8gY2FwdHVyZSBBU04uMSB2YWx1ZXMgd2hpbGUgdGhlXG4gKiBzdHJ1Y3R1cmUgaXMgY2hlY2tlZC5cbiAqXG4gKiBUbyBjYXB0dXJlIGFuIEFTTi4xIHZhbHVlLCBzZXQgYW4gb2JqZWN0IGluIHRoZSB2YWxpZGF0b3IncyAnY2FwdHVyZSdcbiAqIHBhcmFtZXRlciB0byB0aGUga2V5IHRvIHVzZSBpbiB0aGUgY2FwdHVyZSBtYXAuIFRvIGNhcHR1cmUgdGhlIGZ1bGxcbiAqIEFTTi4xIG9iamVjdCwgc3BlY2lmeSAnY2FwdHVyZUFzbjEnLiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIGluY2x1ZGluZ1xuICogdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLCBzcGVjaWZ5ICdjYXB0dXJlQml0U3RyaW5nQ29udGVudHMnLlxuICogVG8gY2FwdHVyZSBCSVQgU1RSSU5HIGJ5dGVzLCB3aXRob3V0IHRoZSBsZWFkaW5nIHVudXNlZCBiaXRzIGNvdW50ZXIgYnl0ZSxcbiAqIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZScuXG4gKlxuICogT2JqZWN0cyBpbiB0aGUgdmFsaWRhdG9yIG1heSBzZXQgYSBmaWVsZCAnb3B0aW9uYWwnIHRvIHRydWUgdG8gaW5kaWNhdGVcbiAqIHRoYXQgaXQgaXNuJ3QgbmVjZXNzYXJ5IHRvIHBhc3MgdmFsaWRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gdiB0aGUgQVNOLjEgc3RydWN0dXJlIHZhbGlkYXRvci5cbiAqIEBwYXJhbSBjYXB0dXJlIGFuIG9wdGlvbmFsIG1hcCB0byBjYXB0dXJlIHZhbHVlcyBpbi5cbiAqIEBwYXJhbSBlcnJvcnMgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIHN0b3JpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHJldHVybiB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmUuXG4gKi9cbmFzbjEudmFsaWRhdGUgPSBmdW5jdGlvbihvYmosIHYsIGNhcHR1cmUsIGVycm9ycykge1xuICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gIC8vIGVuc3VyZSB0YWcgY2xhc3MgYW5kIHR5cGUgYXJlIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICBpZigob2JqLnRhZ0NsYXNzID09PSB2LnRhZ0NsYXNzIHx8IHR5cGVvZih2LnRhZ0NsYXNzKSA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgKG9iai50eXBlID09PSB2LnR5cGUgfHwgdHlwZW9mKHYudHlwZSkgPT09ICd1bmRlZmluZWQnKSkge1xuICAgIC8vIGVuc3VyZSBjb25zdHJ1Y3RlZCBmbGFnIGlzIHRoZSBzYW1lIGlmIHNwZWNpZmllZFxuICAgIGlmKG9iai5jb25zdHJ1Y3RlZCA9PT0gdi5jb25zdHJ1Y3RlZCB8fFxuICAgICAgdHlwZW9mKHYuY29uc3RydWN0ZWQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcnZhbCA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBzdWIgdmFsdWVzXG4gICAgICBpZih2LnZhbHVlICYmIGZvcmdlLnV0aWwuaXNBcnJheSh2LnZhbHVlKSkge1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgJiYgaSA8IHYudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBydmFsID0gdi52YWx1ZVtpXS5vcHRpb25hbCB8fCBmYWxzZTtcbiAgICAgICAgICBpZihvYmoudmFsdWVbal0pIHtcbiAgICAgICAgICAgIHJ2YWwgPSBhc24xLnZhbGlkYXRlKG9iai52YWx1ZVtqXSwgdi52YWx1ZVtpXSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHYudmFsdWVbaV0ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgcnZhbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCFydmFsICYmIGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAgICAgICAnVGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgdi50eXBlICsgJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicgK1xuICAgICAgICAgICAgICB2LnZhbHVlLmxlbmd0aCArICdcIiwgZ290IFwiJyArXG4gICAgICAgICAgICAgIG9iai52YWx1ZS5sZW5ndGggKyAnXCInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocnZhbCAmJiBjYXB0dXJlKSB7XG4gICAgICAgIGlmKHYuY2FwdHVyZSkge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlXSA9IG9iai52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVBc24xKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVBc24xXSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZih2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50cyAmJiAnYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nQ29udGVudHNdID0gb2JqLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgIGlmKG9iai5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCB1bnVzZWQgYml0cyB3aXRoIGRhdGEgc2hpZnRpbmdcbiAgICAgICAgICAgIHZhciB1bnVzZWQgPSBvYmouYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmKHVudXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2NhcHR1cmVCaXRTdHJpbmdWYWx1ZSBvbmx5IHN1cHBvcnRlZCBmb3IgemVybyB1bnVzZWQgYml0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV0gPSBvYmouYml0U3RyaW5nQ29udGVudHMuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgY29uc3RydWN0ZWQgXCInICsgdi5jb25zdHJ1Y3RlZCArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai5jb25zdHJ1Y3RlZCArICdcIicpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGVycm9ycykge1xuICAgIGlmKG9iai50YWdDbGFzcyAhPT0gdi50YWdDbGFzcykge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdGFnIGNsYXNzIFwiJyArIHYudGFnQ2xhc3MgKyAnXCIsIGdvdCBcIicgK1xuICAgICAgICBvYmoudGFnQ2xhc3MgKyAnXCInKTtcbiAgICB9XG4gICAgaWYob2JqLnR5cGUgIT09IHYudHlwZSkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICdbJyArIHYubmFtZSArICddICcgK1xuICAgICAgICAnRXhwZWN0ZWQgdHlwZSBcIicgKyB2LnR5cGUgKyAnXCIsIGdvdCBcIicgKyBvYmoudHlwZSArICdcIicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8vIHJlZ2V4IGZvciB0ZXN0aW5nIGZvciBub24tbGF0aW4gY2hhcmFjdGVyc1xudmFyIF9ub25MYXRpblJlZ2V4ID0gL1teXFxcXHUwMDAwLVxcXFx1MDBmZl0vO1xuXG4vKipcbiAqIFByZXR0eSBwcmludHMgYW4gQVNOLjEgb2JqZWN0IHRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIG9iamVjdCB0byB3cml0ZSBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgdGhlIGxldmVsIGluIHRoZSB0cmVlLlxuICogQHBhcmFtIGluZGVudGF0aW9uIHRoZSBpbmRlbnRhdGlvbiB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nLlxuICovXG5hc24xLnByZXR0eVByaW50ID0gZnVuY3Rpb24ob2JqLCBsZXZlbCwgaW5kZW50YXRpb24pIHtcbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBzZXQgZGVmYXVsdCBsZXZlbCBhbmQgaW5kZW50YXRpb25cbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBpbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uIHx8IDI7XG5cbiAgLy8gc3RhcnQgbmV3IGxpbmUgZm9yIGRlZXAgbGV2ZWxzXG4gIGlmKGxldmVsID4gMCkge1xuICAgIHJ2YWwgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBjcmVhdGUgaW5kZW50XG4gIHZhciBpbmRlbnQgPSAnJztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxldmVsICogaW5kZW50YXRpb247ICsraSkge1xuICAgIGluZGVudCArPSAnICc7XG4gIH1cblxuICAvLyBwcmludCBjbGFzczp0eXBlXG4gIHJ2YWwgKz0gaW5kZW50ICsgJ1RhZzogJztcbiAgc3dpdGNoKG9iai50YWdDbGFzcykge1xuICBjYXNlIGFzbjEuQ2xhc3MuVU5JVkVSU0FMOlxuICAgIHJ2YWwgKz0gJ1VuaXZlcnNhbDonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQVBQTElDQVRJT046XG4gICAgcnZhbCArPSAnQXBwbGljYXRpb246JztcbiAgICBicmVhaztcbiAgY2FzZSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6XG4gICAgcnZhbCArPSAnQ29udGV4dC1TcGVjaWZpYzonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuUFJJVkFURTpcbiAgICBydmFsICs9ICdQcml2YXRlOic7XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZihvYmoudGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMKSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcblxuICAgIC8vIGtub3duIHR5cGVzXG4gICAgc3dpdGNoKG9iai50eXBlKSB7XG4gICAgY2FzZSBhc24xLlR5cGUuTk9ORTpcbiAgICAgIHJ2YWwgKz0gJyAoTm9uZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk9PTEVBTjpcbiAgICAgIHJ2YWwgKz0gJyAoQm9vbGVhbiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSU5URUdFUjpcbiAgICAgIHJ2YWwgKz0gJyAoSW50ZWdlciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQklUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCaXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PQ1RFVFNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoT2N0ZXQgc3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5OVUxMOlxuICAgICAgcnZhbCArPSAnIChOdWxsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PSUQ6XG4gICAgICBydmFsICs9ICcgKE9iamVjdCBJZGVudGlmaWVyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5PREVTQzpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IERlc2NyaXB0b3IpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkVYVEVSTkFMOlxuICAgICAgcnZhbCArPSAnIChFeHRlcm5hbCBvciBJbnN0YW5jZSBvZiknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUkVBTDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVhbCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU5VTUVSQVRFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW51bWVyYXRlZCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRU1CRURERUQ6XG4gICAgICBydmFsICs9ICcgKEVtYmVkZGVkIFBEViknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRGODpcbiAgICAgIHJ2YWwgKz0gJyAoVVRGOCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlNFUVVFTkNFOlxuICAgICAgcnZhbCArPSAnIChTZXF1ZW5jZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VUOlxuICAgICAgcnZhbCArPSAnIChTZXQpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORzpcbiAgICAgIHJ2YWwgKz0gJyAoUHJpbnRhYmxlIFN0cmluZyknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuSUE1U3RyaW5nOlxuICAgICAgcnZhbCArPSAnIChJQTVTdHJpbmcgKEFTQ0lJKSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuVVRDVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoVVRDIHRpbWUpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRTpcbiAgICAgIHJ2YWwgKz0gJyAoR2VuZXJhbGl6ZWQgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuQk1QU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChCTVAgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCArPSBvYmoudHlwZTtcbiAgfVxuXG4gIHJ2YWwgKz0gJ1xcbic7XG4gIHJ2YWwgKz0gaW5kZW50ICsgJ0NvbnN0cnVjdGVkOiAnICsgb2JqLmNvbnN0cnVjdGVkICsgJ1xcbic7XG5cbiAgaWYob2JqLmNvbXBvc2VkKSB7XG4gICAgdmFyIHN1YnZhbHVlcyA9IDA7XG4gICAgdmFyIHN1YiA9ICcnO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKG9iai52YWx1ZVtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YnZhbHVlcyArPSAxO1xuICAgICAgICBzdWIgKz0gYXNuMS5wcmV0dHlQcmludChvYmoudmFsdWVbaV0sIGxldmVsICsgMSwgaW5kZW50YXRpb24pO1xuICAgICAgICBpZigoaSArIDEpIDwgb2JqLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHN1YiArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbCArPSBpbmRlbnQgKyAnU3ViIHZhbHVlczogJyArIHN1YnZhbHVlcyArIHN1YjtcbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IGluZGVudCArICdWYWx1ZTogJztcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9JRCkge1xuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQob2JqLnZhbHVlKTtcbiAgICAgIHJ2YWwgKz0gb2lkO1xuICAgICAgaWYoZm9yZ2UucGtpICYmIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgIGlmKG9pZCBpbiBmb3JnZS5wa2kub2lkcykge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIGZvcmdlLnBraS5vaWRzW29pZF0gKyAnKSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuSU5URUdFUikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbCArPSBhc24xLmRlclRvSW50ZWdlcihvYmoudmFsdWUpO1xuICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICAgIC8vIFRPRE86IHNoaWZ0IGJpdHMgYXMgbmVlZGVkIHRvIGRpc3BsYXkgd2l0aG91dCBwYWRkaW5nXG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyByZW1vdmUgdW51c2VkIGJpdHMgZmllbGRcbiAgICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZS5zbGljZSgxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsICs9ICcobm9uZSknO1xuICAgICAgfVxuICAgICAgLy8gc2hvdyB1bnVzZWQgYml0IGNvdW50XG4gICAgICBpZihvYmoudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdW51c2VkID0gb2JqLnZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmKHVudXNlZCA9PSAxKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgxIHVudXNlZCBiaXQgc2hvd24pJztcbiAgICAgICAgfSBlbHNlIGlmKHVudXNlZCA+IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKCcgKyB1bnVzZWQgKyAnIHVudXNlZCBiaXRzIHNob3duKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5PQ1RFVFNUUklORykge1xuICAgICAgaWYoIV9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgICBydmFsICs9ICcoJyArIG9iai52YWx1ZSArICcpICc7XG4gICAgICB9XG4gICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICBydmFsICs9IGZvcmdlLnV0aWwuZGVjb2RlVXRmOChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgb2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JQTVTdHJpbmcpIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH0gZWxzZSBpZihfbm9uTGF0aW5SZWdleC50ZXN0KG9iai52YWx1ZSkpIHtcbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBydmFsICs9ICdbbnVsbF0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsICs9IG9iai52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogT2JqZWN0IElEcyBmb3IgQVNOLjEuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC41JywgJ3NlcmlhbE5hbWUnKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuMTAnLCAnb3JnYW5pemF0aW9uTmFtZScpO1xuX0lOKCcyLjUuNC4xMScsICdvcmdhbml6YXRpb25hbFVuaXROYW1lJyk7XG5fSU4oJzIuNS40LjEzJywgJ2Rlc2NyaXB0aW9uJyk7XG5cbi8vIFguNTA5IGV4dGVuc2lvbiBPSURzXG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMScsICduc0NlcnRUeXBlJyk7XG5fSV8oJzIuNS4yOS4xJywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zNVxuX0lfKCcyLjUuMjkuMicsICdrZXlBdHRyaWJ1dGVzJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS4zJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTsgLy8gZGVwcmVjYXRlZCwgdXNlIC4zMlxuX0lfKCcyLjUuMjkuNCcsICdrZXlVc2FnZVJlc3RyaWN0aW9uJyk7IC8vIG9ic29sZXRlIHVzZSAuMzcgb3IgLjE1XG5fSV8oJzIuNS4yOS41JywgJ3BvbGljeU1hcHBpbmcnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMzXG5fSV8oJzIuNS4yOS42JywgJ3N1YnRyZWVzQ29uc3RyYWludCcpOyAvLyBvYnNvbGV0ZSB1c2UgLjMwXG5fSV8oJzIuNS4yOS43JywgJ3N1YmplY3RBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xN1xuX0lfKCcyLjUuMjkuOCcsICdpc3N1ZXJBbHROYW1lJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4xOFxuX0lfKCcyLjUuMjkuOScsICdzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlcycpO1xuX0lfKCcyLjUuMjkuMTAnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JXygnMi41LjI5LjExJywgJ25hbWVDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzBcbl9JXygnMi41LjI5LjEyJywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zNlxuX0lfKCcyLjUuMjkuMTMnLCAnYmFzaWNDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTlcbl9JTignMi41LjI5LjE0JywgJ3N1YmplY3RLZXlJZGVudGlmaWVyJyk7XG5fSU4oJzIuNS4yOS4xNScsICdrZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuMTYnLCAncHJpdmF0ZUtleVVzYWdlUGVyaW9kJyk7XG5fSU4oJzIuNS4yOS4xNycsICdzdWJqZWN0QWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTgnLCAnaXNzdWVyQWx0TmFtZScpO1xuX0lOKCcyLjUuMjkuMTknLCAnYmFzaWNDb25zdHJhaW50cycpO1xuX0lfKCcyLjUuMjkuMjAnLCAnY1JMTnVtYmVyJyk7XG5fSV8oJzIuNS4yOS4yMScsICdjUkxSZWFzb24nKTtcbl9JXygnMi41LjI5LjIyJywgJ2V4cGlyYXRpb25EYXRlJyk7XG5fSV8oJzIuNS4yOS4yMycsICdpbnN0cnVjdGlvbkNvZGUnKTtcbl9JXygnMi41LjI5LjI0JywgJ2ludmFsaWRpdHlEYXRlJyk7XG5fSV8oJzIuNS4yOS4yNScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMxXG5fSV8oJzIuNS4yOS4yNicsICdpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnQnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjI4XG5fSV8oJzIuNS4yOS4yNycsICdkZWx0YUNSTEluZGljYXRvcicpO1xuX0lfKCcyLjUuMjkuMjgnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7XG5fSV8oJzIuNS4yOS4yOScsICdjZXJ0aWZpY2F0ZUlzc3VlcicpO1xuX0lfKCcyLjUuMjkuMzAnLCAnbmFtZUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zMScsICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKTtcbl9JTignMi41LjI5LjMyJywgJ2NlcnRpZmljYXRlUG9saWNpZXMnKTtcbl9JXygnMi41LjI5LjMzJywgJ3BvbGljeU1hcHBpbmdzJyk7XG5fSV8oJzIuNS4yOS4zNCcsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JTignMi41LjI5LjM1JywgJ2F1dGhvcml0eUtleUlkZW50aWZpZXInKTtcbl9JXygnMi41LjI5LjM2JywgJ3BvbGljeUNvbnN0cmFpbnRzJyk7XG5fSU4oJzIuNS4yOS4zNycsICdleHRLZXlVc2FnZScpO1xuX0lfKCcyLjUuMjkuNDYnLCAnZnJlc2hlc3RDUkwnKTtcbl9JXygnMi41LjI5LjU0JywgJ2luaGliaXRBbnlQb2xpY3knKTtcblxuLy8gZXh0S2V5VXNhZ2UgcHVycG9zZXNcbl9JTignMS4zLjYuMS40LjEuMTExMjkuMi40LjInLCAndGltZXN0YW1wTGlzdCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjEuMScsICdhdXRob3JpdHlJbmZvQWNjZXNzJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4xJywgJ3NlcnZlckF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjInLCAnY2xpZW50QXV0aCcpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMycsICdjb2RlU2lnbmluZycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuNCcsICdlbWFpbFByb3RlY3Rpb24nKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjgnLCAndGltZVN0YW1waW5nJyk7XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlIG1lc3NhZ2UgZGlnZXN0cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQW4gQVBJIGZvciBnZXR0aW5nIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBhcmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgRm9ydHVuYSBhbGdvcml0aG0gZGV2aXNlZCBieSBCcnVjZSBTY2huZWllciBhbmRcbiAqIE5pZWxzIEZlcmd1c29uLlxuICpcbiAqIEdldHRpbmcgc3Ryb25nIHJhbmRvbSBieXRlcyBpcyBub3QgeWV0IGVhc3kgdG8gZG8gaW4gamF2YXNjcmlwdC4gVGhlIG9ubHlcbiAqIHRydWlzaCByYW5kb20gZW50cm9weSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgaXMgZnJvbSB0aGUgbW91c2UsIGtleWJvYXJkLCBvclxuICogZnJvbSB0aW1pbmcgd2l0aCByZXNwZWN0IHRvIHBhZ2UgbG9hZHMsIGV0Yy4gVGhpcyBnZW5lcmF0b3IgbWFrZXMgYSBwb29yXG4gKiBhdHRlbXB0IGF0IHByb3ZpZGluZyByYW5kb20gYnl0ZXMgd2hlbiB0aG9zZSBzb3VyY2VzIGhhdmVuJ3QgeWV0IHByb3ZpZGVkXG4gKiBlbm91Z2ggZW50cm9weSB0byBpbml0aWFsbHkgc2VlZCBvciB0byByZXNlZWQgdGhlIFBSTkcuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnJhbmRvbSBhbHJlYWR5IGRlZmluZWRcbmlmKGZvcmdlLnJhbmRvbSAmJiBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG4gIHJldHVybjtcbn1cblxuKGZ1bmN0aW9uKGpRdWVyeSkge1xuXG4vLyB0aGUgZGVmYXVsdCBwcm5nIHBsdWdpbiwgdXNlcyBBRVMtMTI4XG52YXIgcHJuZ19hZXMgPSB7fTtcbnZhciBfcHJuZ19hZXNfb3V0cHV0ID0gbmV3IEFycmF5KDQpO1xudmFyIF9wcm5nX2Flc19idWZmZXIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xucHJuZ19hZXMuZm9ybWF0S2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIGNvbnZlcnQgdGhlIGtleSBpbnRvIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgdG1wID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAga2V5ID0gbmV3IEFycmF5KDQpO1xuICBrZXlbMF0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzFdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbM10gPSB0bXAuZ2V0SW50MzIoKTtcblxuICAvLyByZXR1cm4gdGhlIGV4cGFuZGVkIGtleVxuICByZXR1cm4gZm9yZ2UuYWVzLl9leHBhbmRLZXkoa2V5LCBmYWxzZSk7XG59O1xucHJuZ19hZXMuZm9ybWF0U2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gY29udmVydCBzZWVkIGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzZWVkKTtcbiAgc2VlZCA9IG5ldyBBcnJheSg0KTtcbiAgc2VlZFswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzFdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMl0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFszXSA9IHRtcC5nZXRJbnQzMigpO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5jaXBoZXIgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgZm9yZ2UuYWVzLl91cGRhdGVCbG9jayhrZXksIHNlZWQsIF9wcm5nX2Flc19vdXRwdXQsIGZhbHNlKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzBdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzFdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzJdKTtcbiAgX3BybmdfYWVzX2J1ZmZlci5wdXRJbnQzMihfcHJuZ19hZXNfb3V0cHV0WzNdKTtcbiAgcmV0dXJuIF9wcm5nX2Flc19idWZmZXIuZ2V0Qnl0ZXMoKTtcbn07XG5wcm5nX2Flcy5pbmNyZW1lbnQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIC8vIEZJWE1FOiBkbyB3ZSBjYXJlIGFib3V0IGNhcnJ5IG9yIHNpZ25lZCBpc3N1ZXM/XG4gICsrc2VlZFszXTtcbiAgcmV0dXJuIHNlZWQ7XG59O1xucHJuZ19hZXMubWQgPSBmb3JnZS5tZC5zaGEyNTY7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HLlxuICovXG5mdW5jdGlvbiBzcGF3blBybmcoKSB7XG4gIHZhciBjdHggPSBmb3JnZS5wcm5nLmNyZWF0ZShwcm5nX2Flcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzLiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpcyB1bmF2YWlsYWJsZSwgdGhpc1xuICAgKiBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5IGRyYXdpbmcgZnJvbSBkYXRhIHRoYXRcbiAgICogY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLCBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIElmIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwgYnl0ZXMpXSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgcmFuZG9tIGJ5dGVzIGluIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdldEJ5dGVzID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGN0eC5nZW5lcmF0ZShjb3VudCwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHJhbmRvbSBieXRlcyBhc3luY2hyb25vdXNseS4gSWYgYSBuYXRpdmUgc2VjdXJlIGNyeXB0byBBUEkgaXNcbiAgICogdW5hdmFpbGFibGUsIHRoaXMgbWV0aG9kIHRyaWVzIHRvIG1ha2UgdGhlIGJ5dGVzIG1vcmUgdW5wcmVkaWN0YWJsZSBieVxuICAgKiBkcmF3aW5nIGZyb20gZGF0YSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgZnJvbSB0aGUgdXNlciBvZiB0aGUgYnJvd3NlcixcbiAgICogZWc6IG1vdXNlIG1vdmVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXNTeW5jID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50KTtcbiAgfTtcblxuICByZXR1cm4gY3R4O1xufVxuXG4vLyBjcmVhdGUgZGVmYXVsdCBwcm5nIGNvbnRleHRcbnZhciBfY3R4ID0gc3Bhd25Qcm5nKCk7XG5cbi8vIGFkZCBvdGhlciBzb3VyY2VzIG9mIGVudHJvcHkgb25seSBpZiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpcyBub3Rcbi8vIGF2YWlsYWJsZSAtLSBvdGhlcndpc2UgdGhpcyBzb3VyY2Ugd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYnkgdGhlIHBybmdcbnZhciBnZXRSYW5kb21WYWx1ZXMgPSBudWxsO1xuaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgaWYoX2NyeXB0byAmJiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgfTtcbiAgfVxufVxuaWYoZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCB8fFxuICAoIWZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWdldFJhbmRvbVZhbHVlcykpIHtcbiAgLy8gaWYgdGhpcyBpcyBhIHdlYiB3b3JrZXIsIGRvIG5vdCB1c2Ugd2VhayBlbnRyb3B5LCBpbnN0ZWFkIHJlZ2lzdGVyIHRvXG4gIC8vIHJlY2VpdmUgc3Ryb25nIGVudHJvcHkgYXN5bmNocm9ub3VzbHkgZnJvbSB0aGUgbWFpbiB0aHJlYWRcbiAgaWYodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgd2luZG93LmRvY3VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBGSVhNRTpcbiAgfVxuXG4gIC8vIGdldCBsb2FkIHRpbWUgZW50cm9weVxuICBfY3R4LmNvbGxlY3RJbnQoK25ldyBEYXRlKCksIDMyKTtcblxuICAvLyBhZGQgc29tZSBlbnRyb3B5IGZyb20gbmF2aWdhdG9yIG9iamVjdFxuICBpZih0eXBlb2YobmF2aWdhdG9yKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgX25hdkJ5dGVzID0gJyc7XG4gICAgZm9yKHZhciBrZXkgaW4gbmF2aWdhdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZih0eXBlb2YobmF2aWdhdG9yW2tleV0pID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgX25hdkJ5dGVzICs9IG5hdmlnYXRvcltrZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLyogU29tZSBuYXZpZ2F0b3Iga2V5cyBtaWdodCBub3QgYmUgYWNjZXNzaWJsZSwgZS5nLiB0aGUgZ2VvbG9jYXRpb25cbiAgICAgICAgICBhdHRyaWJ1dGUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0b3VjaGVkIGluIE1vemlsbGEgY2hyb21lOi8vXG4gICAgICAgICAgY29udGV4dC5cblxuICAgICAgICAgIFNpbGVudGx5IGlnbm9yZSB0aGlzIGFuZCBqdXN0IGRvbid0IHVzZSB0aGlzIGFzIGEgc291cmNlIG9mXG4gICAgICAgICAgZW50cm9weS4gKi9cbiAgICAgIH1cbiAgICB9XG4gICAgX2N0eC5jb2xsZWN0KF9uYXZCeXRlcyk7XG4gICAgX25hdkJ5dGVzID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFkZCBtb3VzZSBhbmQga2V5Ym9hcmQgY29sbGVjdG9ycyBpZiBqcXVlcnkgaXMgYXZhaWxhYmxlXG4gIGlmKGpRdWVyeSkge1xuICAgIC8vIHNldCB1cCBtb3VzZSBlbnRyb3B5IGNhcHR1cmVcbiAgICBqUXVlcnkoKS5tb3VzZW1vdmUoZnVuY3Rpb24oZSkge1xuICAgICAgLy8gYWRkIG1vdXNlIGNvb3Jkc1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WCwgMTYpO1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2xpZW50WSwgMTYpO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IHVwIGtleWJvYXJkIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLmtleXByZXNzKGZ1bmN0aW9uKGUpIHtcbiAgICAgIF9jdHguY29sbGVjdEludChlLmNoYXJDb2RlLCA4KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKiBSYW5kb20gQVBJICovXG5pZighZm9yZ2UucmFuZG9tKSB7XG4gIGZvcmdlLnJhbmRvbSA9IF9jdHg7XG59IGVsc2Uge1xuICAvLyBleHRlbmQgZm9yZ2UucmFuZG9tIHdpdGggX2N0eFxuICBmb3IodmFyIGtleSBpbiBfY3R4KSB7XG4gICAgZm9yZ2UucmFuZG9tW2tleV0gPSBfY3R4W2tleV07XG4gIH1cbn1cblxuLy8gZXhwb3NlIHNwYXduIFBSTkdcbmZvcmdlLnJhbmRvbS5jcmVhdGVJbnN0YW5jZSA9IHNwYXduUHJuZztcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYW5kb207XG5cbn0pKHR5cGVvZihqUXVlcnkpICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwpO1xuXG59KSgpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmlmKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcbn1cblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKlxuICogUlNBIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24sIHNlZSBSRkMgMjMxMy5cbiAqL1xuZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2kucnNhID0gZm9yZ2UucnNhID0gZm9yZ2UucnNhIHx8IHt9O1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gZm9yIGZpbmRpbmcgcHJpbWVzLCB3aGljaCBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUHJpdmF0ZUtleUluZm8gc3RydWN0dXJlXG52YXIgcHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdQcml2YXRlS2V5SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIHByaXZhdGVLZXlBbGdvcml0aG1cbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlPaWQnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIFByaXZhdGVLZXlcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHJpdmF0ZSBrZXlcbnZhciByc2FQcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIG5hbWU6ICdSU0FQcml2YXRlS2V5JyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlWZXJzaW9uJ1xuICB9LCB7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5TW9kdWx1cydcbiAgfSwge1xuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnB1YmxpY0V4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHVibGljRXhwb25lbnQnXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpbWUxIChwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaW1lMScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaW1lMSdcbiAgfSwge1xuICAgIC8vIHByaW1lMiAocSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTInLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTInXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDEgKGQgbW9kIChwLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MSdcbiAgfSwge1xuICAgIC8vIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkuZXhwb25lbnQyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5RXhwb25lbnQyJ1xuICB9LCB7XG4gICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmNvZWZmaWNpZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5Q29lZmZpY2llbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcnNhUHVibGljS2V5VmFsaWRhdG9yID0ge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgbmFtZTogJ1JTQVB1YmxpY0tleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5Lm1vZHVsdXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3B1YmxpY0tleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHVibGljS2V5LmV4cG9uZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlFeHBvbmVudCdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gU3ViamVjdFB1YmxpY0tleUluZm8gc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3aXRoIGFuIFJTQSBwdWJsaWMga2V5XG52YXIgcHVibGljS2V5VmFsaWRhdG9yID0gZm9yZ2UucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdzdWJqZWN0UHVibGljS2V5SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAncHVibGljS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIFJTQVB1YmxpY0tleVxuICAgICAgbmFtZTogJ1N1YmplY3RQdWJsaWNLZXlJbmZvLnN1YmplY3RQdWJsaWNLZXkuUlNBUHVibGljS2V5JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ3JzYVB1YmxpY0tleSdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBXcmFwIGRpZ2VzdCBpbiBEaWdlc3RJbmZvIG9iamVjdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QS0NTMS12MV81LUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcuXG4gKlxuICogRGlnZXN0SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBkaWdlc3RBbGdvcml0aG0gRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZGlnZXN0IERpZ2VzdFxuICogfVxuICpcbiAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSAocmVhZHkgZm9yIFJTQSBlbmNyeXRpb24pXG4gKi9cbnZhciBlbXNhUGtjczF2MTVlbmNvZGUgPSBmdW5jdGlvbihtZCkge1xuICAvLyBnZXQgdGhlIG9pZCBmb3IgdGhlIGFsZ29yaXRobVxuICB2YXIgb2lkO1xuICBpZihtZC5hbGdvcml0aG0gaW4gcGtpLm9pZHMpIHtcbiAgICBvaWQgPSBwa2kub2lkc1ttZC5hbGdvcml0aG1dO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gbWQuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHZhciBvaWRCeXRlcyA9IGFzbjEub2lkVG9EZXIob2lkKS5nZXRCeXRlcygpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZGlnZXN0IGluZm9cbiAgdmFyIGRpZ2VzdEluZm8gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHZhciBkaWdlc3RBbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkQnl0ZXMpKTtcbiAgZGlnZXN0QWxnb3JpdGhtLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpKTtcbiAgdmFyIGRpZ2VzdCA9IGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgZmFsc2UsIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICBkaWdlc3RJbmZvLnZhbHVlLnB1c2goZGlnZXN0QWxnb3JpdGhtKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdCk7XG5cbiAgLy8gZW5jb2RlIGRpZ2VzdCBpbmZvXG4gIHJldHVybiBhc24xLnRvRGVyKGRpZ2VzdEluZm8pLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHheYyBtb2QgbiAoUlNBIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBvcGVyYXRpb24pLlxuICpcbiAqIEBwYXJhbSB4IHRoZSBudW1iZXIgdG8gcmFpc2UgYW5kIG1vZC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBwdWJsaWMsIGZhbHNlIGlmIHByaXZhdGUuXG4gKlxuICogQHJldHVybiB0aGUgcmVzdWx0IG9mIHheYyBtb2Qgbi5cbiAqL1xudmFyIF9tb2RQb3cgPSBmdW5jdGlvbih4LCBrZXksIHB1Yikge1xuICBpZihwdWIpIHtcbiAgICByZXR1cm4geC5tb2RQb3coa2V5LmUsIGtleS5uKTtcbiAgfVxuXG4gIGlmKCFrZXkucCB8fCAha2V5LnEpIHtcbiAgICAvLyBhbGxvdyBjYWxjdWxhdGlvbiB3aXRob3V0IENSVCBwYXJhbXMgKHNsb3cpXG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5kLCBrZXkubik7XG4gIH1cblxuICAvLyBwcmUtY29tcHV0ZSBkUCwgZFEsIGFuZCBxSW52IGlmIG5lY2Vzc2FyeVxuICBpZigha2V5LmRQKSB7XG4gICAga2V5LmRQID0ga2V5LmQubW9kKGtleS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKSk7XG4gIH1cbiAgaWYoIWtleS5kUSkge1xuICAgIGtleS5kUSA9IGtleS5kLm1vZChrZXkucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkucUludikge1xuICAgIGtleS5xSW52ID0ga2V5LnEubW9kSW52ZXJzZShrZXkucCk7XG4gIH1cblxuICAvKiBDaGluZXNlIHJlbWFpbmRlciB0aGVvcmVtIChDUlQpIHN0YXRlczpcblxuICAgIFN1cHBvc2UgbjEsIG4yLCAuLi4sIG5rIGFyZSBwb3NpdGl2ZSBpbnRlZ2VycyB3aGljaCBhcmUgcGFpcndpc2VcbiAgICBjb3ByaW1lIChuMSBhbmQgbjIgaGF2ZSBubyBjb21tb24gZmFjdG9ycyBvdGhlciB0aGFuIDEpLiBGb3IgYW55XG4gICAgaW50ZWdlcnMgeDEsIHgyLCAuLi4sIHhrIHRoZXJlIGV4aXN0cyBhbiBpbnRlZ2VyIHggc29sdmluZyB0aGVcbiAgICBzeXN0ZW0gb2Ygc2ltdWx0YW5lb3VzIGNvbmdydWVuY2VzICh3aGVyZSB+PSBtZWFucyBtb2R1bGFybHlcbiAgICBjb25ncnVlbnQgc28gYSB+PSBiIG1vZCBuIG1lYW5zIGEgbW9kIG4gPSBiIG1vZCBuKTpcblxuICAgIHggfj0geDEgbW9kIG4xXG4gICAgeCB+PSB4MiBtb2QgbjJcbiAgICAuLi5cbiAgICB4IH49IHhrIG1vZCBua1xuXG4gICAgVGhpcyBzeXN0ZW0gb2YgY29uZ3J1ZW5jZXMgaGFzIGEgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4XG4gICAgYmV0d2VlbiAwIGFuZCBuIC0gMS4gRnVydGhlcm1vcmUsIGVhY2ggeGsgc29sdXRpb24gYW5kIHggaXRzZWxmXG4gICAgaXMgY29uZ3J1ZW50IG1vZHVsbyB0aGUgcHJvZHVjdCBuID0gbjEqbjIqLi4uKm5rLlxuICAgIFNvIHgxIG1vZCBuID0geDIgbW9kIG4gPSB4ayBtb2QgbiA9IHggbW9kIG4uXG5cbiAgICBUaGUgc2luZ2xlIHNpbXVsdGFuZW91cyBzb2x1dGlvbiB4IGNhbiBiZSBzb2x2ZWQgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgZXF1YXRpb246XG5cbiAgICB4ID0gc3VtKHhpKnJpKnNpKSBtb2QgbiB3aGVyZSByaSA9IG4vbmkgYW5kIHNpID0gcmleLTEgbW9kIG5pLlxuXG4gICAgV2hlcmUgeCBpcyBsZXNzIHRoYW4gbiwgeGkgPSB4IG1vZCBuaS5cblxuICAgIEZvciBSU0Egd2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggayA9IDIuIFRoZSBtb2R1bHVzIG4gPSBwcSwgd2hlcmVcbiAgICBwIGFuZCBxIGFyZSBjb3ByaW1lLiBUaGUgUlNBIGRlY3J5cHRpb24gYWxnb3JpdGhtIGlzOlxuXG4gICAgeSA9IHheZCBtb2QgblxuXG4gICAgR2l2ZW4gdGhlIGFib3ZlOlxuXG4gICAgeDEgPSB4XmQgbW9kIHBcbiAgICByMSA9IG4vcCA9IHFcbiAgICBzMSA9IHFeLTEgbW9kIHBcbiAgICB4MiA9IHheZCBtb2QgcVxuICAgIHIyID0gbi9xID0gcFxuICAgIHMyID0gcF4tMSBtb2QgcVxuXG4gICAgU28geSA9ICh4MXIxczEgKyB4MnIyczIpIG1vZCBuXG4gICAgICAgICA9ICgoeF5kIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kIG1vZCBxKXAocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBBY2NvcmRpbmcgdG8gRmVybWF0J3MgTGl0dGxlIFRoZW9yZW0sIGlmIHRoZSBtb2R1bHVzIFAgaXMgcHJpbWUsXG4gICAgZm9yIGFueSBpbnRlZ2VyIEEgbm90IGV2ZW5seSBkaXZpc2libGUgYnkgUCwgQV4oUC0xKSB+PSAxIG1vZCBQLlxuICAgIFNpbmNlIEEgaXMgbm90IGRpdmlzaWJsZSBieSBQIGl0IGZvbGxvd3MgdGhhdCBpZjpcbiAgICBOIH49IE0gbW9kIChQIC0gMSksIHRoZW4gQV5OIG1vZCBQID0gQV5NIG1vZCBQLiBUaGVyZWZvcmU6XG5cbiAgICBBXk4gbW9kIFAgPSBBXihNIG1vZCAoUCAtIDEpKSBtb2QgUC4gKFRoZSBsYXR0ZXIgdGFrZXMgbGVzcyBlZmZvcnRcbiAgICB0byBjYWxjdWxhdGUpLiBJbiBvcmRlciB0byBjYWxjdWxhdGUgeF5kIG1vZCBwIG1vcmUgcXVpY2tseSB0aGVcbiAgICBleHBvbmVudCBkIG1vZCAocCAtIDEpIGlzIHN0b3JlZCBpbiB0aGUgUlNBIHByaXZhdGUga2V5ICh0aGUgc2FtZVxuICAgIGlzIGRvbmUgZm9yIHheZCBtb2QgcSkuIFRoZXNlIHZhbHVlcyBhcmUgcmVmZXJyZWQgdG8gYXMgZFAgYW5kIGRRXG4gICAgcmVzcGVjdGl2ZWx5LiBUaGVyZWZvcmUgd2Ugbm93IGhhdmU6XG5cbiAgICB5ID0gKCh4XmRQIG1vZCBwKXEocV4tMSBtb2QgcCkgKyAoeF5kUSBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgU2luY2Ugd2UnbGwgYmUgcmVkdWNpbmcgeF5kUCBieSBtb2R1bG8gcCAoc2FtZSBmb3IgcSkgd2UgY2FuIGFsc29cbiAgICByZWR1Y2UgeCBieSBwIChhbmQgcSByZXNwZWN0aXZlbHkpIGJlZm9yZSBoYW5kLiBUaGVyZWZvcmUsIGxldFxuXG4gICAgeHAgPSAoKHggbW9kIHApXmRQIG1vZCBwKSwgYW5kXG4gICAgeHEgPSAoKHggbW9kIHEpXmRRIG1vZCBxKSwgeWllbGRpbmc6XG5cbiAgICB5ID0gKHhwKnEqKHFeLTEgbW9kIHApICsgeHEqcCoocF4tMSBtb2QgcSkpIG1vZCBuXG5cbiAgICBUaGlzIGNhbiBiZSBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW1wbGUgYWxnb3JpdGhtIHRoYXQgb25seVxuICAgIHJlcXVpcmVzIDEgaW52ZXJzZSAodGhlIHEgaW52ZXJzZSBpcyB1c2VkKSB0byBiZSB1c2VkIGFuZCBzdG9yZWQuXG4gICAgVGhlIGFsZ29yaXRobSBpcyBjYWxsZWQgR2FybmVyJ3MgYWxnb3JpdGhtLiBJZiBxSW52IGlzIHRoZVxuICAgIGludmVyc2Ugb2YgcSwgd2Ugc2ltcGx5IGNhbGN1bGF0ZTpcblxuICAgIHkgPSAocUludiooeHAgLSB4cSkgbW9kIHApICogcSArIHhxXG5cbiAgICBIb3dldmVyLCB0aGVyZSBhcmUgdHdvIGZ1cnRoZXIgY29tcGxpY2F0aW9ucy4gRmlyc3QsIHdlIG5lZWQgdG9cbiAgICBlbnN1cmUgdGhhdCB4cCA+IHhxIHRvIHByZXZlbnQgc2lnbmVkIEJpZ0ludGVnZXJzIGZyb20gYmVpbmcgdXNlZFxuICAgIHNvIHdlIGFkZCBwIHVudGlsIHRoaXMgaXMgdHJ1ZSAoc2luY2Ugd2Ugd2lsbCBiZSBtb2QnaW5nIHdpdGhcbiAgICBwIGFueXdheSkuIFRoZW4sIHRoZXJlIGlzIGEga25vd24gdGltaW5nIGF0dGFjayBvbiBhbGdvcml0aG1zXG4gICAgdXNpbmcgdGhlIENSVC4gVG8gbWl0aWdhdGUgdGhpcyByaXNrLCBcImNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcIlxuICAgIHNob3VsZCBiZSB1c2VkLiBUaGlzIHJlcXVpcmVzIHNpbXBseSBnZW5lcmF0aW5nIGEgcmFuZG9tIG51bWJlciByXG4gICAgYmV0d2VlbiAwIGFuZCBuLTEgYW5kIGl0cyBpbnZlcnNlIGFuZCBtdWx0aXBseWluZyB4IGJ5IHJeZSBiZWZvcmVcbiAgICBjYWxjdWxhdGluZyB5IGFuZCB0aGVuIG11bHRpcGx5aW5nIHkgYnkgcl4tMSBhZnRlcndhcmRzLiBOb3RlIHRoYXRcbiAgICByIG11c3QgYmUgY29wcmltZSB3aXRoIG4gKGdjZChyLCBuKSA9PT0gMSkgaW4gb3JkZXIgdG8gaGF2ZSBhblxuICAgIGludmVyc2UuXG4gICovXG5cbiAgLy8gY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB2YXIgcjtcbiAgZG8ge1xuICAgIHIgPSBuZXcgQmlnSW50ZWdlcihcbiAgICAgIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KSksXG4gICAgICAxNik7XG4gIH0gd2hpbGUoci5jb21wYXJlVG8oa2V5Lm4pID49IDAgfHwgIXIuZ2NkKGtleS5uKS5lcXVhbHMoQmlnSW50ZWdlci5PTkUpKTtcbiAgeCA9IHgubXVsdGlwbHkoci5tb2RQb3coa2V5LmUsIGtleS5uKSkubW9kKGtleS5uKTtcblxuICAvLyBjYWxjdWxhdGUgeHAgYW5kIHhxXG4gIHZhciB4cCA9IHgubW9kKGtleS5wKS5tb2RQb3coa2V5LmRQLCBrZXkucCk7XG4gIHZhciB4cSA9IHgubW9kKGtleS5xKS5tb2RQb3coa2V5LmRRLCBrZXkucSk7XG5cbiAgLy8geHAgbXVzdCBiZSBsYXJnZXIgdGhhbiB4cSB0byBhdm9pZCBzaWduZWQgYml0IHVzYWdlXG4gIHdoaWxlKHhwLmNvbXBhcmVUbyh4cSkgPCAwKSB7XG4gICAgeHAgPSB4cC5hZGQoa2V5LnApO1xuICB9XG5cbiAgLy8gZG8gbGFzdCBzdGVwXG4gIHZhciB5ID0geHAuc3VidHJhY3QoeHEpXG4gICAgLm11bHRpcGx5KGtleS5xSW52KS5tb2Qoa2V5LnApXG4gICAgLm11bHRpcGx5KGtleS5xKS5hZGQoeHEpO1xuXG4gIC8vIHJlbW92ZSBlZmZlY3Qgb2YgcmFuZG9tIGZvciBjcnlwdG9ncmFwaGljIGJsaW5kaW5nXG4gIHkgPSB5Lm11bHRpcGx5KHIubW9kSW52ZXJzZShrZXkubikpLm1vZChrZXkubik7XG5cbiAgcmV0dXJuIHk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnc2lnbicgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICdlbmNyeXB0JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGVuY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBidCBjb250cm9scyB3aGV0aGVyIHRvIHB1dCBwYWRkaW5nIGJ5dGVzIGJlZm9yZSB0aGVcbiAqIG1lc3NhZ2UgcGFzc2VkIGluLiBTZXQgYnQgdG8gZWl0aGVyIHRydWUgb3IgZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nXG4gKiBjb21wbGV0ZWx5IChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBlbmNvZGluZyBzZXBlcmF0ZWx5IGJlZm9yZSksXG4gKiBzaWduYWxpbmcgd2hldGhlciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYSBwdWJsaWMga2V5IG9wZXJhdGlvblxuICogKGkuZS4gZW5jcnlwdGluZyBkYXRhKSBvciBub3QsIGkuZS4gcHJpdmF0ZSBrZXkgb3BlcmF0aW9uIChkYXRhIHNpZ25pbmcpLlxuICpcbiAqIEZvciBQS0NTIzEgdjEuNSBwYWRkaW5nIHBhc3MgaW4gdGhlIGJsb2NrIHR5cGUgdG8gdXNlLCBpLmUuIGVpdGhlciAweDAxXG4gKiAoZm9yIHNpZ25pbmcpIG9yIDB4MDIgKGZvciBlbmNyeXB0aW9uKS4gVGhlIGtleSBvcGVyYXRpb24gbW9kZSAocHJpdmF0ZVxuICogb3IgcHVibGljKSBpcyBkZXJpdmVkIGZyb20gdGhpcyBmbGFnIGluIHRoYXQgY2FzZSkuXG4gKlxuICogQHBhcmFtIG0gdGhlIG1lc3NhZ2UgdG8gZW5jcnlwdCBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gYnQgZm9yIFBLQ1MjMSB2MS41IHBhZGRpbmcsIHRoZSBibG9jayB0eXBlIHRvIHVzZVxuICogICAoMHgwMSBmb3IgcHJpdmF0ZSBrZXksIDB4MDIgZm9yIHB1YmxpYyksXG4gKiAgIHRvIGRpc2FibGUgcGFkZGluZzogdHJ1ZSA9IHB1YmxpYyBrZXksIGZhbHNlID0gcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICovXG5wa2kucnNhLmVuY3J5cHQgPSBmdW5jdGlvbihtLCBrZXksIGJ0KSB7XG4gIHZhciBwdWIgPSBidDtcbiAgdmFyIGViO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgaWYoYnQgIT09IGZhbHNlICYmIGJ0ICE9PSB0cnVlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICBwdWIgPSAoYnQgPT09IDB4MDIpO1xuICAgIGViID0gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCk7XG4gIH0gZWxzZSB7XG4gICAgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGViLnB1dEJ5dGVzKG0pO1xuICB9XG5cbiAgLy8gbG9hZCBlbmNyeXB0aW9uIGJsb2NrIGFzIGJpZyBpbnRlZ2VyICd4J1xuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4ID0gbmV3IEJpZ0ludGVnZXIoZWIudG9IZXgoKSwgMTYpO1xuXG4gIC8vIGRvIFJTQSBlbmNyeXB0aW9uXG4gIHZhciB5ID0gX21vZFBvdyh4LCBrZXksIHB1Yik7XG5cbiAgLy8gY29udmVydCB5IGludG8gdGhlIGVuY3J5cHRlZCBkYXRhIGJ5dGUgc3RyaW5nLCBpZiB5IGlzIHNob3J0ZXIgaW5cbiAgLy8gYnl0ZXMgdGhhbiBrLCB0aGVuIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGVkXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHloZXggPSB5LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh5aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlZC5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWQucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHloZXgpKTtcbiAgcmV0dXJuIGVkLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQsIHVzZSAnZGVjcnlwdCcgb24gYSBwcml2YXRlIGtleSBvYmplY3Qgb3JcbiAqICd2ZXJpZnknIG9uIGEgcHVibGljIGtleSBvYmplY3QgaW5zdGVhZC5cbiAqXG4gKiBQZXJmb3JtcyBSU0EgZGVjcnlwdGlvbi5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIG1sIGNvbnRyb2xzIHdoZXRoZXIgdG8gYXBwbHkgUEtDUyMxIHYxLjUgcGFkZGluZ1xuICogb3Igbm90LiAgU2V0IG1sID0gZmFsc2UgdG8gZGlzYWJsZSBwYWRkaW5nIHJlbW92YWwgY29tcGxldGVseVxuICogKGluIG9yZGVyIHRvIGhhbmRsZSBlLmcuIEVNU0EtUFNTIGxhdGVyIG9uKSBhbmQgc2ltcGx5IHBhc3MgYmFja1xuICogdGhlIFJTQSBlbmNyeXB0aW9uIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBlZCB0aGUgZW5jcnlwdGVkIGRhdGEgdG8gZGVjcnlwdCBpbiBhcyBhIGJ5dGUgc3RyaW5nLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgZm9yIGEgcHVibGljIGtleSBvcGVyYXRpb24sIGZhbHNlIGZvciBwcml2YXRlLlxuICogQHBhcmFtIG1sIHRoZSBtZXNzYWdlIGxlbmd0aCwgaWYga25vd24sIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNyeXB0ZWQgbWVzc2FnZSBhcyBhIGJ5dGUgc3RyaW5nLlxuICovXG5wa2kucnNhLmRlY3J5cHQgPSBmdW5jdGlvbihlZCwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLy8gZXJyb3IgaWYgdGhlIGxlbmd0aCBvZiB0aGUgZW5jcnlwdGVkIGRhdGEgRUQgaXMgbm90IGtcbiAgaWYoZWQubGVuZ3RoICE9PSBrKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlZC5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWQgPSBrO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY29udmVydCBlbmNyeXB0ZWQgZGF0YSBpbnRvIGEgYmlnIGludGVnZXJcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeSA9IG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVkKS50b0hleCgpLCAxNik7XG5cbiAgLy8geSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbW9kdWx1cyBvciBpdCB3YXNuJ3QgdGhlIHJlc3VsdCBvZlxuICAvLyBhIHByZXZpb3VzIG1vZCBvcGVyYXRpb24gKGVuY3J5cHRpb24pIHVzaW5nIHRoYXQgbW9kdWx1c1xuICBpZih5LmNvbXBhcmVUbyhrZXkubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIC8vIGRvIFJTQSBkZWNyeXB0aW9uXG4gIHZhciB4ID0gX21vZFBvdyh5LCBrZXksIHB1Yik7XG5cbiAgLy8gY3JlYXRlIHRoZSBlbmNyeXB0aW9uIGJsb2NrLCBpZiB4IGlzIHNob3J0ZXIgaW4gYnl0ZXMgdGhhbiBrLCB0aGVuXG4gIC8vIHByZXBlbmQgemVybyBieXRlcyB0byBmaWxsIHVwIGViXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHhoZXggPSB4LnRvU3RyaW5nKDE2KTtcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdmFyIHplcm9zID0gayAtIE1hdGguY2VpbCh4aGV4Lmxlbmd0aCAvIDIpO1xuICB3aGlsZSh6ZXJvcyA+IDApIHtcbiAgICBlYi5wdXRCeXRlKDB4MDApO1xuICAgIC0temVyb3M7XG4gIH1cbiAgZWIucHV0Qnl0ZXMoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKHhoZXgpKTtcblxuICBpZihtbCAhPT0gZmFsc2UpIHtcbiAgICAvLyBsZWdhY3ksIGRlZmF1bHQgdG8gUEtDUyMxIHYxLjUgcGFkZGluZ1xuICAgIHJldHVybiBfZGVjb2RlUGtjczFfdjFfNShlYi5nZXRCeXRlcygpLCBrZXksIHB1Yik7XG4gIH1cblxuICAvLyByZXR1cm4gbWVzc2FnZVxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSU0Ega2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZSBvYmplY3QuIEl0IGlzIHVzZWQgdG8gYWxsb3dcbiAqIGtleS1nZW5lcmF0aW9uIHRvIGJlIHBlcmZvcm1lZCBpbiBzdGVwcy4gSXQgYWxzbyBhbGxvd3MgZm9yIGEgVUkgdG9cbiAqIGRpc3BsYXkgcHJvZ3Jlc3MgdXBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgc2l6ZSBmb3IgdGhlIHByaXZhdGUga2V5IGluIGJpdHMsIGRlZmF1bHRzIHRvIDIwNDguXG4gKiBAcGFyYW0gZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcgKDB4MTAwMDEpLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdGF0ZSBvYmplY3QgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBrZXktcGFpci5cbiAqL1xucGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucykge1xuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG5cbiAgLy8gc2V0IGRlZmF1bHQgYml0c1xuICBpZih0eXBlb2YoYml0cykgPT09ICdzdHJpbmcnKSB7XG4gICAgYml0cyA9IHBhcnNlSW50KGJpdHMsIDEwKTtcbiAgfVxuICBiaXRzID0gYml0cyB8fCAyMDQ4O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwcm5nID0gb3B0aW9ucy5wcm5nIHx8IGZvcmdlLnJhbmRvbTtcbiAgdmFyIHJuZyA9IHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGIgPSBwcm5nLmdldEJ5dGVzU3luYyh4Lmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4W2ldID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcblxuICAvLyBjcmVhdGUgUFJJTUVJTkMgYWxnb3JpdGhtIHN0YXRlXG4gIHZhciBydmFsO1xuICBpZihhbGdvcml0aG0gPT09ICdQUklNRUlOQycpIHtcbiAgICBydmFsID0ge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBzdGF0ZTogMCxcbiAgICAgIGJpdHM6IGJpdHMsXG4gICAgICBybmc6IHJuZyxcbiAgICAgIGVJbnQ6IGUgfHwgNjU1MzcsXG4gICAgICBlOiBuZXcgQmlnSW50ZWdlcihudWxsKSxcbiAgICAgIHA6IG51bGwsXG4gICAgICBxOiBudWxsLFxuICAgICAgcUJpdHM6IGJpdHMgPj4gMSxcbiAgICAgIHBCaXRzOiBiaXRzIC0gKGJpdHMgPj4gMSksXG4gICAgICBwcVN0YXRlOiAwLFxuICAgICAgbnVtOiBudWxsLFxuICAgICAga2V5czogbnVsbFxuICAgIH07XG4gICAgcnZhbC5lLmZyb21JbnQocnZhbC5lSW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBydW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gZm9yIGF0IG1vc3QgbiBzZWNvbmRzXG4gKiAoYXBwcm94aW1hdGVseSkgdXNpbmcgdGhlIGdpdmVuIHN0YXRlLiBXaGVuIGtleS1nZW5lcmF0aW9uIGhhcyBjb21wbGV0ZWQsXG4gKiB0aGUga2V5cyB3aWxsIGJlIHN0b3JlZCBpbiBzdGF0ZS5rZXlzLlxuICpcbiAqIFRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIHVwZGF0ZSBhIFVJIHdoaWxlIGdlbmVyYXRpbmcgYSBrZXkgb3IgdG8gcHJldmVudFxuICogY2F1c2luZyBicm93c2VyIGxvY2t1cHMvd2FybmluZ3MsIHNldCBcIm5cIiB0byBhIHZhbHVlIG90aGVyIHRoYW4gMC4gQVxuICogc2ltcGxlIHBhdHRlcm4gZm9yIGdlbmVyYXRpbmcgYSBrZXkgYW5kIHNob3dpbmcgYSBwcm9ncmVzcyBpbmRpY2F0b3IgaXM6XG4gKlxuICogdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKDIwNDgpO1xuICogdmFyIHN0ZXAgPSBmdW5jdGlvbigpIHtcbiAqICAgLy8gc3RlcCBrZXktZ2VuZXJhdGlvbiwgcnVuIGFsZ29yaXRobSBmb3IgMTAwIG1zLCByZXBlYXRcbiAqICAgaWYoIWZvcmdlLnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUoc3RhdGUsIDEwMCkpIHtcbiAqICAgICBzZXRUaW1lb3V0KHN0ZXAsIDEpO1xuICogICB9IGVsc2Uge1xuICogICAgIC8vIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlXG4gKiAgICAgLy8gVE9ETzogdHVybiBvZmYgcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqICAgICAvLyBUT0RPOiB1c2UgdGhlIGdlbmVyYXRlZCBrZXktcGFpciBpbiBcInN0YXRlLmtleXNcIlxuICogICB9XG4gKiB9O1xuICogLy8gVE9ETzogdHVybiBvbiBwcm9ncmVzcyBpbmRpY2F0b3IgaGVyZVxuICogc2V0VGltZW91dChzdGVwLCAwKTtcbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIHVzZS5cbiAqIEBwYXJhbSBuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gcnVuIHRoZSBhbGdvcml0aG0gZm9yLCAwXG4gKiAgICAgICAgICB0byBydW4gdGhlIGFsZ29yaXRobSB0byBjb21wbGV0aW9uLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUga2V5LWdlbmVyYXRpb24gY29tcGxldGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbnBraS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbikge1xuICAvLyBzZXQgZGVmYXVsdCBhbGdvcml0aG0gaWYgbm90IHNldFxuICBpZighKCdhbGdvcml0aG0nIGluIHN0YXRlKSkge1xuICAgIHN0YXRlLmFsZ29yaXRobSA9ICdQUklNRUlOQyc7XG4gIH1cblxuICAvLyBUT0RPOiBtaWdyYXRlIHN0ZXAtYmFzZWQgcHJpbWUgZ2VuZXJhdGlvbiBjb2RlIHRvIGZvcmdlLnByaW1lXG4gIC8vIFRPRE86IGFic3RyYWN0IGFzIFBSSU1FSU5DIGFsZ29yaXRobVxuXG4gIC8vIGRvIGtleSBnZW5lcmF0aW9uIChiYXNlZCBvbiBUb20gV3UncyByc2EuanMsIHNlZSBqc2JuLmpzIGxpY2Vuc2UpXG4gIC8vIHdpdGggc29tZSBtaW5vciBvcHRpbWl6YXRpb25zIGFuZCBkZXNpZ25lZCB0byBydW4gaW4gc3RlcHNcblxuICAvLyBsb2NhbCBzdGF0ZSB2YXJzXG4gIHZhciBUSElSVFkgPSBuZXcgQmlnSW50ZWdlcihudWxsKTtcbiAgVEhJUlRZLmZyb21JbnQoMzApO1xuICB2YXIgZGVsdGFJZHggPSAwO1xuICB2YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4fHk7IH07XG5cbiAgLy8ga2VlcCBzdGVwcGluZyB1bnRpbCB0aW1lIGxpbWl0IGlzIHJlYWNoZWQgb3IgZG9uZVxuICB2YXIgdDEgPSArbmV3IERhdGUoKTtcbiAgdmFyIHQyO1xuICB2YXIgdG90YWwgPSAwO1xuICB3aGlsZShzdGF0ZS5rZXlzID09PSBudWxsICYmIChuIDw9IDAgfHwgdG90YWwgPCBuKSkge1xuICAgIC8vIGdlbmVyYXRlIHAgb3IgcVxuICAgIGlmKHN0YXRlLnN0YXRlID09PSAwKSB7XG4gICAgICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybTpcblxuICAgICAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xLCB3aGVyZSB0aGVyZSBhcmUgOCB2YWx1ZXMgZm9yIGlcblxuICAgICAgICBXaGVuIHdlIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciwgd2UgYWx3YXlzIGFsaWduIGl0IGF0IDMwayArIDEuIEVhY2hcbiAgICAgICAgdGltZSB0aGUgbnVtYmVyIGlzIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlXG4gICAgICAgIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlciB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgICAgIHZhciBiaXRzID0gKHN0YXRlLnAgPT09IG51bGwpID8gc3RhdGUucEJpdHMgOiBzdGF0ZS5xQml0cztcbiAgICAgIHZhciBiaXRzMSA9IGJpdHMgLSAxO1xuXG4gICAgICAvLyBnZXQgYSByYW5kb20gbnVtYmVyXG4gICAgICBpZihzdGF0ZS5wcVN0YXRlID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHN0YXRlLnJuZyk7XG4gICAgICAgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgICAgaWYoIXN0YXRlLm51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgICAgICAgIHN0YXRlLm51bS5iaXR3aXNlVG8oXG4gICAgICAgICAgICBCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYml0czEpLCBvcF9vciwgc3RhdGUubnVtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGlnbiBudW1iZXIgb24gMzBrKzEgYm91bmRhcnlcbiAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoMzEgLSBzdGF0ZS5udW0ubW9kKFRISVJUWSkuYnl0ZVZhbHVlKCksIDApO1xuICAgICAgICBkZWx0YUlkeCA9IDA7XG5cbiAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgfSBlbHNlIGlmKHN0YXRlLnBxU3RhdGUgPT09IDEpIHtcbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgdGhlIG51bWJlciBhIHByaW1lXG4gICAgICAgIGlmKHN0YXRlLm51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgICAvLyBvdmVyZmxvdywgdHJ5IGFnYWluXG4gICAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICAgICAgfSBlbHNlIGlmKHN0YXRlLm51bS5pc1Byb2JhYmxlUHJpbWUoXG4gICAgICAgICAgX2dldE1pbGxlclJhYmluVGVzdHMoc3RhdGUubnVtLmJpdExlbmd0aCgpKSkpIHtcbiAgICAgICAgICArK3N0YXRlLnBxU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgICAgICAgc3RhdGUubnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAyKSB7XG4gICAgICAgIC8vIGVuc3VyZSBudW1iZXIgaXMgY29wcmltZSB3aXRoIGVcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9XG4gICAgICAgICAgKHN0YXRlLm51bS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICBhbmQgJ2UnIG11c3QgKm5vdCogYmUgZ2l2ZW46XG4gKiAgICAgICAgICBiaXRzIHRoZSBzaXplIGZvciB0aGUgcHJpdmF0ZSBrZXkgaW4gYml0cywgKGRlZmF1bHQ6IDIwNDgpLlxuICogICAgICAgICAgZSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgKGRlZmF1bHQ6IDY1NTM3ICgweDEwMDAxKSkuXG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgICAgICAgICBwcm5nIGEgY3VzdG9tIGNyeXB0by1zZWN1cmUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSxcbiAqICAgICAgICAgICAgdGhhdCBtdXN0IGRlZmluZSBcImdldEJ5dGVzU3luY1wiLlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXlwYWlyKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKlxuICogQHJldHVybiBhbiBvYmplY3Qgd2l0aCBwcml2YXRlS2V5IGFuZCBwdWJsaWNLZXkgcHJvcGVydGllcy5cbiAqL1xucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihiaXRzLCBlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyAoYml0cyksIChvcHRpb25zKSwgKGNhbGxiYWNrKVxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYodHlwZW9mIGJpdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0gYml0cztcbiAgICAgIGJpdHMgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBiaXRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyAoYml0cywgZSksIChiaXRzLCBvcHRpb25zKSwgKGJpdHMsIGNhbGxiYWNrKSwgKG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgICBlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmKHR5cGVvZiBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICBvcHRpb25zID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBjYWxsYmFjayA9IGU7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgLy8gKGJpdHMsIGUsIG9wdGlvbnMpLCAoYml0cywgZSwgY2FsbGJhY2spLCAoYml0cywgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgaWYodHlwZW9mIGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBlO1xuICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKGJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGJpdHMgPSBvcHRpb25zLmJpdHMgfHwgMjA0ODtcbiAgfVxuICBpZihlID09PSB1bmRlZmluZWQpIHtcbiAgICBlID0gb3B0aW9ucy5lIHx8IDB4MTAwMDE7XG4gIH1cblxuICAvLyBpZiBuYXRpdmUgY29kZSBpcyBwZXJtaXR0ZWQgYW5kIGEgY2FsbGJhY2sgaXMgZ2l2ZW4sIHVzZSBuYXRpdmVcbiAgLy8ga2V5IGdlbmVyYXRpb24gY29kZSBpZiBhdmFpbGFibGUgYW5kIGlmIHBhcmFtZXRlcnMgYXJlIGFjY2VwdGFibGVcbiAgaWYoIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiYgY2FsbGJhY2sgJiZcbiAgICBiaXRzID49IDI1NiAmJiBiaXRzIDw9IDE2Mzg0ICYmIChlID09PSAweDEwMDAxIHx8IGUgPT09IDMpKSB7XG4gICAgaWYoX2RldGVjdFN1YnRsZUNyeXB0bygnZ2VuZXJhdGVLZXknKSAmJiBfZGV0ZWN0U3VidGxlQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgLy8gdXNlIHN0YW5kYXJkIG5hdGl2ZSBnZW5lcmF0ZUtleVxuICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICB9LCB0cnVlIC8qIGtleSBjYW4gYmUgZXhwb3J0ZWQqLywgWydzaWduJywgJ3ZlcmlmeSddKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocGFpcikge1xuICAgICAgICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAvLyBhdm9pZGluZyBjYXRjaChmdW5jdGlvbihlcnIpIHsuLi59KSB0byBzdXBwb3J0IElFIDw9IDhcbiAgICAgIH0pLnRoZW4odW5kZWZpbmVkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocGtjczgpIHtcbiAgICAgICAgaWYocGtjczgpIHtcbiAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgX2RldGVjdFN1YnRsZU1zQ3J5cHRvKCdleHBvcnRLZXknKSkge1xuICAgICAgdmFyIGdlbk9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICBoYXNoOiB7bmFtZTogJ1NIQS0yNTYnfVxuICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICBnZW5PcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcGFpciA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgdmFyIGV4cG9ydE9wID0gd2luZG93Lm1zQ3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoXG4gICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgZXhwb3J0T3Aub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgcGtjczggPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHBrY3M4KSkpO1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5zZXRSc2FQdWJsaWNLZXkocHJpdmF0ZUtleS5uLCBwcml2YXRlS2V5LmUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGV4cG9ydE9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGdlbk9wLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH07XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiAgdmFyIHN0YXRlID0gcGtpLnJzYS5jcmVhdGVLZXlQYWlyR2VuZXJhdGlvblN0YXRlKGJpdHMsIGUsIG9wdGlvbnMpO1xuICBpZighY2FsbGJhY2spIHtcbiAgICBwa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAwKTtcbiAgICByZXR1cm4gc3RhdGUua2V5cztcbiAgfVxuICBfZ2VuZXJhdGVLZXlQYWlyKHN0YXRlLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHB1YmxpYyBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzIGFuZCBleHBvbmVudC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBleHBvbmVudC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kuc2V0UnNhUHVibGljS2V5ID0gcGtpLnJzYS5zZXRQdWJsaWNLZXkgPSBmdW5jdGlvbihuLCBlKSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlXG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwdWJsaWMga2V5LiBOZXdlciBhcHBsaWNhdGlvbnNcbiAgICogc2hvdWxkIHVzZSB0aGUgJ1JTQS1PQUVQJyBkZWNyeXB0aW9uIHNjaGVtZSwgJ1JTQUVTLVBLQ1MxLVYxXzUnIGlzIGZvclxuICAgKiBsZWdhY3kgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZW5jcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBlbmNyeXB0aW9uLFxuICAgKiAgICAgICAgICBhbiBvYmplY3Qgd2l0aCBhbiAnZW5jb2RlJyBwcm9wZXJ0eSBzZXQgdG8gYSBmdW5jdGlvblxuICAgKiAgICAgICAgICB3aXRoIHRoZSBzaWduYXR1cmUgJ2Z1bmN0aW9uKGRhdGEsIGtleSknIHRoYXQgcmV0dXJuc1xuICAgKiAgICAgICAgICBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZGF0YS5cbiAgICogQHBhcmFtIHNjaGVtZU9wdGlvbnMgYW55IHNjaGVtZS1zcGVjaWZpYyBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNyeXB0ZWQgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuZW5jcnlwdCA9IGZ1bmN0aW9uKGRhdGEsIHNjaGVtZSwgc2NoZW1lT3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FFUy1QS0NTMS1WMV81JztcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSwgcHViKSB7XG4gICAgICAgICAgcmV0dXJuIF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgMHgwMikuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGVuY29kZTogZnVuY3Rpb24obSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmVuY29kZV9yc2Ffb2FlcChrZXksIG0sIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGVuY29kZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gZTsgfSB9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICAga2V5LnZlcmlmeSA9IGZ1bmN0aW9uKGRpZ2VzdCwgc2lnbmF0dXJlLCBzY2hlbWUpIHtcbiAgICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgc2NoZW1lID0gJ1JTQVNTQS1QS0NTMS1WMV81JztcbiAgICAgfVxuXG4gICAgIGlmKHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgIC8vIHJlbW92ZSBwYWRkaW5nXG4gICAgICAgICAgIGQgPSBfZGVjb2RlUGtjczFfdjFfNShkLCBrZXksIHRydWUpO1xuICAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihkKTtcbiAgICAgICAgICAgLy8gY29tcGFyZSB0aGUgZ2l2ZW4gZGlnZXN0IHRvIHRoZSBkZWNyeXB0ZWQgb25lXG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IG9iai52YWx1ZVsxXS52YWx1ZTtcbiAgICAgICAgIH1cbiAgICAgICB9O1xuICAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICAgc2NoZW1lID0ge1xuICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbihkaWdlc3QsIGQpIHtcbiAgICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICAgZCA9IF9kZWNvZGVQa2NzMV92MV81KGQsIGtleSwgdHJ1ZSk7XG4gICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IGQ7XG4gICAgICAgICB9XG4gICAgICAgfTtcbiAgICAgfVxuXG4gICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICAgdmFyIGQgPSBwa2kucnNhLmRlY3J5cHQoc2lnbmF0dXJlLCBrZXksIHRydWUsIGZhbHNlKTtcbiAgICAgcmV0dXJuIHNjaGVtZS52ZXJpZnkoZGlnZXN0LCBkLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBSU0EgcHJpdmF0ZSBrZXkgZnJvbSBCaWdJbnRlZ2VycyBtb2R1bHVzLCBleHBvbmVudCwgcHJpbWVzLFxuICogcHJpbWUgZXhwb25lbnRzLCBhbmQgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICpcbiAqIEBwYXJhbSBuIHRoZSBtb2R1bHVzLlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudC5cbiAqIEBwYXJhbSBkIHRoZSBwcml2YXRlIGV4cG9uZW50ICgoaW52ZXJzZSBvZiBlKSBtb2QgbikuXG4gKiBAcGFyYW0gcCB0aGUgZmlyc3QgcHJpbWUuXG4gKiBAcGFyYW0gcSB0aGUgc2Vjb25kIHByaW1lLlxuICogQHBhcmFtIGRQIGV4cG9uZW50MSAoZCBtb2QgKHAtMSkpLlxuICogQHBhcmFtIGRRIGV4cG9uZW50MiAoZCBtb2QgKHEtMSkpLlxuICogQHBhcmFtIHFJbnYgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kuc2V0UnNhUHJpdmF0ZUtleSA9IHBraS5yc2Euc2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uKFxuICBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnYpIHtcbiAgdmFyIGtleSA9IHtcbiAgICBuOiBuLFxuICAgIGU6IGUsXG4gICAgZDogZCxcbiAgICBwOiBwLFxuICAgIHE6IHEsXG4gICAgZFA6IGRQLFxuICAgIGRROiBkUSxcbiAgICBxSW52OiBxSW52XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHdpdGggdGhpcyBwcml2YXRlIGtleS4gVGhlIGRlY3J5cHRpb24gc2NoZW1lXG4gICAqIG11c3QgbWF0Y2ggdGhlIG9uZSB1c2VkIHRvIGVuY3J5cHQgdGhlIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBieXRlIHN0cmluZyB0byBkZWNyeXB0LlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBkZWNyeXB0aW9uIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FFUy1QS0NTMS1WMV81JyAoZGVmYXVsdCksXG4gICAqICAgICAgICAgICdSU0EtT0FFUCcsXG4gICAqICAgICAgICAgICdSQVcnLCAnTk9ORScsIG9yIG51bGwgdG8gcGVyZm9ybSByYXcgUlNBIGRlY3J5cHRpb24uXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZGVjcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmRlY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgLy8gZG8gcnNhIGRlY3J5cHRpb24gdy9vIGFueSBkZWNvZGluZ1xuICAgIHZhciBkID0gcGtpLnJzYS5kZWNyeXB0KGRhdGEsIGtleSwgZmFsc2UsIGZhbHNlKTtcblxuICAgIGlmKHNjaGVtZSA9PT0gJ1JTQUVTLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogX2RlY29kZVBrY3MxX3YxXzUgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnUlNBLU9BRVAnIHx8IHNjaGVtZSA9PT0gJ1JTQUVTLU9BRVAnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIGRlY29kZTogZnVuY3Rpb24oZCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZvcmdlLnBrY3MxLmRlY29kZV9yc2Ffb2FlcChrZXksIGQsIHNjaGVtZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihbJ1JBVycsICdOT05FJywgJ05VTEwnLCBudWxsXS5pbmRleE9mKHNjaGVtZSkgIT09IC0xKSB7XG4gICAgICBzY2hlbWUgPSB7IGRlY29kZTogZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicgKyBzY2hlbWUgKyAnXCIuJyk7XG4gICAgfVxuXG4gICAgLy8gZGVjb2RlIGFjY29yZGluZyB0byBzY2hlbWVcbiAgICByZXR1cm4gc2NoZW1lLmRlY29kZShkLCBrZXksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhlIGdpdmVuIGRpZ2VzdCwgcHJvZHVjaW5nIGEgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBQS0NTIzEgc3VwcG9ydHMgbXVsdGlwbGUgKGN1cnJlbnRseSB0d28pIHNpZ25hdHVyZSBzY2hlbWVzOlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSBhbmQgUlNBU1NBLVBTUy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCB0aGlzIGltcGxlbWVudGF0aW9uIHVzZXMgdGhlIFwib2xkIHNjaGVtZVwiLCBpLmUuXG4gICAqIFJTQVNTQS1QS0NTMS1WMV81LiBJbiBvcmRlciB0byBnZW5lcmF0ZSBhIFBTUyBzaWduYXR1cmUsIHByb3ZpZGVcbiAgICogYW4gaW5zdGFuY2Ugb2YgRm9yZ2UgUFNTIG9iamVjdCBhcyB0aGUgc2NoZW1lIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3Qgd2l0aCB0aGUgaGFzaCB0byBzaWduLlxuICAgKiBAcGFyYW0gc2NoZW1lIHRoZSBzaWduYXR1cmUgc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQVNTQS1QS0NTMS1WMV81JyBvciB1bmRlZmluZWQgZm9yIFJTQVNTQSBQS0NTIzEgdjEuNSxcbiAgICogICAgICAgICAgYSBGb3JnZSBQU1Mgb2JqZWN0IGZvciBSU0FTU0EtUFNTLFxuICAgKiAgICAgICAgICAnTk9ORScgb3IgbnVsbCBmb3Igbm9uZSwgRGlnZXN0SW5mbyB3aWxsIG5vdCBiZSB1c2VkIGJ1dFxuICAgKiAgICAgICAgICAgIFBLQ1MjMSB2MS41IHBhZGRpbmcgd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzaWduYXR1cmUgYXMgYSBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5zaWduID0gZnVuY3Rpb24obWQsIHNjaGVtZSkge1xuICAgIC8qIE5vdGU6IFRoZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBSU0Egb3BlcmF0aW9ucyBpcyBiZWluZ1xuICAgICAgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhIFBLQ1MjMSB2MS41IGhhcmQtY29kZWQgc2NoZW1lLiBTb21lIGxlZ2FjeVxuICAgICAgY29kZSBsaWtlIHRoZSB1c2Ugb2YgYW4gZW5jb2RpbmcgYmxvY2sgaWRlbnRpZmllciAnYnQnIHdpbGwgZXZlbnR1YWxseVxuICAgICAgYmUgcmVtb3ZlZC4gKi9cblxuICAgIC8vIHByaXZhdGUga2V5IG9wZXJhdGlvblxuICAgIHZhciBidCA9IGZhbHNlO1xuXG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8IHNjaGVtZSA9PT0gJ1JTQVNTQS1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0geyBlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZSB9O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdOT05FJyB8fCBzY2hlbWUgPT09ICdOVUxMJyB8fCBzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgIHNjaGVtZSA9IHsgZW5jb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIG1kOyB9IH07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfVxuXG4gICAgLy8gZW5jb2RlIGFuZCB0aGVuIGVuY3J5cHRcbiAgICB2YXIgZCA9IHNjaGVtZS5lbmNvZGUobWQsIGtleS5uLmJpdExlbmd0aCgpKTtcbiAgICByZXR1cm4gcGtpLnJzYS5lbmNyeXB0KGQsIGtleSwgYnQpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFdyYXBzIGFuIFJTQVByaXZhdGVLZXkgQVNOLjEgb2JqZWN0IGluIGFuIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kud3JhcFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihyc2FLZXkpIHtcbiAgLy8gUHJpdmF0ZUtleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uICgwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgIF0pLFxuICAgIC8vIFByaXZhdGVLZXlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgIGFzbjEudG9EZXIocnNhS2V5KS5nZXRCeXRlcygpKVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGEgUHJpdmF0ZUtleUluZm8gY29udGFpbmluZyBhblxuICogICAgICAgICAgUlNBUHJpdmF0ZUtleSBvciBhbiBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUZyb21Bc24xID0gZnVuY3Rpb24ob2JqKSB7XG4gIC8vIGdldCBQcml2YXRlS2V5SW5mb1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKGFzbjEudmFsaWRhdGUob2JqLCBwcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgb2JqID0gYXNuMS5mcm9tRGVyKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleSkpO1xuICB9XG5cbiAgLy8gZ2V0IFJTQVByaXZhdGVLZXlcbiAgY2FwdHVyZSA9IHt9O1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQcml2YXRlS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYW4gUlNBUHJpdmF0ZUtleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBOb3RlOiBWZXJzaW9uIGlzIGN1cnJlbnRseSBpZ25vcmVkLlxuICAvLyBjYXB0dXJlLnByaXZhdGVLZXlWZXJzaW9uXG4gIC8vIEZJWE1FOiBpbmVmZmljaWVudCwgZ2V0IGEgQmlnSW50ZWdlciB0aGF0IHVzZXMgYnl0ZSBzdHJpbmdzXG4gIHZhciBuLCBlLCBkLCBwLCBxLCBkUCwgZFEsIHFJbnY7XG4gIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlNb2R1bHVzKS50b0hleCgpO1xuICBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5UHVibGljRXhwb25lbnQpLnRvSGV4KCk7XG4gIGQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcml2YXRlRXhwb25lbnQpLnRvSGV4KCk7XG4gIHAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTEpLnRvSGV4KCk7XG4gIHEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQcmltZTIpLnRvSGV4KCk7XG4gIGRQID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpO1xuICBkUSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUV4cG9uZW50MikudG9IZXgoKTtcbiAgcUludiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleUNvZWZmaWNpZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwcml2YXRlIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVByaXZhdGVLZXkoXG4gICAgbmV3IEJpZ0ludGVnZXIobiwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGUsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKHEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihkUCwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRRLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocUludiwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwcml2YXRlIGtleSB0byBhbiBBU04uMSBSU0FQcml2YXRlS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIHJlcHJlc2VudGF0aW9uIG9mIGFuIFJTQVByaXZhdGVLZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5VG9Bc24xID0gcGtpLnByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIHZlcnNpb24gKDAgPSBvbmx5IDIgcHJpbWVzLCAxIG11bHRpcGxlIHByaW1lcylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gbW9kdWx1cyAobilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkubikpLFxuICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5lKSksXG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMSAocClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucCkpLFxuICAgIC8vIHByaXZhdGVLZXlQcmltZTIgKHEpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LnEpKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQxIChkUClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFApKSxcbiAgICAvLyBwcml2YXRlS2V5RXhwb25lbnQyIChkUSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZFEpKSxcbiAgICAvLyBjb2VmZmljaWVudCAocUludilcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucUludikpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgZnJvbSBhbiBBU04uMSBTdWJqZWN0UHVibGljS2V5SW5mbyBvciBSU0FQdWJsaWNLZXkuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHB1YmxpY0tleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIC8vIGdldCBvaWRcbiAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLnB1YmxpY0tleU9pZCk7XG4gICAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIFVua25vd24gT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIG9iaiA9IGNhcHR1cmUucnNhUHVibGljS2V5O1xuICB9XG5cbiAgLy8gZ2V0IFJTQSBwYXJhbXNcbiAgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgcnNhUHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQdWJsaWNLZXkuJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleU1vZHVsdXMpLnRvSGV4KCk7XG4gIHZhciBlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wdWJsaWNLZXlFeHBvbmVudCkudG9IZXgoKTtcblxuICAvLyBzZXQgcHVibGljIGtleVxuICByZXR1cm4gcGtpLnNldFJzYVB1YmxpY0tleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFN1YmplY3RQdWJsaWNLZXlJbmZvLlxuICovXG5wa2kucHVibGljS2V5VG9Bc24xID0gcGtpLnB1YmxpY0tleVRvU3ViamVjdFB1YmxpY0tleUluZm8gPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBBbGdvcml0aG1JZGVudGlmaWVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgXSksXG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgW1xuICAgICAgcGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSlcbiAgICBdKVxuICBdKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIGFuIEFTTi4xIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBSU0FQdWJsaWNLZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQdWJsaWNLZXlcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKVxuICBdKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gbSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBidCB0aGUgYmxvY2sgdHlwZSB0byB1c2UsIGkuZS4gZWl0aGVyIDB4MDEgKGZvciBzaWduaW5nKSBvciAweDAyXG4gKiAgICAgICAgICAoZm9yIGVuY3J5cHRpb24pLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhZGRlZCBieXRlIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX2VuY29kZVBrY3MxX3YxXzUobSwga2V5LCBidCkge1xuICB2YXIgZWIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgKi9cbiAgaWYobS5sZW5ndGggPiAoayAtIDExKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtLmxlbmd0aDtcbiAgICBlcnJvci5tYXggPSBrIC0gMTE7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvKiBBIGJsb2NrIHR5cGUgQlQsIGEgcGFkZGluZyBzdHJpbmcgUFMsIGFuZCB0aGUgZGF0YSBEIHNoYWxsIGJlXG4gICAgZm9ybWF0dGVkIGludG8gYW4gb2N0ZXQgc3RyaW5nIEVCLCB0aGUgZW5jcnlwdGlvbiBibG9jazpcblxuICAgIEVCID0gMDAgfHwgQlQgfHwgUFMgfHwgMDAgfHwgRFxuXG4gICAgVGhlIGJsb2NrIHR5cGUgQlQgc2hhbGwgYmUgYSBzaW5nbGUgb2N0ZXQgaW5kaWNhdGluZyB0aGUgc3RydWN0dXJlIG9mXG4gICAgdGhlIGVuY3J5cHRpb24gYmxvY2suIEZvciB0aGlzIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50IGl0IHNoYWxsIGhhdmVcbiAgICB2YWx1ZSAwMCwgMDEsIG9yIDAyLiBGb3IgYSBwcml2YXRlLWtleSBvcGVyYXRpb24sIHRoZSBibG9jayB0eXBlXG4gICAgc2hhbGwgYmUgMDAgb3IgMDEuIEZvciBhIHB1YmxpYy1rZXkgb3BlcmF0aW9uLCBpdCBzaGFsbCBiZSAwMi5cblxuICAgIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBzaGFsbCBjb25zaXN0IG9mIGstMy18fER8fCBvY3RldHMuIEZvciBibG9ja1xuICAgIHR5cGUgMDAsIHRoZSBvY3RldHMgc2hhbGwgaGF2ZSB2YWx1ZSAwMDsgZm9yIGJsb2NrIHR5cGUgMDEsIHRoZXlcbiAgICBzaGFsbCBoYXZlIHZhbHVlIEZGOyBhbmQgZm9yIGJsb2NrIHR5cGUgMDIsIHRoZXkgc2hhbGwgYmVcbiAgICBwc2V1ZG9yYW5kb21seSBnZW5lcmF0ZWQgYW5kIG5vbnplcm8uIFRoaXMgbWFrZXMgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBlbmNyeXB0aW9uIGJsb2NrIEVCIGVxdWFsIHRvIGsuICovXG5cbiAgLy8gYnVpbGQgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgZWIucHV0Qnl0ZShidCk7XG5cbiAgLy8gY3JlYXRlIHRoZSBwYWRkaW5nXG4gIHZhciBwYWROdW0gPSBrIC0gMyAtIG0ubGVuZ3RoO1xuICB2YXIgcGFkQnl0ZTtcbiAgLy8gcHJpdmF0ZSBrZXkgb3BcbiAgaWYoYnQgPT09IDB4MDAgfHwgYnQgPT09IDB4MDEpIHtcbiAgICBwYWRCeXRlID0gKGJ0ID09PSAweDAwKSA/IDB4MDAgOiAweEZGO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcHVibGljIGtleSBvcFxuICAgIC8vIHBhZCB3aXRoIHJhbmRvbSBub24temVybyB2YWx1ZXNcbiAgICB3aGlsZShwYWROdW0gPiAwKSB7XG4gICAgICB2YXIgbnVtWmVyb3MgPSAwO1xuICAgICAgdmFyIHBhZEJ5dGVzID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKHBhZE51bSk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgICAgcGFkQnl0ZSA9IHBhZEJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmKHBhZEJ5dGUgPT09IDApIHtcbiAgICAgICAgICArK251bVplcm9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGViLnB1dEJ5dGUocGFkQnl0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhZE51bSA9IG51bVplcm9zO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gZm9sbG93ZWQgYnkgbWVzc2FnZVxuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlcyhtKTtcblxuICByZXR1cm4gZWI7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2UgdXNpbmcgUEtDUyMxIHYxLjUgcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gZW0gdGhlIG1lc3NhZ2UgdG8gZGVjb2RlLlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gcHViIHRydWUgaWYgdGhlIGtleSBpcyBhIHB1YmxpYyBrZXksIGZhbHNlIGlmIGl0IGlzIHByaXZhdGUuXG4gKiBAcGFyYW0gbWwgdGhlIG1lc3NhZ2UgbGVuZ3RoLCBpZiBzcGVjaWZpZWQuXG4gKlxuICogQHJldHVybiB0aGUgZGVjb2RlZCBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZVBrY3MxX3YxXzUoZW0sIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8qIEl0IGlzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgb2NjdXJzOlxuXG4gICAgMS4gVGhlIGVuY3J5cHRpb24gYmxvY2sgRUIgY2Fubm90IGJlIHBhcnNlZCB1bmFtYmlndW91c2x5LlxuICAgIDIuIFRoZSBwYWRkaW5nIHN0cmluZyBQUyBjb25zaXN0cyBvZiBmZXdlciB0aGFuIGVpZ2h0IG9jdGV0c1xuICAgICAgb3IgaXMgaW5jb25zaXNlbnQgd2l0aCB0aGUgYmxvY2sgdHlwZSBCVC5cbiAgICAzLiBUaGUgZGVjcnlwdGlvbiBwcm9jZXNzIGlzIGEgcHVibGljLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9ja1xuICAgICAgdHlwZSBCVCBpcyBub3QgMDAgb3IgMDEsIG9yIHRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYVxuICAgICAgcHJpdmF0ZS1rZXkgb3BlcmF0aW9uIGFuZCB0aGUgYmxvY2sgdHlwZSBpcyBub3QgMDIuXG4gICAqL1xuXG4gIC8vIHBhcnNlIHRoZSBlbmNyeXB0aW9uIGJsb2NrXG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGVtKTtcbiAgdmFyIGZpcnN0ID0gZWIuZ2V0Qnl0ZSgpO1xuICB2YXIgYnQgPSBlYi5nZXRCeXRlKCk7XG4gIGlmKGZpcnN0ICE9PSAweDAwIHx8XG4gICAgKHB1YiAmJiBidCAhPT0gMHgwMCAmJiBidCAhPT0gMHgwMSkgfHxcbiAgICAoIXB1YiAmJiBidCAhPSAweDAyKSB8fFxuICAgIChwdWIgJiYgYnQgPT09IDB4MDAgJiYgdHlwZW9mKG1sKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICB2YXIgcGFkTnVtID0gMDtcbiAgaWYoYnQgPT09IDB4MDApIHtcbiAgICAvLyBjaGVjayBhbGwgcGFkZGluZyBieXRlcyBmb3IgMHgwMFxuICAgIHBhZE51bSA9IGsgLSAzIC0gbWw7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDEpIHtcbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBieXRlIHRoYXQgaXNuJ3QgMHhGRiwgc2hvdWxkIGJlIGFmdGVyIGFsbCBwYWRkaW5nXG4gICAgcGFkTnVtID0gMDtcbiAgICB3aGlsZShlYi5sZW5ndGgoKSA+IDEpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHhGRikge1xuICAgICAgICAtLWViLnJlYWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgKytwYWROdW07XG4gICAgfVxuICB9IGVsc2UgaWYoYnQgPT09IDB4MDIpIHtcbiAgICAvLyBsb29rIGZvciAweDAwIGJ5dGVcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpID09PSAweDAwKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH1cblxuICAvLyB6ZXJvIG11c3QgYmUgMHgwMCBhbmQgcGFkTnVtIG11c3QgYmUgKGsgLSAzIC0gbWVzc2FnZSBsZW5ndGgpXG4gIHZhciB6ZXJvID0gZWIuZ2V0Qnl0ZSgpO1xuICBpZih6ZXJvICE9PSAweDAwIHx8IHBhZE51bSAhPT0gKGsgLSAzIC0gZWIubGVuZ3RoKCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICByZXR1cm4gZWIuZ2V0Qnl0ZXMoKTtcbn1cblxuLyoqXG4gKiBSdW5zIHRoZSBrZXktZ2VuZXJhdGlvbiBhbGdvcml0aG0gYXN5bmNocm9ub3VzbHksIGVpdGhlciBpbiB0aGUgYmFja2dyb3VuZFxuICogdmlhIFdlYiBXb3JrZXJzLCBvciB1c2luZyB0aGUgbWFpbiB0aHJlYWQgYW5kIHNldEltbWVkaWF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb246XG4gKiAgICAgICAgICB3b3JrZXJTY3JpcHQgdGhlIHdvcmtlciBzY3JpcHQgVVJMLlxuICogICAgICAgICAgd29ya2VycyB0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDIsIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lKS5cbiAqICAgICAgICAgIHdvcmtMb2FkIHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiAxMDApLlxuICogQHBhcmFtIGNhbGxiYWNrKGVyciwga2V5cGFpcikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9nZW5lcmF0ZUtleVBhaXIoc3RhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgb3B0cyA9IHtcbiAgICBhbGdvcml0aG06IHtcbiAgICAgIG5hbWU6IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHdvcmtlcnM6IG9wdGlvbnMud29ya2VycyB8fCAyLFxuICAgICAgICB3b3JrTG9hZDogb3B0aW9ucy53b3JrTG9hZCB8fCAxMDAsXG4gICAgICAgIHdvcmtlclNjcmlwdDogb3B0aW9ucy53b3JrZXJTY3JpcHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmKCdwcm5nJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0cy5wcm5nID0gb3B0aW9ucy5wcm5nO1xuICB9XG5cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyBmaW5kIHAgYW5kIHRoZW4gcSAoZG9uZSBpbiBzZXJpZXMgdG8gc2ltcGxpZnkpXG4gICAgZ2V0UHJpbWUoc3RhdGUucEJpdHMsIGZ1bmN0aW9uKGVyciwgbnVtKSB7XG4gICAgICBpZihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5wID0gbnVtO1xuICAgICAgaWYoc3RhdGUucSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmluaXNoKGVyciwgc3RhdGUucSk7XG4gICAgICB9XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByaW1lKGJpdHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yZ2UucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lKGJpdHMsIG9wdHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaChlcnIsIG51bSkge1xuICAgIGlmKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0IHFcbiAgICBzdGF0ZS5xID0gbnVtO1xuXG4gICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICBpZihzdGF0ZS5wLmNvbXBhcmVUbyhzdGF0ZS5xKSA8IDApIHtcbiAgICAgIHZhciB0bXAgPSBzdGF0ZS5wO1xuICAgICAgc3RhdGUucCA9IHN0YXRlLnE7XG4gICAgICBzdGF0ZS5xID0gdG1wO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucCA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBxIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgaWYoc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkuZ2NkKHN0YXRlLmUpXG4gICAgICAuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICBzdGF0ZS5wMSA9IHN0YXRlLnAuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgIHN0YXRlLnExID0gc3RhdGUucS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuXG4gICAgLy8gZW5zdXJlIGUgYW5kIHBoaSBhcmUgY29wcmltZVxuICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPT0gMCkge1xuICAgICAgLy8gcGhpIGFuZCBlIGFyZW4ndCBjb3ByaW1lLCBzbyBnZW5lcmF0ZSBhIG5ldyBwIGFuZCBxXG4gICAgICBzdGF0ZS5wID0gc3RhdGUucSA9IG51bGw7XG4gICAgICBnZW5lcmF0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgc3RhdGUubiA9IHN0YXRlLnAubXVsdGlwbHkoc3RhdGUucSk7XG4gICAgaWYoc3RhdGUubi5iaXRMZW5ndGgoKSAhPT0gc3RhdGUuYml0cykge1xuICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgIHN0YXRlLnEgPSBudWxsO1xuICAgICAgZ2V0UHJpbWUoc3RhdGUucUJpdHMsIGZpbmlzaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGtleXNcbiAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgIHN0YXRlLmtleXMgPSB7XG4gICAgICBwcml2YXRlS2V5OiBwa2kucnNhLnNldFByaXZhdGVLZXkoXG4gICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgIGQubW9kKHN0YXRlLnAxKSwgZC5tb2Qoc3RhdGUucTEpLFxuICAgICAgICBzdGF0ZS5xLm1vZEludmVyc2Uoc3RhdGUucCkpLFxuICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgIH07XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0ZS5rZXlzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcG9zaXRpdmUgQmlnSW50ZWdlciBpbnRvIDIncy1jb21wbGVtZW50IGJpZy1lbmRpYW4gYnl0ZXMuXG4gKlxuICogQHBhcmFtIGIgdGhlIGJpZyBpbnRlZ2VyIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9iblRvQnl0ZXMoYikge1xuICAvLyBwcmVwZW5kIDB4MDAgaWYgZmlyc3QgYnl0ZSA+PSAweDgwXG4gIHZhciBoZXggPSBiLnRvU3RyaW5nKDE2KTtcbiAgaWYoaGV4WzBdID49ICc4Jykge1xuICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gIH1cbiAgdmFyIGJ5dGVzID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGhleCk7XG5cbiAgLy8gZW5zdXJlIGludGVnZXIgaXMgbWluaW1hbGx5LWVuY29kZWRcbiAgaWYoYnl0ZXMubGVuZ3RoID4gMSAmJlxuICAgIC8vIGxlYWRpbmcgMHgwMCBmb3IgcG9zaXRpdmUgaW50ZWdlclxuICAgICgoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMCAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgLy8gbGVhZGluZyAweEZGIGZvciBuZWdhdGl2ZSBpbnRlZ2VyXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgxKSAmIDB4ODApID09PSAweDgwKSkpIHtcbiAgICByZXR1cm4gYnl0ZXMuc3Vic3RyKDEpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBmZWF0dXJlIGRldGVjdGlvbiBvbiB0aGUgZGVwcmVjYXRlZCBNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIG91dGRhdGVkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBhZnRlclxuICogY2hlY2tpbmcgZm9yIHRoZSBtb2Rlcm4sIHN0YW5kYXJkIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oZm4pIHtcbiAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8gPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZCAoQUVTKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBwdWJsaWMgZG9tYWluIGxpYnJhcnkgJ2pzY3J5cHRvJyB3aGljaFxuICogd2FzIHdyaXR0ZW4gYnk6XG4gKlxuICogRW1pbHkgU3RhcmsgKGVzdGFya0BzdGFuZm9yZC5lZHUpXG4gKiBNaWtlIEhhbWJ1cmcgKG1oYW1idXJnQHN0YW5mb3JkLmVkdSlcbiAqIERhbiBCb25laCAoZGFib0Bjcy5zdGFuZm9yZC5lZHUpXG4gKlxuICogUGFydHMgb2YgdGhpcyBjb2RlIGFyZSBiYXNlZCBvbiB0aGUgT3BlblNTTCBpbXBsZW1lbnRhdGlvbiBvZiBBRVM6XG4gKiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8qIEFFUyBBUEkgKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYWVzID0gZm9yZ2UuYWVzIHx8IHt9O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RW5jcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZGVjaXBoZXIuc3RhcnQoe2l2OiBpdn0pO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICogVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcyxcbiAqIGEgYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuYWVzLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCwgbW9kZSkge1xuICB2YXIgY2lwaGVyID0gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGFuIEFFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgbW9kZSkge1xuICByZXR1cm4gX2NyZWF0ZUNpcGhlcih7XG4gICAga2V5OiBrZXksXG4gICAgb3V0cHV0OiBudWxsLFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBRVMgY2lwaGVyIGFsZ29yaXRobSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBtb2RlIGZhY3RvcnkgZnVuY3Rpb24uXG4gKlxuICogQHJldHVybiB0aGUgQUVTIGFsZ29yaXRobSBvYmplY3QuXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0gPSBmdW5jdGlvbihuYW1lLCBtb2RlKSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5uYW1lID0gbmFtZTtcbiAgc2VsZi5tb2RlID0gbmV3IG1vZGUoe1xuICAgIGJsb2NrU2l6ZTogMTYsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl93LCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEFFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5hZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdG1wO1xuXG4gIC8qIE5vdGU6IFRoZSBrZXkgbWF5IGJlIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYSBieXRlXG4gICAgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuIElmIHRoZSBrZXkgaXMgaW4gYnl0ZXMsIHRoZW5cbiAgICBpdCBtdXN0IGJlIDE2LCAyNCwgb3IgMzIgYnl0ZXMgaW4gbGVuZ3RoLiBJZiBpdCBpcyBpbiAzMi1iaXRcbiAgICBpbnRlZ2VycywgaXQgbXVzdCBiZSA0LCA2LCBvciA4IGludGVnZXJzIGxvbmcuICovXG5cbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgJiZcbiAgICAoa2V5Lmxlbmd0aCA9PT0gMTYgfHwga2V5Lmxlbmd0aCA9PT0gMjQgfHwga2V5Lmxlbmd0aCA9PT0gMzIpKSB7XG4gICAgLy8gY29udmVydCBrZXkgaW50ZWdlciBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBjb252ZXJ0IGtleSBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgIHRtcCA9IGtleTtcbiAgICBrZXkgPSBbXTtcblxuICAgIC8vIGtleSBsZW5ndGhzIG9mIDE2LCAyNCwgMzIgYnl0ZXMgYWxsb3dlZFxuICAgIHZhciBsZW4gPSB0bXAubGVuZ3RoKCk7XG4gICAgaWYobGVuID09PSAxNiB8fCBsZW4gPT09IDI0IHx8IGxlbiA9PT0gMzIpIHtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gMjtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBrZXkucHVzaCh0bXAuZ2V0SW50MzIoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2V5IG11c3QgYmUgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzIGJ5IG5vd1xuICBpZighZm9yZ2UudXRpbC5pc0FycmF5KGtleSkgfHxcbiAgICAhKGtleS5sZW5ndGggPT09IDQgfHwga2V5Lmxlbmd0aCA9PT0gNiB8fCBrZXkubGVuZ3RoID09PSA4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgLy8gZW5jcnlwdGlvbiBvcGVyYXRpb24gaXMgYWx3YXlzIHVzZWQgZm9yIHRoZXNlIG1vZGVzXG4gIHZhciBtb2RlID0gdGhpcy5tb2RlLm5hbWU7XG4gIHZhciBlbmNyeXB0T3AgPSAoWydDRkInLCAnT0ZCJywgJ0NUUicsICdHQ00nXS5pbmRleE9mKG1vZGUpICE9PSAtMSk7XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvblxuICB0aGlzLl93ID0gX2V4cGFuZEtleShrZXksIG9wdGlvbnMuZGVjcnlwdCAmJiAhZW5jcnlwdE9wKTtcbiAgdGhpcy5faW5pdCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEV4cGFuZHMgYSBrZXkuIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byBleHBhbmQsIGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZXhwYW5kIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXkuXG4gKi9cbmZvcmdlLmFlcy5fZXhwYW5kS2V5ID0gZnVuY3Rpb24oa2V5LCBkZWNyeXB0KSB7XG4gIGlmKCFpbml0KSB7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2suIFR5cGljYWxseSBvbmx5IHVzZWQgZm9yIHRlc3RpbmcuXG4gKlxuICogQHBhcmFtIHcgdGhlIGV4cGFuZGVkIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaW5wdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gb3V0cHV0IGFuIGFycmF5IG9mIGJsb2NrLXNpemUgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0LCBmYWxzZSB0byBlbmNyeXB0LlxuICovXG5mb3JnZS5hZXMuX3VwZGF0ZUJsb2NrID0gX3VwZGF0ZUJsb2NrO1xuXG4vKiogUmVnaXN0ZXIgQUVTIGFsZ29yaXRobXMgKiovXG5cbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNCQycsIGZvcmdlLmNpcGhlci5tb2Rlcy5jYmMpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1DRkInLCBmb3JnZS5jaXBoZXIubW9kZXMuY2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNUUicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jdHIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1HQ00nLCBmb3JnZS5jaXBoZXIubW9kZXMuZ2NtKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogQUVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgaW5pdCA9IGZhbHNlOyAvLyBub3QgeWV0IGluaXRpYWxpemVkXG52YXIgTmIgPSA0OyAgICAgICAvLyBudW1iZXIgb2Ygd29yZHMgY29tcHJpc2luZyB0aGUgc3RhdGUgKEFFUyA9IDQpXG52YXIgc2JveDsgICAgICAgICAvLyBub24tbGluZWFyIHN1YnN0aXR1dGlvbiB0YWJsZSB1c2VkIGluIGtleSBleHBhbnNpb25cbnZhciBpc2JveDsgICAgICAgIC8vIGludmVyc2lvbiBvZiBzYm94XG52YXIgcmNvbjsgICAgICAgICAvLyByb3VuZCBjb25zdGFudCB3b3JkIGFycmF5XG52YXIgbWl4OyAgICAgICAgICAvLyBtaXgtY29sdW1ucyB0YWJsZVxudmFyIGltaXg7ICAgICAgICAgLy8gaW52ZXJzZSBtaXgtY29sdW1ucyB0YWJsZVxuXG4vKipcbiAqIFBlcmZvcm1zIGluaXRpYWxpemF0aW9uLCBpZTogcHJlY29tcHV0ZXMgdGFibGVzIHRvIG9wdGltaXplIGZvciBzcGVlZC5cbiAqXG4gKiBPbmUgd2F5IHRvIHVuZGVyc3RhbmQgaG93IEFFUyB3b3JrcyBpcyB0byBpbWFnaW5lIHRoYXQgJ2FkZGl0aW9uJyBhbmRcbiAqICdtdWx0aXBsaWNhdGlvbicgYXJlIGludGVyZmFjZXMgdGhhdCByZXF1aXJlIGNlcnRhaW4gbWF0aGVtYXRpY2FsXG4gKiBwcm9wZXJ0aWVzIHRvIGhvbGQgdHJ1ZSAoaWU6IHRoZXkgYXJlIGFzc29jaWF0aXZlKSBidXQgdGhleSBtaWdodCBoYXZlXG4gKiBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25zIGFuZCBwcm9kdWNlIGRpZmZlcmVudCBraW5kcyBvZiByZXN1bHRzIC4uLlxuICogcHJvdmlkZWQgdGhhdCB0aGVpciBtYXRoZW1hdGljYWwgcHJvcGVydGllcyByZW1haW4gdHJ1ZS4gQUVTIGRlZmluZXNcbiAqIGl0cyBvd24gbWV0aG9kcyBvZiBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gYnV0IGtlZXBzIHNvbWUgaW1wb3J0YW50XG4gKiBwcm9wZXJ0aWVzIHRoZSBzYW1lLCBpZTogYXNzb2NpYXRpdml0eSBhbmQgZGlzdHJpYnV0aXZpdHkuIFRoZVxuICogZXhwbGFuYXRpb24gYmVsb3cgdHJpZXMgdG8gc2hlZCBzb21lIGxpZ2h0IG9uIGhvdyBBRVMgZGVmaW5lcyBhZGRpdGlvblxuICogYW5kIG11bHRpcGxpY2F0aW9uIG9mIGJ5dGVzIGFuZCAzMi1iaXQgd29yZHMgaW4gb3JkZXIgdG8gcGVyZm9ybSBpdHNcbiAqIGVuY3J5cHRpb24gYW5kIGRlY3J5cHRpb24gYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGUgYmFzaWNzOlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHZpZXdzIGJ5dGVzIGFzIGJpbmFyeSByZXByZXNlbnRhdGlvbnMgb2YgcG9seW5vbWlhbHNcbiAqIHRoYXQgaGF2ZSBlaXRoZXIgMSBvciAwIGFzIHRoZSBjb2VmZmljaWVudHMuIEl0IGRlZmluZXMgdGhlIGFkZGl0aW9uXG4gKiBvciBzdWJ0cmFjdGlvbiBvZiB0d28gYnl0ZXMgYXMgdGhlIFhPUiBvcGVyYXRpb24uIEl0IGFsc28gZGVmaW5lcyB0aGVcbiAqIG11bHRpcGxpY2F0aW9uIG9mIHR3byBieXRlcyBhcyBhIGZpbml0ZSBmaWVsZCByZWZlcnJlZCB0byBhcyBHRigyXjgpXG4gKiAoTm90ZTogJ0dGJyBtZWFucyBcIkdhbG9pcyBGaWVsZFwiIHdoaWNoIGlzIGEgZmllbGQgdGhhdCBjb250YWlucyBhIGZpbml0ZVxuICogbnVtYmVyIG9mIGVsZW1lbnRzIHNvIEdGKDJeOCkgaGFzIDI1NiBlbGVtZW50cykuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IGFueSB0d28gYnl0ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGJpbmFyeSBwb2x5bm9taWFscztcbiAqIHdoZW4gdGhleSBtdWx0aXBsaWVkIHRvZ2V0aGVyIGFuZCBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiB0aGUgOHRoIGRlZ3JlZSwgdGhlIHJlc3VsdHMgYXJlIHRoZSBmaWVsZCBHRigyXjgpLiBUaGVcbiAqIHNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgdGhhdCBBRVMgdXNlcyBpbiBoZXhhZGVjaW1hbCBpcyAweDExYi5cbiAqIFRoaXMgbXVsdGlwbGljYXRpb24gaXMgYXNzb2NpYXRpdmUgd2l0aCAweDAxIGFzIHRoZSBpZGVudGl0eTpcbiAqXG4gKiAoYiAqIDB4MDEgPSBHRihiLCAweDAxKSA9IGIpLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gR0YoYiwgMHgwMikgY2FuIGJlIHBlcmZvcm1lZCBhdCB0aGUgYnl0ZSBsZXZlbCBieSBsZWZ0XG4gKiBzaGlmdGluZyBiIG9uY2UgYW5kIHRoZW4gWE9SJ2luZyBpdCAodG8gcGVyZm9ybSB0aGUgbW9kdWxhciByZWR1Y3Rpb24pXG4gKiB3aXRoIDB4MTFiIGlmIGIgaXMgPj0gMTI4LiBSZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB0aGUgbXVsdGlwbGljYXRpb25cbiAqIG9mIDB4MDIgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IHRoZSBtdWx0aXBsaWNhdGlvbiBvZiBhbnkgdHdvIGJ5dGVzLlxuICpcbiAqIEZvciBpbnN0YW5jZSwgbXVsdGlwbHlpbmcgMHg1NyBhbmQgMHgxMywgZGVub3RlZCBhcyBHRigweDU3LCAweDEzKSwgY2FuXG4gKiBiZSBwZXJmb3JtZWQgYnkgZmFjdG9yaW5nIDB4MTMgaW50byAweDAxLCAweDAyLCBhbmQgMHgxMC4gVGhlbiB0aGVzZVxuICogZmFjdG9ycyBjYW4gZWFjaCBiZSBtdWx0aXBsaWVkIGJ5IDB4NTcgYW5kIHRoZW4gYWRkZWQgdG9nZXRoZXIuIFRvIGRvXG4gKiB0aGUgbXVsdGlwbGljYXRpb24sIHZhbHVlcyBmb3IgMHg1NyBtdWx0aXBsaWVkIGJ5IGVhY2ggb2YgdGhlc2UgMyBmYWN0b3JzXG4gKiBjYW4gYmUgcHJlY29tcHV0ZWQgYW5kIHN0b3JlZCBpbiBhIHRhYmxlLiBUbyBhZGQgdGhlbSwgdGhlIHZhbHVlcyBmcm9tXG4gKiB0aGUgdGFibGUgYXJlIFhPUidkIHRvZ2V0aGVyLlxuICpcbiAqIEFFUyBhbHNvIGRlZmluZXMgYWRkaXRpb24gYW5kIG11bHRpcGxpY2F0aW9uIG9mIHdvcmRzLCB0aGF0IGlzIDQtYnl0ZVxuICogbnVtYmVycyByZXByZXNlbnRlZCBhcyBwb2x5bm9taWFscyBvZiAzIGRlZ3JlZXMgd2hlcmUgdGhlIGNvZWZmaWNpZW50c1xuICogYXJlIHRoZSB2YWx1ZXMgb2YgdGhlIGJ5dGVzLlxuICpcbiAqIFRoZSB3b3JkIFthMCwgYTEsIGEyLCBhM10gaXMgYSBwb2x5bm9taWFsIGEzeF4zICsgYTJ4XjIgKyBhMXggKyBhMC5cbiAqXG4gKiBBZGRpdGlvbiBpcyBwZXJmb3JtZWQgYnkgWE9SJ2luZyBsaWtlIHBvd2VycyBvZiB4LiBNdWx0aXBsaWNhdGlvblxuICogaXMgcGVyZm9ybWVkIGluIHR3byBzdGVwcywgdGhlIGZpcnN0IGlzIGFuIGFsZ2VicmlhYyBleHBhbnNpb24gYXNcbiAqIHlvdSB3b3VsZCBkbyBub3JtYWxseSAod2hlcmUgYWRkaXRpb24gaXMgWE9SKS4gQnV0IHRoZSByZXN1bHQgaXNcbiAqIGEgcG9seW5vbWlhbCBsYXJnZXIgdGhhbiAzIGRlZ3JlZXMgYW5kIHRodXMgaXQgY2Fubm90IGZpdCBpbiBhIHdvcmQuIFNvXG4gKiBuZXh0IHRoZSByZXN1bHQgaXMgbW9kdWxhcmx5IHJlZHVjZWQgYnkgYW4gQUVTLXNwZWNpZmljIHBvbHlub21pYWwgb2ZcbiAqIGRlZ3JlZSA0IHdoaWNoIHdpbGwgYWx3YXlzIHByb2R1Y2UgYSBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiA0IGRlZ3JlZXNcbiAqIHN1Y2ggdGhhdCBpdCB3aWxsIGZpdCBpbiBhIHdvcmQuIEluIEFFUywgdGhpcyBwb2x5bm9taWFsIGlzIHheNCArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcHJvZHVjdCBvZiB0d28gcG9seW5vbWlhbHMgJ2EnIGFuZCAnYicgaXMgdGh1czpcbiAqXG4gKiBkKHgpID0gZDN4XjMgKyBkMnheMiArIGQxeCArIGQwXG4gKiB3aXRoXG4gKiBkMCA9IEdGKGEwLCBiMCkgXiBHRihhMywgYjEpIF4gR0YoYTIsIGIyKSBeIEdGKGExLCBiMylcbiAqIGQxID0gR0YoYTEsIGIwKSBeIEdGKGEwLCBiMSkgXiBHRihhMywgYjIpIF4gR0YoYTIsIGIzKVxuICogZDIgPSBHRihhMiwgYjApIF4gR0YoYTEsIGIxKSBeIEdGKGEwLCBiMikgXiBHRihhMywgYjMpXG4gKiBkMyA9IEdGKGEzLCBiMCkgXiBHRihhMiwgYjEpIF4gR0YoYTEsIGIyKSBeIEdGKGEwLCBiMylcbiAqXG4gKiBBcyBhIG1hdHJpeDpcbiAqXG4gKiBbZDBdID0gW2EwIGEzIGEyIGExXVtiMF1cbiAqIFtkMV0gICBbYTEgYTAgYTMgYTJdW2IxXVxuICogW2QyXSAgIFthMiBhMSBhMCBhM11bYjJdXG4gKiBbZDNdICAgW2EzIGEyIGExIGEwXVtiM11cbiAqXG4gKiBTcGVjaWFsIHBvbHlub21pYWxzIGRlZmluZWQgYnkgQUVTICgweDAyID09IHswMn0pOlxuICogYSh4KSAgICA9IHswM314XjMgKyB7MDF9eF4yICsgezAxfXggKyB7MDJ9XG4gKiBhXi0xKHgpID0gezBifXheMyArIHswZH14XjIgKyB7MDl9eCArIHswZX0uXG4gKlxuICogVGhlc2UgcG9seW5vbWlhbHMgYXJlIHVzZWQgaW4gdGhlIE1peENvbHVtbnMoKSBhbmQgSW52ZXJzZU1peENvbHVtbnMoKVxuICogb3BlcmF0aW9ucywgcmVzcGVjdGl2ZWx5LCB0byBjYXVzZSBlYWNoIGVsZW1lbnQgaW4gdGhlIHN0YXRlIHRvIGFmZmVjdFxuICogdGhlIG91dHB1dCAocmVmZXJyZWQgdG8gYXMgZGlmZnVzaW5nKS5cbiAqXG4gKiBSb3RXb3JkKCkgdXNlczogYTAgPSBhMSA9IGEyID0gezAwfSBhbmQgYTMgPSB7MDF9LCB3aGljaCBpcyB0aGVcbiAqIHBvbHlub21pYWwgeDMuXG4gKlxuICogVGhlIFNoaWZ0Um93cygpIG1ldGhvZCBtb2RpZmllcyB0aGUgbGFzdCAzIHJvd3MgaW4gdGhlIHN0YXRlICh3aGVyZVxuICogdGhlIHN0YXRlIGlzIDQgd29yZHMgd2l0aCA0IGJ5dGVzIHBlciB3b3JkKSBieSBzaGlmdGluZyBieXRlcyBjeWNsaWNhbGx5LlxuICogVGhlIDFzdCBieXRlIGluIHRoZSBzZWNvbmQgcm93IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdFxuICogYW5kIDJuZCBieXRlcyBpbiB0aGUgdGhpcmQgcm93IGFyZSBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoZSByb3cuIFRoZSAxc3QsXG4gKiAybmQsIGFuZCAzcmQgYnl0ZXMgYXJlIG1vdmVkIGluIHRoZSBmb3VydGggcm93LlxuICpcbiAqIE1vcmUgZGV0YWlscyBvbiBob3cgQUVTIGFyaXRobWV0aWMgd29ya3M6XG4gKlxuICogSW4gdGhlIHBvbHlub21pYWwgcmVwcmVzZW50YXRpb24gb2YgYmluYXJ5IG51bWJlcnMsIFhPUiBwZXJmb3JtcyBhZGRpdGlvblxuICogYW5kIHN1YnRyYWN0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBpbiBHRigyXjgpIGRlbm90ZWQgYXMgR0YoYSwgYilcbiAqIGNvcnJlc3BvbmRzIHdpdGggdGhlIG11bHRpcGxpY2F0aW9uIG9mIHBvbHlub21pYWxzIG1vZHVsbyBhbiBpcnJlZHVjaWJsZVxuICogcG9seW5vbWlhbCBvZiBkZWdyZWUgOC4gSW4gb3RoZXIgd29yZHMsIGZvciBBRVMsIEdGKGEsIGIpIHdpbGwgbXVsdGlwbHlcbiAqIHBvbHlub21pYWwgJ2EnIHdpdGggcG9seW5vbWlhbCAnYicgYW5kIHRoZW4gZG8gYSBtb2R1bGFyIHJlZHVjdGlvbiBieVxuICogYW4gQUVTLXNwZWNpZmljIGlycmVkdWNpYmxlIHBvbHlub21pYWwgb2YgZGVncmVlIDguXG4gKlxuICogQSBwb2x5bm9taWFsIGlzIGlycmVkdWNpYmxlIGlmIGl0cyBvbmx5IGRpdmlzb3JzIGFyZSBvbmUgYW5kIGl0c2VsZi4gRm9yXG4gKiB0aGUgQUVTIGFsZ29yaXRobSwgdGhpcyBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIGlzOlxuICpcbiAqIG0oeCkgPSB4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSxcbiAqXG4gKiBvciB7MDF9ezFifSBpbiBoZXhhZGVjaW1hbCBub3RhdGlvbiwgd2hlcmUgZWFjaCBjb2VmZmljaWVudCBpcyBhIGJpdDpcbiAqIDEwMDAxMTAxMSA9IDI4MyA9IDB4MTFiLlxuICpcbiAqIEZvciBleGFtcGxlLCBHRigweDU3LCAweDgzKSA9IDB4YzEgYmVjYXVzZVxuICpcbiAqIDB4NTcgPSA4NyAgPSAwMTAxMDExMSA9IHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiAweDg1ID0gMTMxID0gMTAwMDAxMDEgPSB4XjcgKyB4ICsgMVxuICpcbiAqICh4XjYgKyB4XjQgKyB4XjIgKyB4ICsgMSkgKiAoeF43ICsgeCArIDEpXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNyArXG4gKiAgICB4XjcgKyB4XjUgKyB4XjMgKyB4XjIgKyB4ICtcbiAqICAgIHheNiArIHheNCArIHheMiArIHggKyAxXG4gKiA9ICB4XjEzICsgeF4xMSArIHheOSArIHheOCArIHheNiArIHheNSArIHheNCArIHheMyArIDEgPSB5XG4gKiAgICB5IG1vZHVsbyAoeF44ICsgeF40ICsgeF4zICsgeCArIDEpXG4gKiA9ICB4XjcgKyB4XjYgKyAxLlxuICpcbiAqIFRoZSBtb2R1bGFyIHJlZHVjdGlvbiBieSBtKHgpIGd1YXJhbnRlZXMgdGhlIHJlc3VsdCB3aWxsIGJlIGEgYmluYXJ5XG4gKiBwb2x5bm9taWFsIG9mIGxlc3MgdGhhbiBkZWdyZWUgOCwgc28gdGhhdCBpdCBjYW4gZml0IGluIGEgYnl0ZS5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIHRvIG11bHRpcGx5IGEgYmluYXJ5IHBvbHlub21pYWwgYiB3aXRoIHggKHRoZSBwb2x5bm9taWFsXG4gKiB4IGluIGJpbmFyeSByZXByZXNlbnRhdGlvbiBpcyAwMDAwMDAxMCkgaXM6XG4gKlxuICogYl83eF44ICsgYl82eF43ICsgYl81eF42ICsgYl80eF41ICsgYl8zeF40ICsgYl8yeF4zICsgYl8xeF4yICsgYl8weF4xXG4gKlxuICogVG8gZ2V0IEdGKGIsIHgpIHdlIG11c3QgcmVkdWNlIHRoYXQgYnkgbSh4KS4gSWYgYl83IGlzIDAgKHRoYXQgaXMgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBpcyAwIGluIGIpIHRoZW4gdGhlIHJlc3VsdCBpcyBhbHJlYWR5IHJlZHVjZWQuIElmXG4gKiBpdCBpcyAxLCB0aGVuIHdlIGNhbiByZWR1Y2UgaXQgYnkgc3VidHJhY3RpbmcgbSh4KSB2aWEgYW4gWE9SLlxuICpcbiAqIEl0IGZvbGxvd3MgdGhhdCBtdWx0aXBsaWNhdGlvbiBieSB4ICgwMDAwMDAxMCBvciAweDAyKSBjYW4gYmUgaW1wbGVtZW50ZWRcbiAqIGJ5IHBlcmZvcm1pbmcgYSBsZWZ0IHNoaWZ0IGZvbGxvd2VkIGJ5IGEgY29uZGl0aW9uYWwgYml0d2lzZSBYT1Igd2l0aFxuICogMHgxYi4gVGhpcyBvcGVyYXRpb24gb24gYnl0ZXMgaXMgZGVub3RlZCBieSB4dGltZSgpLiBNdWx0aXBsaWNhdGlvbiBieVxuICogaGlnaGVyIHBvd2VycyBvZiB4IGNhbiBiZSBpbXBsZW1lbnRlZCBieSByZXBlYXRlZCBhcHBsaWNhdGlvbiBvZiB4dGltZSgpLlxuICpcbiAqIEJ5IGFkZGluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cywgbXVsdGlwbGljYXRpb24gYnkgYW55IGNvbnN0YW50IGNhbiBiZVxuICogaW1wbGVtZW50ZWQuIEZvciBpbnN0YW5jZTpcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IDB4ZmUgYmVjYXVzZTpcbiAqXG4gKiB4dGltZShiKSA9IChiICYgMTI4KSA/IChiIDw8IDEgXiAweDExYikgOiAoYiA8PCAxKVxuICpcbiAqIE5vdGU6IFdlIFhPUiB3aXRoIDB4MTFiIGluc3RlYWQgb2YgMHgxYiBiZWNhdXNlIGluIGphdmFzY3JpcHQgb3VyXG4gKiBkYXRhdHlwZSBmb3IgYiBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBieXRlLCBzbyBhIGxlZnQgc2hpZnQgd2lsbCBub3RcbiAqIGF1dG9tYXRpY2FsbHkgZWxpbWluYXRlIGJpdHMgdGhhdCBvdmVyZmxvdyBhIGJ5dGUgLi4uIGJ5IFhPUidpbmcgdGhlXG4gKiBvdmVyZmxvdyBiaXQgd2l0aCAxICh0aGUgZXh0cmEgb25lIGZyb20gMHgxMWIpIHdlIHplcm8gaXQgb3V0LlxuICpcbiAqIEdGKDB4NTcsIDB4MDIpID0geHRpbWUoMHg1NykgPSAweGFlXG4gKiBHRigweDU3LCAweDA0KSA9IHh0aW1lKDB4YWUpID0gMHg0N1xuICogR0YoMHg1NywgMHgwOCkgPSB4dGltZSgweDQ3KSA9IDB4OGVcbiAqIEdGKDB4NTcsIDB4MTApID0geHRpbWUoMHg4ZSkgPSAweDA3XG4gKlxuICogR0YoMHg1NywgMHgxMykgPSBHRigweDU3LCAoMHgwMSBeIDB4MDIgXiAweDEwKSlcbiAqXG4gKiBBbmQgYnkgdGhlIGRpc3RyaWJ1dGl2ZSBwcm9wZXJ0eSAoc2luY2UgWE9SIGlzIGFkZGl0aW9uIGFuZCBHRigpIGlzXG4gKiBtdWx0aXBsaWNhdGlvbik6XG4gKlxuICogPSBHRigweDU3LCAweDAxKSBeIEdGKDB4NTcsIDB4MDIpIF4gR0YoMHg1NywgMHgxMClcbiAqID0gMHg1NyBeIDB4YWUgXiAweDA3XG4gKiA9IDB4ZmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGluaXQgPSB0cnVlO1xuXG4gIC8qIFBvcHVsYXRlIHRoZSBSY29uIHRhYmxlLiBUaGVzZSBhcmUgdGhlIHZhbHVlcyBnaXZlbiBieVxuICAgIFt4XihpLTEpLHswMH0sezAwfSx7MDB9XSB3aGVyZSB4XihpLTEpIGFyZSBwb3dlcnMgb2YgeCAoYW5kIHggPSAweDAyKVxuICAgIGluIHRoZSBmaWVsZCBvZiBHRigyXjgpLCB3aGVyZSBpIHN0YXJ0cyBhdCAxLlxuXG4gICAgcmNvblswXSA9IFsweDAwLCAweDAwLCAweDAwLCAweDAwXVxuICAgIHJjb25bMV0gPSBbMHgwMSwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMS0xKSA9IDJeMCA9IDFcbiAgICByY29uWzJdID0gWzB4MDIsIDB4MDAsIDB4MDAsIDB4MDBdIDJeKDItMSkgPSAyXjEgPSAyXG4gICAgLi4uXG4gICAgcmNvbls5XSAgPSBbMHgxQiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oOS0xKSAgPSAyXjggPSAweDFCXG4gICAgcmNvblsxMF0gPSBbMHgzNiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMTAtMSkgPSAyXjkgPSAweDM2XG5cbiAgICBXZSBvbmx5IHN0b3JlIHRoZSBmaXJzdCBieXRlIGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgb25lIHVzZWQuXG4gICovXG4gIHJjb24gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxQiwgMHgzNl07XG5cbiAgLy8gY29tcHV0ZSB4dGltZSB0YWJsZSB3aGljaCBtYXBzIGkgb250byBHRihpLCAweDAyKVxuICB2YXIgeHRpbWUgPSBuZXcgQXJyYXkoMjU2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgeHRpbWVbaV0gPSBpIDw8IDE7XG4gICAgeHRpbWVbaSArIDEyOF0gPSAoaSArIDEyOCkgPDwgMSBeIDB4MTFCO1xuICB9XG5cbiAgLy8gY29tcHV0ZSBhbGwgb3RoZXIgdGFibGVzXG4gIHNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgaXNib3ggPSBuZXcgQXJyYXkoMjU2KTtcbiAgbWl4ID0gbmV3IEFycmF5KDQpO1xuICBpbWl4ID0gbmV3IEFycmF5KDQpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gICAgaW1peFtpXSA9IG5ldyBBcnJheSgyNTYpO1xuICB9XG4gIHZhciBlID0gMCwgZWkgPSAwLCBlMiwgZTQsIGU4LCBzeCwgc3gyLCBtZSwgaW1lO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAvKiBXZSBuZWVkIHRvIGdlbmVyYXRlIHRoZSBTdWJCeXRlcygpIHNib3ggYW5kIGlzYm94IHRhYmxlcyBzbyB0aGF0XG4gICAgICB3ZSBjYW4gcGVyZm9ybSBieXRlIHN1YnN0aXR1dGlvbnMuIFRoaXMgcmVxdWlyZXMgdXMgdG8gdHJhdmVyc2VcbiAgICAgIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gR0YsIGZpbmQgdGhlaXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXMsXG4gICAgICBhbmQgYXBwbHkgdG8gZWFjaCB0aGUgZm9sbG93aW5nIGFmZmluZSB0cmFuc2Zvcm1hdGlvbjpcblxuICAgICAgYmknID0gYmkgXiBiKGkgKyA0KSBtb2QgOCBeIGIoaSArIDUpIG1vZCA4IF4gYihpICsgNikgbW9kIDggXlxuICAgICAgICAgICAgYihpICsgNykgbW9kIDggXiBjaVxuICAgICAgZm9yIDAgPD0gaSA8IDgsIHdoZXJlIGJpIGlzIHRoZSBpdGggYml0IG9mIHRoZSBieXRlLCBhbmQgY2kgaXMgdGhlXG4gICAgICBpdGggYml0IG9mIGEgYnl0ZSBjIHdpdGggdGhlIHZhbHVlIHs2M30gb3IgezAxMTAwMDExfS5cblxuICAgICAgSXQgaXMgcG9zc2libGUgdG8gdHJhdmVyc2UgZXZlcnkgcG9zc2libGUgdmFsdWUgaW4gYSBHYWxvaXMgZmllbGRcbiAgICAgIHVzaW5nIHdoYXQgaXMgcmVmZXJyZWQgdG8gYXMgYSAnZ2VuZXJhdG9yJy4gVGhlcmUgYXJlIG1hbnlcbiAgICAgIGdlbmVyYXRvcnMgKDEyOCBvdXQgb2YgMjU2KTogMyw1LDYsOSwxMSw4MiB0byBuYW1lIGEgZmV3LiBUbyBmdWxseVxuICAgICAgdHJhdmVyc2UgR0Ygd2UgaXRlcmF0ZSAyNTUgdGltZXMsIG11bHRpcGx5aW5nIGJ5IG91ciBnZW5lcmF0b3JcbiAgICAgIGVhY2ggdGltZS5cblxuICAgICAgT24gZWFjaCBpdGVyYXRpb24gd2UgY2FuIGRldGVybWluZSB0aGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBmb3JcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQuXG5cbiAgICAgIFN1cHBvc2UgdGhlcmUgaXMgYW4gZWxlbWVudCBpbiBHRiAnZScuIEZvciBhIGdpdmVuIGdlbmVyYXRvciAnZycsXG4gICAgICBlID0gZ154LiBUaGUgbXVsdGlwbGljYXRpdmUgaW52ZXJzZSBvZiBlIGlzIGdeKDI1NSAtIHgpLiBJdCB0dXJuc1xuICAgICAgb3V0IHRoYXQgaWYgdXNlIHRoZSBpbnZlcnNlIG9mIGEgZ2VuZXJhdG9yIGFzIGFub3RoZXIgZ2VuZXJhdG9yXG4gICAgICBpdCB3aWxsIHByb2R1Y2UgYWxsIG9mIHRoZSBjb3JyZXNwb25kaW5nIG11bHRpcGxpY2F0aXZlIGludmVyc2VzXG4gICAgICBhdCB0aGUgc2FtZSB0aW1lLiBGb3IgdGhpcyByZWFzb24sIHdlIGNob29zZSA1IGFzIG91ciBpbnZlcnNlXG4gICAgICBnZW5lcmF0b3IgYmVjYXVzZSBpdCBvbmx5IHJlcXVpcmVzIDIgbXVsdGlwbGllcyBhbmQgMSBhZGQgYW5kIGl0c1xuICAgICAgaW52ZXJzZSwgODIsIHJlcXVpcmVzIHJlbGF0aXZlbHkgZmV3IG9wZXJhdGlvbnMgYXMgd2VsbC5cblxuICAgICAgSW4gb3JkZXIgdG8gYXBwbHkgdGhlIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiwgdGhlIG11bHRpcGxpY2F0aXZlXG4gICAgICBpbnZlcnNlICdlaScgb2YgJ2UnIGNhbiBiZSByZXBlYXRlZGx5IFhPUidkICg0IHRpbWVzKSB3aXRoIGFcbiAgICAgIGJpdC1jeWNsaW5nIG9mICdlaScuIFRvIGRvIHRoaXMgJ2VpJyBpcyBmaXJzdCBzdG9yZWQgaW4gJ3MnIGFuZFxuICAgICAgJ3gnLiBUaGVuICdzJyBpcyBsZWZ0IHNoaWZ0ZWQgYW5kIHRoZSBoaWdoIGJpdCBvZiAncycgaXMgbWFkZSB0aGVcbiAgICAgIGxvdyBiaXQuIFRoZSByZXN1bHRpbmcgdmFsdWUgaXMgc3RvcmVkIGluICdzJy4gVGhlbiAneCcgaXMgWE9SJ2RcbiAgICAgIHdpdGggJ3MnIGFuZCBzdG9yZWQgaW4gJ3gnLiBPbiBlYWNoIHN1YnNlcXVlbnQgaXRlcmF0aW9uIHRoZSBzYW1lXG4gICAgICBvcGVyYXRpb24gaXMgcGVyZm9ybWVkLiBXaGVuIDQgaXRlcmF0aW9ucyBhcmUgY29tcGxldGUsICd4JyBpc1xuICAgICAgWE9SJ2Qgd2l0aCAnYycgKDB4NjMpIGFuZCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgaXMgc3RvcmVkIGluICd4Jy5cbiAgICAgIEZvciBleGFtcGxlOlxuXG4gICAgICBzID0gMDEwMDAwMDFcbiAgICAgIHggPSAwMTAwMDAwMVxuXG4gICAgICBpdGVyYXRpb24gMTogcyA9IDEwMDAwMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiAyOiBzID0gMDAwMDAxMDEsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDM6IHMgPSAwMDAwMTAxMCwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gNDogcyA9IDAwMDEwMTAwLCB4IF49IHNcbiAgICAgIHggXj0gMHg2M1xuXG4gICAgICBUaGlzIGNhbiBiZSBkb25lIHdpdGggYSBsb29wIHdoZXJlIHMgPSAocyA8PCAxKSB8IChzID4+IDcpLiBIb3dldmVyLFxuICAgICAgaXQgY2FuIGFsc28gYmUgZG9uZSBieSB1c2luZyBhIHNpbmdsZSAxNi1iaXQgKGluIHRoaXMgY2FzZSAzMi1iaXQpXG4gICAgICBudW1iZXIgJ3N4Jy4gU2luY2UgWE9SIGlzIGFuIGFzc29jaWF0aXZlIG9wZXJhdGlvbiwgd2UgY2FuIHNldCAnc3gnXG4gICAgICB0byAnZWknIGFuZCB0aGVuIFhPUiBpdCB3aXRoICdzeCcgbGVmdC1zaGlmdGVkIDEsMiwzLCBhbmQgNCB0aW1lcy5cbiAgICAgIFRoZSBtb3N0IHNpZ25pZmljYW50IGJpdHMgd2lsbCBmbG93IGludG8gdGhlIGhpZ2ggOCBiaXQgcG9zaXRpb25zXG4gICAgICBhbmQgYmUgY29ycmVjdGx5IFhPUidkIHdpdGggb25lIGFub3RoZXIuIEFsbCB0aGF0IHJlbWFpbnMgd2lsbCBiZVxuICAgICAgdG8gY3ljbGUgdGhlIGhpZ2ggOCBiaXRzIGJ5IFhPUidpbmcgdGhlbSBhbGwgd2l0aCB0aGUgbG93ZXIgOCBiaXRzXG4gICAgICBhZnRlcndhcmRzLlxuXG4gICAgICBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIHBvcHVsYXRpbmcgc2JveCBhbmQgaXNib3ggd2UgY2FuIHByZWNvbXB1dGVcbiAgICAgIHRoZSBtdWx0aXBsaWNhdGlvbiB3ZSdsbCBuZWVkIHRvIGRvIHRvIGRvIE1peENvbHVtbnMoKSBsYXRlci5cbiAgICAqL1xuXG4gICAgLy8gYXBwbHkgYWZmaW5lIHRyYW5zZm9ybWF0aW9uXG4gICAgc3ggPSBlaSBeIChlaSA8PCAxKSBeIChlaSA8PCAyKSBeIChlaSA8PCAzKSBeIChlaSA8PCA0KTtcbiAgICBzeCA9IChzeCA+PiA4KSBeIChzeCAmIDI1NSkgXiAweDYzO1xuXG4gICAgLy8gdXBkYXRlIHRhYmxlc1xuICAgIHNib3hbZV0gPSBzeDtcbiAgICBpc2JveFtzeF0gPSBlO1xuXG4gICAgLyogTWl4aW5nIGNvbHVtbnMgaXMgZG9uZSB1c2luZyBtYXRyaXggbXVsdGlwbGljYXRpb24uIFRoZSBjb2x1bW5zXG4gICAgICB0aGF0IGFyZSB0byBiZSBtaXhlZCBhcmUgZWFjaCBhIHNpbmdsZSB3b3JkIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgVGhlIHN0YXRlIGhhcyBOYiBjb2x1bW5zICg0IGNvbHVtbnMpLiBUaGVyZWZvcmUgZWFjaCBjb2x1bW4gaXMgYVxuICAgICAgNCBieXRlIHdvcmQuIFNvIHRvIG1peCB0aGUgY29sdW1ucyBpbiBhIHNpbmdsZSBjb2x1bW4gJ2MnIHdoZXJlXG4gICAgICBpdHMgcm93cyBhcmUgcjAsIHIxLCByMiwgYW5kIHIzLCB3ZSB1c2UgdGhlIGZvbGxvd2luZyBtYXRyaXhcbiAgICAgIG11bHRpcGxpY2F0aW9uOlxuXG4gICAgICBbMiAzIDEgMV0qW3IwLGNdPVtyJzAsY11cbiAgICAgIFsxIDIgMyAxXSBbcjEsY10gW3InMSxjXVxuICAgICAgWzEgMSAyIDNdIFtyMixjXSBbcicyLGNdXG4gICAgICBbMyAxIDEgMl0gW3IzLGNdIFtyJzMsY11cblxuICAgICAgcjAsIHIxLCByMiwgYW5kIHIzIGFyZSBlYWNoIDEgYnl0ZSBvZiBvbmUgb2YgdGhlIHdvcmRzIGluIHRoZVxuICAgICAgc3RhdGUgKGEgY29sdW1uKS4gVG8gZG8gbWF0cml4IG11bHRpcGxpY2F0aW9uIGZvciBlYWNoIG1peGVkXG4gICAgICBjb2x1bW4gYycgd2UgbXVsdGlwbHkgdGhlIGNvcnJlc3BvbmRpbmcgcm93IGZyb20gdGhlIGxlZnQgbWF0cml4XG4gICAgICB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBmcm9tIHRoZSByaWdodCBtYXRyaXguIEluIHRvdGFsLCB3ZVxuICAgICAgZ2V0IDQgZXF1YXRpb25zOlxuXG4gICAgICByMCxjJyA9IDIqcjAsYyArIDMqcjEsYyArIDEqcjIsYyArIDEqcjMsY1xuICAgICAgcjEsYycgPSAxKnIwLGMgKyAyKnIxLGMgKyAzKnIyLGMgKyAxKnIzLGNcbiAgICAgIHIyLGMnID0gMSpyMCxjICsgMSpyMSxjICsgMipyMixjICsgMypyMyxjXG4gICAgICByMyxjJyA9IDMqcjAsYyArIDEqcjEsYyArIDEqcjIsYyArIDIqcjMsY1xuXG4gICAgICBBcyB1c3VhbCwgdGhlIG11bHRpcGxpY2F0aW9uIGlzIGFzIHByZXZpb3VzbHkgZGVmaW5lZCBhbmQgdGhlXG4gICAgICBhZGRpdGlvbiBpcyBYT1IuIEluIG9yZGVyIHRvIG9wdGltaXplIG1peGluZyBjb2x1bW5zIHdlIGNhbiBzdG9yZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdHMgaW4gdGFibGVzLiBJZiB5b3UgdGhpbmsgb2YgdGhlIHdob2xlXG4gICAgICBjb2x1bW4gYXMgYSB3b3JkIChpdCBtaWdodCBoZWxwIHRvIHZpc3VhbGl6ZSBieSBtZW50YWxseSByb3RhdGluZ1xuICAgICAgdGhlIGVxdWF0aW9ucyBhYm92ZSBieSBjb3VudGVyY2xvY2t3aXNlIDkwIGRlZ3JlZXMpIHRoZW4geW91IGNhblxuICAgICAgc2VlIHRoYXQgaXQgd291bGQgYmUgdXNlZnVsIHRvIG1hcCB0aGUgbXVsdGlwbGljYXRpb25zIHBlcmZvcm1lZCBvblxuICAgICAgZWFjaCBieXRlIChyMCwgcjEsIHIyLCByMykgb250byBhIHdvcmQgYXMgd2VsbC4gRm9yIGluc3RhbmNlLCB3ZVxuICAgICAgY291bGQgbWFwIDIqcjAsMSpyMCwxKnIwLDMqcjAgb250byBhIHdvcmQgYnkgc3RvcmluZyAyKnIwIGluIHRoZVxuICAgICAgaGlnaGVzdCA4IGJpdHMgYW5kIDMqcjAgaW4gdGhlIGxvd2VzdCA4IGJpdHMgKHdpdGggdGhlIG90aGVyIHR3b1xuICAgICAgcmVzcGVjdGl2ZWx5IGluIHRoZSBtaWRkbGUpLiBUaGlzIG1lYW5zIHRoYXQgYSB0YWJsZSBjYW4gYmVcbiAgICAgIGNvbnN0cnVjdGVkIHRoYXQgdXNlcyByMCBhcyBhbiBpbmRleCB0byB0aGUgd29yZC4gV2UgY2FuIGRvIHRoZVxuICAgICAgc2FtZSB3aXRoIHIxLCByMiwgYW5kIHIzLCBjcmVhdGluZyBhIHRvdGFsIG9mIDQgdGFibGVzLlxuXG4gICAgICBUbyBjb25zdHJ1Y3QgYSBmdWxsIGMnLCB3ZSBjYW4ganVzdCBsb29rIHVwIGVhY2ggYnl0ZSBvZiBjIGluXG4gICAgICB0aGVpciByZXNwZWN0aXZlIHRhYmxlcyBhbmQgWE9SIHRoZSByZXN1bHRzIHRvZ2V0aGVyLlxuXG4gICAgICBBbHNvLCB0byBidWlsZCBlYWNoIHRhYmxlIHdlIG9ubHkgaGF2ZSB0byBjYWxjdWxhdGUgdGhlIHdvcmRcbiAgICAgIGZvciAyLDEsMSwzIGZvciBldmVyeSBieXRlIC4uLiB3aGljaCB3ZSBjYW4gZG8gb24gZWFjaCBpdGVyYXRpb25cbiAgICAgIG9mIHRoaXMgbG9vcCBzaW5jZSB3ZSB3aWxsIGl0ZXJhdGUgb3ZlciBldmVyeSBieXRlLiBBZnRlciB3ZSBoYXZlXG4gICAgICBjYWxjdWxhdGVkIDIsMSwxLDMgd2UgY2FuIGdldCB0aGUgcmVzdWx0cyBmb3IgdGhlIG90aGVyIHRhYmxlc1xuICAgICAgYnkgY3ljbGluZyB0aGUgYnl0ZSBhdCB0aGUgZW5kIHRvIHRoZSBiZWdpbm5pbmcuIEZvciBpbnN0YW5jZVxuICAgICAgd2UgY2FuIHRha2UgdGhlIHJlc3VsdCBvZiB0YWJsZSAyLDEsMSwzIGFuZCBwcm9kdWNlIHRhYmxlIDMsMiwxLDFcbiAgICAgIGJ5IG1vdmluZyB0aGUgcmlnaHQgbW9zdCBieXRlIHRvIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb24ganVzdCBsaWtlXG4gICAgICBob3cgeW91IGNhbiBpbWFnaW5lIHRoZSAzIG1vdmVkIG91dCBvZiAyLDEsMSwzIGFuZCB0byB0aGUgZnJvbnRcbiAgICAgIHRvIHByb2R1Y2UgMywyLDEsMS5cblxuICAgICAgVGhlcmUgaXMgYW5vdGhlciBvcHRpbWl6YXRpb24gaW4gdGhhdCB0aGUgc2FtZSBtdWx0aXBsZXMgb2ZcbiAgICAgIHRoZSBjdXJyZW50IGVsZW1lbnQgd2UgbmVlZCBpbiBvcmRlciB0byBhZHZhbmNlIG91ciBnZW5lcmF0b3JcbiAgICAgIHRvIHRoZSBuZXh0IGl0ZXJhdGlvbiBjYW4gYmUgcmV1c2VkIGluIHBlcmZvcm1pbmcgdGhlIDIsMSwxLDNcbiAgICAgIGNhbGN1bGF0aW9uLiBXZSBhbHNvIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZSBtaXggY29sdW1uIHRhYmxlcyxcbiAgICAgIHdpdGggZSw5LGQsYiBiZWluZyB0aGUgaW52ZXJzZSBvZiAyLDEsMSwzLlxuXG4gICAgICBXaGVuIHdlJ3JlIGRvbmUsIGFuZCB3ZSBuZWVkIHRvIGFjdHVhbGx5IG1peCBjb2x1bW5zLCB0aGUgZmlyc3RcbiAgICAgIGJ5dGUgb2YgZWFjaCBzdGF0ZSB3b3JkIHNob3VsZCBiZSBwdXQgdGhyb3VnaCBtaXhbMF0gKDIsMSwxLDMpLFxuICAgICAgdGhlIHNlY29uZCB0aHJvdWdoIG1peFsxXSAoMywyLDEsMSkgYW5kIHNvIGZvcnRoLiBUaGVuIHRoZXkgc2hvdWxkXG4gICAgICBiZSBYT1InZCB0b2dldGhlciB0byBwcm9kdWNlIHRoZSBmdWxseSBtaXhlZCBjb2x1bW4uXG4gICAgKi9cblxuICAgIC8vIGNhbGN1bGF0ZSBtaXggYW5kIGltaXggdGFibGUgdmFsdWVzXG4gICAgc3gyID0geHRpbWVbc3hdO1xuICAgIGUyID0geHRpbWVbZV07XG4gICAgZTQgPSB4dGltZVtlMl07XG4gICAgZTggPSB4dGltZVtlNF07XG4gICAgbWUgPVxuICAgICAgKHN4MiA8PCAyNCkgXiAgLy8gMlxuICAgICAgKHN4IDw8IDE2KSBeICAgLy8gMVxuICAgICAgKHN4IDw8IDgpIF4gICAgLy8gMVxuICAgICAgKHN4IF4gc3gyKTsgICAgLy8gM1xuICAgIGltZSA9XG4gICAgICAoZTIgXiBlNCBeIGU4KSA8PCAyNCBeICAvLyBFICgxNClcbiAgICAgIChlIF4gZTgpIDw8IDE2IF4gICAgICAgIC8vIDlcbiAgICAgIChlIF4gZTQgXiBlOCkgPDwgOCBeICAgIC8vIEQgKDEzKVxuICAgICAgKGUgXiBlMiBeIGU4KTsgICAgICAgICAgLy8gQiAoMTEpXG4gICAgLy8gcHJvZHVjZSBlYWNoIG9mIHRoZSBtaXggdGFibGVzIGJ5IHJvdGF0aW5nIHRoZSAyLDEsMSwzIHZhbHVlXG4gICAgZm9yKHZhciBuID0gMDsgbiA8IDQ7ICsrbikge1xuICAgICAgbWl4W25dW2VdID0gbWU7XG4gICAgICBpbWl4W25dW3N4XSA9IGltZTtcbiAgICAgIC8vIGN5Y2xlIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvblxuICAgICAgLy8gaWU6IDIsMSwxLDMgYmVjb21lcyAzLDIsMSwxXG4gICAgICBtZSA9IG1lIDw8IDI0IHwgbWUgPj4+IDg7XG4gICAgICBpbWUgPSBpbWUgPDwgMjQgfCBpbWUgPj4+IDg7XG4gICAgfVxuXG4gICAgLy8gZ2V0IG5leHQgZWxlbWVudCBhbmQgaW52ZXJzZVxuICAgIGlmKGUgPT09IDApIHtcbiAgICAgIC8vIDEgaXMgdGhlIGludmVyc2Ugb2YgMVxuICAgICAgZSA9IGVpID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZSA9IDJlICsgMioyKjIqKDEwZSkpID0gbXVsdGlwbHkgZSBieSA4MiAoY2hvc2VuIGdlbmVyYXRvcilcbiAgICAgIC8vIGVpID0gZWkgKyAyKjIqZWkgPSBtdWx0aXBseSBlaSBieSA1IChpbnZlcnNlIGdlbmVyYXRvcilcbiAgICAgIGUgPSBlMiBeIHh0aW1lW3h0aW1lW3h0aW1lW2UyIF4gZThdXV07XG4gICAgICBlaSBePSB4dGltZVt4dGltZVtlaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBzY2hlZHVsZSB1c2luZyB0aGUgQUVTIGtleSBleHBhbnNpb24gYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBBRVMgYWxnb3JpdGhtIHRha2VzIHRoZSBDaXBoZXIgS2V5LCBLLCBhbmQgcGVyZm9ybXMgYSBLZXkgRXhwYW5zaW9uXG4gKiByb3V0aW5lIHRvIGdlbmVyYXRlIGEga2V5IHNjaGVkdWxlLiBUaGUgS2V5IEV4cGFuc2lvbiBnZW5lcmF0ZXMgYSB0b3RhbFxuICogb2YgTmIqKE5yICsgMSkgd29yZHM6IHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgYW4gaW5pdGlhbCBzZXQgb2YgTmIgd29yZHMsXG4gKiBhbmQgZWFjaCBvZiB0aGUgTnIgcm91bmRzIHJlcXVpcmVzIE5iIHdvcmRzIG9mIGtleSBkYXRhLiBUaGUgcmVzdWx0aW5nXG4gKiBrZXkgc2NoZWR1bGUgY29uc2lzdHMgb2YgYSBsaW5lYXIgYXJyYXkgb2YgNC1ieXRlIHdvcmRzLCBkZW5vdGVkIFt3aSBdLFxuICogd2l0aCBpIGluIHRoZSByYW5nZSAwIOKJpCBpIDwgTmIoTnIgKyAxKS5cbiAqXG4gKiBLZXlFeHBhbnNpb24oYnl0ZSBrZXlbNCpOa10sIHdvcmQgd1tOYiooTnIrMSldLCBOaylcbiAqIEFFUy0xMjggKE5iPTQsIE5rPTQsIE5yPTEwKVxuICogQUVTLTE5MiAoTmI9NCwgTms9NiwgTnI9MTIpXG4gKiBBRVMtMjU2IChOYj00LCBOaz04LCBOcj0xNClcbiAqIE5vdGU6IE5yPU5rKzYuXG4gKlxuICogTmIgaXMgdGhlIG51bWJlciBvZiBjb2x1bW5zICgzMi1iaXQgd29yZHMpIGNvbXByaXNpbmcgdGhlIFN0YXRlIChvclxuICogbnVtYmVyIG9mIGJ5dGVzIGluIGEgYmxvY2spLiBGb3IgQUVTLCBOYj00LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byBzY2hlZHVsZSAoYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gbW9kaWZ5IHRoZSBrZXkgc2NoZWR1bGUgdG8gZGVjcnlwdCwgZmFsc2Ugbm90IHRvLlxuICpcbiAqIEByZXR1cm4gdGhlIGdlbmVyYXRlZCBrZXkgc2NoZWR1bGUuXG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KSB7XG4gIC8vIGNvcHkgdGhlIGtleSdzIHdvcmRzIHRvIGluaXRpYWxpemUgdGhlIGtleSBzY2hlZHVsZVxuICB2YXIgdyA9IGtleS5zbGljZSgwKTtcblxuICAvKiBSb3RXb3JkKCkgd2lsbCByb3RhdGUgYSB3b3JkLCBtb3ZpbmcgdGhlIGZpcnN0IGJ5dGUgdG8gdGhlIGxhc3RcbiAgICBieXRlJ3MgcG9zaXRpb24gKHNoaWZ0aW5nIHRoZSBvdGhlciBieXRlcyBsZWZ0KS5cblxuICAgIFdlIHdpbGwgYmUgZ2V0dGluZyB0aGUgdmFsdWUgb2YgUmNvbiBhdCBpIC8gTmsuICdpJyB3aWxsIGl0ZXJhdGVcbiAgICBmcm9tIE5rIHRvIChOYiAqIE5yKzEpLiBOayA9IDQgKDQgYnl0ZSBrZXkpLCBOYiA9IDQgKDQgd29yZHMgaW5cbiAgICBhIGJsb2NrKSwgTnIgPSBOayArIDYgKDEwKS4gVGhlcmVmb3JlICdpJyB3aWxsIGl0ZXJhdGUgZnJvbVxuICAgIDQgdG8gNDQgKGV4Y2x1c2l2ZSkuIEVhY2ggdGltZSB3ZSBpdGVyYXRlIDQgdGltZXMsIGkgLyBOayB3aWxsXG4gICAgaW5jcmVhc2UgYnkgMS4gV2UgdXNlIGEgY291bnRlciBpTmsgdG8ga2VlcCB0cmFjayBvZiB0aGlzLlxuICAgKi9cblxuICAvLyBnbyB0aHJvdWdoIHRoZSByb3VuZHMgZXhwYW5kaW5nIHRoZSBrZXlcbiAgdmFyIHRlbXAsIGlOayA9IDE7XG4gIHZhciBOayA9IHcubGVuZ3RoO1xuICB2YXIgTnIxID0gTmsgKyA2ICsgMTtcbiAgdmFyIGVuZCA9IE5iICogTnIxO1xuICBmb3IodmFyIGkgPSBOazsgaSA8IGVuZDsgKytpKSB7XG4gICAgdGVtcCA9IHdbaSAtIDFdO1xuICAgIGlmKGkgJSBOayA9PT0gMCkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQoUm90V29yZCh0ZW1wKSkgXiBSY29uW2kgLyBOa11cbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgMTYgXlxuICAgICAgICBzYm94W3RlbXAgJiAyNTVdIDw8IDggXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSBeIChyY29uW2lOa10gPDwgMjQpO1xuICAgICAgaU5rKys7XG4gICAgfSBlbHNlIGlmKE5rID4gNiAmJiAoaSAlIE5rID09PSA0KSkge1xuICAgICAgLy8gdGVtcCA9IFN1YldvcmQodGVtcClcbiAgICAgIHRlbXAgPVxuICAgICAgICBzYm94W3RlbXAgPj4+IDI0XSA8PCAyNCBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gMTYgJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiA4ICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XTtcbiAgICB9XG4gICAgd1tpXSA9IHdbaSAtIE5rXSBeIHRlbXA7XG4gIH1cblxuICAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOcuKAkzFcbiAgICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgICAgTWl4Q29sdW1ucyhzdGF0ZSlcbiAgICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W3JvdW5kKk5iLCAocm91bmQrMSkqTmItMV0pXG4gICAgZW5kIGZvclxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuXG4gIEludkNpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICAgIGZvciByb3VuZCA9IE5yLTEgc3RlcCAtMSBkb3dudG8gMVxuICAgICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgICAgSW52TWl4Q29sdW1ucyhzdGF0ZSlcbiAgICBlbmQgZm9yXG4gICAgSW52U2hpZnRSb3dzKHN0YXRlKVxuICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAgIG91dCA9IHN0YXRlXG4gIGVuZFxuICAqL1xuXG4gIC8vIEVuY3J5cHQ6IEFkZFJvdW5kS2V5KHN0YXRlLCB3WzAsIE5iLTFdKVxuICAvLyBEZWNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuICB2YXIgTnIgPSB3Lmxlbmd0aCAvIDQgLSAxO1xuICB2YXIgbTAsIG0xLCBtMiwgbTMsIHN1YjtcbiAgaWYoZGVjcnlwdCkge1xuICAgIG0wID0gaW1peFswXTtcbiAgICBtMSA9IGltaXhbMV07XG4gICAgbTIgPSBpbWl4WzJdO1xuICAgIG0zID0gaW1peFszXTtcbiAgICBzdWIgPSBpc2JveDtcbiAgfSBlbHNlIHtcbiAgICBtMCA9IG1peFswXTtcbiAgICBtMSA9IG1peFsxXTtcbiAgICBtMiA9IG1peFsyXTtcbiAgICBtMyA9IG1peFszXTtcbiAgICBzdWIgPSBzYm94O1xuICB9XG4gIHZhciBhLCBiLCBjLCBkLCBhMiwgYjIsIGMyO1xuICBhID0gaW5wdXRbMF0gXiB3WzBdO1xuICBiID0gaW5wdXRbZGVjcnlwdCA/IDMgOiAxXSBeIHdbMV07XG4gIGMgPSBpbnB1dFsyXSBeIHdbMl07XG4gIGQgPSBpbnB1dFtkZWNyeXB0ID8gMSA6IDNdIF4gd1szXTtcbiAgdmFyIGkgPSAzO1xuXG4gIC8qIEluIG9yZGVyIHRvIHNoYXJlIGNvZGUgd2UgZm9sbG93IHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB3aGVuIGJvdGhcbiAgICBlbmNyeXB0aW5nIGFuZCBkZWNyeXB0aW5nLiBUbyBhY2NvdW50IGZvciB0aGUgY2hhbmdlcyByZXF1aXJlZCBpbiB0aGVcbiAgICBkZWNyeXB0aW9uIGFsZ29yaXRobSwgd2UgdXNlIGRpZmZlcmVudCBsb29rdXAgdGFibGVzIHdoZW4gZGVjcnlwdGluZ1xuICAgIGFuZCB1c2UgYSBtb2RpZmllZCBrZXkgc2NoZWR1bGUgdG8gYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2UgaW4gdGhlXG4gICAgb3JkZXIgb2YgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHJvdW5kcy4gV2UgYWxzbyBnZXRcbiAgICBrZXkgcm91bmRzIGluIHJldmVyc2Ugb3JkZXIgKHJlbGF0aXZlIHRvIGVuY3J5cHRpb24pLiAqL1xuICBmb3IodmFyIHJvdW5kID0gMTsgcm91bmQgPCBOcjsgKytyb3VuZCkge1xuICAgIC8qIEFzIGRlc2NyaWJlZCBhYm92ZSwgd2UnbGwgYmUgdXNpbmcgdGFibGUgbG9va3VwcyB0byBwZXJmb3JtIHRoZVxuICAgICAgY29sdW1uIG1peGluZy4gRWFjaCBjb2x1bW4gaXMgc3RvcmVkIGFzIGEgd29yZCBpbiB0aGUgc3RhdGUgKHRoZVxuICAgICAgYXJyYXkgJ2lucHV0JyBoYXMgb25lIGNvbHVtbiBhcyBhIHdvcmQgYXQgZWFjaCBpbmRleCkuIEluIG9yZGVyIHRvXG4gICAgICBtaXggYSBjb2x1bW4sIHdlIHBlcmZvcm0gdGhlc2UgdHJhbnNmb3JtYXRpb25zIG9uIGVhY2ggcm93IGluIGMsXG4gICAgICB3aGljaCBpcyAxIGJ5dGUgaW4gZWFjaCB3b3JkLiBUaGUgbmV3IGNvbHVtbiBmb3IgYzAgaXMgYycwOlxuXG4gICAgICAgICAgICAgICBtMCAgICAgIG0xICAgICAgbTIgICAgICBtM1xuICAgICAgcjAsYycwID0gMipyMCxjMCArIDMqcjEsYzAgKyAxKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjEsYycwID0gMSpyMCxjMCArIDIqcjEsYzAgKyAzKnIyLGMwICsgMSpyMyxjMFxuICAgICAgcjIsYycwID0gMSpyMCxjMCArIDEqcjEsYzAgKyAyKnIyLGMwICsgMypyMyxjMFxuICAgICAgcjMsYycwID0gMypyMCxjMCArIDEqcjEsYzAgKyAxKnIyLGMwICsgMipyMyxjMFxuXG4gICAgICBTbyB1c2luZyBtaXggdGFibGVzIHdoZXJlIGMwIGlzIGEgd29yZCB3aXRoIHIwIGJlaW5nIGl0cyB1cHBlclxuICAgICAgOCBiaXRzIGFuZCByMyBiZWluZyBpdHMgbG93ZXIgOCBiaXRzOlxuXG4gICAgICBtMFtjMCA+PiAyNF0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsyKnIwLDEqcjAsMSpyMCwzKnIwXVxuICAgICAgLi4uXG4gICAgICBtM1tjMCAmIDI1NV0gd2lsbCB5aWVsZCB0aGlzIHdvcmQ6IFsxKnIzLDEqcjMsMypyMywyKnIzXVxuXG4gICAgICBUaGVyZWZvcmUgdG8gbWl4IHRoZSBjb2x1bW5zIGluIGVhY2ggd29yZCBpbiB0aGUgc3RhdGUgd2VcbiAgICAgIGRvIHRoZSBmb2xsb3dpbmcgKCYgMjU1IG9taXR0ZWQgZm9yIGJyZXZpdHkpOlxuICAgICAgYycwLHIwID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMSA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjIgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIzID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cblxuICAgICAgSG93ZXZlciwgYmVmb3JlIG1peGluZywgdGhlIGFsZ29yaXRobSByZXF1aXJlcyB1cyB0byBwZXJmb3JtXG4gICAgICBTaGlmdFJvd3MoKS4gVGhlIFNoaWZ0Um93cygpIHRyYW5zZm9ybWF0aW9uIGN5Y2xpY2FsbHkgc2hpZnRzIHRoZVxuICAgICAgbGFzdCAzIHJvd3Mgb2YgdGhlIHN0YXRlIG92ZXIgZGlmZmVyZW50IG9mZnNldHMuIFRoZSBmaXJzdCByb3dcbiAgICAgIChyID0gMCkgaXMgbm90IHNoaWZ0ZWQuXG5cbiAgICAgIHMnX3IsYyA9IHNfciwoYyArIHNoaWZ0KHIsIE5iKSBtb2QgTmJcbiAgICAgIGZvciAwIDwgciA8IDQgYW5kIDAgPD0gYyA8IE5iIGFuZFxuICAgICAgc2hpZnQoMSwgNCkgPSAxXG4gICAgICBzaGlmdCgyLCA0KSA9IDJcbiAgICAgIHNoaWZ0KDMsIDQpID0gMy5cblxuICAgICAgVGhpcyBjYXVzZXMgdGhlIGZpcnN0IGJ5dGUgaW4gciA9IDEgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDIgYnl0ZXMgaW4gciA9IDIgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdywgdGhlIGZpcnN0IDMgYnl0ZXMgaW4gciA9IDMgdG8gYmUgbW92ZWQgdG8gdGhlIGVuZCBvZlxuICAgICAgdGhlIHJvdzpcblxuICAgICAgcjE6IFtjMCBjMSBjMiBjM10gPT4gW2MxIGMyIGMzIGMwXVxuICAgICAgcjI6IFtjMCBjMSBjMiBjM10gICAgW2MyIGMzIGMwIGMxXVxuICAgICAgcjM6IFtjMCBjMSBjMiBjM10gICAgW2MzIGMwIGMxIGMyXVxuXG4gICAgICBXZSBjYW4gbWFrZSB0aGVzZSBzdWJzdGl0dXRpb25zIGlubGluZSB3aXRoIG91ciBjb2x1bW4gbWl4aW5nIHRvXG4gICAgICBnZW5lcmF0ZSBhbiB1cGRhdGVkIHNldCBvZiBlcXVhdGlvbnMgdG8gcHJvZHVjZSBlYWNoIHdvcmQgaW4gdGhlXG4gICAgICBzdGF0ZSAobm90ZSB0aGUgY29sdW1ucyBoYXZlIGNoYW5nZWQgcG9zaXRpb25zKTpcblxuICAgICAgYzAgYzEgYzIgYzMgPT4gYzAgYzEgYzIgYzNcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMxIGMyIGMzIGMwICAoY3ljbGVkIDEgYnl0ZSlcbiAgICAgIGMwIGMxIGMyIGMzICAgIGMyIGMzIGMwIGMxICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMyBjMCBjMSBjMiAgKGN5Y2xlZCAzIGJ5dGVzKVxuXG4gICAgICBUaGVyZWZvcmU6XG5cbiAgICAgIGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMxICsgMSpyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMxICsgMypyMixjMiArIDEqcjMsYzNcbiAgICAgIGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMxICsgMipyMixjMiArIDMqcjMsYzNcbiAgICAgIGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMxICsgMSpyMixjMiArIDIqcjMsYzNcblxuICAgICAgYycxID0gMipyMCxjMSArIDMqcjEsYzIgKyAxKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDIqcjEsYzIgKyAzKnIyLGMzICsgMSpyMyxjMFxuICAgICAgYycxID0gMSpyMCxjMSArIDEqcjEsYzIgKyAyKnIyLGMzICsgMypyMyxjMFxuICAgICAgYycxID0gMypyMCxjMSArIDEqcjEsYzIgKyAxKnIyLGMzICsgMipyMyxjMFxuXG4gICAgICAuLi4gYW5kIHNvIGZvcnRoIGZvciBjJzIgYW5kIGMnMy4gVGhlIGltcG9ydGFudCBkaXN0aW5jdGlvbiBpc1xuICAgICAgdGhhdCB0aGUgY29sdW1ucyBhcmUgY3ljbGluZywgd2l0aCBjMCBiZWluZyB1c2VkIHdpdGggdGhlIG0wXG4gICAgICBtYXAgd2hlbiBjYWxjdWxhdGluZyBjMCwgYnV0IGMxIGJlaW5nIHVzZWQgd2l0aCB0aGUgbTAgbWFwIHdoZW5cbiAgICAgIGNhbGN1bGF0aW5nIGMxIC4uLiBhbmQgc28gZm9ydGguXG5cbiAgICAgIFdoZW4gcGVyZm9ybWluZyB0aGUgaW52ZXJzZSB3ZSB0cmFuc2Zvcm0gdGhlIG1pcnJvciBpbWFnZSBhbmRcbiAgICAgIHNraXAgdGhlIGJvdHRvbSByb3csIGluc3RlYWQgb2YgdGhlIHRvcCBvbmUsIGFuZCBtb3ZlIHVwd2FyZHM6XG5cbiAgICAgIGMzIGMyIGMxIGMwID0+IGMwIGMzIGMyIGMxICAoY3ljbGVkIDMgYnl0ZXMpICpzYW1lIGFzIGVuY3J5cHRpb25cbiAgICAgIGMzIGMyIGMxIGMwICAgIGMxIGMwIGMzIGMyICAoY3ljbGVkIDIgYnl0ZXMpXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMiBjMSBjMCBjMyAgKGN5Y2xlZCAxIGJ5dGUpICAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMyBjMiBjMSBjMFxuXG4gICAgICBJZiB5b3UgY29tcGFyZSB0aGUgcmVzdWx0aW5nIG1hdHJpY2VzIGZvciBTaGlmdFJvd3MoKStNaXhDb2x1bW5zKClcbiAgICAgIGFuZCBmb3IgSW52U2hpZnRSb3dzKCkrSW52TWl4Q29sdW1ucygpIHRoZSAybmQgYW5kIDR0aCBjb2x1bW5zIGFyZVxuICAgICAgZGlmZmVyZW50IChpbiBlbmNyeXB0IG1vZGUgdnMuIGRlY3J5cHQgbW9kZSkuIFNvIGluIG9yZGVyIHRvIHVzZVxuICAgICAgdGhlIHNhbWUgY29kZSB0byBoYW5kbGUgYm90aCBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCB3ZSB3aWxsXG4gICAgICBuZWVkIHRvIGRvIHNvbWUgbWFwcGluZy5cblxuICAgICAgSWYgaW4gZW5jcnlwdGlvbiBtb2RlIHdlIGxldCBhPWMwLCBiPWMxLCBjPWMyLCBkPWMzLCBhbmQgcjxOPiBiZVxuICAgICAgYSByb3cgbnVtYmVyIGluIHRoZSBzdGF0ZSwgdGhlbiB0aGUgcmVzdWx0aW5nIG1hdHJpeCBpbiBlbmNyeXB0aW9uXG4gICAgICBtb2RlIGZvciBhcHBseWluZyB0aGUgYWJvdmUgdHJhbnNmb3JtYXRpb25zIHdvdWxkIGJlOlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGIgYyBkIGFcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogZCBhIGIgY1xuXG4gICAgICBJZiB3ZSBkaWQgdGhlIHNhbWUgaW4gZGVjcnlwdGlvbiBtb2RlIHdlIHdvdWxkIGdldDpcblxuICAgICAgcjE6IGEgZCBjIGJcbiAgICAgIHIyOiBiIGEgZCBjXG4gICAgICByMzogYyBiIGEgZFxuICAgICAgcjQ6IGQgYyBiIGFcblxuICAgICAgSWYgaW5zdGVhZCB3ZSBzd2FwIGQgYW5kIGIgKHNldCBiPWMzIGFuZCBkPWMxKSwgdGhlbiB3ZSBnZXQ6XG5cbiAgICAgIHIxOiBhIGIgYyBkXG4gICAgICByMjogZCBhIGIgY1xuICAgICAgcjM6IGMgZCBhIGJcbiAgICAgIHI0OiBiIGMgZCBhXG5cbiAgICAgIE5vdyB0aGUgMXN0IGFuZCAzcmQgcm93cyBhcmUgdGhlIHNhbWUgYXMgdGhlIGVuY3J5cHRpb24gbWF0cml4LiBBbGxcbiAgICAgIHdlIG5lZWQgdG8gZG8gdGhlbiB0byBtYWtlIHRoZSBtYXBwaW5nIGV4YWN0bHkgdGhlIHNhbWUgaXMgdG8gc3dhcFxuICAgICAgdGhlIDJuZCBhbmQgNHRoIHJvd3Mgd2hlbiBpbiBkZWNyeXB0aW9uIG1vZGUuIFRvIGRvIHRoaXMgd2l0aG91dFxuICAgICAgaGF2aW5nIHRvIGRvIGl0IG9uIGVhY2ggaXRlcmF0aW9uLCB3ZSBzd2FwcGVkIHRoZSAybmQgYW5kIDR0aCByb3dzXG4gICAgICBpbiB0aGUgZGVjcnlwdGlvbiBrZXkgc2NoZWR1bGUuIFdlIGFsc28gaGF2ZSB0byBkbyB0aGUgc3dhcCBhYm92ZVxuICAgICAgd2hlbiB3ZSBmaXJzdCBwdWxsIGluIHRoZSBpbnB1dCBhbmQgd2hlbiB3ZSBzZXQgdGhlIGZpbmFsIG91dHB1dC4gKi9cbiAgICBhMiA9XG4gICAgICBtMFthID4+PiAyNF0gXlxuICAgICAgbTFbYiA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2MgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2QgJiAyNTVdIF4gd1srK2ldO1xuICAgIGIyID1cbiAgICAgIG0wW2IgPj4+IDI0XSBeXG4gICAgICBtMVtjID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbZCA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYSAmIDI1NV0gXiB3WysraV07XG4gICAgYzIgPVxuICAgICAgbTBbYyA+Pj4gMjRdIF5cbiAgICAgIG0xW2QgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMlthID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tiICYgMjU1XSBeIHdbKytpXTtcbiAgICBkID1cbiAgICAgIG0wW2QgPj4+IDI0XSBeXG4gICAgICBtMVthID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYiA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYyAmIDI1NV0gXiB3WysraV07XG4gICAgYSA9IGEyO1xuICAgIGIgPSBiMjtcbiAgICBjID0gYzI7XG4gIH1cblxuICAvKlxuICAgIEVuY3J5cHQ6XG4gICAgU3ViQnl0ZXMoc3RhdGUpXG4gICAgU2hpZnRSb3dzKHN0YXRlKVxuICAgIEFkZFJvdW5kS2V5KHN0YXRlLCB3W05yKk5iLCAoTnIrMSkqTmItMV0pXG5cbiAgICBEZWNyeXB0OlxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICovXG4gICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBQRU0gKFByaXZhY3kgRW5oYW5jZWQgTWFpbCkgYWxnb3JpdGhtcy5cbiAqXG4gKiBTZWU6IFJGQyAxNDIxLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBIEZvcmdlIFBFTSBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqIHR5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSAoZWc6IFwiUlNBIFBSSVZBVEUgS0VZXCIpLlxuICpcbiAqIHByb2NUeXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHByb2Nlc3NpbmcgcGVyZm9ybWVkIG9uIHRoZSBtZXNzYWdlLFxuICogICBpdCBoYXMgdHdvIHN1YmZpZWxkczogdmVyc2lvbiBhbmQgdHlwZSwgZWc6IDQsRU5DUllQVEVELlxuICpcbiAqIGNvbnRlbnREb21haW46IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgY29udGVudCBpbiB0aGUgbWVzc2FnZSwgdHlwaWNhbGx5XG4gKiAgIG9ubHkgdXNlcyB0aGUgdmFsdWU6IFwiUkZDODIyXCIuXG4gKlxuICogZGVrSW5mbzogaWRlbnRpZmllcyB0aGUgbWVzc2FnZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBhbmQgbW9kZSBhbmQgaW5jbHVkZXNcbiAqICAgYW55IHBhcmFtZXRlcnMgZm9yIHRoZSBhbGdvcml0aG0sIGl0IGhhcyB0d28gc3ViZmllbGRzOiBhbGdvcml0aG0gYW5kXG4gKiAgIHBhcmFtZXRlcnMsIGVnOiBERVMtQ0JDLEY4MTQzRURFNTk2MEM1OTcuXG4gKlxuICogaGVhZGVyczogY29udGFpbnMgYWxsIG90aGVyIFBFTSBlbmNhcHN1bGF0ZWQgaGVhZGVycyAtLSB3aGVyZSBvcmRlciBpc1xuICogICBzaWduaWZpY2FudCAoZm9yIHBhaXJpbmcgZGF0YSBsaWtlIHJlY2lwaWVudCBJRCArIGtleSBpbmZvKS5cbiAqXG4gKiBib2R5OiB0aGUgYmluYXJ5LWVuY29kZWQgYm9keS5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBwZW0gQVBJXG52YXIgcGVtID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wZW0gPSBmb3JnZS5wZW0gfHwge307XG5cbi8qKlxuICogRW5jb2RlcyAoc2VyaWFsaXplcykgdGhlIGdpdmVuIFBFTSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSBmb3IgdGhlIGJvZHksIChkZWZhdWx0OiA2NCkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbnBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBydmFsID0gJy0tLS0tQkVHSU4gJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcblxuICAvLyBlbmNvZGUgc3BlY2lhbCBoZWFkZXJzXG4gIHZhciBoZWFkZXI7XG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIGhlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQcm9jLVR5cGUnLFxuICAgICAgdmFsdWVzOiBbU3RyaW5nKG1zZy5wcm9jVHlwZS52ZXJzaW9uKSwgbXNnLnByb2NUeXBlLnR5cGVdXG4gICAgfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuY29udGVudERvbWFpbikge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnQ29udGVudC1Eb21haW4nLCB2YWx1ZXM6IFttc2cuY29udGVudERvbWFpbl19O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5kZWtJbmZvKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdERUstSW5mbycsIHZhbHVlczogW21zZy5kZWtJbmZvLmFsZ29yaXRobV19O1xuICAgIGlmKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpIHtcbiAgICAgIGhlYWRlci52YWx1ZXMucHVzaChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cblxuICBpZihtc2cuaGVhZGVycykge1xuICAgIC8vIGVuY29kZSBhbGwgb3RoZXIgaGVhZGVyc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSBmb2xkSGVhZGVyKG1zZy5oZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyB0ZXJtaW5hdGUgaGVhZGVyXG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIHJ2YWwgKz0gJ1xcclxcbic7XG4gIH1cblxuICAvLyBhZGQgYm9keVxuICBydmFsICs9IGZvcmdlLnV0aWwuZW5jb2RlNjQobXNnLmJvZHksIG9wdGlvbnMubWF4bGluZSB8fCA2NCkgKyAnXFxyXFxuJztcblxuICBydmFsICs9ICctLS0tLUVORCAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyAoZGVzZXJpYWxpemVzKSBhbGwgUEVNIG1lc3NhZ2VzIGZvdW5kIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTSBtZXNzYWdlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gKi9cbnBlbS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBzcGxpdCBzdHJpbmcgaW50byBQRU0gbWVzc2FnZXMgKGJlIGxlbmllbnQgdy9FT0Ygb24gQkVHSU4gbGluZSlcbiAgdmFyIHJNZXNzYWdlID0gL1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZztcbiAgdmFyIHJIZWFkZXIgPSAvKFtcXHgyMS1cXHg3ZV0rKTpcXHMqKFtcXHgyMS1cXHg3ZVxcc146XSspLztcbiAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlKHRydWUpIHtcbiAgICBtYXRjaCA9IHJNZXNzYWdlLmV4ZWMoc3RyKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB7XG4gICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgIHByb2NUeXBlOiBudWxsLFxuICAgICAgY29udGVudERvbWFpbjogbnVsbCxcbiAgICAgIGRla0luZm86IG51bGwsXG4gICAgICBoZWFkZXJzOiBbXSxcbiAgICAgIGJvZHk6IGZvcmdlLnV0aWwuZGVjb2RlNjQobWF0Y2hbM10pXG4gICAgfTtcbiAgICBydmFsLnB1c2gobXNnKTtcblxuICAgIC8vIG5vIGhlYWRlcnNcbiAgICBpZighbWF0Y2hbMl0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGhlYWRlcnNcbiAgICB2YXIgbGluZXMgPSBtYXRjaFsyXS5zcGxpdChyQ1JMRik7XG4gICAgdmFyIGxpID0gMDtcbiAgICB3aGlsZShtYXRjaCAmJiBsaSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0IGxpbmUsIHRyaW0gYW55IHJocyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xpXS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcblxuICAgICAgLy8gUkZDMjgyMiB1bmZvbGQgYW55IGZvbGxvd2luZyBmb2xkZWQgbGluZXNcbiAgICAgIGZvcih2YXIgbmwgPSBsaSArIDE7IG5sIDwgbGluZXMubGVuZ3RoOyArK25sKSB7XG4gICAgICAgIHZhciBuZXh0ID0gbGluZXNbbmxdO1xuICAgICAgICBpZighL1xccy8udGVzdChuZXh0WzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gbmV4dDtcbiAgICAgICAgbGkgPSBubDtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgaGVhZGVyXG4gICAgICBtYXRjaCA9IGxpbmUubWF0Y2gockhlYWRlcik7XG4gICAgICBpZihtYXRjaCkge1xuICAgICAgICB2YXIgaGVhZGVyID0ge25hbWU6IG1hdGNoWzFdLCB2YWx1ZXM6IFtdfTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IHZhbHVlcy5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsdWVzLnB1c2gobHRyaW0odmFsdWVzW3ZpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvYy1UeXBlIG11c3QgYmUgdGhlIGZpcnN0IGhlYWRlclxuICAgICAgICBpZighbXNnLnByb2NUeXBlKSB7XG4gICAgICAgICAgaWYoaGVhZGVyLm5hbWUgIT09ICdQcm9jLVR5cGUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICdlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiICcgK1xuICAgICAgICAgICAgICAnaGVhZGVyIG11c3QgaGF2ZSB0d28gc3ViZmllbGRzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cucHJvY1R5cGUgPSB7dmVyc2lvbjogdmFsdWVzWzBdLCB0eXBlOiB2YWx1ZXNbMV19O1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5jb250ZW50RG9tYWluICYmIGhlYWRlci5uYW1lID09PSAnQ29udGVudC1Eb21haW4nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIENvbnRlbnQtRG9tYWluXG4gICAgICAgICAgbXNnLmNvbnRlbnREb21haW4gPSB2YWx1ZXNbMF0gfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZighbXNnLmRla0luZm8gJiYgaGVhZGVyLm5hbWUgPT09ICdERUstSW5mbycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgREVLLUluZm9cbiAgICAgICAgICBpZihoZWFkZXIudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN1YmZpZWxkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuZGVrSW5mbyA9IHthbGdvcml0aG06IHZhbHVlc1swXSwgcGFyYW1ldGVyczogdmFsdWVzWzFdIHx8IG51bGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zZy5oZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICArK2xpO1xuICAgIH1cblxuICAgIGlmKG1zZy5wcm9jVHlwZSA9PT0gJ0VOQ1JZUFRFRCcgJiYgIW1zZy5kZWtJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJERUstSW5mb1wiICcgK1xuICAgICAgICAnaGVhZGVyIG11c3QgYmUgcHJlc2VudCBpZiBcIlByb2MtVHlwZVwiIGlzIFwiRU5DUllQVEVEXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYocnZhbC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG5mdW5jdGlvbiBmb2xkSGVhZGVyKGhlYWRlcikge1xuICB2YXIgcnZhbCA9IGhlYWRlci5uYW1lICsgJzogJztcblxuICAvLyBlbnN1cmUgdmFsdWVzIHdpdGggQ1JMRiBhcmUgZm9sZGVkXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGluc2VydFNwYWNlID0gZnVuY3Rpb24obWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICcgJyArICQxO1xuICB9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaGVhZGVyLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhbHVlcy5wdXNoKGhlYWRlci52YWx1ZXNbaV0ucmVwbGFjZSgvXihcXFMrXFxyXFxuKS8sIGluc2VydFNwYWNlKSk7XG4gIH1cbiAgcnZhbCArPSB2YWx1ZXMuam9pbignLCcpICsgJ1xcclxcbic7XG5cbiAgLy8gZG8gZm9sZGluZ1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGNhbmRpZGF0ZSA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcnZhbC5sZW5ndGg7ICsraSwgKytsZW5ndGgpIHtcbiAgICBpZihsZW5ndGggPiA2NSAmJiBjYW5kaWRhdGUgIT09IC0xKSB7XG4gICAgICB2YXIgaW5zZXJ0ID0gcnZhbFtjYW5kaWRhdGVdO1xuICAgICAgaWYoaW5zZXJ0ID09PSAnLCcpIHtcbiAgICAgICAgKytjYW5kaWRhdGU7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICsgJ1xcclxcbiAnICsgcnZhbC5zdWJzdHIoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICtcbiAgICAgICAgICAnXFxyXFxuJyArIGluc2VydCArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSArIDEpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gKGkgLSBjYW5kaWRhdGUgLSAxKTtcbiAgICAgIGNhbmRpZGF0ZSA9IC0xO1xuICAgICAgKytpO1xuICAgIH0gZWxzZSBpZihydmFsW2ldID09PSAnICcgfHwgcnZhbFtpXSA9PT0gJ1xcdCcgfHwgcnZhbFtpXSA9PT0gJywnKSB7XG4gICAgICBjYW5kaWRhdGUgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbl9fd2VicGFja19yZXF1aXJlX18oNSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUGFzc3dvcmQtYmFzZWQgZW5jcnlwdGlvbiBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBmb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG5tb2R1bGUuZXhwb3J0cyA9IHBraS5wYmUgPSBmb3JnZS5wYmUgPSBmb3JnZS5wYmUgfHwge307XG52YXIgb2lkcyA9IHBraS5vaWRzO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9hbGdvcml0aG0gcGFyYW1zXG52YXIgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2VuY3J5cHRpb25PaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0FsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVycycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGlvblBhcmFtcydcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0ZWREYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnZW5jcnlwdGVkRGF0YSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBQQkVTMkFsZ29yaXRobXMgc3RydWN0dXJlXG4vLyBOb3RlOiBDdXJyZW50bHkgb25seSB3b3JrcyB3L1BCS0RGMiArIEFFUyBlbmNyeXB0aW9uIHNjaGVtZXNcbnZhciBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jLm9pZCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2tkZk9pZCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcycsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZlNhbHQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50JyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAna2RmSXRlcmF0aW9uQ291bnQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdrZXlMZW5ndGgnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIHByZlxuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW3tcbiAgICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogJ3ByZk9pZCdcbiAgICAgICAgfV1cbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLml2JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNJdidcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHBrY3MxMlBiZVBhcmFtc1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLnNhbHQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzYWx0J1xuICB9LCB7XG4gICAgbmFtZTogJ3BrY3MtMTJQYmVQYXJhbXMuaXRlcmF0aW9ucycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnaXRlcmF0aW9ucydcbiAgfV1cbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QsIHByb2R1Y2luZyBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqXG4gKiBQQkVTMkFsZ29yaXRobXMgQUxHT1JJVEhNLUlERU5USUZJRVIgOjo9XG4gKiAgIHsge1BCRVMyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCRVMyfSwgLi4ufVxuICpcbiAqIGlkLVBCRVMyIE9CSkVDVCBJREVOVElGSUVSIDo6PSB7cGtjcy01IDEzfVxuICpcbiAqIFBCRVMyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBrZXlEZXJpdmF0aW9uRnVuYyBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItS0RGc319LFxuICogICBlbmNyeXB0aW9uU2NoZW1lIEFsZ29yaXRobUlkZW50aWZpZXIge3tQQkVTMi1FbmNzfX1cbiAqIH1cbiAqXG4gKiBQQkVTMi1LREZzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQktERjItcGFyYW1zIElERU5USUZJRUQgQlkgaWQtUEJLREYyfSwgLi4uIH1cbiAqXG4gKiBQQkVTMi1FbmNzIEFMR09SSVRITS1JREVOVElGSUVSIDo6PSB7IC4uLiB9XG4gKlxuICogUEJLREYyLXBhcmFtcyA6Oj0gU0VRVUVOQ0Uge1xuICogICBzYWx0IENIT0lDRSB7XG4gKiAgICAgc3BlY2lmaWVkIE9DVEVUIFNUUklORyxcbiAqICAgICBvdGhlclNvdXJjZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVNhbHRTb3VyY2VzfX1cbiAqICAgfSxcbiAqICAgaXRlcmF0aW9uQ291bnQgSU5URUdFUiAoMS4uTUFYKSxcbiAqICAga2V5TGVuZ3RoIElOVEVHRVIgKDEuLk1BWCkgT1BUSU9OQUwsXG4gKiAgIHByZiBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJLREYyLVBSRnN9fSBERUZBVUxUIGFsZ2lkLWhtYWNXaXRoU0hBMVxuICogfVxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZW5jcnlwdCB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnM6XG4gKiAgICAgICAgICBhbGdvcml0aG0gdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnKSwgZGVmYXVsdHMgdG8gJ2FlczEyOCcuXG4gKiAgICAgICAgICBjb3VudCB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplIHRoZSBzYWx0IHNpemUgdG8gdXNlLlxuICogICAgICAgICAgcHJmQWxnb3JpdGhtIHRoZSBQUkYgbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ3NoYTEnLCAnc2hhMjI0JywgJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJylcbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyA9IGZ1bmN0aW9uKG9iaiwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5zYWx0U2l6ZSA9IG9wdGlvbnMuc2FsdFNpemUgfHwgODtcbiAgb3B0aW9ucy5jb3VudCA9IG9wdGlvbnMuY291bnQgfHwgMjA0ODtcbiAgb3B0aW9ucy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnYWVzMTI4JztcbiAgb3B0aW9ucy5wcmZBbGdvcml0aG0gPSBvcHRpb25zLnByZkFsZ29yaXRobSB8fCAnc2hhMSc7XG5cbiAgLy8gZ2VuZXJhdGUgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMob3B0aW9ucy5zYWx0U2l6ZSk7XG4gIHZhciBjb3VudCA9IG9wdGlvbnMuY291bnQ7XG4gIHZhciBjb3VudEJ5dGVzID0gYXNuMS5pbnRlZ2VyVG9EZXIoY291bnQpO1xuICB2YXIgZGtMZW47XG4gIHZhciBlbmNyeXB0aW9uQWxnb3JpdGhtO1xuICB2YXIgZW5jcnlwdGVkRGF0YTtcbiAgaWYob3B0aW9ucy5hbGdvcml0aG0uaW5kZXhPZignYWVzJykgPT09IDAgfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdkZXMnKSB7XG4gICAgLy8gZG8gUEJFUzJcbiAgICB2YXIgaXZMZW4sIGVuY09pZCwgY2lwaGVyRm47XG4gICAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnYWVzMTI4JzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMTI4LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2FlczE5Mic6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczE5Mi1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMyNTYnOlxuICAgICAgZGtMZW4gPSAzMjtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMyNTYtQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVzJzpcbiAgICAgIGRrTGVuID0gODtcbiAgICAgIGl2TGVuID0gODtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2Rlc0NCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gICAgdmFyIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aCcgKyBvcHRpb25zLnByZkFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBtZCA9IHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xuXG4gICAgLy8gZW5jcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgU0hBLTEgYW5kIEFFUy9ERVNcbiAgICB2YXIgZGsgPSBmb3JnZS5wa2NzNS5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIGNvdW50LCBka0xlbiwgbWQpO1xuICAgIHZhciBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoaXZMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIob2JqKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIGVuY3J5cHRlZERhdGEgPSBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKCk7XG5cbiAgICAvLyBnZXQgUEJLREYyLXBhcmFtc1xuICAgIHZhciBwYXJhbXMgPSBjcmVhdGVQYmtkZjJQYXJhbXMoc2FsdCwgY291bnRCeXRlcywgZGtMZW4sIHByZkFsZ29yaXRobSk7XG5cbiAgICBlbmNyeXB0aW9uQWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQkVTMiddKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8ga2V5RGVyaXZhdGlvbkZ1bmNcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIob2lkc1sncGtjczVQQktERjInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgLy8gUEJLREYyLXBhcmFtc1xuICAgICAgICAgIHBhcmFtc1xuICAgICAgICBdKSxcbiAgICAgICAgLy8gZW5jcnlwdGlvblNjaGVtZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihlbmNPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIGl2XG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgaXYpXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2UgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICczZGVzJykge1xuICAgIC8vIERvIFBLQ1MxMiBQQkVcbiAgICBka0xlbiA9IDI0O1xuXG4gICAgdmFyIHNhbHRCeXRlcyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoc2FsdCk7XG4gICAgdmFyIGRrID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdEJ5dGVzLCAxLCBjb3VudCwgZGtMZW4pO1xuICAgIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMiwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwa2NzLTEyUGJlUGFyYW1zXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIHNhbHRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgICAgICAvLyBpdGVyYXRpb24gY291bnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gICAgICBdKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mb1xuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBlbmNyeXB0aW9uQWxnb3JpdGhtXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSxcbiAgICAvLyBlbmNyeXB0ZWREYXRhXG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgZW5jcnlwdGVkRGF0YSlcbiAgXSk7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhIEFTTi4xIFByaXZhdGVLZXlJbmZvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKG9iaiwgZW5jcnlwdGVkUHJpdmF0ZUtleVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBjaXBoZXJcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNyeXB0aW9uT2lkKTtcbiAgdmFyIGNpcGhlciA9IHBraS5wYmUuZ2V0Q2lwaGVyKG9pZCwgY2FwdHVyZS5lbmNyeXB0aW9uUGFyYW1zLCBwYXNzd29yZCk7XG5cbiAgLy8gZ2V0IGVuY3J5cHRlZCBkYXRhXG4gIHZhciBlbmNyeXB0ZWQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmVuY3J5cHRlZERhdGEpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgcnZhbCA9IGFzbjEuZnJvbURlcihjaXBoZXIub3V0cHV0KTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGVwa2kgdGhlIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0gPSBmdW5jdGlvbihlcGtpLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKGVwa2kpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBFTS1lbmNvZGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvIHRvIEFTTi4xIGZvcm1hdC4gRGVjcnlwdGlvblxuICogaXMgbm90IHBlcmZvcm1lZC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBpbiBQRU0tZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIEFTTi4xIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICByZXR1cm4gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcbn07XG5cbi8qKlxuICogRW5jcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LiBCeSBkZWZhdWx0LCB0aGUga2V5IHdpbGwgYmUgd3JhcHBlZCBpblxuICogYSBQcml2YXRlS2V5SW5mbyBhbmQgZW5jcnlwdGVkIHRvIHByb2R1Y2UgYSBQS0NTIzggRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKiBUaGlzIGlzIHRoZSBzdGFuZGFyZCwgcHJlZmVycmVkIHdheSB0byBlbmNyeXB0IGEgcHJpdmF0ZSBrZXkuXG4gKlxuICogVG8gcHJvZHVjZSBhIG5vbi1zdGFuZGFyZCBQRU0tZW5jcnlwdGVkIHByaXZhdGUga2V5IHRoYXQgdXNlcyBlbmNhcHN1bGF0ZWRcbiAqIGhlYWRlcnMgdG8gaW5kaWNhdGUgdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIChvbGQtc3R5bGUgbm9uLVBLQ1MjOCBPcGVuU1NMXG4gKiBwcml2YXRlIGtleSBlbmNyeXB0aW9uKSwgc2V0IHRoZSAnbGVnYWN5JyBvcHRpb24gdG8gdHJ1ZS4gTm90ZTogVXNpbmcgdGhpc1xuICogb3B0aW9uIHdpbGwgY2F1c2UgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byBiZSBmb3JjZWQgdG8gMS5cbiAqXG4gKiBOb3RlOiBUaGUgJ2RlcycgYWxnb3JpdGhtIGlzIHN1cHBvcnRlZCwgYnV0IGl0IGlzIG5vdCBjb25zaWRlcmVkIHRvIGJlXG4gKiBzZWN1cmUgYmVjYXVzZSBpdCBvbmx5IHVzZXMgYSBzaW5nbGUgNTYtYml0IGtleS4gSWYgcG9zc2libGUsIGl0IGlzIGhpZ2hseVxuICogcmVjb21tZW5kZWQgdGhhdCBhIGRpZmZlcmVudCBhbGdvcml0aG0gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnNhS2V5IHRoZSBSU0Ega2V5IHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtOiB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gdG8gdXNlXG4gKiAgICAgICAgICAgICgnYWVzMTI4JywgJ2FlczE5MicsICdhZXMyNTYnLCAnM2RlcycsICdkZXMnKS5cbiAqICAgICAgICAgIGNvdW50OiB0aGUgaXRlcmF0aW9uIGNvdW50IHRvIHVzZS5cbiAqICAgICAgICAgIHNhbHRTaXplOiB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIGxlZ2FjeTogb3V0cHV0IGFuIG9sZCBub24tUEtDUyM4IFBFTS1lbmNyeXB0ZWQrZW5jYXBzdWxhdGVkXG4gKiAgICAgICAgICAgIGhlYWRlcnMgKERFSy1JbmZvKSBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZW5jb2RlZCBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5LCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAvLyBzdGFuZGFyZCBQS0NTIzhcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCFvcHRpb25zLmxlZ2FjeSkge1xuICAgIC8vIGVuY3J5cHQgUHJpdmF0ZUtleUluZm9cbiAgICB2YXIgcnZhbCA9IHBraS53cmFwUnNhUHJpdmF0ZUtleShwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKTtcbiAgICBydmFsID0gcGtpLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhydmFsLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBraS5lbmNyeXB0ZWRQcml2YXRlS2V5VG9QZW0ocnZhbCk7XG4gIH1cblxuICAvLyBsZWdhY3kgbm9uLVBLQ1MjOFxuICB2YXIgYWxnb3JpdGhtO1xuICB2YXIgaXY7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgY2FzZSAnYWVzMTI4JzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTEyOC1DQkMnO1xuICAgIGRrTGVuID0gMTY7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTInOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMTkyLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Nic6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0yNTYtQ0JDJztcbiAgICBka0xlbiA9IDMyO1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnM2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1FREUzLUNCQyc7XG4gICAgZGtMZW4gPSAyNDtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzJzpcbiAgICBhbGdvcml0aG0gPSAnREVTLUNCQyc7XG4gICAgZGtMZW4gPSA4O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYyg4KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGVuY3J5cHQgUlNBIHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICdlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicgKyBvcHRpb25zLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgT3BlblNTTCBsZWdhY3kga2V5IGRlcml2YXRpb25cbiAgdmFyIGRrID0gZm9yZ2UucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyhwYXNzd29yZCwgaXYuc3Vic3RyKDAsIDgpLCBka0xlbik7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIGNpcGhlci51cGRhdGUoYXNuMS50b0Rlcihwa2kucHJpdmF0ZUtleVRvQXNuMShyc2FLZXkpKSk7XG4gIGNpcGhlci5maW5pc2goKTtcblxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHByb2NUeXBlOiB7XG4gICAgICB2ZXJzaW9uOiAnNCcsXG4gICAgICB0eXBlOiAnRU5DUllQVEVEJ1xuICAgIH0sXG4gICAgZGVrSW5mbzoge1xuICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG0sXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoaXYpLnRvVXBwZXJDYXNlKClcbiAgICB9LFxuICAgIGJvZHk6IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2cpO1xufTtcblxuLyoqXG4gKiBEZWNyeXB0cyBhbiBSU0EgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBkZWNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgUlNBIGtleSBvbiBzdWNjZXNzLCBudWxsIG9uIGZhaWx1cmUuXG4gKi9cbnBraS5kZWNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHBlbSwgcGFzc3dvcmQpIHtcbiAgdmFyIHJ2YWwgPSBudWxsO1xuXG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1JTQSBQUklWQVRFIEtFWScpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiRU5DUllQVEVEIFBSSVZBVEUgS0VZXCIsIFwiUFJJVkFURSBLRVlcIiwgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdmFyIGRrTGVuO1xuICAgIHZhciBjaXBoZXJGbjtcbiAgICBzd2l0Y2gobXNnLmRla0luZm8uYWxnb3JpdGhtKSB7XG4gICAgY2FzZSAnREVTLUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnREVTLUVERTMtQ0JDJzpcbiAgICAgIGRrTGVuID0gMjQ7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMTkyLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0yNTYtQ0JDJzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTQwLUNCQyc6XG4gICAgICBka0xlbiA9IDU7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTY0LUNCQyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA2NCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnUkMyLTEyOC1DQkMnOlxuICAgICAgZGtMZW4gPSAxNjtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBmb3JnZS5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGRlY3J5cHQgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkICcgK1xuICAgICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgbXNnLmRla0luZm8uYWxnb3JpdGhtICsgJ1wiLicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gbXNnLmRla0luZm8uYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gdXNlIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gICAgdmFyIGl2ID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpO1xuICAgIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICAgIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gICAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgICBjaXBoZXIudXBkYXRlKGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG1zZy5ib2R5KSk7XG4gICAgaWYoY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICBydmFsID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcnZhbCA9IG1zZy5ib2R5O1xuICB9XG5cbiAgaWYobXNnLnR5cGUgPT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgcnZhbCA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYXNuMS5mcm9tRGVyKHJ2YWwpLCBwYXNzd29yZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjcnlwdGlvbiBhbHJlYWR5IHBlcmZvcm1lZCBhYm92ZVxuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIocnZhbCk7XG4gIH1cblxuICBpZihydmFsICE9PSBudWxsKSB7XG4gICAgcnZhbCA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEocnZhbCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleSA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBpZCwgaXRlciwgbiwgbWQpIHtcbiAgdmFyIGosIGw7XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ3NoYTEnIGluIGZvcmdlLm1kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNoYTFcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9XG5cbiAgdmFyIHUgPSBtZC5kaWdlc3RMZW5ndGg7XG4gIHZhciB2ID0gbWQuYmxvY2tMZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgLyogQ29udmVydCBwYXNzd29yZCB0byBVbmljb2RlIGJ5dGUgYnVmZmVyICsgdHJhaWxpbmcgMC1ieXRlLiAqL1xuICB2YXIgcGFzc0J1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgaWYocGFzc3dvcmQgIT09IG51bGwgJiYgcGFzc3dvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvcihsID0gMDsgbCA8IHBhc3N3b3JkLmxlbmd0aDsgbCsrKSB7XG4gICAgICBwYXNzQnVmLnB1dEludDE2KHBhc3N3b3JkLmNoYXJDb2RlQXQobCkpO1xuICAgIH1cbiAgICBwYXNzQnVmLnB1dEludDE2KDApO1xuICB9XG5cbiAgLyogTGVuZ3RoIG9mIHNhbHQgYW5kIHBhc3N3b3JkIGluIEJZVEVTLiAqL1xuICB2YXIgcCA9IHBhc3NCdWYubGVuZ3RoKCk7XG4gIHZhciBzID0gc2FsdC5sZW5ndGgoKTtcblxuICAvKiAxLiBDb25zdHJ1Y3QgYSBzdHJpbmcsIEQgKHRoZSBcImRpdmVyc2lmaWVyXCIpLCBieSBjb25jYXRlbmF0aW5nXG4gICAgICAgIHYgY29waWVzIG9mIElELiAqL1xuICB2YXIgRCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgRC5maWxsV2l0aEJ5dGUoaWQsIHYpO1xuXG4gIC8qIDIuIENvbmNhdGVuYXRlIGNvcGllcyBvZiB0aGUgc2FsdCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUyBvZiBsZW5ndGhcbiAgICAgICAgdiAqIGNlaWwocyAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgc2FsdCBtYXkgYmUgdHJ1bmFjdGVkXG4gICAgICAgIHRvIGNyZWF0ZSBTKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc28gaXMgUy4gKi9cbiAgdmFyIFNsZW4gPSB2ICogTWF0aC5jZWlsKHMgLyB2KTtcbiAgdmFyIFMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGZvcihsID0gMDsgbCA8IFNsZW47IGwrKykge1xuICAgIFMucHV0Qnl0ZShzYWx0LmF0KGwgJSBzKSk7XG4gIH1cblxuICAvKiAzLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHBhc3N3b3JkIHRvZ2V0aGVyIHRvIGNyZWF0ZSBhIHN0cmluZyBQIG9mXG4gICAgICAgIGxlbmd0aCB2ICogY2VpbChwIC8gdikgYnl0ZXMgKHRoZSBmaW5hbCBjb3B5IG9mIHRoZSBwYXNzd29yZCBtYXkgYmVcbiAgICAgICAgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBQKS5cbiAgICAgICAgTm90ZSB0aGF0IGlmIHRoZSBwYXNzd29yZCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFAuICovXG4gIHZhciBQbGVuID0gdiAqIE1hdGguY2VpbChwIC8gdik7XG4gIHZhciBQID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBQbGVuOyBsKyspIHtcbiAgICBQLnB1dEJ5dGUocGFzc0J1Zi5hdChsICUgcCkpO1xuICB9XG5cbiAgLyogNC4gU2V0IEk9U3x8UCB0byBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBTIGFuZCBQLiAqL1xuICB2YXIgSSA9IFM7XG4gIEkucHV0QnVmZmVyKFApO1xuXG4gIC8qIDUuIFNldCBjPWNlaWwobiAvIHUpLiAqL1xuICB2YXIgYyA9IE1hdGguY2VpbChuIC8gdSk7XG5cbiAgLyogNi4gRm9yIGk9MSwgMiwgLi4uLCBjLCBkbyB0aGUgZm9sbG93aW5nOiAqL1xuICBmb3IodmFyIGkgPSAxOyBpIDw9IGM7IGkrKykge1xuICAgIC8qIGEpIFNldCBBaT1IXnIoRHx8SSkuIChsLmUuIHRoZSBydGggaGFzaCBvZiBEfHxJLCBIKEgoSCguLi5IKER8fEkpKSkpICovXG4gICAgdmFyIGJ1ZiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBidWYucHV0Qnl0ZXMoRC5ieXRlcygpKTtcbiAgICBidWYucHV0Qnl0ZXMoSS5ieXRlcygpKTtcbiAgICBmb3IodmFyIHJvdW5kID0gMDsgcm91bmQgPCBpdGVyOyByb3VuZCsrKSB7XG4gICAgICBtZC5zdGFydCgpO1xuICAgICAgbWQudXBkYXRlKGJ1Zi5nZXRCeXRlcygpKTtcbiAgICAgIGJ1ZiA9IG1kLmRpZ2VzdCgpO1xuICAgIH1cblxuICAgIC8qIGIpIENvbmNhdGVuYXRlIGNvcGllcyBvZiBBaSB0byBjcmVhdGUgYSBzdHJpbmcgQiBvZiBsZW5ndGggdiBieXRlcyAodGhlXG4gICAgICAgICAgZmluYWwgY29weSBvZiBBaSBtYXkgYmUgdHJ1bmNhdGVkIHRvIGNyZWF0ZSBCKS4gKi9cbiAgICB2YXIgQiA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IobCA9IDA7IGwgPCB2OyBsKyspIHtcbiAgICAgIEIucHV0Qnl0ZShidWYuYXQobCAlIHUpKTtcbiAgICB9XG5cbiAgICAvKiBjKSBUcmVhdGluZyBJIGFzIGEgY29uY2F0ZW5hdGlvbiBJMCwgSTEsIC4uLiwgSWstMSBvZiB2LWJ5dGUgYmxvY2tzLFxuICAgICAgICAgIHdoZXJlIGs9Y2VpbChzIC8gdikgKyBjZWlsKHAgLyB2KSwgbW9kaWZ5IEkgYnkgc2V0dGluZ1xuICAgICAgICAgIElqPShJaitCKzEpIG1vZCAydiBmb3IgZWFjaCBqLiAgKi9cbiAgICB2YXIgayA9IE1hdGguY2VpbChzIC8gdikgKyBNYXRoLmNlaWwocCAvIHYpO1xuICAgIHZhciBJbmV3ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIGZvcihqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgdmFyIGNodW5rID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihJLmdldEJ5dGVzKHYpKTtcbiAgICAgIHZhciB4ID0gMHgxZmY7XG4gICAgICBmb3IobCA9IEIubGVuZ3RoKCkgLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgICB4ID0geCA+PiA4O1xuICAgICAgICB4ICs9IEIuYXQobCkgKyBjaHVuay5hdChsKTtcbiAgICAgICAgY2h1bmsuc2V0QXQobCwgeCAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgSW5ldy5wdXRCdWZmZXIoY2h1bmspO1xuICAgIH1cbiAgICBJID0gSW5ldztcblxuICAgIC8qIEFkZCBBaSB0byBBLiAqL1xuICAgIHJlc3VsdC5wdXRCdWZmZXIoYnVmKTtcbiAgfVxuXG4gIHJlc3VsdC50cnVuY2F0ZShyZXN1bHQubGVuZ3RoKCkgLSBuKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvaWQgdGhlIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIHBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlciA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICBzd2l0Y2gob2lkKSB7XG4gIGNhc2UgcGtpLm9pZHNbJ3BrY3M1UEJFUzInXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMihvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGNhc2UgcGtpLm9pZHNbJ3BiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkMnXTpcbiAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgIHJldHVybiBwa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRShvaWQsIHBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIGRlZmF1bHQ6XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdwa2NzNVBCRVMyJyxcbiAgICAgICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyxcbiAgICAgICdwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDJ1xuICAgIF07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGFjY29yZGluZyB0byBQQkVTMiBwYXJhbXMgYmxvY2suXG4gKlxuICogVGhlIHJldHVybmVkIGNpcGhlciBpbnN0YW5jZSBpcyBhbHJlYWR5IHN0YXJ0ZWQgdXNpbmcgdGhlIElWXG4gKiBmcm9tIFBCRVMyIHBhcmFtZXRlciBibG9jay5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBQS0NTIzUgUEJLREYyIE9JRCAoaW4gc3RyaW5nIG5vdGF0aW9uKS5cbiAqIEBwYXJhbSBwYXJhbXMgdGhlIEFTTi4xIFBCRVMyLXBhcmFtcyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBCRVMyID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBQQkVTMkFsZ29yaXRobXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gY2hlY2sgb2lkc1xuICBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUua2RmT2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkc1sncGtjczVQQktERjInXSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdVbnN1cHBvcnRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbJ3BrY3M1UEJLREYyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmVuY09pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ2FlczEyOC1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczE5Mi1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2FlczI1Ni1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlcy1FREUzLUNCQyddICYmXG4gICAgb2lkICE9PSBwa2kub2lkc1snZGVzQ0JDJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBzY2hlbWUgT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gW1xuICAgICAgJ2FlczEyOC1DQkMnLCAnYWVzMTkyLUNCQycsICdhZXMyNTYtQ0JDJywgJ2Rlcy1FREUzLUNCQycsICdkZXNDQkMnXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIHNldCBQQkUgcGFyYW1zXG4gIHZhciBzYWx0ID0gY2FwdHVyZS5rZGZTYWx0O1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmtkZkl0ZXJhdGlvbkNvdW50KTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG4gIHZhciBka0xlbjtcbiAgdmFyIGNpcGhlckZuO1xuICBzd2l0Y2gocGtpLm9pZHNbb2lkXSkge1xuICBjYXNlICdhZXMxMjgtQ0JDJzpcbiAgICBka0xlbiA9IDE2O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczE5Mi1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMjU2LUNCQyc6XG4gICAgZGtMZW4gPSAzMjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdkZXMtRURFMy1DQkMnOlxuICAgIGRrTGVuID0gMjQ7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzQ0JDJzpcbiAgICBka0xlbiA9IDg7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGdldCBQUkYgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIG1kID0gcHJmT2lkVG9NZXNzYWdlRGlnZXN0KGNhcHR1cmUucHJmT2lkKTtcblxuICAvLyBkZWNyeXB0IHByaXZhdGUga2V5IHVzaW5nIHBiZSB3aXRoIGNob3NlbiBQUkYgYW5kIEFFUy9ERVNcbiAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgdmFyIGl2ID0gY2FwdHVyZS5lbmNJdjtcbiAgdmFyIGNpcGhlciA9IGNpcGhlckZuKGRrKTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBHZXQgbmV3IEZvcmdlIGNpcGhlciBvYmplY3QgaW5zdGFuY2UgZm9yIFBLQ1MjMTIgUEJFLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBrZXkgJiBJVlxuICogZGVyaXZlZCBmcm9tIHRoZSBwcm92aWRlZCBwYXNzd29yZCBhbmQgUEtDUyMxMiBQQkUgc2FsdC5cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBQS0NTIzEyIFBCRSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBBU04uMSBQS0NTIzEyIFBCRS1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgbmV3IGNpcGhlciBvYmplY3QgaW5zdGFuY2UuXG4gKi9cbnBraS5wYmUuZ2V0Q2lwaGVyRm9yUEtDUzEyUEJFID0gZnVuY3Rpb24ob2lkLCBwYXJhbXMsIHBhc3N3b3JkKSB7XG4gIC8vIGdldCBQQkUgcGFyYW1zXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUocGFyYW1zLCBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gYWxnb3JpdGhtICcgK1xuICAgICAgJ3BhcmFtZXRlcnMuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHNhbHQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnNhbHQpO1xuICB2YXIgY291bnQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLml0ZXJhdGlvbnMpO1xuICBjb3VudCA9IGNvdW50LmdldEludChjb3VudC5sZW5ndGgoKSA8PCAzKTtcblxuICB2YXIgZGtMZW4sIGRJdkxlbiwgY2lwaGVyRm47XG4gIHN3aXRjaChvaWQpIHtcbiAgICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLnN0YXJ0RGVjcnlwdGluZztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwa2kub2lkc1sncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQyddOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgZEl2TGVuID0gODtcbiAgICAgIGNpcGhlckZuID0gZnVuY3Rpb24oa2V5LCBpdikge1xuICAgICAgICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCA0MCk7XG4gICAgICAgIGNpcGhlci5zdGFydChpdiwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjaXBoZXI7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTICMxMiBQQkUgZGF0YSBibG9jay4gVW5zdXBwb3J0ZWQgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gb2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG4gIHZhciBrZXkgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0LCAxLCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgbWQuc3RhcnQoKTtcbiAgdmFyIGl2ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMiwgY291bnQsIGRJdkxlbiwgbWQpO1xuXG4gIHJldHVybiBjaXBoZXJGbihrZXksIGl2KTtcbn07XG5cbi8qKlxuICogT3BlblNTTCdzIGxlZ2FjeSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBTZWU6IGh0dHA6Ly93d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgZnJvbS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0IHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBka0xlbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG5lZWRlZCBmb3IgdGhlIGRlcml2ZWQga2V5LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbbWRdIGFuIG9wdGlvbmFsIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UuXG4gKi9cbnBraS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzID0gZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIGRrTGVuLCBtZCkge1xuICBpZih0eXBlb2YgbWQgPT09ICd1bmRlZmluZWQnIHx8IG1kID09PSBudWxsKSB7XG4gICAgaWYoISgnbWQ1JyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZDVcIiBoYXNoIGFsZ29yaXRobSB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gIH1cbiAgaWYoc2FsdCA9PT0gbnVsbCkge1xuICAgIHNhbHQgPSAnJztcbiAgfVxuICB2YXIgZGlnZXN0cyA9IFtoYXNoKG1kLCBwYXNzd29yZCArIHNhbHQpXTtcbiAgZm9yKHZhciBsZW5ndGggPSAxNiwgaSA9IDE7IGxlbmd0aCA8IGRrTGVuOyArK2ksIGxlbmd0aCArPSAxNikge1xuICAgIGRpZ2VzdHMucHVzaChoYXNoKG1kLCBkaWdlc3RzW2kgLSAxXSArIHBhc3N3b3JkICsgc2FsdCkpO1xuICB9XG4gIHJldHVybiBkaWdlc3RzLmpvaW4oJycpLnN1YnN0cigwLCBka0xlbik7XG59O1xuXG5mdW5jdGlvbiBoYXNoKG1kLCBieXRlcykge1xuICByZXR1cm4gbWQuc3RhcnQoKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG59XG5cbmZ1bmN0aW9uIHByZk9pZFRvTWVzc2FnZURpZ2VzdChwcmZPaWQpIHtcbiAgLy8gZ2V0IFBSRiBhbGdvcml0aG0sIGRlZmF1bHQgdG8gU0hBLTFcbiAgdmFyIHByZkFsZ29yaXRobTtcbiAgaWYoIXByZk9pZCkge1xuICAgIHByZkFsZ29yaXRobSA9ICdobWFjV2l0aFNIQTEnO1xuICB9IGVsc2Uge1xuICAgIHByZkFsZ29yaXRobSA9IHBraS5vaWRzW2FzbjEuZGVyVG9PaWQocHJmT2lkKV07XG4gICAgaWYoIXByZkFsZ29yaXRobSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQUkYgT0lELicpO1xuICAgICAgZXJyb3Iub2lkID0gcHJmT2lkO1xuICAgICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgICAnaG1hY1dpdGhTSEExJywgJ2htYWNXaXRoU0hBMjI0JywgJ2htYWNXaXRoU0hBMjU2JywgJ2htYWNXaXRoU0hBMzg0JyxcbiAgICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZkFsZ29yaXRobVRvTWVzc2FnZURpZ2VzdChwcmZBbGdvcml0aG0pO1xufVxuXG5mdW5jdGlvbiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKSB7XG4gIHZhciBmYWN0b3J5ID0gZm9yZ2UubWQ7XG4gIHN3aXRjaChwcmZBbGdvcml0aG0pIHtcbiAgY2FzZSAnaG1hY1dpdGhTSEEyMjQnOlxuICAgIGZhY3RvcnkgPSBmb3JnZS5tZC5zaGE1MTI7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMSc6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjU2JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEEzODQnOlxuICBjYXNlICdobWFjV2l0aFNIQTUxMic6XG4gICAgcHJmQWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtLnN1YnN0cig4KS50b0xvd2VyQ2FzZSgpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIGFsZ29yaXRobS4nKTtcbiAgICBlcnJvci5hbGdvcml0aG0gPSBwcmZBbGdvcml0aG07XG4gICAgZXJyb3Iuc3VwcG9ydGVkID0gW1xuICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAnaG1hY1dpdGhTSEE1MTInXTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZighZmFjdG9yeSB8fCAhKHByZkFsZ29yaXRobSBpbiBmYWN0b3J5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIHByZkFsZ29yaXRobSk7XG4gIH1cbiAgcmV0dXJuIGZhY3RvcnlbcHJmQWxnb3JpdGhtXS5jcmVhdGUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pIHtcbiAgdmFyIHBhcmFtcyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBzYWx0XG4gICAgYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2FsdCksXG4gICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGNvdW50Qnl0ZXMuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG4gIC8vIHdoZW4gUFJGIGFsZ29yaXRobSBpcyBub3QgU0hBLTEgZGVmYXVsdCwgYWRkIGtleSBsZW5ndGggYW5kIFBSRiBhbGdvcml0aG1cbiAgaWYocHJmQWxnb3JpdGhtICE9PSAnaG1hY1dpdGhTSEExJykge1xuICAgIHBhcmFtcy52YWx1ZS5wdXNoKFxuICAgICAgLy8ga2V5IGxlbmd0aFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGRrTGVuLnRvU3RyaW5nKDE2KSkpLFxuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllclxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHNbcHJmQWxnb3JpdGhtXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgXSkpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENpcGhlciBiYXNlIEFQSS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcblxuLy8gcmVnaXN0ZXJlZCBhbGdvcml0aG1zXG5mb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyA9IGZvcmdlLmNpcGhlci5hbGdvcml0aG1zIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlY2lwaGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW5cbiAqIGFsZ29yaXRobSBhbmQga2V5LiBUaGUgYWxnb3JpdGhtIG1heSBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyB2YWx1ZSBmb3IgYVxuICogcHJldmlvdXNseSByZWdpc3RlcmVkIGFsZ29yaXRobSBvciBpdCBtYXkgYmUgZ2l2ZW4gYXMgYSBjaXBoZXIgYWxnb3JpdGhtXG4gKiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UsIGVpdGhlciBhIHN0cmluZyBvciBhbiBhbGdvcml0aG0gQVBJXG4gKiAgICAgICAgICBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhXG4gKiAgICAgICAgICBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gYWxnb3JpdGhtIGJ5IG5hbWUuIElmIHRoZSBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRoZVxuICogYWxnb3JpdGhtIEFQSSBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIEFQSSBvYmplY3QuXG4gKi9cbmZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIGFsZ29yaXRobSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXSA9IGFsZ29yaXRobTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHJlZ2lzdGVyZWQgYWxnb3JpdGhtIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhbGdvcml0aG0sIGlmIGZvdW5kLCBudWxsIGlmIG5vdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgaWYobmFtZSBpbiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcykge1xuICAgIHJldHVybiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBCbG9ja0NpcGhlciA9IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgdGhpcy5tb2RlID0gdGhpcy5hbGdvcml0aG0ubW9kZTtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLm1vZGUuYmxvY2tTaXplO1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB0aGlzLm91dHB1dCA9IG51bGw7XG4gIHRoaXMuX29wID0gb3B0aW9ucy5kZWNyeXB0ID8gdGhpcy5tb2RlLmRlY3J5cHQgOiB0aGlzLm1vZGUuZW5jcnlwdDtcbiAgdGhpcy5fZGVjcnlwdCA9IG9wdGlvbnMuZGVjcnlwdDtcbiAgdGhpcy5hbGdvcml0aG0uaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICpcbiAqIEZvciBub24tR0NNIG1vZGUsIHRoZSBJViBtYXkgYmUgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5XG4gKiBvZiBieXRlcywgYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzLiBJZiB0aGUgSVYgaXMgaW5cbiAqIGJ5dGVzLCB0aGVuIGl0IG11c3QgYmUgTmIgKDE2KSBieXRlcyBpbiBsZW5ndGguIElmIHRoZSBJViBpcyBnaXZlbiBpbiBhc1xuICogMzItYml0IGludGVnZXJzLCB0aGVuIGl0IG11c3QgYmUgNCBpbnRlZ2VycyBsb25nLlxuICpcbiAqIE5vdGU6IGFuIElWIGlzIG5vdCByZXF1aXJlZCBvciB1c2VkIGluIEVDQiBtb2RlLlxuICpcbiAqIEZvciBHQ00tbW9kZSwgdGhlIElWIG11c3QgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3JcbiAqIGEgYnl0ZSBidWZmZXIuIFRoZSBudW1iZXIgb2YgYnl0ZXMgc2hvdWxkIGJlIDEyICg5NiBiaXRzKSBhcyByZWNvbW1lbmRlZFxuICogYnkgTklTVCBTUC04MDAtMzhEIGJ1dCBhbm90aGVyIGxlbmd0aCBtYXkgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2ZcbiAqICAgICAgICAgICAgYnl0ZXMsIG51bGwgdG8gcmV1c2UgdGhlIGxhc3QgY2lwaGVyZWQgYmxvY2sgZnJvbSBhIHByZXZpb3VzXG4gKiAgICAgICAgICAgIHVwZGF0ZSgpICh0aGlzIFwicmVzaWR1ZVwiIG1ldGhvZCBpcyBmb3IgbGVnYWN5IHN1cHBvcnQgb25seSkuXG4gKiAgICAgICAgICBhZGRpdGlvbmFsRGF0YSBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0aW9uIGRhdGEgYXMgYSBiaW5hcnktZW5jb2RlZFxuICogICAgICAgICAgICBzdHJpbmcgb2YgYnl0ZXMsIGZvciAnR0NNJyBtb2RlLCAoZGVmYXVsdDogbm9uZSkuXG4gKiAgICAgICAgICB0YWdMZW5ndGggZGVzaXJlZCBsZW5ndGggb2YgYXV0aGVudGljYXRpb24gdGFnLCBpbiBiaXRzLCBmb3JcbiAqICAgICAgICAgICAgJ0dDTScgbW9kZSAoMC0xMjgsIGRlZmF1bHQ6IDEyOCkuXG4gKiAgICAgICAgICB0YWcgdGhlIGF1dGhlbnRpY2F0aW9uIHRhZyB0byBjaGVjayBpZiBkZWNyeXB0aW5nLCBhcyBhXG4gKiAgICAgICAgICAgICBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBvcHRzID0ge307XG4gIGZvcih2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgb3B0cy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcbiAgdGhpcy5fZmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dCB8fCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm1vZGUuc3RhcnQob3B0cyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBjaXBoZXIgbW9kZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZihpbnB1dCkge1xuICAgIC8vIGlucHV0IGdpdmVuLCBzbyBlbXB0eSBpdCBpbnRvIHRoZSBpbnB1dCBidWZmZXJcbiAgICB0aGlzLl9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICB9XG5cbiAgLy8gZG8gY2lwaGVyIG9wZXJhdGlvbiB1bnRpbCBpdCBuZWVkcyBtb3JlIGlucHV0IGFuZCBub3QgZmluaXNoZWRcbiAgd2hpbGUoIXRoaXMuX29wLmNhbGwodGhpcy5tb2RlLCB0aGlzLl9pbnB1dCwgdGhpcy5vdXRwdXQsIHRoaXMuX2ZpbmlzaCkgJiZcbiAgICAhdGhpcy5fZmluaXNoKSB7fVxuXG4gIC8vIGZyZWUgY29uc3VtZWQgbWVtb3J5IGZyb20gaW5wdXQgYnVmZmVyXG4gIHRoaXMuX2lucHV0LmNvbXBhY3QoKTtcbn07XG5cbi8qKlxuICogRmluaXNoZXMgZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nLlxuICpcbiAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSBpbiBDQkMgbW9kZSwgbnVsbCBmb3IgZGVmYXVsdCxcbiAqICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ocGFkKSB7XG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHcvZGVwcmVjYXRlZCBwYWRkaW5nIEFQSVxuICAvLyBOb3RlOiB3aWxsIG92ZXJ3cml0ZSBwYWRkaW5nIGZ1bmN0aW9ucyBldmVuIGFmdGVyIGFub3RoZXIgc3RhcnQoKSBjYWxsXG4gIGlmKHBhZCAmJiAodGhpcy5tb2RlLm5hbWUgPT09ICdFQ0InIHx8IHRoaXMubW9kZS5uYW1lID09PSAnQ0JDJykpIHtcbiAgICB0aGlzLm1vZGUucGFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIGlucHV0LCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vZGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIG91dHB1dCwgdHJ1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnMgZm9yIHBhZGRpbmcgYW5kIGFmdGVyRmluaXNoIGZ1bmN0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuXG4gIC8vIGdldCAjIG9mIGJ5dGVzIHRoYXQgd29uJ3QgZmlsbCBhIGJsb2NrXG4gIG9wdGlvbnMub3ZlcmZsb3cgPSB0aGlzLl9pbnB1dC5sZW5ndGgoKSAlIHRoaXMuYmxvY2tTaXplO1xuXG4gIGlmKCF0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS5wYWQpIHtcbiAgICBpZighdGhpcy5tb2RlLnBhZCh0aGlzLl9pbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkbyBmaW5hbCB1cGRhdGVcbiAgdGhpcy5fZmluaXNoID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGUoKTtcblxuICBpZih0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS51bnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUudW5wYWQodGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYodGhpcy5tb2RlLmFmdGVyRmluaXNoKSB7XG4gICAgaWYoIXRoaXMubW9kZS5hZnRlckZpbmlzaCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdik7XG4gICAgdGhpcy5fcHJldiA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB9XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBwbGFpbnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wcmV2W2ldIF4gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9vdXRCbG9jaztcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBjaXBoZXJlZCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIGNpcGhlcnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9wcmV2W2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9pbkJsb2NrLnNsaWNlKDApO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyIGZlZWRiYWNrIChDRkIpICoqL1xuXG5tb2Rlcy5jZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENGQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbi8qKiBPdXRwdXQgZmVlZGJhY2sgKE9GQikgKiovXG5cbm1vZGVzLm9mYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdPRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENUUiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIGJsb2NrIGNvbXBsZXRlLCBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogR2Fsb2lzL0NvdW50ZXIgTW9kZSAoR0NNKSAqKi9cblxubW9kZXMuZ2NtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0dDTSc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBSIGlzIGFjdHVhbGx5IHRoaXMgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggMTIwIG1vcmUgemVybyBiaXRzLCBidXRcbiAgLy8gd2Ugb25seSBYT1IgYWdhaW5zdCBSIHNvIHRoZSBvdGhlciB6ZXJvcyBoYXZlIG5vIGVmZmVjdCAtLSB3ZSBqdXN0XG4gIC8vIGFwcGx5IHRoaXMgdmFsdWUgdG8gdGhlIGZpcnN0IGludGVnZXIgaW4gYSBibG9ja1xuICB0aGlzLl9SID0gMHhFMTAwMDAwMDtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gZW5zdXJlIElWIGlzIGEgYnl0ZSBidWZmZXJcbiAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG5cbiAgLy8gbm8gY2lwaGVyZWQgZGF0YSBwcm9jZXNzZWQgeWV0XG4gIHRoaXMuX2NpcGhlckxlbmd0aCA9IDA7XG5cbiAgLy8gZGVmYXVsdCBhZGRpdGlvbmFsIGRhdGEgaXMgbm9uZVxuICB2YXIgYWRkaXRpb25hbERhdGE7XG4gIGlmKCdhZGRpdGlvbmFsRGF0YScgaW4gb3B0aW9ucykge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0YWcgbGVuZ3RoIGlzIDEyOCBiaXRzXG4gIGlmKCd0YWdMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSBvcHRpb25zLnRhZ0xlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSAxMjg7XG4gIH1cblxuICAvLyBpZiB0YWcgaXMgZ2l2ZW4sIGVuc3VyZSB0YWcgbWF0Y2hlcyB0YWcgbGVuZ3RoXG4gIHRoaXMuX3RhZyA9IG51bGw7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIC8vIHNhdmUgdGFnIHRvIGNoZWNrIGxhdGVyXG4gICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgaWYodGhpcy5fdGFnLmxlbmd0aCAhPT0gKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHRhZyBkb2VzIG5vdCBtYXRjaCB0YWcgbGVuZ3RoLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSB0bXAgc3RvcmFnZSBmb3IgaGFzaCBjYWxjdWxhdGlvblxuICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG5cbiAgLy8gbm8gdGFnIGdlbmVyYXRlZCB5ZXRcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIC8vIGdlbmVyYXRlIGhhc2ggc3Via2V5XG4gIC8vIChhcHBseSBibG9jayBjaXBoZXIgdG8gXCJ6ZXJvXCIgYmxvY2spXG4gIHRoaXMuX2hhc2hTdWJrZXkgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsIDAsIDAsIDBdLCB0aGlzLl9oYXNoU3Via2V5KTtcblxuICAvLyBnZW5lcmF0ZSB0YWJsZSBNXG4gIC8vIHVzZSA0LWJpdCB0YWJsZXMgKDMyIGNvbXBvbmVudCBkZWNvbXBvc2l0aW9uIG9mIGEgMTYgYnl0ZSB2YWx1ZSlcbiAgLy8gOC1iaXQgdGFibGVzIHRha2UgbW9yZSBzcGFjZSBhbmQgYXJlIGtub3duIHRvIGhhdmUgc2VjdXJpdHlcbiAgLy8gdnVsbmVyYWJpbGl0aWVzIChpbiBuYXRpdmUgaW1wbGVtZW50YXRpb25zKVxuICB0aGlzLmNvbXBvbmVudEJpdHMgPSA0O1xuICB0aGlzLl9tID0gdGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLmNvbXBvbmVudEJpdHMpO1xuXG4gIC8vIE5vdGU6IHN1cHBvcnQgSVYgbGVuZ3RoIGRpZmZlcmVudCBmcm9tIDk2IGJpdHM/IChvbmx5IHN1cHBvcnRpbmdcbiAgLy8gOTYgYml0cyBpcyByZWNvbW1lbmRlZCBieSBOSVNUIFNQLTgwMC0zOEQpXG4gIC8vIGdlbmVyYXRlIEpfMFxuICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgaWYoaXZMZW5ndGggPT09IDEyKSB7XG4gICAgLy8gOTYtYml0IElWXG4gICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gIH0gZWxzZSB7XG4gICAgLy8gSVYgaXMgTk9UIDk2LWJpdHNcbiAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICB3aGlsZShpdi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsXG4gICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXSk7XG4gICAgfVxuICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLCBbMCwgMF0uY29uY2F0KGZyb202NFRvMzIoaXZMZW5ndGggKiA4KSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgSUNCIChpbml0aWFsIGNvdW50ZXIgYmxvY2spXG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9qMC5zbGljZSgwKTtcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gY29uc3VtZSBhdXRoZW50aWNhdGlvbiBkYXRhXG4gIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYWRkaXRpb25hbERhdGEpO1xuICAvLyBzYXZlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggYXMgYSBCRSA2NC1iaXQgbnVtYmVyXG4gIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAvLyBwYWQgYWRkaXRpb25hbCBkYXRhIHRvIDEyOCBiaXQgKDE2IGJ5dGUpIGJsb2NrIHNpemVcbiAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYob3ZlcmZsb3cpIHtcbiAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gIH1cbiAgdGhpcy5fcyA9IFswLCAwLCAwLCAwXTtcbiAgd2hpbGUoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgW1xuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgIF0pO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA9PT0gMCB8fCBmaW5pc2gpIHtcbiAgICAgIC8vIGhhbmRsZSBvdmVyZmxvdyBwcmlvciB0byBoYXNoaW5nXG4gICAgICBpZihmaW5pc2gpIHtcbiAgICAgICAgLy8gZ2V0IGJsb2NrIG92ZXJmbG93XG4gICAgICAgIHZhciBvdmVyZmxvdyA9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSBvdmVyZmxvdztcbiAgICAgICAgLy8gdHJ1bmNhdGUgZm9yIGhhc2ggZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG92ZXJmbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IG91dHB1dCBibG9jayBmb3IgaGFzaGluZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgICB0aGlzLl9vdXRCbG9ja1tpXSA9IHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIGFueSBwcmV2aW91cyBwYXJ0aWFsIGJ5dGVzXG4gICAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXIsIGdldCBwYXJ0aWFsIG91dHB1dCxcbiAgICAgIC8vIGFuZCByZXR1cm4gZWFybHlcbiAgICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBoYXNoIGJsb2NrIFNcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBkZWNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0TGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKEdDTSBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGluY3JlbWVudCBjb3VudGVyIChpbnB1dCBibG9jaylcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9oYXNoQmxvY2tbMF0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbMl0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9oYXNoQmxvY2tbM10gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9oYXNoQmxvY2spO1xuXG4gIC8vIFhPUiBoYXNoIGlucHV0IHdpdGggb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXiB0aGlzLl9oYXNoQmxvY2tbaV0pO1xuICB9XG5cbiAgLy8gaW5jcmVtZW50IGNpcGhlciBkYXRhIGxlbmd0aFxuICBpZihpbnB1dExlbmd0aCA8IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IGlucHV0TGVuZ3RoICUgdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmFmdGVyRmluaXNoID0gZnVuY3Rpb24ob3V0cHV0LCBvcHRpb25zKSB7XG4gIHZhciBydmFsID0gdHJ1ZTtcblxuICAvLyBoYW5kbGUgb3ZlcmZsb3dcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIG9wdGlvbnMub3ZlcmZsb3cpIHtcbiAgICBvdXRwdXQudHJ1bmNhdGUodGhpcy5ibG9ja1NpemUgLSBvcHRpb25zLm92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBhdXRoZW50aWNhdGlvbiB0YWdcbiAgdGhpcy50YWcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGNvbmNhdGVuYXRlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggd2l0aCBjaXBoZXIgbGVuZ3RoXG4gIHZhciBsZW5ndGhzID0gdGhpcy5fYURhdGFMZW5ndGguY29uY2F0KGZyb202NFRvMzIodGhpcy5fY2lwaGVyTGVuZ3RoICogOCkpO1xuXG4gIC8vIGluY2x1ZGUgbGVuZ3RocyBpbiBoYXNoXG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIGxlbmd0aHMpO1xuXG4gIC8vIGRvIEdDVFIoSl8wLCBTKVxuICB2YXIgdGFnID0gW107XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsIHRhZyk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW2ldIF4gdGFnW2ldKTtcbiAgfVxuXG4gIC8vIHRyaW0gdGFnIHRvIGxlbmd0aFxuICB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSAlICh0aGlzLl90YWdMZW5ndGggLyA4KSk7XG5cbiAgLy8gY2hlY2sgYXV0aGVudGljYXRpb24gdGFnXG4gIGlmKG9wdGlvbnMuZGVjcnlwdCAmJiB0aGlzLnRhZy5ieXRlcygpICE9PSB0aGlzLl90YWcpIHtcbiAgICBydmFsID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU2VlIE5JU1QgU1AtODAwLTM4RCA2LjMgKEFsZ29yaXRobSAxKS4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBHYWxvaXNcbiAqIGZpZWxkIG11bHRpcGxpY2F0aW9uLiBUaGUgZmllbGQsIEdGKDJeMTI4KSwgaXMgZGVmaW5lZCBieSB0aGUgcG9seW5vbWlhbDpcbiAqXG4gKiB4XjEyOCArIHheNyArIHheMiArIHggKyAxXG4gKlxuICogV2hpY2ggaXMgcmVwcmVzZW50ZWQgaW4gbGl0dGxlLWVuZGlhbiBiaW5hcnkgZm9ybSBhczogMTExMDAwMDEgKDB4ZTEpLiBXaGVuXG4gKiB0aGUgdmFsdWUgb2YgYSBjb2VmZmljaWVudCBpcyAxLCBhIGJpdCBpcyBzZXQuIFRoZSB2YWx1ZSBSLCBpcyB0aGVcbiAqIGNvbmNhdGVuYXRpb24gb2YgdGhpcyB2YWx1ZSBhbmQgMTIwIHplcm8gYml0cywgeWllbGRpbmcgYSAxMjgtYml0IHZhbHVlXG4gKiB3aGljaCBtYXRjaGVzIHRoZSBibG9jayBzaXplLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtdWx0aXBseSB0d28gZWxlbWVudHMgKHZlY3RvcnMgb2YgYnl0ZXMpLCBYIGFuZCBZLCBpblxuICogdGhlIGZpZWxkIEdGKDJeMTI4KS4gVGhlIHJlc3VsdCBpcyBpbml0aWFsaXplZCB0byB6ZXJvLiBGb3IgZWFjaCBiaXQgb2ZcbiAqIFggKG91dCBvZiAxMjgpLCB4X2ksIGlmIHhfaSBpcyBzZXQsIHRoZW4gdGhlIHJlc3VsdCBpcyBtdWx0aXBsaWVkIChYT1InZClcbiAqIGJ5IHRoZSBjdXJyZW50IHZhbHVlIG9mIFkuIEZvciBlYWNoIGJpdCwgdGhlIHZhbHVlIG9mIFkgd2lsbCBiZSByYWlzZWQgYnlcbiAqIGEgcG93ZXIgb2YgeCAobXVsdGlwbGllZCBieSB0aGUgcG9seW5vbWlhbCB4KS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnlcbiAqIHNoaWZ0aW5nIFkgb25jZSB0byB0aGUgcmlnaHQuIElmIHRoZSBjdXJyZW50IHZhbHVlIG9mIFksIHByaW9yIHRvIGJlaW5nXG4gKiBtdWx0aXBsaWVkIGJ5IHgsIGhhcyAwIGFzIGl0cyBMU0IsIHRoZW4gaXQgaXMgYSAxMjd0aCBkZWdyZWUgcG9seW5vbWlhbC5cbiAqIE90aGVyd2lzZSwgd2UgbXVzdCBkaXZpZGUgYnkgUiBhZnRlciBzaGlmdGluZyB0byBmaW5kIHRoZSByZW1haW5kZXIuXG4gKlxuICogQHBhcmFtIHggdGhlIGZpcnN0IGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0geSB0aGUgc2Vjb25kIGJsb2NrIHRvIG11bHRpcGx5IGJ5IHRoZSBmaXJzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBibG9jayByZXN1bHQgb2YgdGhlIG11bHRpcGxpY2F0aW9uLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgel9pID0gWzAsIDAsIDAsIDBdO1xuICB2YXIgdl9pID0geS5zbGljZSgwKTtcblxuICAvLyBjYWxjdWxhdGUgWl8xMjggKGJsb2NrIGhhcyAxMjggYml0cylcbiAgZm9yKHZhciBpID0gMDsgaSA8IDEyODsgKytpKSB7XG4gICAgLy8gaWYgeF9pIGlzIDAsIFpfe2krMX0gPSBaX2kgKHVuY2hhbmdlZClcbiAgICAvLyBlbHNlIFpfe2krMX0gPSBaX2kgXiBWX2lcbiAgICAvLyBnZXQgeF9pIGJ5IGZpbmRpbmcgMzItYml0IGludCBwb3NpdGlvbiwgdGhlbiBsZWZ0IHNoaWZ0IDEgYnkgcmVtYWluZGVyXG4gICAgdmFyIHhfaSA9IHhbKGkgLyAzMikgfCAwXSAmICgxIDw8ICgzMSAtIGkgJSAzMikpO1xuICAgIGlmKHhfaSkge1xuICAgICAgel9pWzBdIF49IHZfaVswXTtcbiAgICAgIHpfaVsxXSBePSB2X2lbMV07XG4gICAgICB6X2lbMl0gXj0gdl9pWzJdO1xuICAgICAgel9pWzNdIF49IHZfaVszXTtcbiAgICB9XG5cbiAgICAvLyBpZiBMU0IoVl9pKSBpcyAxLCBWX2kgPSBWX2kgPj4gMVxuICAgIC8vIGVsc2UgVl9pID0gKFZfaSA+PiAxKSBeIFJcbiAgICB0aGlzLnBvdyh2X2ksIHZfaSk7XG4gIH1cblxuICByZXR1cm4gel9pO1xufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbih4LCBvdXQpIHtcbiAgLy8gaWYgTFNCKHgpIGlzIDEsIHggPSB4ID4+PiAxXG4gIC8vIGVsc2UgeCA9ICh4ID4+PiAxKSBeIFJcbiAgdmFyIGxzYiA9IHhbM10gJiAxO1xuXG4gIC8vIGFsd2F5cyBkbyB4ID4+PiAxOlxuICAvLyBzdGFydGluZyB3aXRoIHRoZSByaWdodG1vc3QgaW50ZWdlciwgc2hpZnQgZWFjaCBpbnRlZ2VyIHRvIHRoZSByaWdodFxuICAvLyBvbmUgYml0LCBwdWxsaW5nIGluIHRoZSBiaXQgZnJvbSB0aGUgaW50ZWdlciB0byB0aGUgbGVmdCBhcyBpdHMgdG9wXG4gIC8vIG1vc3QgYml0IChkbyB0aGlzIGZvciB0aGUgbGFzdCAzIGludGVnZXJzKVxuICBmb3IodmFyIGkgPSAzOyBpID4gMDsgLS1pKSB7XG4gICAgb3V0W2ldID0gKHhbaV0gPj4+IDEpIHwgKCh4W2kgLSAxXSAmIDEpIDw8IDMxKTtcbiAgfVxuICAvLyBzaGlmdCB0aGUgZmlyc3QgaW50ZWdlciBub3JtYWxseVxuICBvdXRbMF0gPSB4WzBdID4+PiAxO1xuXG4gIC8vIGlmIGxzYiB3YXMgbm90IHNldCwgdGhlbiBwb2x5bm9taWFsIGhhZCBhIGRlZ3JlZSBvZiAxMjcgYW5kIGRvZXNuJ3RcbiAgLy8gbmVlZCB0byBkaXZpZGVkOyBvdGhlcndpc2UsIFhPUiB3aXRoIFIgdG8gZmluZCB0aGUgcmVtYWluZGVyOyB3ZSBvbmx5XG4gIC8vIG5lZWQgdG8gWE9SIHRoZSBmaXJzdCBpbnRlZ2VyIHNpbmNlIFIgdGVjaG5pY2FsbHkgZW5kcyB3LzEyMCB6ZXJvIGJpdHNcbiAgaWYobHNiKSB7XG4gICAgb3V0WzBdIF49IHRoaXMuX1I7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUudGFibGVNdWx0aXBseSA9IGZ1bmN0aW9uKHgpIHtcbiAgLy8gYXNzdW1lcyA0LWJpdCB0YWJsZXMgYXJlIHVzZWRcbiAgdmFyIHogPSBbMCwgMCwgMCwgMF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IChpIC8gOCkgfCAwO1xuICAgIHZhciB4X2kgPSAoeFtpZHhdID4+PiAoKDcgLSAoaSAlIDgpKSAqIDQpKSAmIDB4RjtcbiAgICB2YXIgYWggPSB0aGlzLl9tW2ldW3hfaV07XG4gICAgelswXSBePSBhaFswXTtcbiAgICB6WzFdIF49IGFoWzFdO1xuICAgIHpbMl0gXj0gYWhbMl07XG4gICAgelszXSBePSBhaFszXTtcbiAgfVxuICByZXR1cm4gejtcbn07XG5cbi8qKlxuICogQSBjb250aW51aW5nIHZlcnNpb24gb2YgdGhlIEdIQVNIIGFsZ29yaXRobSB0aGF0IG9wZXJhdGVzIG9uIGEgc2luZ2xlXG4gKiBibG9jay4gVGhlIGhhc2ggYmxvY2ssIGxhc3QgaGFzaCB2YWx1ZSAoWW0pIGFuZCB0aGUgbmV3IGJsb2NrIHRvIGhhc2hcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBibG9jay5cbiAqIEBwYXJhbSB5IHRoZSBwcmV2aW91cyB2YWx1ZSBmb3IgWW0sIHVzZSBbMCwgMCwgMCwgMF0gZm9yIGEgbmV3IGhhc2guXG4gKiBAcGFyYW0geCB0aGUgYmxvY2sgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoYXNoZWQgdmFsdWUgKFltKS5cbiAqL1xubW9kZXMuZ2NtLnByb3RvdHlwZS5naGFzaCA9IGZ1bmN0aW9uKGgsIHksIHgpIHtcbiAgeVswXSBePSB4WzBdO1xuICB5WzFdIF49IHhbMV07XG4gIHlbMl0gXj0geFsyXTtcbiAgeVszXSBePSB4WzNdO1xuICByZXR1cm4gdGhpcy50YWJsZU11bHRpcGx5KHkpO1xuICAvL3JldHVybiB0aGlzLm11bHRpcGx5KHksIGgpO1xufTtcblxuLyoqXG4gKiBQcmVjb21wdXRlcyBhIHRhYmxlIGZvciBtdWx0aXBseWluZyBhZ2FpbnN0IHRoZSBoYXNoIHN1YmtleS4gVGhpc1xuICogbWVjaGFuaXNtIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgc3BlZWQgaW5jcmVhc2Ugb3ZlciBtdWx0aXBsaWNhdGlvblxuICogcGVyZm9ybWVkIHdpdGhvdXQgYSB0YWJsZS4gVGhlIHRhYmxlLWJhc2VkIG11bHRpcGxpY2F0aW9uIHRoaXMgdGFibGUgaXNcbiAqIGZvciBzb2x2ZXMgWCAqIEggYnkgbXVsdGlwbHlpbmcgZWFjaCBjb21wb25lbnQgb2YgWCBieSBIIGFuZCB0aGVuXG4gKiBjb21wb3NpbmcgdGhlIHJlc3VsdHMgdG9nZXRoZXIgdXNpbmcgWE9SLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGFibGVzIHdpdGggZGlmZmVyZW50IGJpdCBzaXplc1xuICogZm9yIHRoZSBjb21wb25lbnRzLCBob3dldmVyLCB0aGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhlcmUgYXJlXG4gKiAzMiBjb21wb25lbnRzIG9mIFggKHdoaWNoIGlzIGEgMTYgYnl0ZSB2ZWN0b3IpLCB0aGVyZWZvcmUgZWFjaCBjb21wb25lbnRcbiAqIHRha2VzIDQtYml0cyAoc28gdGhlIHRhYmxlIGlzIGNvbnN0cnVjdGVkIHdpdGggYml0cz00KS5cbiAqXG4gKiBAcGFyYW0gaCB0aGUgaGFzaCBzdWJrZXkuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlSGFzaFRhYmxlID0gZnVuY3Rpb24oaCwgYml0cykge1xuICAvLyBUT0RPOiBUaGVyZSBhcmUgZnVydGhlciBvcHRpbWl6YXRpb25zIHRoYXQgd291bGQgdXNlIG9ubHkgdGhlXG4gIC8vIGZpcnN0IHRhYmxlIE1fMCAob3Igc29tZSB2YXJpYW50KSBhbG9uZyB3aXRoIGEgcmVtYWluZGVyIHRhYmxlO1xuICAvLyB0aGlzIGNhbiBiZSBleHBsb3JlZCBpbiB0aGUgZnV0dXJlXG4gIHZhciBtdWx0aXBsaWVyID0gOCAvIGJpdHM7XG4gIHZhciBwZXJJbnQgPSA0ICogbXVsdGlwbGllcjtcbiAgdmFyIHNpemUgPSAxNiAqIG11bHRpcGxpZXI7XG4gIHZhciBtID0gbmV3IEFycmF5KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgdmFyIHRtcCA9IFswLCAwLCAwLCAwXTtcbiAgICB2YXIgaWR4ID0gKGkgLyBwZXJJbnQpIHwgMDtcbiAgICB2YXIgc2hmdCA9ICgocGVySW50IC0gMSAtIChpICUgcGVySW50KSkgKiBiaXRzKTtcbiAgICB0bXBbaWR4XSA9ICgxIDw8IChiaXRzIC0gMSkpIDw8IHNoZnQ7XG4gICAgbVtpXSA9IHRoaXMuZ2VuZXJhdGVTdWJIYXNoVGFibGUodGhpcy5tdWx0aXBseSh0bXAsIGgpLCBiaXRzKTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5IGZvciBvbmVcbiAqIHBhcnRpY3VsYXIgY29tcG9uZW50IChvdXQgb2YgYWxsIHBvc3NpYmxlIGNvbXBvbmVudCB2YWx1ZXMpLlxuICpcbiAqIEBwYXJhbSBtaWQgdGhlIHByZS1tdWx0aXBsaWVkIHZhbHVlIGZvciB0aGUgbWlkZGxlIGtleSBvZiB0aGUgdGFibGUuXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUgZm9yIGEgY29tcG9uZW50LlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlID0gZnVuY3Rpb24obWlkLCBiaXRzKSB7XG4gIC8vIGNvbXB1dGUgdGhlIHRhYmxlIHF1aWNrbHkgYnkgbWluaW1pemluZyB0aGUgbnVtYmVyIG9mXG4gIC8vIFBPVyBvcGVyYXRpb25zIC0tIHRoZXkgb25seSBuZWVkIHRvIGJlIHBlcmZvcm1lZCBmb3IgcG93ZXJzIG9mIDIsXG4gIC8vIGFsbCBvdGhlciBlbnRyaWVzIGNhbiBiZSBjb21wb3NlZCBmcm9tIHRob3NlIHBvd2VycyB1c2luZyBYT1JcbiAgdmFyIHNpemUgPSAxIDw8IGJpdHM7XG4gIHZhciBoYWxmID0gc2l6ZSA+Pj4gMTtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIG1baGFsZl0gPSBtaWQuc2xpY2UoMCk7XG4gIHZhciBpID0gaGFsZiA+Pj4gMTtcbiAgd2hpbGUoaSA+IDApIHtcbiAgICAvLyByYWlzZSBtMFsyICogaV0gYW5kIHN0b3JlIGluIG0wW2ldXG4gICAgdGhpcy5wb3cobVsyICogaV0sIG1baV0gPSBbXSk7XG4gICAgaSA+Pj0gMTtcbiAgfVxuICBpID0gMjtcbiAgd2hpbGUoaSA8IGhhbGYpIHtcbiAgICBmb3IodmFyIGogPSAxOyBqIDwgaTsgKytqKSB7XG4gICAgICB2YXIgbV9pID0gbVtpXTtcbiAgICAgIHZhciBtX2ogPSBtW2pdO1xuICAgICAgbVtpICsgal0gPSBbXG4gICAgICAgIG1faVswXSBeIG1falswXSxcbiAgICAgICAgbV9pWzFdIF4gbV9qWzFdLFxuICAgICAgICBtX2lbMl0gXiBtX2pbMl0sXG4gICAgICAgIG1faVszXSBeIG1falszXVxuICAgICAgXTtcbiAgICB9XG4gICAgaSAqPSAyO1xuICB9XG4gIG1bMF0gPSBbMCwgMCwgMCwgMF07XG4gIC8qIE5vdGU6IFdlIGNvdWxkIGF2b2lkIHN0b3JpbmcgdGhlc2UgYnkgZG9pbmcgY29tcG9zaXRpb24gZHVyaW5nIG11bHRpcGx5XG4gIGNhbGN1bGF0ZSB0b3AgaGFsZiB1c2luZyBjb21wb3NpdGlvbiBieSBzcGVlZCBpcyBwcmVmZXJyZWQuICovXG4gIGZvcihpID0gaGFsZiArIDE7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgYyA9IG1baSBeIGhhbGZdO1xuICAgIG1baV0gPSBbbWlkWzBdIF4gY1swXSwgbWlkWzFdIF4gY1sxXSwgbWlkWzJdIF4gY1syXSwgbWlkWzNdIF4gY1szXV07XG4gIH1cbiAgcmV0dXJuIG07XG59O1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtSVYoaXYpIHtcbiAgaWYodHlwZW9mIGl2ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGNvbnZlcnQgaXYgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgfVxuXG4gIGlmKGZvcmdlLnV0aWwuaXNBcnJheShpdikgJiYgaXYubGVuZ3RoID4gNCkge1xuICAgIC8vIGNvbnZlcnQgaXYgYnl0ZSBhcnJheSBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgdmFyIHRtcCA9IGl2O1xuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBpdi5wdXRCeXRlKHRtcFtpXSk7XG4gICAgfVxuICB9XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoaXYpKSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGJ1ZmZlciBpbnRvIDMyLWJpdCBpbnRlZ2VyIGFycmF5XG4gICAgaXYgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKV07XG4gIH1cblxuICByZXR1cm4gaXY7XG59XG5cbmZ1bmN0aW9uIGluYzMyKGJsb2NrKSB7XG4gIC8vIGluY3JlbWVudCBsYXN0IDMyIGJpdHMgb2YgYmxvY2sgb25seVxuICBibG9ja1tibG9jay5sZW5ndGggLSAxXSA9IChibG9ja1tibG9jay5sZW5ndGggLSAxXSArIDEpICYgMHhGRkZGRkZGRjtcbn1cblxuZnVuY3Rpb24gZnJvbTY0VG8zMihudW0pIHtcbiAgLy8gY29udmVydCA2NC1iaXQgbnVtYmVyIHRvIHR3byBCRSBJbnQzMnNcbiAgcmV0dXJuIFsobnVtIC8gMHgxMDAwMDAwMDApIHwgMCwgbnVtICYgMHhGRkZGRkZGRl07XG59XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIERFUyAoRGF0YSBFbmNyeXB0aW9uIFN0YW5kYXJkKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIERFUyBhcyB3ZWxsIGFzIDNERVMtRURFIGluIEVDQiBhbmQgQ0JDIG1vZGUuXG4gKiBJdCBpcyBiYXNlZCBvbiB0aGUgQlNELWxpY2Vuc2VkIGltcGxlbWVudGF0aW9uIGJ5IFBhdWwgVGVybzpcbiAqXG4gKiBQYXVsIFRlcm8sIEp1bHkgMjAwMVxuICogaHR0cDovL3d3dy50ZXJvLmNvLnVrL2Rlcy9cbiAqXG4gKiBPcHRpbWlzZWQgZm9yIHBlcmZvcm1hbmNlIHdpdGggbGFyZ2UgYmxvY2tzIGJ5IE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUGFzc3dvcmQtQmFzZWQgS2V5LURlcml2YXRpb24gRnVuY3Rpb24gIzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogU2VlIFJGQyAyODk4IGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBwa2NzNSA9IGZvcmdlLnBrY3M1ID0gZm9yZ2UucGtjczUgfHwge307XG5cbnZhciBjcnlwdG87XG5pZihmb3JnZS51dGlsLmlzTm9kZWpzICYmICFmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0KSB7XG4gIGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xufVxuXG4vKipcbiAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBwIHRoZSBwYXNzd29yZCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBzIHRoZSBzYWx0IGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIGMgdGhlIGl0ZXJhdGlvbiBjb3VudCwgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRrTGVuIHRoZSBpbnRlbmRlZCBsZW5ndGgsIGluIGJ5dGVzLCBvZiB0aGUgZGVyaXZlZCBrZXksXG4gKiAgICAgICAgICAobWF4OiAyXjMyIC0gMSkgKiBoYXNoIGxlbmd0aCBvZiB0aGUgUFJGLlxuICogQHBhcmFtIFttZF0gdGhlIG1lc3NhZ2UgZGlnZXN0IChvciBhbGdvcml0aG0gaWRlbnRpZmllciBhcyBhIHN0cmluZykgdG8gdXNlXG4gKiAgICAgICAgICBpbiB0aGUgUFJGLCBkZWZhdWx0cyB0byBTSEEtMS5cbiAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBrZXkpXSBwcmVzZW5jZSB0cmlnZ2VycyBhc3luY2hyb25vdXMgdmVyc2lvbiwgY2FsbGVkXG4gKiAgICAgICAgICBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlcml2ZWQga2V5LCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcywgZm9yIHRoZVxuICogICAgICAgICAgIHN5bmNocm9ub3VzIHZlcnNpb24gKGlmIG5vIGNhbGxiYWNrIGlzIHNwZWNpZmllZCkuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGJrZGYyID0gcGtjczUucGJrZGYyID0gZnVuY3Rpb24oXG4gIHAsIHMsIGMsIGRrTGVuLCBtZCwgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG1kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZDtcbiAgICBtZCA9IG51bGw7XG4gIH1cblxuICAvLyB1c2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlmIHBvc3NpYmxlIGFuZCBub3QgZGlzYWJsZWQsIG5vdGUgdGhhdFxuICAvLyBzb21lIG5vZGUgdmVyc2lvbnMgb25seSBzdXBwb3J0IFNIQS0xLCBvdGhlcnMgYWxsb3cgZGlnZXN0IHRvIGJlIGNoYW5nZWRcbiAgaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAgIGNyeXB0by5wYmtkZjIgJiYgKG1kID09PSBudWxsIHx8IHR5cGVvZiBtZCAhPT0gJ29iamVjdCcpICYmXG4gICAgKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA+IDQgfHwgKCFtZCB8fCBtZCA9PT0gJ3NoYTEnKSkpIHtcbiAgICBpZih0eXBlb2YgbWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBkZWZhdWx0IHByZiB0byBTSEEtMVxuICAgICAgbWQgPSAnc2hhMSc7XG4gICAgfVxuICAgIHAgPSBuZXcgQnVmZmVyKHAsICdiaW5hcnknKTtcbiAgICBzID0gbmV3IEJ1ZmZlcihzLCAnYmluYXJ5Jyk7XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4sIG1kKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfVxuICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBtZCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgbWQgPSAnc2hhMSc7XG4gIH1cbiAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgIGlmKCEobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIG1kKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gIH1cblxuICB2YXIgaExlbiA9IG1kLmRpZ2VzdExlbmd0aDtcblxuICAvKiAxLiBJZiBka0xlbiA+ICgyXjMyIC0gMSkgKiBoTGVuLCBvdXRwdXQgXCJkZXJpdmVkIGtleSB0b28gbG9uZ1wiIGFuZFxuICAgIHN0b3AuICovXG4gIGlmKGRrTGVuID4gKDB4RkZGRkZGRkYgKiBoTGVuKSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Rlcml2ZWQga2V5IGlzIHRvbyBsb25nLicpO1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLyogMi4gTGV0IGxlbiBiZSB0aGUgbnVtYmVyIG9mIGhMZW4tb2N0ZXQgYmxvY2tzIGluIHRoZSBkZXJpdmVkIGtleSxcbiAgICByb3VuZGluZyB1cCwgYW5kIGxldCByIGJlIHRoZSBudW1iZXIgb2Ygb2N0ZXRzIGluIHRoZSBsYXN0XG4gICAgYmxvY2s6XG5cbiAgICBsZW4gPSBDRUlMKGRrTGVuIC8gaExlbiksXG4gICAgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbi4gKi9cbiAgdmFyIGxlbiA9IE1hdGguY2VpbChka0xlbiAvIGhMZW4pO1xuICB2YXIgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbjtcblxuICAvKiAzLiBGb3IgZWFjaCBibG9jayBvZiB0aGUgZGVyaXZlZCBrZXkgYXBwbHkgdGhlIGZ1bmN0aW9uIEYgZGVmaW5lZFxuICAgIGJlbG93IHRvIHRoZSBwYXNzd29yZCBQLCB0aGUgc2FsdCBTLCB0aGUgaXRlcmF0aW9uIGNvdW50IGMsIGFuZFxuICAgIHRoZSBibG9jayBpbmRleCB0byBjb21wdXRlIHRoZSBibG9jazpcblxuICAgIFRfMSA9IEYoUCwgUywgYywgMSksXG4gICAgVF8yID0gRihQLCBTLCBjLCAyKSxcbiAgICAuLi5cbiAgICBUX2xlbiA9IEYoUCwgUywgYywgbGVuKSxcblxuICAgIHdoZXJlIHRoZSBmdW5jdGlvbiBGIGlzIGRlZmluZWQgYXMgdGhlIGV4Y2x1c2l2ZS1vciBzdW0gb2YgdGhlXG4gICAgZmlyc3QgYyBpdGVyYXRlcyBvZiB0aGUgdW5kZXJseWluZyBwc2V1ZG9yYW5kb20gZnVuY3Rpb24gUFJGXG4gICAgYXBwbGllZCB0byB0aGUgcGFzc3dvcmQgUCBhbmQgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHNhbHQgU1xuICAgIGFuZCB0aGUgYmxvY2sgaW5kZXggaTpcblxuICAgIEYoUCwgUywgYywgaSkgPSB1XzEgWE9SIHVfMiBYT1IgLi4uIFhPUiB1X2NcblxuICAgIHdoZXJlXG5cbiAgICB1XzEgPSBQUkYoUCwgUyB8fCBJTlQoaSkpLFxuICAgIHVfMiA9IFBSRihQLCB1XzEpLFxuICAgIC4uLlxuICAgIHVfYyA9IFBSRihQLCB1X3tjLTF9KS5cblxuICAgIEhlcmUsIElOVChpKSBpcyBhIGZvdXItb2N0ZXQgZW5jb2Rpbmcgb2YgdGhlIGludGVnZXIgaSwgbW9zdFxuICAgIHNpZ25pZmljYW50IG9jdGV0IGZpcnN0LiAqL1xuICB2YXIgcHJmID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgcHJmLnN0YXJ0KG1kLCBwKTtcbiAgdmFyIGRrID0gJyc7XG4gIHZhciB4b3IsIHVfYywgdV9jMTtcblxuICAvLyBzeW5jIHZlcnNpb25cbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSBsZW47ICsraSkge1xuICAgICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZShzKTtcbiAgICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgICBmb3IodmFyIGogPSAyOyBqIDw9IGM7ICsraikge1xuICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgICB1X2MxID0gdV9jO1xuICAgICAgfVxuXG4gICAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuICAgIH1cbiAgICAvKiA1LiBPdXRwdXQgdGhlIGRlcml2ZWQga2V5IERLLiAqL1xuICAgIHJldHVybiBkaztcbiAgfVxuXG4gIC8vIGFzeW5jIHZlcnNpb25cbiAgdmFyIGkgPSAxLCBqO1xuICBmdW5jdGlvbiBvdXRlcigpIHtcbiAgICBpZihpID4gbGVuKSB7XG4gICAgICAvLyBkb25lXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGspO1xuICAgIH1cblxuICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgcHJmLnVwZGF0ZShzKTtcbiAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgaiA9IDI7XG4gICAgaW5uZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgIGlmKGogPD0gYykge1xuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICB1X2MxID0gdV9jO1xuICAgICAgKytqO1xuICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGlubmVyKTtcbiAgICB9XG5cbiAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuXG4gICAgKytpO1xuICAgIG91dGVyKCk7XG4gIH1cblxuICBvdXRlcigpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSGFzaC1iYXNlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgaW1wbGVtZW50YXRpb24uIFJlcXVpcmVzIGEgbWVzc2FnZVxuICogZGlnZXN0IG9iamVjdCB0aGF0IGNhbiBiZSBvYnRhaW5lZCwgZm9yIGV4YW1wbGUsIGZyb20gZm9yZ2UubWQuc2hhMSBvclxuICogZm9yZ2UubWQubWQ1LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vKiBITUFDIEFQSSAqL1xudmFyIGhtYWMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmhtYWMgPSBmb3JnZS5obWFjIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gSE1BQyBvYmplY3QgdGhhdCB1c2VzIHRoZSBnaXZlbiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhbiBITUFDIG9iamVjdC5cbiAqL1xuaG1hYy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdGhlIGhtYWMga2V5IHRvIHVzZVxuICB2YXIgX2tleSA9IG51bGw7XG5cbiAgLy8gdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZVxuICB2YXIgX21kID0gbnVsbDtcblxuICAvLyB0aGUgaW5uZXIgcGFkZGluZ1xuICB2YXIgX2lwYWRkaW5nID0gbnVsbDtcblxuICAvLyB0aGUgb3V0ZXIgcGFkZGluZ1xuICB2YXIgX29wYWRkaW5nID0gbnVsbDtcblxuICAvLyBobWFjIGNvbnRleHRcbiAgdmFyIGN0eCA9IHt9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIEhNQUMgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlIGRpZ2VzdC5cbiAgICpcbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIG9uZSxcbiAgICogICAgICAgICAgIGEgc3RyaW5nIHRvIHVzZSBidWlsdGluICdzaGExJywgJ21kNScsICdzaGEyNTYnLlxuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlIGFzIGEgc3RyaW5nLCBhcnJheSBvZiBieXRlcywgYnl0ZSBidWZmZXIsXG4gICAqICAgICAgICAgICBvciBudWxsIHRvIHJldXNlIHRoZSBwcmV2aW91cyBrZXkuXG4gICAqL1xuICBjdHguc3RhcnQgPSBmdW5jdGlvbihtZCwga2V5KSB7XG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIGlmKHR5cGVvZiBtZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gY3JlYXRlIGJ1aWx0aW4gbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgbWQgPSBtZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZihtZCBpbiBmb3JnZS5tZC5hbGdvcml0aG1zKSB7XG4gICAgICAgICAgX21kID0gZm9yZ2UubWQuYWxnb3JpdGhtc1ttZF0uY3JlYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtIFwiJyArIG1kICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0b3JlIG1lc3NhZ2UgZGlnZXN0XG4gICAgICAgIF9tZCA9IG1kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGtleSA9PT0gbnVsbCkge1xuICAgICAgLy8gcmV1c2UgcHJldmlvdXMga2V5XG4gICAgICBrZXkgPSBfa2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjb252ZXJ0IHN0cmluZyBpbnRvIGJ5dGUgYnVmZmVyXG4gICAgICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy8gY29udmVydCBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAgdmFyIHRtcCA9IGtleTtcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleS5wdXRCeXRlKHRtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIGxvbmdlciB0aGFuIGJsb2Nrc2l6ZSwgaGFzaCBpdFxuICAgICAgdmFyIGtleWxlbiA9IGtleS5sZW5ndGgoKTtcbiAgICAgIGlmKGtleWxlbiA+IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICBfbWQuc3RhcnQoKTtcbiAgICAgICAgX21kLnVwZGF0ZShrZXkuYnl0ZXMoKSk7XG4gICAgICAgIGtleSA9IF9tZC5kaWdlc3QoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWl4IGtleSBpbnRvIGlubmVyIGFuZCBvdXRlciBwYWRkaW5nXG4gICAgICAvLyBpcGFkZGluZyA9IFsweDM2ICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgLy8gb3BhZGRpbmcgPSBbMHg1QyAqIGJsb2Nrc2l6ZV0gXiBrZXlcbiAgICAgIF9pcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfb3BhZGRpbmcgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGtleWxlbjsgKytpKSB7XG4gICAgICAgIHZhciB0bXAgPSBrZXkuYXQoaSk7XG4gICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYgXiB0bXApO1xuICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDIF4gdG1wKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYga2V5IGlzIHNob3J0ZXIgdGhhbiBibG9ja3NpemUsIGFkZCBhZGRpdGlvbmFsIHBhZGRpbmdcbiAgICAgIGlmKGtleWxlbiA8IF9tZC5ibG9ja0xlbmd0aCkge1xuICAgICAgICB2YXIgdG1wID0gX21kLmJsb2NrTGVuZ3RoIC0ga2V5bGVuO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wOyArK2kpIHtcbiAgICAgICAgICBfaXBhZGRpbmcucHV0Qnl0ZSgweDM2KTtcbiAgICAgICAgICBfb3BhZGRpbmcucHV0Qnl0ZSgweDVDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2tleSA9IGtleTtcbiAgICAgIF9pcGFkZGluZyA9IF9pcGFkZGluZy5ieXRlcygpO1xuICAgICAgX29wYWRkaW5nID0gX29wYWRkaW5nLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcblxuICAgIC8vIHByZXBhcmUgdG8gZG8gaW5uZXIgaGFzaFxuICAgIC8vIGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKVxuICAgIF9tZC5zdGFydCgpO1xuICAgIF9tZC51cGRhdGUoX2lwYWRkaW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHVwZGF0ZSB3aXRoLlxuICAgKi9cbiAgY3R4LnVwZGF0ZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgX21kLnVwZGF0ZShieXRlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgKE1BQykuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBjdHguZ2V0TWFjID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gZGlnZXN0IGlzIGRvbmUgbGlrZSBzbzogaGFzaChvcGFkZGluZyB8IGhhc2goaXBhZGRpbmcgfCBtZXNzYWdlKSlcbiAgICAvLyBoZXJlIHdlIGRvIHRoZSBvdXRlciBoYXNoaW5nXG4gICAgdmFyIGlubmVyID0gX21kLmRpZ2VzdCgpLmJ5dGVzKCk7XG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfb3BhZGRpbmcpO1xuICAgIF9tZC51cGRhdGUoaW5uZXIpO1xuICAgIHJldHVybiBfbWQuZGlnZXN0KCk7XG4gIH07XG4gIC8vIGFsaWFzIGZvciBnZXRNYWNcbiAgY3R4LmRpZ2VzdCA9IGN0eC5nZXRNYWM7XG5cbiAgcmV0dXJuIGN0eDtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiAoaWdub3JlZCkgKi9cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDUgIFRvbSBXdVxuLy8gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuLy8gQmFzaWMgSmF2YVNjcmlwdCBCTiBsaWJyYXJ5IC0gc3Vic2V0IHVzZWZ1bCBmb3IgUlNBIGVuY3J5cHRpb24uXG5cbi8qXG5MaWNlbnNpbmcgKExJQ0VOU0UpXG4tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblRoaXMgc29mdHdhcmUgaXMgY292ZXJlZCB1bmRlciB0aGUgZm9sbG93aW5nIGNvcHlyaWdodDpcbiovXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUy1JU1wiIEFORCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUywgSU1QTElFRCBPUiBPVEhFUldJU0UsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04sIEFOWVxuICogV0FSUkFOVFkgT0YgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuICpcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRPTSBXVSBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBJTkNJREVOVEFMLFxuICogSU5ESVJFQ1QgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9GIEFOWSBLSU5ELCBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSXG4gKiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIE9SIE5PVCBBRFZJU0VEIE9GXG4gKiBUSEUgUE9TU0lCSUxJVFkgT0YgREFNQUdFLCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIEFSSVNJTkcgT1VUXG4gKiBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqIEluIGFkZGl0aW9uLCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBhcHBsaWVzOlxuICpcbiAqIEFsbCByZWRpc3RyaWJ1dGlvbnMgbXVzdCByZXRhaW4gYW4gaW50YWN0IGNvcHkgb2YgdGhpcyBjb3B5cmlnaHQgbm90aWNlXG4gKiBhbmQgZGlzY2xhaW1lci5cbiAqL1xuLypcbkFkZHJlc3MgYWxsIHF1ZXN0aW9ucyByZWdhcmRpbmcgdGhpcyBsaWNlbnNlIHRvOlxuXG4gIFRvbSBXdVxuICB0andAY3MuU3RhbmZvcmQuRURVXG4qL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5qc2JuID0gZm9yZ2UuanNibiB8fCB7fTtcblxuLy8gQml0cyBwZXIgZGlnaXRcbnZhciBkYml0cztcblxuLy8gSmF2YVNjcmlwdCBlbmdpbmUgYW5hbHlzaXNcbnZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbnZhciBqX2xtID0gKChjYW5hcnkmMHhmZmZmZmYpPT0weGVmY2FmZSk7XG5cbi8vIChwdWJsaWMpIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gIHRoaXMuZGF0YSA9IFtdO1xuICBpZihhICE9IG51bGwpXG4gICAgaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYSkgdGhpcy5mcm9tTnVtYmVyKGEsYixjKTtcbiAgICBlbHNlIGlmKGIgPT0gbnVsbCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBhKSB0aGlzLmZyb21TdHJpbmcoYSwyNTYpO1xuICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG59XG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuXG4vLyByZXR1cm4gbmV3LCB1bnNldCBCaWdJbnRlZ2VyXG5mdW5jdGlvbiBuYmkoKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihudWxsKTsgfVxuXG4vLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4vLyBjIGlzIGluaXRpYWwgY2FycnksIHJldHVybnMgZmluYWwgY2FycnkuXG4vLyBjIDwgMypkdmFsdWUsIHggPCAyKmR2YWx1ZSwgdGhpc19pIDwgZHZhbHVlXG4vLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4vLyBhbTE6IHVzZSBhIHNpbmdsZSBtdWx0IGFuZCBkaXZpZGUgdG8gZ2V0IHRoZSBoaWdoIGJpdHMsXG4vLyBtYXggZGlnaXQgYml0cyBzaG91bGQgYmUgMjYgYmVjYXVzZVxuLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuZnVuY3Rpb24gYW0xKGkseCx3LGosYyxuKSB7XG4gIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgdmFyIHYgPSB4KnRoaXMuZGF0YVtpKytdK3cuZGF0YVtqXStjO1xuICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICB3LmRhdGFbaisrXSA9IHYmMHgzZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4vLyBNYXggZGlnaXQgYml0cyBzaG91bGQgYmUgPD0gMzAgYmVjYXVzZSB3ZSBkbyBiaXR3aXNlIG9wc1xuLy8gb24gdmFsdWVzIHVwIHRvIDIqaGR2YWx1ZV4yLWhkdmFsdWUtMSAoPCAyXjMxKVxuZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHg3ZmZmLCB4aCA9IHg+PjE1O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNTtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHg3ZmZmKTw8MTUpK3cuZGF0YVtqXSsoYyYweDNmZmZmZmZmKTtcbiAgICBjID0gKGw+Pj4zMCkrKG0+Pj4xNSkreGgqaCsoYz4+PjMwKTtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIEFsdGVybmF0ZWx5LCBzZXQgbWF4IGRpZ2l0IGJpdHMgdG8gMjggc2luY2Ugc29tZVxuLy8gYnJvd3NlcnMgc2xvdyBkb3duIHdoZW4gZGVhbGluZyB3aXRoIDMyLWJpdCBudW1iZXJzLlxuZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gIHZhciB4bCA9IHgmMHgzZmZmLCB4aCA9IHg+PjE0O1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciBsID0gdGhpcy5kYXRhW2ldJjB4M2ZmZjtcbiAgICB2YXIgaCA9IHRoaXMuZGF0YVtpKytdPj4xNDtcbiAgICB2YXIgbSA9IHhoKmwraCp4bDtcbiAgICBsID0geGwqbCsoKG0mMHgzZmZmKTw8MTQpK3cuZGF0YVtqXStjO1xuICAgIGMgPSAobD4+MjgpKyhtPj4xNCkreGgqaDtcbiAgICB3LmRhdGFbaisrXSA9IGwmMHhmZmZmZmZmO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG4vLyBub2RlLmpzIChubyBicm93c2VyKVxuaWYodHlwZW9mKG5hdmlnYXRvcikgPT09ICd1bmRlZmluZWQnKVxue1xuICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gICBkYml0cyA9IDI4O1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0yO1xuICBkYml0cyA9IDMwO1xufSBlbHNlIGlmKGpfbG0gJiYgKG5hdmlnYXRvci5hcHBOYW1lICE9IFwiTmV0c2NhcGVcIikpIHtcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTE7XG4gIGRiaXRzID0gMjY7XG59IGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTM7XG4gIGRiaXRzID0gMjg7XG59XG5cbkJpZ0ludGVnZXIucHJvdG90eXBlLkRCID0gZGJpdHM7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ETSA9ICgoMTw8ZGJpdHMpLTEpO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG52YXIgQklfRlAgPSA1MjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkZWID0gTWF0aC5wb3coMixCSV9GUCk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjIgPSAyKmRiaXRzLUJJX0ZQO1xuXG4vLyBEaWdpdCBjb252ZXJzaW9uc1xudmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbnZhciBCSV9SQyA9IG5ldyBBcnJheSgpO1xudmFyIHJyLHZ2O1xucnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMDsgdnYgPD0gOTsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJhXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xucnIgPSBcIkFcIi5jaGFyQ29kZUF0KDApO1xuZm9yKHZ2ID0gMTA7IHZ2IDwgMzY7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5cbmZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuZnVuY3Rpb24gaW50QXQocyxpKSB7XG4gIHZhciBjID0gQklfUkNbcy5jaGFyQ29kZUF0KGkpXTtcbiAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjb3B5IHRoaXMgdG8gclxuZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IHRoaXMudDtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBpbnRlZ2VyIHZhbHVlIHgsIC1EViA8PSB4IDwgRFZcbmZ1bmN0aW9uIGJucEZyb21JbnQoeCkge1xuICB0aGlzLnQgPSAxO1xuICB0aGlzLnMgPSAoeDwwKT8tMTowO1xuICBpZih4ID4gMCkgdGhpcy5kYXRhWzBdID0geDtcbiAgZWxzZSBpZih4IDwgLTEpIHRoaXMuZGF0YVswXSA9IHgrdGhpcy5EVjtcbiAgZWxzZSB0aGlzLnQgPSAwO1xufVxuXG4vLyByZXR1cm4gYmlnaW50IGluaXRpYWxpemVkIHRvIHZhbHVlXG5mdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHNldCBmcm9tIHN0cmluZyBhbmQgcmFkaXhcbmZ1bmN0aW9uIGJucEZyb21TdHJpbmcocyxiKSB7XG4gIHZhciBrO1xuICBpZihiID09IDE2KSBrID0gNDtcbiAgZWxzZSBpZihiID09IDgpIGsgPSAzO1xuICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICBlbHNlIGlmKGIgPT0gMikgayA9IDE7XG4gIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgZWxzZSB7IHRoaXMuZnJvbVJhZGl4KHMsYik7IHJldHVybjsgfVxuICB0aGlzLnQgPSAwO1xuICB0aGlzLnMgPSAwO1xuICB2YXIgaSA9IHMubGVuZ3RoLCBtaSA9IGZhbHNlLCBzaCA9IDA7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgaWYoeCA8IDApIHtcbiAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiKSBtaSA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbWkgPSBmYWxzZTtcbiAgICBpZihzaCA9PSAwKVxuICAgICAgdGhpcy5kYXRhW3RoaXMudCsrXSA9IHg7XG4gICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoeCYoKDE8PCh0aGlzLkRCLXNoKSktMSkpPDxzaDtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAoeD4+KHRoaXMuREItc2gpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0geDw8c2g7XG4gICAgc2ggKz0gaztcbiAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICB9XG4gIGlmKGsgPT0gOCAmJiAoc1swXSYweDgwKSAhPSAwKSB7XG4gICAgdGhpcy5zID0gLTE7XG4gICAgaWYoc2ggPiAwKSB0aGlzLmRhdGFbdGhpcy50LTFdIHw9ICgoMTw8KHRoaXMuREItc2gpKS0xKTw8c2g7XG4gIH1cbiAgdGhpcy5jbGFtcCgpO1xuICBpZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIGNsYW1wIG9mZiBleGNlc3MgaGlnaCB3b3Jkc1xuZnVuY3Rpb24gYm5wQ2xhbXAoKSB7XG4gIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gIHdoaWxlKHRoaXMudCA+IDAgJiYgdGhpcy5kYXRhW3RoaXMudC0xXSA9PSBjKSAtLXRoaXMudDtcbn1cblxuLy8gKHB1YmxpYykgcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBpbiBnaXZlbiByYWRpeFxuZnVuY3Rpb24gYm5Ub1N0cmluZyhiKSB7XG4gIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgcmV0dXJuIHRoaXMudG9SYWRpeChiKTtcbiAgdmFyIGttID0gKDE8PGspLTEsIGQsIG0gPSBmYWxzZSwgciA9IFwiXCIsIGkgPSB0aGlzLnQ7XG4gIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICBpZihpLS0gPiAwKSB7XG4gICAgaWYocCA8IHRoaXMuREIgJiYgKGQgPSB0aGlzLmRhdGFbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICBpZihwIDwgaykge1xuICAgICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KGstcCk7XG4gICAgICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT1rKSkma207XG4gICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgfVxuICAgICAgaWYoZCA+IDApIG0gPSB0cnVlO1xuICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG0/cjpcIjBcIjtcbn1cblxuLy8gKHB1YmxpYykgLXRoaXNcbmZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuLy8gKHB1YmxpYykgfHRoaXN8XG5mdW5jdGlvbiBibkFicygpIHsgcmV0dXJuICh0aGlzLnM8MCk/dGhpcy5uZWdhdGUoKTp0aGlzOyB9XG5cbi8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG5mdW5jdGlvbiBibkNvbXBhcmVUbyhhKSB7XG4gIHZhciByID0gdGhpcy5zLWEucztcbiAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgdmFyIGkgPSB0aGlzLnQ7XG4gIHIgPSBpLWEudDtcbiAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICB3aGlsZSgtLWkgPj0gMCkgaWYoKHI9dGhpcy5kYXRhW2ldLWEuZGF0YVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gIHJldHVybiAwO1xufVxuXG4vLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuZnVuY3Rpb24gbmJpdHMoeCkge1xuICB2YXIgciA9IDEsIHQ7XG4gIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICBpZigodD14Pj44KSAhPSAwKSB7IHggPSB0OyByICs9IDg7IH1cbiAgaWYoKHQ9eD4+NCkgIT0gMCkgeyB4ID0gdDsgciArPSA0OyB9XG4gIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICBpZigodD14Pj4xKSAhPSAwKSB7IHggPSB0OyByICs9IDE7IH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gXCJ0aGlzXCJcbmZ1bmN0aW9uIGJuQml0TGVuZ3RoKCkge1xuICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiB0aGlzLkRCKih0aGlzLnQtMSkrbmJpdHModGhpcy5kYXRhW3RoaXMudC0xXV4odGhpcy5zJnRoaXMuRE0pKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgbipEQlxuZnVuY3Rpb24gYm5wRExTaGlmdFRvKG4scikge1xuICB2YXIgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpK25dID0gdGhpcy5kYXRhW2ldO1xuICBmb3IoaSA9IG4tMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIudCA9IHRoaXMudCtuO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbmZ1bmN0aW9uIGJucERSU2hpZnRUbyhuLHIpIHtcbiAgZm9yKHZhciBpID0gbjsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaS1uXSA9IHRoaXMuZGF0YVtpXTtcbiAgci50ID0gTWF0aC5tYXgodGhpcy50LW4sMCk7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPDwgblxuZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKSwgYyA9ICh0aGlzLnM8PGJzKSZ0aGlzLkRNLCBpO1xuICBmb3IoaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkge1xuICAgIHIuZGF0YVtpK2RzKzFdID0gKHRoaXMuZGF0YVtpXT4+Y2JzKXxjO1xuICAgIGMgPSAodGhpcy5kYXRhW2ldJmJtKTw8YnM7XG4gIH1cbiAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gMDtcbiAgci5kYXRhW2RzXSA9IGM7XG4gIHIudCA9IHRoaXMudCtkcysxO1xuICByLnMgPSB0aGlzLnM7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgPj4gblxuZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gIHIucyA9IHRoaXMucztcbiAgdmFyIGRzID0gTWF0aC5mbG9vcihuL3RoaXMuREIpO1xuICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gIHZhciBicyA9IG4ldGhpcy5EQjtcbiAgdmFyIGNicyA9IHRoaXMuREItYnM7XG4gIHZhciBibSA9ICgxPDxicyktMTtcbiAgci5kYXRhWzBdID0gdGhpcy5kYXRhW2RzXT4+YnM7XG4gIGZvcih2YXIgaSA9IGRzKzE7IGkgPCB0aGlzLnQ7ICsraSkge1xuICAgIHIuZGF0YVtpLWRzLTFdIHw9ICh0aGlzLmRhdGFbaV0mYm0pPDxjYnM7XG4gICAgci5kYXRhW2ktZHNdID0gdGhpcy5kYXRhW2ldPj5icztcbiAgfVxuICBpZihicyA+IDApIHIuZGF0YVt0aGlzLnQtZHMtMV0gfD0gKHRoaXMucyZibSk8PGNicztcbiAgci50ID0gdGhpcy50LWRzO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gIHZhciBpID0gMCwgYyA9IDAsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbiAgd2hpbGUoaSA8IG0pIHtcbiAgICBjICs9IHRoaXMuZGF0YVtpXS1hLmRhdGFbaV07XG4gICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgYyA+Pj0gdGhpcy5EQjtcbiAgfVxuICBpZihhLnQgPCB0aGlzLnQpIHtcbiAgICBjIC09IGEucztcbiAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICBjICs9IHRoaXMuZGF0YVtpXTtcbiAgICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICB9XG4gICAgYyArPSB0aGlzLnM7XG4gIH0gZWxzZSB7XG4gICAgYyArPSB0aGlzLnM7XG4gICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgYyAtPSBhLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgLT0gYS5zO1xuICB9XG4gIHIucyA9IChjPDApPy0xOjA7XG4gIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG4gIGVsc2UgaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbiAgci50ID0gaTtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAqIGEsIHIgIT0gdGhpcyxhIChIQUMgMTQuMTIpXG4vLyBcInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCksIHkgPSBhLmFicygpO1xuICB2YXIgaSA9IHgudDtcbiAgci50ID0gaSt5LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgci5kYXRhW2kreC50XSA9IHguYW0oMCx5LmRhdGFbaV0scixpLDAseC50KTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xuICBpZih0aGlzLnMgIT0gYS5zKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXNeMiwgciAhPSB0aGlzIChIQUMgMTQuMTYpXG5mdW5jdGlvbiBibnBTcXVhcmVUbyhyKSB7XG4gIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgdmFyIGkgPSByLnQgPSAyKngudDtcbiAgd2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG4gIGZvcihpID0gMDsgaSA8IHgudC0xOyArK2kpIHtcbiAgICB2YXIgYyA9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgICBpZigoci5kYXRhW2kreC50XSs9eC5hbShpKzEsMip4LmRhdGFbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICByLmRhdGFbaSt4LnRdIC09IHguRFY7XG4gICAgICByLmRhdGFbaSt4LnQrMV0gPSAxO1xuICAgIH1cbiAgfVxuICBpZihyLnQgPiAwKSByLmRhdGFbci50LTFdICs9IHguYW0oaSx4LmRhdGFbaV0sciwyKmksMCwxKTtcbiAgci5zID0gMDtcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBkaXZpZGUgdGhpcyBieSBtLCBxdW90aWVudCBhbmQgcmVtYWluZGVyIHRvIHEsIHIgKEhBQyAxNC4yMClcbi8vIHIgIT0gcSwgdGhpcyAhPSBtLiAgcSBvciByIG1heSBiZSBudWxsLlxuZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgdmFyIHBtID0gbS5hYnMoKTtcbiAgaWYocG0udCA8PSAwKSByZXR1cm47XG4gIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gIGlmKHB0LnQgPCBwbS50KSB7XG4gICAgaWYocSAhPSBudWxsKSBxLmZyb21JbnQoMCk7XG4gICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gIHZhciB5ID0gbmJpKCksIHRzID0gdGhpcy5zLCBtcyA9IG0ucztcbiAgdmFyIG5zaCA9IHRoaXMuREItbmJpdHMocG0uZGF0YVtwbS50LTFdKTtcdC8vIG5vcm1hbGl6ZSBtb2R1bHVzXG4gIGlmKG5zaCA+IDApIHsgcG0ubFNoaWZ0VG8obnNoLHkpOyBwdC5sU2hpZnRUbyhuc2gscik7IH0gZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gIHZhciB5cyA9IHkudDtcbiAgdmFyIHkwID0geS5kYXRhW3lzLTFdO1xuICBpZih5MCA9PSAwKSByZXR1cm47XG4gIHZhciB5dCA9IHkwKigxPDx0aGlzLkYxKSsoKHlzPjEpP3kuZGF0YVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgdmFyIGQxID0gdGhpcy5GVi95dCwgZDIgPSAoMTw8dGhpcy5GMSkveXQsIGUgPSAxPDx0aGlzLkYyO1xuICB2YXIgaSA9IHIudCwgaiA9IGkteXMsIHQgPSAocT09bnVsbCk/bmJpKCk6cTtcbiAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgaWYoci5jb21wYXJlVG8odCkgPj0gMCkge1xuICAgIHIuZGF0YVtyLnQrK10gPSAxO1xuICAgIHIuc3ViVG8odCxyKTtcbiAgfVxuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gIHQuc3ViVG8oeSx5KTtcdC8vIFwibmVnYXRpdmVcIiB5IHNvIHdlIGNhbiByZXBsYWNlIHN1YiB3aXRoIGFtIGxhdGVyXG4gIHdoaWxlKHkudCA8IHlzKSB5LmRhdGFbeS50KytdID0gMDtcbiAgd2hpbGUoLS1qID49IDApIHtcbiAgICAvLyBFc3RpbWF0ZSBxdW90aWVudCBkaWdpdFxuICAgIHZhciBxZCA9IChyLmRhdGFbLS1pXT09eTApP3RoaXMuRE06TWF0aC5mbG9vcihyLmRhdGFbaV0qZDErKHIuZGF0YVtpLTFdK2UpKmQyKTtcbiAgICBpZigoci5kYXRhW2ldKz15LmFtKDAscWQscixqLDAseXMpKSA8IHFkKSB7XHQvLyBUcnkgaXQgb3V0XG4gICAgICB5LmRsU2hpZnRUbyhqLHQpO1xuICAgICAgci5zdWJUbyh0LHIpO1xuICAgICAgd2hpbGUoci5kYXRhW2ldIDwgLS1xZCkgci5zdWJUbyh0LHIpO1xuICAgIH1cbiAgfVxuICBpZihxICE9IG51bGwpIHtcbiAgICByLmRyU2hpZnRUbyh5cyxxKTtcbiAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gIH1cbiAgci50ID0geXM7XG4gIHIuY2xhbXAoKTtcbiAgaWYobnNoID4gMCkgci5yU2hpZnRUbyhuc2gscik7XHQvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgaWYodHMgPCAwKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8ocixyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuZnVuY3Rpb24gYm5Nb2QoYSkge1xuICB2YXIgciA9IG5iaSgpO1xuICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgaWYodGhpcy5zIDwgMCAmJiByLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLlpFUk8pID4gMCkgYS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gTW9kdWxhciByZWR1Y3Rpb24gdXNpbmcgXCJjbGFzc2ljXCIgYWxnb3JpdGhtXG5mdW5jdGlvbiBDbGFzc2ljKG0pIHsgdGhpcy5tID0gbTsgfVxuZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG4gIGVsc2UgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBjUmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIGNSZWR1Y2UoeCkgeyB4LmRpdlJlbVRvKHRoaXMubSxudWxsLHgpOyB9XG5mdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5mdW5jdGlvbiBjU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbkNsYXNzaWMucHJvdG90eXBlLmNvbnZlcnQgPSBjQ29udmVydDtcbkNsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZWR1Y2UgPSBjUmVkdWNlO1xuQ2xhc3NpYy5wcm90b3R5cGUubXVsVG8gPSBjTXVsVG87XG5DbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuLy8gKHByb3RlY3RlZCkgcmV0dXJuIFwiLTEvdGhpcyAlIDJeREJcIjsgdXNlZnVsIGZvciBNb250LiByZWR1Y3Rpb25cbi8vIGp1c3RpZmljYXRpb246XG4vLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuLy8gICAgICAgICB4eSA9ICAxK2ttXG4vLyAgIHh5KDIteHkpID0gKDEra20pKDEta20pXG4vLyB4W3koMi14eSldID0gMS1rXjJtXjJcbi8vIHhbeSgyLXh5KV0gPT0gMSAobW9kIG1eMilcbi8vIGlmIHkgaXMgMS94IG1vZCBtLCB0aGVuIHkoMi14eSkgaXMgMS94IG1vZCBtXjJcbi8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuLy8gSlMgbXVsdGlwbHkgXCJvdmVyZmxvd3NcIiBkaWZmZXJlbnRseSBmcm9tIEMvQysrLCBzbyBjYXJlIGlzIG5lZWRlZCBoZXJlLlxuZnVuY3Rpb24gYm5wSW52RGlnaXQoKSB7XG4gIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICB2YXIgeCA9IHRoaXMuZGF0YVswXTtcbiAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gIHZhciB5ID0geCYzO1x0XHQvLyB5ID09IDEveCBtb2QgMl4yXG4gIHkgPSAoeSooMi0oeCYweGYpKnkpKSYweGY7XHQvLyB5ID09IDEveCBtb2QgMl40XG4gIHkgPSAoeSooMi0oeCYweGZmKSp5KSkmMHhmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgeSA9ICh5KigyLSgoKHgmMHhmZmZmKSp5KSYweGZmZmYpKSkmMHhmZmZmO1x0Ly8geSA9PSAxL3ggbW9kIDJeMTZcbiAgLy8gbGFzdCBzdGVwIC0gY2FsY3VsYXRlIGludmVyc2UgbW9kIERWIGRpcmVjdGx5O1xuICAvLyBhc3N1bWVzIDE2IDwgREIgPD0gMzIgYW5kIGFzc3VtZXMgYWJpbGl0eSB0byBoYW5kbGUgNDgtYml0IGludHNcbiAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjtcdFx0Ly8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgLy8gd2UgcmVhbGx5IHdhbnQgdGhlIG5lZ2F0aXZlIGludmVyc2UsIGFuZCAtRFYgPCB5IDwgRFZcbiAgcmV0dXJuICh5PjApP3RoaXMuRFYteToteTtcbn1cblxuLy8gTW9udGdvbWVyeSByZWR1Y3Rpb25cbmZ1bmN0aW9uIE1vbnRnb21lcnkobSkge1xuICB0aGlzLm0gPSBtO1xuICB0aGlzLm1wID0gbS5pbnZEaWdpdCgpO1xuICB0aGlzLm1wbCA9IHRoaXMubXAmMHg3ZmZmO1xuICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICB0aGlzLnVtID0gKDE8PChtLkRCLTE1KSktMTtcbiAgdGhpcy5tdDIgPSAyKm0udDtcbn1cblxuLy8geFIgbW9kIG1cbmZ1bmN0aW9uIG1vbnRDb252ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQscik7XG4gIHIuZGl2UmVtVG8odGhpcy5tLG51bGwscik7XG4gIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geC9SIG1vZCBtXG5mdW5jdGlvbiBtb250UmV2ZXJ0KHgpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgeC5jb3B5VG8ocik7XG4gIHRoaXMucmVkdWNlKHIpO1xuICByZXR1cm4gcjtcbn1cblxuLy8geCA9IHgvUiBtb2QgbSAoSEFDIDE0LjMyKVxuZnVuY3Rpb24gbW9udFJlZHVjZSh4KSB7XG4gIHdoaWxlKHgudCA8PSB0aGlzLm10MilcdC8vIHBhZCB4IHNvIGFtIGhhcyBlbm91Z2ggcm9vbSBsYXRlclxuICAgIHguZGF0YVt4LnQrK10gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5tLnQ7ICsraSkge1xuICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4LmRhdGFbaV0qbXAgbW9kIERWXG4gICAgdmFyIGogPSB4LmRhdGFbaV0mMHg3ZmZmO1xuICAgIHZhciB1MCA9IChqKnRoaXMubXBsKygoKGoqdGhpcy5tcGgrKHguZGF0YVtpXT4+MTUpKnRoaXMubXBsKSZ0aGlzLnVtKTw8MTUpKSZ4LkRNO1xuICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgIGogPSBpK3RoaXMubS50O1xuICAgIHguZGF0YVtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgLy8gcHJvcGFnYXRlIGNhcnJ5XG4gICAgd2hpbGUoeC5kYXRhW2pdID49IHguRFYpIHsgeC5kYXRhW2pdIC09IHguRFY7IHguZGF0YVsrK2pdKys7IH1cbiAgfVxuICB4LmNsYW1wKCk7XG4gIHguZHJTaGlmdFRvKHRoaXMubS50LHgpO1xuICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0gXCJ4XjIvUiBtb2QgbVwiOyB4ICE9IHJcbmZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IFwieHkvUiBtb2QgbVwiOyB4LHkgIT0gclxuZnVuY3Rpb24gbW9udE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5Nb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5yZXZlcnQgPSBtb250UmV2ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmVkdWNlID0gbW9udFJlZHVjZTtcbk1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuTW9udGdvbWVyeS5wcm90b3R5cGUuc3FyVG8gPSBtb250U3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHRydWUgaWZmIHRoaXMgaXMgZXZlblxuZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXMuZGF0YVswXSYxKTp0aGlzLnMpID09IDA7IH1cblxuLy8gKHByb3RlY3RlZCkgdGhpc15lLCBlIDwgMl4zMiwgZG9pbmcgc3FyIGFuZCBtdWwgd2l0aCBcInJcIiAoSEFDIDE0Ljc5KVxuZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICBpZihlID4gMHhmZmZmZmZmZiB8fCBlIDwgMSkgcmV0dXJuIEJpZ0ludGVnZXIuT05FO1xuICB2YXIgciA9IG5iaSgpLCByMiA9IG5iaSgpLCBnID0gei5jb252ZXJ0KHRoaXMpLCBpID0gbmJpdHMoZSktMTtcbiAgZy5jb3B5VG8ocik7XG4gIHdoaWxlKC0taSA+PSAwKSB7XG4gICAgei5zcXJUbyhyLHIyKTtcbiAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgIGVsc2UgeyB2YXIgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gIH1cbiAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xufVxuXG4vLyAocHVibGljKSB0aGlzXmUgJSBtLCAwIDw9IGUgPCAyXjMyXG5mdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgdmFyIHo7XG4gIGlmKGUgPCAyNTYgfHwgbS5pc0V2ZW4oKSkgeiA9IG5ldyBDbGFzc2ljKG0pOyBlbHNlIHogPSBuZXcgTW9udGdvbWVyeShtKTtcbiAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG59XG5cbi8vIHByb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbUludCA9IGJucEZyb21JbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gYm5wRnJvbVN0cmluZztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kbFNoaWZ0VG8gPSBibnBETFNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kclNoaWZ0VG8gPSBibnBEUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuclNoaWZ0VG8gPSBibnBSU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnN1YlRvID0gYm5wU3ViVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZVRvID0gYm5wU3F1YXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZSZW1UbyA9IGJucERpdlJlbVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbiA9IGJucElzRXZlbjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmV4cCA9IGJucEV4cDtcblxuLy8gcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGJuVG9TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBibk5lZ2F0ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gYm5Db21wYXJlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGggPSBibkJpdExlbmd0aDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93SW50ID0gYm5Nb2RQb3dJbnQ7XG5cbi8vIFwiY29uc3RhbnRzXCJcbkJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbkJpZ0ludGVnZXIuT05FID0gbmJ2KDEpO1xuXG4vLyBqc2JuMiBsaWJcblxuLy9Db3B5cmlnaHQgKGMpIDIwMDUtMjAwOSAgVG9tIFd1XG4vL0FsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1NlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscyAoU2VlIGpzYm4uanMgZm9yIExJQ0VOU0UpLlxuXG4vL0V4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4vL1ZlcnNpb24gMS4xOiBuZXcgQmlnSW50ZWdlcihcIjBcIiwgMTApIHJldHVybnMgXCJwcm9wZXJcIiB6ZXJvXG5cbi8vKHB1YmxpYylcbmZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBpbnRlZ2VyXG5mdW5jdGlvbiBibkludFZhbHVlKCkge1xuaWYodGhpcy5zIDwgMCkge1xuIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdLXRoaXMuRFY7XG4gZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xufSBlbHNlIGlmKHRoaXMudCA9PSAxKSByZXR1cm4gdGhpcy5kYXRhWzBdO1xuZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIDA7XG4vLyBhc3N1bWVzIDE2IDwgREIgPCAzMlxucmV0dXJuICgodGhpcy5kYXRhWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXMuZGF0YVswXTtcbn1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgYnl0ZVxuZnVuY3Rpb24gYm5CeXRlVmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MjQpPj4yNDsgfVxuXG4vLyhwdWJsaWMpIHJldHVybiB2YWx1ZSBhcyBzaG9ydCAoYXNzdW1lcyBEQj49MTYpXG5mdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXMuZGF0YVswXTw8MTYpPj4xNjsgfVxuXG4vLyhwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbmZ1bmN0aW9uIGJucENodW5rU2l6ZShyKSB7IHJldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2cocikpOyB9XG5cbi8vKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbmZ1bmN0aW9uIGJuU2lnTnVtKCkge1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIC0xO1xuZWxzZSBpZih0aGlzLnQgPD0gMCB8fCAodGhpcy50ID09IDEgJiYgdGhpcy5kYXRhWzBdIDw9IDApKSByZXR1cm4gMDtcbmVsc2UgcmV0dXJuIDE7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCB0byByYWRpeCBzdHJpbmdcbmZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG5pZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBhID0gTWF0aC5wb3coYixjcyk7XG52YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xudGhpcy5kaXZSZW1UbyhkLHkseik7XG53aGlsZSh5LnNpZ251bSgpID4gMCkge1xuIHIgPSAoYSt6LmludFZhbHVlKCkpLnRvU3RyaW5nKGIpLnN1YnN0cigxKSArIHI7XG4geS5kaXZSZW1UbyhkLHkseik7XG59XG5yZXR1cm4gei5pbnRWYWx1ZSgpLnRvU3RyaW5nKGIpICsgcjtcbn1cblxuLy8ocHJvdGVjdGVkKSBjb252ZXJ0IGZyb20gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG50aGlzLmZyb21JbnQoMCk7XG5pZihiID09IG51bGwpIGIgPSAxMDtcbnZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xudmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiB2YXIgeCA9IGludEF0KHMsaSk7XG4gaWYoeCA8IDApIHtcbiAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgY29udGludWU7XG4gfVxuIHcgPSBiKncreDtcbiBpZigrK2ogPj0gY3MpIHtcbiAgIHRoaXMuZE11bHRpcGx5KGQpO1xuICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICBqID0gMDtcbiAgIHcgPSAwO1xuIH1cbn1cbmlmKGogPiAwKSB7XG4gdGhpcy5kTXVsdGlwbHkoTWF0aC5wb3coYixqKSk7XG4gdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG59XG5pZihtaSkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMsdGhpcyk7XG59XG5cbi8vKHByb3RlY3RlZCkgYWx0ZXJuYXRlIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG5pZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LGludCxSTkcpXG4gaWYoYSA8IDIpIHRoaXMuZnJvbUludCgxKTtcbiBlbHNlIHtcbiAgIHRoaXMuZnJvbU51bWJlcihhLGMpO1xuICAgaWYoIXRoaXMudGVzdEJpdChhLTEpKSAgLy8gZm9yY2UgTVNCIHNldFxuICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgIGlmKHRoaXMuaXNFdmVuKCkpIHRoaXMuZEFkZE9mZnNldCgxLDApOyAvLyBmb3JjZSBvZGRcbiAgIHdoaWxlKCF0aGlzLmlzUHJvYmFibGVQcmltZShiKSkge1xuICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgaWYodGhpcy5iaXRMZW5ndGgoKSA+IGEpIHRoaXMuc3ViVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksdGhpcyk7XG4gICB9XG4gfVxufSBlbHNlIHtcbiAvLyBuZXcgQmlnSW50ZWdlcihpbnQsUk5HKVxuIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4geC5sZW5ndGggPSAoYT4+MykrMTtcbiBiLm5leHRCeXRlcyh4KTtcbiBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuIHRoaXMuZnJvbVN0cmluZyh4LDI1Nik7XG59XG59XG5cbi8vKHB1YmxpYykgY29udmVydCB0byBiaWdlbmRpYW4gYnl0ZSBhcnJheVxuZnVuY3Rpb24gYm5Ub0J5dGVBcnJheSgpIHtcbnZhciBpID0gdGhpcy50LCByID0gbmV3IEFycmF5KCk7XG5yWzBdID0gdGhpcy5zO1xudmFyIHAgPSB0aGlzLkRCLShpKnRoaXMuREIpJTgsIGQsIGsgPSAwO1xuaWYoaS0tID4gMCkge1xuIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSAhPSAodGhpcy5zJnRoaXMuRE0pPj5wKVxuICAgcltrKytdID0gZHwodGhpcy5zPDwodGhpcy5EQi1wKSk7XG4gd2hpbGUoaSA+PSAwKSB7XG4gICBpZihwIDwgOCkge1xuICAgICBkID0gKHRoaXMuZGF0YVtpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgIGQgfD0gdGhpcy5kYXRhWy0taV0+PihwKz10aGlzLkRCLTgpO1xuICAgfSBlbHNlIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0+PihwLT04KSkmMHhmZjtcbiAgICAgaWYocCA8PSAwKSB7IHAgKz0gdGhpcy5EQjsgLS1pOyB9XG4gICB9XG4gICBpZigoZCYweDgwKSAhPSAwKSBkIHw9IC0yNTY7XG4gICBpZihrID09IDAgJiYgKHRoaXMucyYweDgwKSAhPSAoZCYweDgwKSkgKytrO1xuICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gfVxufVxucmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuZnVuY3Rpb24gYm5NaW4oYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk8MCk/dGhpczphOyB9XG5mdW5jdGlvbiBibk1heChhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT4wKT90aGlzOmE7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyBvcCBhIChiaXR3aXNlKVxuZnVuY3Rpb24gYm5wQml0d2lzZVRvKGEsb3Ascikge1xudmFyIGksIGYsIG0gPSBNYXRoLm1pbihhLnQsdGhpcy50KTtcbmZvcihpID0gMDsgaSA8IG07ICsraSkgci5kYXRhW2ldID0gb3AodGhpcy5kYXRhW2ldLGEuZGF0YVtpXSk7XG5pZihhLnQgPCB0aGlzLnQpIHtcbiBmID0gYS5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgdGhpcy50OyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxmKTtcbiByLnQgPSB0aGlzLnQ7XG59IGVsc2Uge1xuIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiBmb3IoaSA9IG07IGkgPCBhLnQ7ICsraSkgci5kYXRhW2ldID0gb3AoZixhLmRhdGFbaV0pO1xuIHIudCA9IGEudDtcbn1cbnIucyA9IG9wKHRoaXMucyxhLnMpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgJiBhXG5mdW5jdGlvbiBvcF9hbmQoeCx5KSB7IHJldHVybiB4Jnk7IH1cbmZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyB8IGFcbmZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG5mdW5jdGlvbiBibk9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9vcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIF4gYVxuZnVuY3Rpb24gb3BfeG9yKHgseSkgeyByZXR1cm4geF55OyB9XG5mdW5jdGlvbiBiblhvcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfeG9yLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+YVxuZnVuY3Rpb24gb3BfYW5kbm90KHgseSkgeyByZXR1cm4geCZ+eTsgfVxuZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB+dGhpc1xuZnVuY3Rpb24gYm5Ob3QoKSB7XG52YXIgciA9IG5iaSgpO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSB0aGlzLkRNJn50aGlzLmRhdGFbaV07XG5yLnQgPSB0aGlzLnQ7XG5yLnMgPSB+dGhpcy5zO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA8PCBuXG5mdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG52YXIgciA9IG5iaSgpO1xuaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdGhpcyA+PiBuXG5mdW5jdGlvbiBiblNoaWZ0UmlnaHQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLmxTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMuclNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vL3JldHVybiBpbmRleCBvZiBsb3dlc3QgMS1iaXQgaW4geCwgeCA8IDJeMzFcbmZ1bmN0aW9uIGxiaXQoeCkge1xuaWYoeCA9PSAwKSByZXR1cm4gLTE7XG52YXIgciA9IDA7XG5pZigoeCYweGZmZmYpID09IDApIHsgeCA+Pj0gMTY7IHIgKz0gMTY7IH1cbmlmKCh4JjB4ZmYpID09IDApIHsgeCA+Pj0gODsgciArPSA4OyB9XG5pZigoeCYweGYpID09IDApIHsgeCA+Pj0gNDsgciArPSA0OyB9XG5pZigoeCYzKSA9PSAwKSB7IHggPj49IDI7IHIgKz0gMjsgfVxuaWYoKHgmMSkgPT0gMCkgKytyO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJucyBpbmRleCBvZiBsb3dlc3QgMS1iaXQgKG9yIC0xIGlmIG5vbmUpXG5mdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiBpZih0aGlzLmRhdGFbaV0gIT0gMCkgcmV0dXJuIGkqdGhpcy5EQitsYml0KHRoaXMuZGF0YVtpXSk7XG5pZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG5yZXR1cm4gLTE7XG59XG5cbi8vcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuZnVuY3Rpb24gY2JpdCh4KSB7XG52YXIgciA9IDA7XG53aGlsZSh4ICE9IDApIHsgeCAmPSB4LTE7ICsrcjsgfVxucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIG51bWJlciBvZiBzZXQgYml0c1xuZnVuY3Rpb24gYm5CaXRDb3VudCgpIHtcbnZhciByID0gMCwgeCA9IHRoaXMucyZ0aGlzLkRNO1xuZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByICs9IGNiaXQodGhpcy5kYXRhW2ldXngpO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbmZ1bmN0aW9uIGJuVGVzdEJpdChuKSB7XG52YXIgaiA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbmlmKGogPj0gdGhpcy50KSByZXR1cm4odGhpcy5zIT0wKTtcbnJldHVybigodGhpcy5kYXRhW2pdJigxPDwobiV0aGlzLkRCKSkpIT0wKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzIG9wICgxPDxuKVxuZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbnZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xudGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgfCAoMTw8bilcbmZ1bmN0aW9uIGJuU2V0Qml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3Bfb3IpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbmZ1bmN0aW9uIGJuQ2xlYXJCaXQobikgeyByZXR1cm4gdGhpcy5jaGFuZ2VCaXQobixvcF9hbmRub3QpOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuZnVuY3Rpb24gYm5GbGlwQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfeG9yKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuZnVuY3Rpb24gYm5wQWRkVG8oYSxyKSB7XG52YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG53aGlsZShpIDwgbSkge1xuIGMgKz0gdGhpcy5kYXRhW2ldK2EuZGF0YVtpXTtcbiByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiBjID4+PSB0aGlzLkRCO1xufVxuaWYoYS50IDwgdGhpcy50KSB7XG4gYyArPSBhLnM7XG4gd2hpbGUoaSA8IHRoaXMudCkge1xuICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gdGhpcy5zO1xufSBlbHNlIHtcbiBjICs9IHRoaXMucztcbiB3aGlsZShpIDwgYS50KSB7XG4gICBjICs9IGEuZGF0YVtpXTtcbiAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgYyA+Pj0gdGhpcy5EQjtcbiB9XG4gYyArPSBhLnM7XG59XG5yLnMgPSAoYzwwKT8tMTowO1xuaWYoYyA+IDApIHIuZGF0YVtpKytdID0gYztcbmVsc2UgaWYoYyA8IC0xKSByLmRhdGFbaSsrXSA9IHRoaXMuRFYrYztcbnIudCA9IGk7XG5yLmNsYW1wKCk7XG59XG5cbi8vKHB1YmxpYykgdGhpcyArIGFcbmZ1bmN0aW9uIGJuQWRkKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5hZGRUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLSBhXG5mdW5jdGlvbiBiblN1YnRyYWN0KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5zdWJUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgKiBhXG5mdW5jdGlvbiBibk11bHRpcGx5KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5tdWx0aXBseVRvKGEscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAvIGFcbmZ1bmN0aW9uIGJuRGl2aWRlKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLHIsbnVsbCk7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyAlIGFcbmZ1bmN0aW9uIGJuUmVtYWluZGVyKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5kaXZSZW1UbyhhLG51bGwscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG5mdW5jdGlvbiBibkRpdmlkZUFuZFJlbWFpbmRlcihhKSB7XG52YXIgcSA9IG5iaSgpLCByID0gbmJpKCk7XG50aGlzLmRpdlJlbVRvKGEscSxyKTtcbnJldHVybiBuZXcgQXJyYXkocSxyKTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICo9IG4sIHRoaXMgPj0gMCwgMSA8IG4gPCBEVlxuZnVuY3Rpb24gYm5wRE11bHRpcGx5KG4pIHtcbnRoaXMuZGF0YVt0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuKyt0aGlzLnQ7XG50aGlzLmNsYW1wKCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuZnVuY3Rpb24gYm5wREFkZE9mZnNldChuLHcpIHtcbmlmKG4gPT0gMCkgcmV0dXJuO1xud2hpbGUodGhpcy50IDw9IHcpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xudGhpcy5kYXRhW3ddICs9IG47XG53aGlsZSh0aGlzLmRhdGFbd10gPj0gdGhpcy5EVikge1xuIHRoaXMuZGF0YVt3XSAtPSB0aGlzLkRWO1xuIGlmKCsrdyA+PSB0aGlzLnQpIHRoaXMuZGF0YVt0aGlzLnQrK10gPSAwO1xuICsrdGhpcy5kYXRhW3ddO1xufVxufVxuXG4vL0EgXCJudWxsXCIgcmVkdWNlclxuZnVuY3Rpb24gTnVsbEV4cCgpIHt9XG5mdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbmZ1bmN0aW9uIG5NdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgfVxuZnVuY3Rpb24gblNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB9XG5cbk51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuTnVsbEV4cC5wcm90b3R5cGUucmV2ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLm11bFRvID0gbk11bFRvO1xuTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lXG5mdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IGxvd2VyIG4gd29yZHMgb2YgXCJ0aGlzICogYVwiLCBhLnQgPD0gblxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseUxvd2VyVG8oYSxuLHIpIHtcbnZhciBpID0gTWF0aC5taW4odGhpcy50K2EudCxuKTtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbnIudCA9IGk7XG53aGlsZShpID4gMCkgci5kYXRhWy0taV0gPSAwO1xudmFyIGo7XG5mb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHIuZGF0YVtpK3RoaXMudF0gPSB0aGlzLmFtKDAsYS5kYXRhW2ldLHIsaSwwLHRoaXMudCk7XG5mb3IoaiA9IE1hdGgubWluKGEudCxuKTsgaSA8IGo7ICsraSkgdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCxuLWkpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuLy9cInRoaXNcIiBzaG91bGQgYmUgdGhlIGxhcmdlciBvbmUgaWYgYXBwcm9wcmlhdGUuXG5mdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbi0tbjtcbnZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxud2hpbGUoLS1pID49IDApIHIuZGF0YVtpXSA9IDA7XG5mb3IoaSA9IE1hdGgubWF4KG4tdGhpcy50LDApOyBpIDwgYS50OyArK2kpXG4gci5kYXRhW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYS5kYXRhW2ldLHIsMCwwLHRoaXMudCtpLW4pO1xuci5jbGFtcCgpO1xuci5kclNoaWZ0VG8oMSxyKTtcbn1cblxuLy9CYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbi8vIHNldHVwIEJhcnJldHRcbnRoaXMucjIgPSBuYmkoKTtcbnRoaXMucTMgPSBuYmkoKTtcbkJpZ0ludGVnZXIuT05FLmRsU2hpZnRUbygyKm0udCx0aGlzLnIyKTtcbnRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbnRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbmlmKHgucyA8IDAgfHwgeC50ID4gMip0aGlzLm0udCkgcmV0dXJuIHgubW9kKHRoaXMubSk7XG5lbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbmVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vL3ggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbnguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG5pZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxudGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xudGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG53aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xueC5zdWJUbyh0aGlzLnIyLHgpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy9yID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy9yID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vKHB1YmxpYykgdGhpc15lICUgbSAoSEFDIDE0Ljg1KVxuZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG52YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG5pZihpIDw9IDApIHJldHVybiByO1xuZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbmVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG5lbHNlIGsgPSA2O1xuaWYoaSA8IDgpXG4geiA9IG5ldyBDbGFzc2ljKG0pO1xuZWxzZSBpZihtLmlzRXZlbigpKVxuIHogPSBuZXcgQmFycmV0dChtKTtcbmVsc2VcbiB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbi8vIHByZWNvbXB1dGF0aW9uXG52YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG5nWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuaWYoayA+IDEpIHtcbiB2YXIgZzIgPSBuYmkoKTtcbiB6LnNxclRvKGdbMV0sZzIpO1xuIHdoaWxlKG4gPD0ga20pIHtcbiAgIGdbbl0gPSBuYmkoKTtcbiAgIHoubXVsVG8oZzIsZ1tuLTJdLGdbbl0pO1xuICAgbiArPSAyO1xuIH1cbn1cblxudmFyIGogPSBlLnQtMSwgdywgaXMxID0gdHJ1ZSwgcjIgPSBuYmkoKSwgdDtcbmkgPSBuYml0cyhlLmRhdGFbal0pLTE7XG53aGlsZShqID49IDApIHtcbiBpZihpID49IGsxKSB3ID0gKGUuZGF0YVtqXT4+KGktazEpKSZrbTtcbiBlbHNlIHtcbiAgIHcgPSAoZS5kYXRhW2pdJigoMTw8KGkrMSkpLTEpKTw8KGsxLWkpO1xuICAgaWYoaiA+IDApIHcgfD0gZS5kYXRhW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuIH1cblxuIG4gPSBrO1xuIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gaWYoKGkgLT0gbikgPCAwKSB7IGkgKz0gdGhpcy5EQjsgLS1qOyB9XG4gaWYoaXMxKSB7ICAvLyByZXQgPT0gMSwgZG9uJ3QgYm90aGVyIHNxdWFyaW5nIG9yIG11bHRpcGx5aW5nIGl0XG4gICBnW3ddLmNvcHlUbyhyKTtcbiAgIGlzMSA9IGZhbHNlO1xuIH0gZWxzZSB7XG4gICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgIGlmKG4gPiAwKSB6LnNxclRvKHIscjIpOyBlbHNlIHsgdCA9IHI7IHIgPSByMjsgcjIgPSB0OyB9XG4gICB6Lm11bFRvKHIyLGdbd10scik7XG4gfVxuXG4gd2hpbGUoaiA+PSAwICYmIChlLmRhdGFbal0mKDE8PGkpKSA9PSAwKSB7XG4gICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICBpZigtLWkgPCAwKSB7IGkgPSB0aGlzLkRCLTE7IC0tajsgfVxuIH1cbn1cbnJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8ocHVibGljKSBnY2QodGhpcyxhKSAoSEFDIDE0LjU0KVxuZnVuY3Rpb24gYm5HQ0QoYSkge1xudmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xudmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG52YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuaWYoZyA8IDApIHJldHVybiB4O1xuaWYoaSA8IGcpIGcgPSBpO1xuaWYoZyA+IDApIHtcbiB4LnJTaGlmdFRvKGcseCk7XG4geS5yU2hpZnRUbyhnLHkpO1xufVxud2hpbGUoeC5zaWdudW0oKSA+IDApIHtcbiBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuIGlmKChpID0geS5nZXRMb3dlc3RTZXRCaXQoKSkgPiAwKSB5LnJTaGlmdFRvKGkseSk7XG4gaWYoeC5jb21wYXJlVG8oeSkgPj0gMCkge1xuICAgeC5zdWJUbyh5LHgpO1xuICAgeC5yU2hpZnRUbygxLHgpO1xuIH0gZWxzZSB7XG4gICB5LnN1YlRvKHgseSk7XG4gICB5LnJTaGlmdFRvKDEseSk7XG4gfVxufVxuaWYoZyA+IDApIHkubFNoaWZ0VG8oZyx5KTtcbnJldHVybiB5O1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgJSBuLCBuIDwgMl4yNlxuZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbmlmKG4gPD0gMCkgcmV0dXJuIDA7XG52YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG5pZih0aGlzLnQgPiAwKVxuIGlmKGQgPT0gMCkgciA9IHRoaXMuZGF0YVswXSVuO1xuIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzLmRhdGFbaV0pJW47XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSAxL3RoaXMgJSBtIChIQUMgMTQuNjEpXG5mdW5jdGlvbiBibk1vZEludmVyc2UobSkge1xudmFyIGFjID0gbS5pc0V2ZW4oKTtcbmlmKCh0aGlzLmlzRXZlbigpICYmIGFjKSB8fCBtLnNpZ251bSgpID09IDApIHJldHVybiBCaWdJbnRlZ2VyLlpFUk87XG52YXIgdSA9IG0uY2xvbmUoKSwgdiA9IHRoaXMuY2xvbmUoKTtcbnZhciBhID0gbmJ2KDEpLCBiID0gbmJ2KDApLCBjID0gbmJ2KDApLCBkID0gbmJ2KDEpO1xud2hpbGUodS5zaWdudW0oKSAhPSAwKSB7XG4gd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgdS5yU2hpZnRUbygxLHUpO1xuICAgaWYoYWMpIHtcbiAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgYS5yU2hpZnRUbygxLGEpO1xuICAgfSBlbHNlIGlmKCFiLmlzRXZlbigpKSBiLnN1YlRvKG0sYik7XG4gICBiLnJTaGlmdFRvKDEsYik7XG4gfVxuIHdoaWxlKHYuaXNFdmVuKCkpIHtcbiAgIHYuclNoaWZ0VG8oMSx2KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFjLmlzRXZlbigpIHx8ICFkLmlzRXZlbigpKSB7IGMuYWRkVG8odGhpcyxjKTsgZC5zdWJUbyhtLGQpOyB9XG4gICAgIGMuclNoaWZ0VG8oMSxjKTtcbiAgIH0gZWxzZSBpZighZC5pc0V2ZW4oKSkgZC5zdWJUbyhtLGQpO1xuICAgZC5yU2hpZnRUbygxLGQpO1xuIH1cbiBpZih1LmNvbXBhcmVUbyh2KSA+PSAwKSB7XG4gICB1LnN1YlRvKHYsdSk7XG4gICBpZihhYykgYS5zdWJUbyhjLGEpO1xuICAgYi5zdWJUbyhkLGIpO1xuIH0gZWxzZSB7XG4gICB2LnN1YlRvKHUsdik7XG4gICBpZihhYykgYy5zdWJUbyhhLGMpO1xuICAgZC5zdWJUbyhiLGQpO1xuIH1cbn1cbmlmKHYuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xuaWYoZC5jb21wYXJlVG8obSkgPj0gMCkgcmV0dXJuIGQuc3VidHJhY3QobSk7XG5pZihkLnNpZ251bSgpIDwgMCkgZC5hZGRUbyhtLGQpOyBlbHNlIHJldHVybiBkO1xuaWYoZC5zaWdudW0oKSA8IDApIHJldHVybiBkLmFkZChtKTsgZWxzZSByZXR1cm4gZDtcbn1cblxudmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5XTtcbnZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbi8vKHB1YmxpYykgdGVzdCBwcmltYWxpdHkgd2l0aCBjZXJ0YWludHkgPj0gMS0uNV50XG5mdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG52YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG5pZih4LnQgPT0gMSAmJiB4LmRhdGFbMF0gPD0gbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV0pIHtcbiBmb3IoaSA9IDA7IGkgPCBsb3dwcmltZXMubGVuZ3RoOyArK2kpXG4gICBpZih4LmRhdGFbMF0gPT0gbG93cHJpbWVzW2ldKSByZXR1cm4gdHJ1ZTtcbiByZXR1cm4gZmFsc2U7XG59XG5pZih4LmlzRXZlbigpKSByZXR1cm4gZmFsc2U7XG5pID0gMTtcbndoaWxlKGkgPCBsb3dwcmltZXMubGVuZ3RoKSB7XG4gdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gd2hpbGUoaiA8IGxvd3ByaW1lcy5sZW5ndGggJiYgbSA8IGxwbGltKSBtICo9IGxvd3ByaW1lc1tqKytdO1xuIG0gPSB4Lm1vZEludChtKTtcbiB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG59XG5yZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuZnVuY3Rpb24gYm5wTWlsbGVyUmFiaW4odCkge1xudmFyIG4xID0gdGhpcy5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG52YXIgayA9IG4xLmdldExvd2VzdFNldEJpdCgpO1xuaWYoayA8PSAwKSByZXR1cm4gZmFsc2U7XG52YXIgciA9IG4xLnNoaWZ0UmlnaHQoayk7XG52YXIgcHJuZyA9IGJuR2V0UHJuZygpO1xudmFyIGE7XG5mb3IodmFyIGkgPSAwOyBpIDwgdDsgKytpKSB7XG4gLy8gc2VsZWN0IHdpdG5lc3MgJ2EnIGF0IHJhbmRvbSBmcm9tIGJldHdlZW4gMSBhbmQgbjFcbiBkbyB7XG4gICBhID0gbmV3IEJpZ0ludGVnZXIodGhpcy5iaXRMZW5ndGgoKSwgcHJuZyk7XG4gfVxuIHdoaWxlKGEuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8PSAwIHx8IGEuY29tcGFyZVRvKG4xKSA+PSAwKTtcbiB2YXIgeSA9IGEubW9kUG93KHIsdGhpcyk7XG4gaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgIHZhciBqID0gMTtcbiAgIHdoaWxlKGorKyA8IGsgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICB9XG4gICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuIH1cbn1cbnJldHVybiB0cnVlO1xufVxuXG4vLyBnZXQgcHNldWRvIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5mdW5jdGlvbiBibkdldFBybmcoKSB7XG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgcmV0dXJuIHtcbiAgICAvLyB4IGlzIGFuIGFycmF5IHRvIGZpbGwgd2l0aCBieXRlc1xuICAgIG5leHRCeXRlczogZnVuY3Rpb24oeCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MDEwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL3Byb3RlY3RlZFxuQmlnSW50ZWdlci5wcm90b3R5cGUuY2h1bmtTaXplID0gYm5wQ2h1bmtTaXplO1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tUmFkaXggPSBibnBGcm9tUmFkaXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mcm9tTnVtYmVyID0gYm5wRnJvbU51bWJlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNoYW5nZUJpdCA9IGJucENoYW5nZUJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZFRvID0gYm5wQWRkVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kQWRkT2Zmc2V0ID0gYm5wREFkZE9mZnNldDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5TG93ZXJUbyA9IGJucE11bHRpcGx5TG93ZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludCA9IGJucE1vZEludDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbGxlclJhYmluID0gYm5wTWlsbGVyUmFiaW47XG5cbi8vcHVibGljXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbG9uZSA9IGJuQ2xvbmU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ieXRlVmFsdWUgPSBibkJ5dGVWYWx1ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNob3J0VmFsdWUgPSBiblNob3J0VmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gYm5Ub0J5dGVBcnJheTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IGJuRXF1YWxzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tYXggPSBibk1heDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFuZCA9IGJuQW5kO1xuQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUueG9yID0gYm5Yb3I7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmROb3QgPSBibkFuZE5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gYm5TaGlmdExlZnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gYm5TaGlmdFJpZ2h0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRDb3VudCA9IGJuQml0Q291bnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50ZXN0Qml0ID0gYm5UZXN0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGVhckJpdCA9IGJuQ2xlYXJCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5mbGlwQml0ID0gYm5GbGlwQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGJuU3VidHJhY3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseSA9IGJuTXVsdGlwbHk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IGJuUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlQW5kUmVtYWluZGVyID0gYm5EaXZpZGVBbmRSZW1haW5kZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBibk1vZEludmVyc2U7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBiblBvdztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lID0gYm5Jc1Byb2JhYmxlUHJpbWU7XG5cbi8vQmlnSW50ZWdlciBpbnRlcmZhY2VzIG5vdCBpbXBsZW1lbnRlZCBpbiBqc2JuOlxuXG4vL0JpZ0ludGVnZXIoaW50IHNpZ251bSwgYnl0ZVtdIG1hZ25pdHVkZSlcbi8vZG91YmxlIGRvdWJsZVZhbHVlKClcbi8vZmxvYXQgZmxvYXRWYWx1ZSgpXG4vL2ludCBoYXNoQ29kZSgpXG4vL2xvbmcgbG9uZ1ZhbHVlKClcbi8vc3RhdGljIEJpZ0ludGVnZXIgdmFsdWVPZihsb25nIHZhbClcblxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMTYwLWJpdCBkaWdlc3QgKFNIQS0xKSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHNoYTEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuZm9yZ2UubWQuc2hhMSA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMSA9IHNoYTE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0xIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGExLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMSBzdGF0ZSBjb250YWlucyBmaXZlIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGExJyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2LFxuICAgICAgaDQ6IDB4QzNEMkUxRjBcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgIC8qKlxuICAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICAqXG4gICAgKiBAcmV0dXJuIGEgYnl0ZSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0IHZhbHVlLlxuICAgICovXG4gICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTEgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNFxuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMSBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTEgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA4MCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0xIGFsZ29yaXRobVxuICAgIC8vIGFuZCBmb3IgMzItNzkgdXNpbmcgTWF4IExvY2t0eXVraGluJ3Mgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCAyMDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDQwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAzXG4gICAgZm9yKDsgaSA8IDYwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDhGMUJCQ0RDICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweENBNjJDMUQ2ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgWC41MDkgYW5kIHJlbGF0ZWQgY29tcG9uZW50cyAoc3VjaCBhc1xuICogQ2VydGlmaWNhdGlvbiBTaWduaW5nIFJlcXVlc3RzKSBvZiBhIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIGNlcnRpZmljYXRlIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDIDI0NTkpOlxuICpcbiAqIENlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHRic0NlcnRpZmljYXRlICAgICAgIFRCU0NlcnRpZmljYXRlLFxuICogICBzaWduYXR1cmVBbGdvcml0aG0gICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzaWduYXR1cmVWYWx1ZSAgICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVEJTQ2VydGlmaWNhdGUgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgIFswXSAgRVhQTElDSVQgVmVyc2lvbiBERUZBVUxUIHYxLFxuICogICBzZXJpYWxOdW1iZXIgICAgICAgICBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlcixcbiAqICAgc2lnbmF0dXJlICAgICAgICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgaXNzdWVyICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgdmFsaWRpdHkgICAgICAgICAgICAgVmFsaWRpdHksXG4gKiAgIHN1YmplY3QgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXlJbmZvIFN1YmplY3RQdWJsaWNLZXlJbmZvLFxuICogICBpc3N1ZXJVbmlxdWVJRCAgWzFdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIHN1YmplY3RVbmlxdWVJRCBbMl0gIElNUExJQ0lUIFVuaXF1ZUlkZW50aWZpZXIgT1BUSU9OQUwsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIC0tIElmIHByZXNlbnQsIHZlcnNpb24gc2hhbGwgYmUgdjIgb3IgdjNcbiAqICAgZXh0ZW5zaW9ucyAgICAgIFszXSAgRVhQTElDSVQgRXh0ZW5zaW9ucyBPUFRJT05BTFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYzXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUiAgeyB2MSgwKSwgdjIoMSksIHYzKDIpIH1cbiAqXG4gKiBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlciA6Oj0gSU5URUdFUlxuICpcbiAqIE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIC8vIG9ubHkgb25lIHBvc3NpYmxlIGNob2ljZSBmb3Igbm93XG4gKiAgIFJETlNlcXVlbmNlXG4gKiB9XG4gKlxuICogUkROU2VxdWVuY2UgOjo9IFNFUVVFTkNFIE9GIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqXG4gKiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIDo6PSBTRVQgT0YgQXR0cmlidXRlVHlwZUFuZFZhbHVlXG4gKlxuICogQXR0cmlidXRlVHlwZUFuZFZhbHVlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICAgIEF0dHJpYnV0ZVR5cGUsXG4gKiAgIHZhbHVlICAgIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKiBBdHRyaWJ1dGVUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWSBERUZJTkVEIEJZIEF0dHJpYnV0ZVR5cGVcbiAqXG4gKiBWYWxpZGl0eSA6Oj0gU0VRVUVOQ0Uge1xuICogICBub3RCZWZvcmUgICAgICBUaW1lLFxuICogICBub3RBZnRlciAgICAgICBUaW1lXG4gKiB9XG4gKlxuICogVGltZSA6Oj0gQ0hPSUNFIHtcbiAqICAgdXRjVGltZSAgICAgICAgVVRDVGltZSxcbiAqICAgZ2VuZXJhbFRpbWUgICAgR2VuZXJhbGl6ZWRUaW1lXG4gKiB9XG4gKlxuICogVW5pcXVlSWRlbnRpZmllciA6Oj0gQklUIFNUUklOR1xuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBFeHRlbnNpb25zIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEV4dGVuc2lvblxuICpcbiAqIEV4dGVuc2lvbiA6Oj0gU0VRVUVOQ0Uge1xuICogICBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBUaGUgb25seSBrZXkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogUlNBU1NBLVBTUyBzaWduYXR1cmVzIGFyZSBkZXNjcmliZWQgaW4gUkZDIDM0NDcgYW5kIFJGQyA0MDU1LlxuICpcbiAqIFBLQ1MjMTAgdjEuNyBkZXNjcmliZXMgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0czpcbiAqXG4gKiBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm86XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgSU5URUdFUiB7IHYxKDApIH0gKHYxLC4uLiksXG4gKiAgIHN1YmplY3QgICAgICAgTmFtZSxcbiAqICAgc3ViamVjdFBLSW5mbyBTdWJqZWN0UHVibGljS2V5SW5mb3t7IFBLSW5mb0FsZ29yaXRobXMgfX0sXG4gKiAgIGF0dHJpYnV0ZXMgICAgWzBdIEF0dHJpYnV0ZXN7eyBDUklBdHRyaWJ1dGVzIH19XG4gKiB9XG4gKlxuICogQXR0cmlidXRlcyB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVQgT0YgQXR0cmlidXRle3sgSU9TZXQgfX1cbiAqXG4gKiBDUklBdHRyaWJ1dGVzICBBVFRSSUJVVEUgIDo6PSB7XG4gKiAgIC4uLiAtLSBhZGQgYW55IGxvY2FsbHkgZGVmaW5lZCBhdHRyaWJ1dGVzIGhlcmUgLS0gfVxuICpcbiAqIEF0dHJpYnV0ZSB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICBBVFRSSUJVVEUuJmlkKHtJT1NldH0pLFxuICogICB2YWx1ZXMgU0VUIFNJWkUoMS4uTUFYKSBPRiBBVFRSSUJVVEUuJlR5cGUoe0lPU2V0fXtAdHlwZX0pXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3QgOjo9IFNFUVVFTkNFIHtcbiAqICAgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXJ7eyBTaWduYXR1cmVBbGdvcml0aG1zIH19LFxuICogICBzaWduYXR1cmUgICAgICAgICAgQklUIFNUUklOR1xuICogfVxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gc2hvcnQgbmFtZSBPSUQgbWFwcGluZ3NcbnZhciBfc2hvcnROYW1lcyA9IHt9O1xuX3Nob3J0TmFtZXNbJ0NOJ10gPSBvaWRzWydjb21tb25OYW1lJ107XG5fc2hvcnROYW1lc1snY29tbW9uTmFtZSddID0gJ0NOJztcbl9zaG9ydE5hbWVzWydDJ10gPSBvaWRzWydjb3VudHJ5TmFtZSddO1xuX3Nob3J0TmFtZXNbJ2NvdW50cnlOYW1lJ10gPSAnQyc7XG5fc2hvcnROYW1lc1snTCddID0gb2lkc1snbG9jYWxpdHlOYW1lJ107XG5fc2hvcnROYW1lc1snbG9jYWxpdHlOYW1lJ10gPSAnTCc7XG5fc2hvcnROYW1lc1snU1QnXSA9IG9pZHNbJ3N0YXRlT3JQcm92aW5jZU5hbWUnXTtcbl9zaG9ydE5hbWVzWydzdGF0ZU9yUHJvdmluY2VOYW1lJ10gPSAnU1QnO1xuX3Nob3J0TmFtZXNbJ08nXSA9IG9pZHNbJ29yZ2FuaXphdGlvbk5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25OYW1lJ10gPSAnTyc7XG5fc2hvcnROYW1lc1snT1UnXSA9IG9pZHNbJ29yZ2FuaXphdGlvbmFsVW5pdE5hbWUnXTtcbl9zaG9ydE5hbWVzWydvcmdhbml6YXRpb25hbFVuaXROYW1lJ10gPSAnT1UnO1xuX3Nob3J0TmFtZXNbJ0UnXSA9IG9pZHNbJ2VtYWlsQWRkcmVzcyddO1xuX3Nob3J0TmFtZXNbJ2VtYWlsQWRkcmVzcyddID0gJ0UnO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yO1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFguNTA5djMgY2VydGlmaWNhdGVcbnZhciB4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0ZScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAndGJzQ2VydGlmaWNhdGUnLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDAsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uLmludGVnZXInLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmVyc2lvbidcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNlcmlhbE51bWJlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjZXJ0U2VyaWFsTnVtYmVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRpbmZvU2lnbmF0dXJlT2lkJ1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlQXNuMTogJ2NlcnRpbmZvU2lnbmF0dXJlUGFyYW1zJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0SXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIC8vIE5vdGU6IFVUQyBhbmQgZ2VuZXJhbGl6ZWQgdGltZXMgbWF5IGJvdGggYXBwZWFyIHNvIHRoZSBjYXB0dXJlXG4gICAgICAvLyBuYW1lcyBhcmUgYmFzZWQgb24gdGhlaXIgZGV0ZWN0ZWQgb3JkZXIsIHRoZSBuYW1lcyB1c2VkIGJlbG93XG4gICAgICAvLyBhcmUgb25seSBmb3IgdGhlIGNvbW1vbiBjYXNlLCB3aGljaCB2YWxpZGl0eSB0aW1lIHJlYWxseSBtZWFuc1xuICAgICAgLy8gXCJub3RCZWZvcmVcIiBhbmQgd2hpY2ggbWVhbnMgXCJub3RBZnRlclwiIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBvcmRlclxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKFVUQyB0aW1lIGNhc2UpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKHV0YyknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MVVUQ1RpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKGdlbmVyYWxpemVkIHRpbWUgY2FzZSlcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAoZ2VuZXJhbGl6ZWQpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyICh1dGMpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTNVVENUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U3ViamVjdCdcbiAgICB9LFxuICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICB7XG4gICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0SXNzdWVyVW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAyLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTdWJqZWN0VW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDMsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydEV4dGVuc2lvbnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U2lnbmF0dXJlUGFyYW1zJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTaWduYXR1cmUnXG4gIH1dXG59O1xuXG52YXIgcnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAncnNhcHNzJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnaGFzaE9pZCdcbiAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ21hc2tHZW5PaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuSGFzaE9pZCdcbiAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGgnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMixcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdzYWx0TGVuZ3RoJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnRyYWlsZXJGaWVsZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAzLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyLnRyYWlsZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3RyYWlsZXInXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmVyc2lvbidcbiAgfSwge1xuICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0J1xuICB9LFxuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gIHtcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnR5cGUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudmFsdWUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlXG4gICAgICB9XVxuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3Qgc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjc3InLFxuICB2YWx1ZTogW1xuICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciwge1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdjc3JTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjc3JTaWduYXR1cmVQYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIHNpZ25hdHVyZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjc3JTaWduYXR1cmUnXG4gIH1dXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJETlNlcXVlbmNlIG9mIEFTTi4xIERFUi1lbmNvZGVkIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqIHNldHMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHJkbiB0aGUgUkROU2VxdWVuY2UgdG8gY29udmVydC5cbiAqIEBwYXJhbSBtZCBhIG1lc3NhZ2UgZGlnZXN0IHRvIGFwcGVuZCB0eXBlIGFuZCB2YWx1ZSB0byBpZiBwcm92aWRlZC5cbiAqL1xucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24ocmRuLCBtZCkge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ3JkbicgaW4gaXMgYSBTRVQgb2YgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICB2YXIgc2V0LCBhdHRyLCBvYmo7XG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IHJkbi52YWx1ZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAvLyBnZXQgdGhlIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgc2V0ID0gcmRuLnZhbHVlW3NpXTtcblxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIFNFVCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgc2VxdWVuY2VcbiAgICAvLyBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIGEgdmFsdWUgKGRlZmluZWQgYnlcbiAgICAvLyB0aGUgT0lEKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXQudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9iaiA9IHt9O1xuICAgICAgYXR0ciA9IHNldC52YWx1ZVtpXTtcbiAgICAgIG9iai50eXBlID0gYXNuMS5kZXJUb09pZChhdHRyLnZhbHVlWzBdLnZhbHVlKTtcbiAgICAgIG9iai52YWx1ZSA9IGF0dHIudmFsdWVbMV0udmFsdWU7XG4gICAgICBvYmoudmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVbMV0udHlwZTtcbiAgICAgIC8vIGlmIHRoZSBPSUQgaXMga25vd24sIGdldCBpdHMgbmFtZSBhbmQgc2hvcnQgbmFtZVxuICAgICAgaWYob2JqLnR5cGUgaW4gb2lkcykge1xuICAgICAgICBvYmoubmFtZSA9IG9pZHNbb2JqLnR5cGVdO1xuICAgICAgICBpZihvYmoubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICAgIG9iai5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1tvYmoubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kKSB7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudHlwZSk7XG4gICAgICAgIG1kLnVwZGF0ZShvYmoudmFsdWUpO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIEFTTi4xIENSSUF0dHJpYnV0ZXMgaW50byBhbiBhcnJheSB3aXRoIG9iamVjdHMgdGhhdCBoYXZlIHR5cGUgYW5kXG4gKiB2YWx1ZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIHRoZSBDUklBdHRyaWJ1dGVzIHRvIGNvbnZlcnQuXG4gKi9cbnBraS5DUklBdHRyaWJ1dGVzQXNBcnJheSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBlYWNoIHZhbHVlIGluICdhdHRyaWJ1dGVzJyBpbiBpcyBhIFNFUVVFTkNFIHdpdGggYW4gT0lEIGFuZCBhIFNFVFxuICBmb3IodmFyIHNpID0gMDsgc2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgYXR0cmlidXRlIHNlcXVlbmNlXG4gICAgdmFyIHNlcSA9IGF0dHJpYnV0ZXNbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VRVUVOQ0UgY29udGFpbmluZyBmaXJzdCBhIHR5cGUgKGFuIE9JRCkgYW5kXG4gICAgLy8gc2Vjb25kIGEgc2V0IG9mIHZhbHVlcyAoZGVmaW5lZCBieSB0aGUgT0lEKVxuICAgIHZhciB0eXBlID0gYXNuMS5kZXJUb09pZChzZXEudmFsdWVbMF0udmFsdWUpO1xuICAgIHZhciB2YWx1ZXMgPSBzZXEudmFsdWVbMV0udmFsdWU7XG4gICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgdmFsdWVzLmxlbmd0aDsgKyt2aSkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xuICAgICAgb2JqLnZhbHVlID0gdmFsdWVzW3ZpXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gdmFsdWVzW3ZpXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcGFyc2UgZXh0ZW5zaW9uc1xuICAgICAgaWYob2JqLnR5cGUgPT09IG9pZHMuZXh0ZW5zaW9uUmVxdWVzdCkge1xuICAgICAgICBvYmouZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBvYmoudmFsdWUubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgb2JqLmV4dGVuc2lvbnMucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShvYmoudmFsdWVbZWldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaChvYmopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGFuIGlzc3VlciBvciBzdWJqZWN0IGF0dHJpYnV0ZSBmcm9tIGl0cyBuYW1lLCB0eXBlLCBvciBzaG9ydCBuYW1lLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGlzc3VlciBvciBzdWJqZWN0IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIGEgc2hvcnQgbmFtZSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICBzaG9ydE5hbWUgdGhlIHNob3J0IG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIGZvciB0aGUgYXR0cmlidXRlLlxuICogICAgICAgICAgdHlwZSB0aGUgdHlwZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUob2JqLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7c2hvcnROYW1lOiBvcHRpb25zfTtcbiAgfVxuXG4gIHZhciBydmFsID0gbnVsbDtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IG9iai5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IG9iai5hdHRyaWJ1dGVzW2ldO1xuICAgIGlmKG9wdGlvbnMudHlwZSAmJiBvcHRpb25zLnR5cGUgPT09IGF0dHIudHlwZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMubmFtZSAmJiBvcHRpb25zLm5hbWUgPT09IGF0dHIubmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfSBlbHNlIGlmKG9wdGlvbnMuc2hvcnROYW1lICYmIG9wdGlvbnMuc2hvcnROYW1lID09PSBhdHRyLnNob3J0TmFtZSkge1xuICAgICAgcnZhbCA9IGF0dHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGZyb20gQVNOLjEgc3RydWN0dXJlLlxuICpcbiAqIEN1cnJlbnRseSBvbmx5IFJTQVNTQS1QU1Mgc3VwcG9ydGVkLiAgVGhlIFBLQ1MjMSB2MS41IHNpZ25hdHVyZSBzY2hlbWUgaGFkXG4gKiBubyBwYXJhbWV0ZXJzLlxuICpcbiAqIFJTQVNTQS1QU1MtcGFyYW1zICA6Oj0gIFNFUVVFTkNFICB7XG4gKiAgIGhhc2hBbGdvcml0aG0gICAgICBbMF0gSGFzaEFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhMUlkZW50aWZpZXIsXG4gKiAgIG1hc2tHZW5BbGdvcml0aG0gICBbMV0gTWFza0dlbkFsZ29yaXRobSBERUZBVUxUXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWdmMVNIQTFJZGVudGlmaWVyLFxuICogICBzYWx0TGVuZ3RoICAgICAgICAgWzJdIElOVEVHRVIgREVGQVVMVCAyMCxcbiAqICAgdHJhaWxlckZpZWxkICAgICAgIFszXSBJTlRFR0VSIERFRkFVTFQgMVxuICogfVxuICpcbiAqIEhhc2hBbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIE1hc2tHZW5BbGdvcml0aG0gIDo6PSAgQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQHBhcmFtIG9pZCBUaGUgT0lEIHNwZWNpZnlpbmcgdGhlIHNpZ25hdHVyZSBhbGdvcml0aG1cbiAqIEBwYXJhbSBvYmogVGhlIEFTTi4xIHN0cnVjdHVyZSBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gZmlsbERlZmF1bHRzIFdoZXRoZXIgdG8gdXNlIHJldHVybiBkZWZhdWx0IHZhbHVlcyB3aGVyZSBvbWl0dGVkXG4gKiBAcmV0dXJuIHNpZ25hdHVyZSBwYXJhbWV0ZXIgb2JqZWN0XG4gKi9cbnZhciBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihvaWQsIG9iaiwgZmlsbERlZmF1bHRzKSB7XG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBpZihvaWQgIT09IG9pZHNbJ1JTQVNTQS1QU1MnXSkge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICBpZihmaWxsRGVmYXVsdHMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snc2hhMSddXG4gICAgICB9LFxuICAgICAgbWdmOiB7XG4gICAgICAgIGFsZ29yaXRobU9pZDogb2lkc1snbWdmMSddLFxuICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNhbHRMZW5ndGg6IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2Fzc2FQc3NQYXJhbWV0ZXJWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFJTQVNTQS1QU1MgcGFyYW1ldGVyIGJsb2NrLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuaGFzaE9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLmhhc2ggPSBwYXJhbXMuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuaGFzaE9pZCk7XG4gIH1cblxuICBpZihjYXB0dXJlLm1hc2tHZW5PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHBhcmFtcy5tZ2YgPSBwYXJhbXMubWdmIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5PaWQpO1xuICAgIHBhcmFtcy5tZ2YuaGFzaCA9IHBhcmFtcy5tZ2YuaGFzaCB8fCB7fTtcbiAgICBwYXJhbXMubWdmLmhhc2guYWxnb3JpdGhtT2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLm1hc2tHZW5IYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLnNhbHRMZW5ndGggPSBjYXB0dXJlLnNhbHRMZW5ndGguY2hhckNvZGVBdCgwKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5IGNlcnRpZmljYXRlIGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWQgYmFja1xuICogdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY2VydGlmaWNhdGVGcm9tUGVtID0gZnVuY3Rpb24ocGVtLCBjb21wdXRlSGFzaCwgc3RyaWN0KSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1g1MDkgQ0VSVElGSUNBVEUnICYmXG4gICAgbXNnLnR5cGUgIT09ICdUUlVTVEVEIENFUlRJRklDQVRFJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGUgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSAnICtcbiAgICAgICdpcyBub3QgXCJDRVJUSUZJQ0FURVwiLCBcIlg1MDkgQ0VSVElGSUNBVEVcIiwgb3IgXCJUUlVTVEVEIENFUlRJRklDQVRFXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBjZXJ0aWZpY2F0ZSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ1BVQkxJQyBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBVQkxJQyBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyICcgK1xuICAgICAgJ3R5cGUgaXMgbm90IFwiUFVCTElDIEtFWVwiIG9yIFwiUlNBIFBVQkxJQyBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcGtpLnB1YmxpY0tleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGEgU3ViamVjdFB1YmxpY0tleUluZm8pLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHB1YmxpYyBrZXkgdG8gUEVNIGZvcm1hdCAodXNpbmcgYW4gUlNBUHVibGljS2V5KS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFVCTElDIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBmaW5nZXJwcmludCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW21kXSB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gKiAgICAgICAgICBbdHlwZV0gdGhlIHR5cGUgb2YgZmluZ2VycHJpbnQsIHN1Y2ggYXMgJ1JTQVB1YmxpY0tleScsXG4gKiAgICAgICAgICAgICdTdWJqZWN0UHVibGljS2V5SW5mbycgKGRlZmF1bHRzIHRvICdSU0FQdWJsaWNLZXknKS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IGVuY29kaW5nLCBzdWNoIGFzICdoZXgnXG4gKiAgICAgICAgICAgIChkZWZhdWx0cyB0byBub25lLCBvdXRwdXRzIGEgYnl0ZSBidWZmZXIpLlxuICogICAgICAgICAgW2RlbGltaXRlcl0gdGhlIGRlbGltaXRlciB0byB1c2UgYmV0d2VlbiBieXRlcyBmb3IgJ2hleCcgZW5jb2RlZFxuICogICAgICAgICAgICBvdXRwdXQsIGVnOiAnOicgKGRlZmF1bHRzIHRvIG5vbmUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbmdlcnByaW50IGFzIGEgYnl0ZSBidWZmZXIgb3Igb3RoZXIgZW5jb2RpbmcgYmFzZWQgb24gb3B0aW9ucy5cbiAqL1xucGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50ID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWQgPSBvcHRpb25zLm1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8ICdSU0FQdWJsaWNLZXknO1xuXG4gIHZhciBieXRlcztcbiAgc3dpdGNoKHR5cGUpIHtcbiAgY2FzZSAnUlNBUHVibGljS2V5JzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGtleSkpLmdldEJ5dGVzKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1N1YmplY3RQdWJsaWNLZXlJbmZvJzpcbiAgICBieXRlcyA9IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaW5nZXJwcmludCB0eXBlIFwiJyArIG9wdGlvbnMudHlwZSArICdcIi4nKTtcbiAgfVxuXG4gIC8vIGhhc2ggcHVibGljIGtleSBieXRlc1xuICBtZC5zdGFydCgpO1xuICBtZC51cGRhdGUoYnl0ZXMpO1xuICB2YXIgZGlnZXN0ID0gbWQuZGlnZXN0KCk7XG4gIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgdmFyIGhleCA9IGRpZ2VzdC50b0hleCgpO1xuICAgIGlmKG9wdGlvbnMuZGVsaW1pdGVyKSB7XG4gICAgICByZXR1cm4gaGV4Lm1hdGNoKC8uezJ9L2cpLmpvaW4ob3B0aW9ucy5kZWxpbWl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9IGVsc2UgaWYob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICByZXR1cm4gZGlnZXN0LmdldEJ5dGVzKCk7XG4gIH0gZWxzZSBpZihvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIFwiJyArIG9wdGlvbnMuZW5jb2RpbmcgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIGRpZ2VzdDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgc2NhbiB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2ZcbiAqIHRoZSBBU04uMSBvYmplY3Qgd2hpbGUgaXQgaXMgY29udmVydGVkIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBjb252ZXJ0ZWRcbiAqIGJhY2sgdG8gQVNOLjEtREVSLWVuY29kaW5nIGxhdGVyLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgQVNOLjEgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKS5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbVBlbSA9IGZ1bmN0aW9uKHBlbSwgY29tcHV0ZUhhc2gsIHN0cmljdCkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnQ0VSVElGSUNBVEUgUkVRVUVTVCcpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGZyb20gUEVNOyAnICtcbiAgICAgICdQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvUGVtID0gZnVuY3Rpb24oY3NyLCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnQ0VSVElGSUNBVEUgUkVRVUVTVCcsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGlvblJlcXVlc3RUb0FzbjEoY3NyKSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgWC41MDl2MyBSU0EgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VydCA9IHt9O1xuICBjZXJ0LnZlcnNpb24gPSAweDAyO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9ICcwMCc7XG4gIGNlcnQuc2lnbmF0dXJlT2lkID0gbnVsbDtcbiAgY2VydC5zaWduYXR1cmUgPSBudWxsO1xuICBjZXJ0LnNpZ2luZm8gPSB7fTtcbiAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IG51bGw7XG4gIGNlcnQudmFsaWRpdHkgPSB7fTtcbiAgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgPSBuZXcgRGF0ZSgpO1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyID0gbmV3IERhdGUoKTtcblxuICBjZXJ0Lmlzc3VlciA9IHt9O1xuICBjZXJ0Lmlzc3Vlci5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5pc3N1ZXIsIHNuKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gW107XG4gIGNlcnQuaXNzdWVyLmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuc3ViamVjdCA9IHt9O1xuICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuc3ViamVjdCwgc24pO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICBjZXJ0LnB1YmxpY0tleSA9IG51bGw7XG4gIGNlcnQubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICogQHBhcmFtIHVuaXF1ZUlkIGFuIG9wdGlvbmFsIGEgdW5pcXVlIElEIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzLCB1bmlxdWVJZCkge1xuICAgIC8vIHNldCBuZXcgYXR0cmlidXRlcywgY2xlYXIgaGFzaFxuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycyk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5zdWJqZWN0LnVuaXF1ZUlkO1xuICAgIGlmKHVuaXF1ZUlkKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgfVxuICAgIGNlcnQuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgaXNzdWVyIG9mIHRoaXMgY2VydGlmaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgaXNzdWVyIGF0dHJpYnV0ZXMgdG8gdXNlLlxuICAgKiBAcGFyYW0gdW5pcXVlSWQgYW4gb3B0aW9uYWwgYSB1bmlxdWUgSUQgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRJc3N1ZXIgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXMsIGNsZWFyIGhhc2hcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBkZWxldGUgY2VydC5pc3N1ZXIudW5pcXVlSWQ7XG4gICAgaWYodW5pcXVlSWQpIHtcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICBjZXJ0Lmlzc3Vlci51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIH1cbiAgICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgZXh0ZW5zaW9ucyBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gZXh0cyB0aGUgYXJyYXkgb2YgZXh0ZW5zaW9ucyB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldEV4dGVuc2lvbnMgPSBmdW5jdGlvbihleHRzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhleHRzW2ldLCB7Y2VydDogY2VydH0pO1xuICAgIH1cbiAgICAvLyBzZXQgbmV3IGV4dGVuc2lvbnNcbiAgICBjZXJ0LmV4dGVuc2lvbnMgPSBleHRzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGV4dGVuc2lvbiBieSBpdHMgbmFtZSBvciBpZC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5hbWUgdG8gdXNlIG9yIGFuIG9iamVjdCB3aXRoOlxuICAgKiAgICAgICAgICBuYW1lIHRoZSBuYW1lIHRvIHVzZS5cbiAgICogICAgICAgICAgaWQgdGhlIGlkIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgKi9cbiAgY2VydC5nZXRFeHRlbnNpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0ge25hbWU6IG9wdGlvbnN9O1xuICAgIH1cblxuICAgIHZhciBydmFsID0gbnVsbDtcbiAgICB2YXIgZXh0O1xuICAgIGZvcih2YXIgaSA9IDA7IHJ2YWwgPT09IG51bGwgJiYgaSA8IGNlcnQuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgZXh0ID0gY2VydC5leHRlbnNpb25zW2ldO1xuICAgICAgaWYob3B0aW9ucy5pZCAmJiBleHQuaWQgPT09IG9wdGlvbnMuaWQpIHtcbiAgICAgICAgcnZhbCA9IGV4dDtcbiAgICAgIH0gZWxzZSBpZihvcHRpb25zLm5hbWUgJiYgZXh0Lm5hbWUgPT09IG9wdGlvbnMubmFtZSkge1xuICAgICAgICBydmFsID0gZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogU2lnbnMgdGhpcyBjZXJ0aWZpY2F0ZSB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNlcnQuc2lnbiA9IGZ1bmN0aW9uKGtleSwgbWQpIHtcbiAgICAvLyBUT0RPOiBnZXQgc2lnbmF0dXJlIE9JRCBmcm9tIHByaXZhdGUga2V5XG4gICAgY2VydC5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY2VydC5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjZXJ0Lm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgVEJTQ2VydGlmaWNhdGUsIGNvbnZlcnQgdG8gREVSXG4gICAgY2VydC50YnNDZXJ0aWZpY2F0ZSA9IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNlcnQudGJzQ2VydGlmaWNhdGUpO1xuXG4gICAgLy8gZGlnZXN0IGFuZCBzaWduXG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY2VydC5zaWduYXR1cmUgPSBrZXkuc2lnbihjZXJ0Lm1kKTtcbiAgfTtcblxuICAvKipcbiAgICogQXR0ZW1wdHMgdmVyaWZ5IHRoZSBzaWduYXR1cmUgb24gdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSB1c2luZyB0aGlzXG4gICAqIGNlcnRpZmljYXRlJ3MgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGNoaWxkIHRoZSBjZXJ0aWZpY2F0ZSB0byB2ZXJpZnkuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnkgPSBmdW5jdGlvbihjaGlsZCkge1xuICAgIHZhciBydmFsID0gZmFsc2U7XG5cbiAgICBpZighY2VydC5pc3N1ZWQoY2hpbGQpKSB7XG4gICAgICB2YXIgaXNzdWVyID0gY2hpbGQuaXNzdWVyO1xuICAgICAgdmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3Q7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1RoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgJyArXG4gICAgICAgICdjZXJ0aWZpY2F0ZTsgdGhlIGNoaWxkIGNlcnRpZmljYXRlXFwncyBpc3N1ZXIgZG9lcyBub3QgbWF0Y2ggdGhlICcgK1xuICAgICAgICAncGFyZW50XFwncyBzdWJqZWN0LicpO1xuICAgICAgZXJyb3IuZXhwZWN0ZWRJc3N1ZXIgPSBpc3N1ZXIuYXR0cmlidXRlcztcbiAgICAgIGVycm9yLmFjdHVhbElzc3VlciA9IHN1YmplY3QuYXR0cmlidXRlcztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBtZCA9IGNoaWxkLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjaGlsZC5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgICB2YXIgb2lkID0gb2lkc1tjaGlsZC5zaWduYXR1cmVPaWRdO1xuICAgICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICAgIGNhc2UgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhMzg0V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY2hpbGQuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIFRCU0NlcnRpZmljYXRlIGFuZCBkaWdlc3QgaXRcbiAgICAgIHZhciB0YnNDZXJ0aWZpY2F0ZSA9IGNoaWxkLnRic0NlcnRpZmljYXRlIHx8IHBraS5nZXRUQlNDZXJ0aWZpY2F0ZShjaGlsZCk7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKHRic0NlcnRpZmljYXRlKTtcbiAgICAgIG1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgICB9XG5cbiAgICBpZihtZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHNjaGVtZTtcblxuICAgICAgc3dpdGNoKGNoaWxkLnNpZ25hdHVyZU9pZCkge1xuICAgICAgY2FzZSBvaWRzLnNoYTFXaXRoUlNBRW5jcnlwdGlvbjpcbiAgICAgICAgc2NoZW1lID0gdW5kZWZpbmVkOyAgLyogdXNlIFBLQ1MjMSB2MS41IHBhZGRpbmcgc2NoZW1lICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICAgIHZhciBoYXNoLCBtZ2Y7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBtZ2YgKi9cbiAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBtZ2YgPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF07XG4gICAgICAgIGlmKG1nZiA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjaGlsZC5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2NoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVbnN1cHBvcnRlZCBSU0FTU0EtUFNTIGhhc2ggZnVuY3Rpb24uJyxcbiAgICAgICAgICAgIG9pZDogY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZCxcbiAgICAgICAgICAgIG5hbWU6IGhhc2hcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSwgbWdmLFxuICAgICAgICAgIGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuc2FsdExlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgc2lnbmF0dXJlIG9uIGNlcnQgdXNpbmcgcHVibGljIGtleVxuICAgICAgcnZhbCA9IGNlcnQucHVibGljS2V5LnZlcmlmeShcbiAgICAgICAgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSwgY2hpbGQuc2lnbmF0dXJlLCBzY2hlbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogY2VydGlmaWNhdGUncyBzdWJqZWN0LiBOb3RlIHRoYXQgbm8gc2lnbmF0dXJlIGNoZWNrIGlzIHBlcmZvcm1lZC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmVudCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3MgaXNzdWVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSdzXG4gICAqICAgICAgICAgc3ViamVjdC5cbiAgICovXG4gIGNlcnQuaXNJc3N1ZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIGkgPSBjZXJ0Lmlzc3VlcjtcbiAgICB2YXIgcyA9IHBhcmVudC5zdWJqZWN0O1xuXG4gICAgLy8gY29tcGFyZSBoYXNoZXMgaWYgcHJlc2VudFxuICAgIGlmKGkuaGFzaCAmJiBzLmhhc2gpIHtcbiAgICAgIHJ2YWwgPSAoaS5oYXNoID09PSBzLmhhc2gpO1xuICAgIH0gZWxzZSBpZihpLmF0dHJpYnV0ZXMubGVuZ3RoID09PSBzLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBhbGwgYXR0cmlidXRlcyBhcmUgdGhlIHNhbWUgc28gaXNzdWVyIG1hdGNoZXMgc3ViamVjdFxuICAgICAgcnZhbCA9IHRydWU7XG4gICAgICB2YXIgaWF0dHIsIHNhdHRyO1xuICAgICAgZm9yKHZhciBuID0gMDsgcnZhbCAmJiBuIDwgaS5hdHRyaWJ1dGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGlhdHRyID0gaS5hdHRyaWJ1dGVzW25dO1xuICAgICAgICBzYXR0ciA9IHMuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgaWYoaWF0dHIudHlwZSAhPT0gc2F0dHIudHlwZSB8fCBpYXR0ci52YWx1ZSAhPT0gc2F0dHIudmFsdWUpIHtcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUgbWlzbWF0Y2hcbiAgICAgICAgICBydmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBzdWJqZWN0IG1hdGNoZXMgdGhlIGlzc3VlciBvZiB0aGVcbiAgICogZ2l2ZW4gY2VydGlmaWNhdGUpLiBOb3RlIHRoYXQgbm90IHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBwYXNzZWRcbiAgICogICAgICAgICBjZXJ0aWZpY2F0ZSdzIGlzc3Vlci5cbiAgICovXG4gIGNlcnQuaXNzdWVkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQuaXNJc3N1ZXIoY2VydCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgc3ViamVjdEtleUlkZW50aWZpZXIgZm9yIHRoaXMgY2VydGlmaWNhdGUgYXMgYnl0ZSBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKi9cbiAgY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogU2VlOiA0LjIuMS4yIHNlY3Rpb24gb2YgdGhlIHRoZSBSRkMzMjgwLCBrZXlJZGVudGlmaWVyIGlzIGVpdGhlcjpcblxuICAgICAgKDEpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIHRoZSAxNjAtYml0IFNIQS0xIGhhc2ggb2YgdGhlXG4gICAgICAgIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXkgKGV4Y2x1ZGluZyB0aGUgdGFnLFxuICAgICAgICBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMpLlxuXG4gICAgICAoMikgVGhlIGtleUlkZW50aWZpZXIgaXMgY29tcG9zZWQgb2YgYSBmb3VyIGJpdCB0eXBlIGZpZWxkIHdpdGhcbiAgICAgICAgdGhlIHZhbHVlIDAxMDAgZm9sbG93ZWQgYnkgdGhlIGxlYXN0IHNpZ25pZmljYW50IDYwIGJpdHMgb2YgdGhlXG4gICAgICAgIFNIQS0xIGhhc2ggb2YgdGhlIHZhbHVlIG9mIHRoZSBCSVQgU1RSSU5HIHN1YmplY3RQdWJsaWNLZXlcbiAgICAgICAgKGV4Y2x1ZGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdCBzdHJpbmcgYml0cykuXG4gICAgKi9cblxuICAgIC8vIHNraXBwaW5nIHRoZSB0YWcsIGxlbmd0aCwgYW5kIG51bWJlciBvZiB1bnVzZWQgYml0cyBpcyB0aGUgc2FtZVxuICAgIC8vIGFzIGp1c3QgdXNpbmcgdGhlIFJTQVB1YmxpY0tleSAoZm9yIFJTQSBrZXlzLCB3aGljaCBhcmUgdGhlXG4gICAgLy8gb25seSBvbmVzIHN1cHBvcnRlZClcbiAgICByZXR1cm4gcGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50KGNlcnQucHVibGljS2V5LCB7dHlwZTogJ1JTQVB1YmxpY0tleSd9KTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGV4dGVuc2lvbiB2YWx1ZSBmb3IgdGhpcyBjZXJ0aWZpY2F0ZVxuICAgKiBhZ2FpbnN0IGl0cyBwdWJsaWMga2V5LiBJZiBubyBleHRlbnNpb24gaXMgZm91bmQsIGZhbHNlIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm4gdHJ1ZSBpZiB2ZXJpZmllZCwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2VydC52ZXJpZnlTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvaWQgPSBvaWRzWydzdWJqZWN0S2V5SWRlbnRpZmllciddO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICBpZihleHQuaWQgPT09IG9pZCkge1xuICAgICAgICB2YXIgc2tpID0gY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIChmb3JnZS51dGlsLmhleFRvQnl0ZXMoZXh0LnN1YmplY3RLZXlJZGVudGlmaWVyKSA9PT0gc2tpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZSBmcm9tIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBOb3RlOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2ggc2hvdWxkXG4gKiBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgdGhlIEFTTi4xXG4gKiBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNlcnQgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlRnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRlIGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRlXG4gIHZhciBjZXJ0ID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRlKCk7XG4gIGNlcnQudmVyc2lvbiA9IGNhcHR1cmUuY2VydFZlcnNpb24gP1xuICAgIGNhcHR1cmUuY2VydFZlcnNpb24uY2hhckNvZGVBdCgwKSA6IDA7XG4gIHZhciBzZXJpYWwgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLmNlcnRTZXJpYWxOdW1iZXIpO1xuICBjZXJ0LnNlcmlhbE51bWJlciA9IHNlcmlhbC50b0hleCgpO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0U2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNlcnQuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNlcnRTaWduYXR1cmVQYXJhbXMsIHRydWUpO1xuICBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlT2lkKTtcbiAgY2VydC5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCxcbiAgICBjYXB0dXJlLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCBmYWxzZSk7XG4gIGNlcnQuc2lnbmF0dXJlID0gY2FwdHVyZS5jZXJ0U2lnbmF0dXJlO1xuXG4gIHZhciB2YWxpZGl0eSA9IFtdO1xuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEudXRjVGltZVRvRGF0ZShjYXB0dXJlLmNlcnRWYWxpZGl0eTFVVENUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGl0eS5wdXNoKGFzbjEuZ2VuZXJhbGl6ZWRUaW1lVG9EYXRlKFxuICAgICAgY2FwdHVyZS5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSk7XG4gIH1cbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkzVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKHZhbGlkaXR5Lmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIG5vdEJlZm9yZS9ub3RBZnRlciB2YWxpZGl0eSB0aW1lczsgbW9yZSAnICtcbiAgICAgICd0aGFuIHR3byB0aW1lcyB3ZXJlIHByb3ZpZGVkIGluIHRoZSBjZXJ0aWZpY2F0ZS4nKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IHRoZXkgJyArXG4gICAgICAnd2VyZSBub3QgcHJvdmlkZWQgYXMgZWl0aGVyIFVUQ1RpbWUgb3IgR2VuZXJhbGl6ZWRUaW1lLicpO1xuICB9XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gdmFsaWRpdHlbMF07XG4gIGNlcnQudmFsaWRpdHkubm90QWZ0ZXIgPSB2YWxpZGl0eVsxXTtcblxuICAvLyBrZWVwIFRCU0NlcnRpZmljYXRlIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjZXJ0LnRic0NlcnRpZmljYXRlID0gY2FwdHVyZS50YnNDZXJ0aWZpY2F0ZTtcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjZXJ0Lm1kID0gbnVsbDtcbiAgICBpZihjZXJ0LnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICB2YXIgb2lkID0gb2lkc1tjZXJ0LnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnUlNBU1NBLVBTUyc6XG4gICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjZXJ0Lm1kID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ25hdHVyZU9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBUQlNDZXJ0aWZpY2F0ZSBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcbiAgICBjZXJ0Lm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBpc3N1ZXIsIGJ1aWxkIGlzc3VlciBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgaW1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgY2VydC5pc3N1ZXIuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuaXNzdWVyLCBzbik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRJc3N1ZXIsIGltZCk7XG4gIGlmKGNhcHR1cmUuY2VydElzc3VlclVuaXF1ZUlkKSB7XG4gICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZDtcbiAgfVxuICBjZXJ0Lmlzc3Vlci5oYXNoID0gaW1kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNlcnQuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY2VydC5zdWJqZWN0LCBzbik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShjYXB0dXJlLmNlcnRTdWJqZWN0LCBzbWQpO1xuICBpZihjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQpIHtcbiAgICBjZXJ0LnN1YmplY3QudW5pcXVlSWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0VW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5zdWJqZWN0Lmhhc2ggPSBzbWQuZGlnZXN0KCkudG9IZXgoKTtcblxuICAvLyBoYW5kbGUgZXh0ZW5zaW9uc1xuICBpZihjYXB0dXJlLmNlcnRFeHRlbnNpb25zKSB7XG4gICAgY2VydC5leHRlbnNpb25zID0gcGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uc0Zyb21Bc24xKGNhcHR1cmUuY2VydEV4dGVuc2lvbnMpO1xuICB9IGVsc2Uge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IFtdO1xuICB9XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNlcnQucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIHJldHVybiBjZXJ0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBU04uMSBleHRlbnNpb25zIG9iamVjdCAod2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIGFzIGl0c1xuICogdmFsdWVzKSBpbnRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbiBvYmplY3RzIHdpdGggdHlwZXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBTdXBwb3J0ZWQgZXh0ZW5zaW9uczpcbiAqXG4gKiBpZC1jZS1rZXlVc2FnZSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTUgfVxuICogS2V5VXNhZ2UgOjo9IEJJVCBTVFJJTkcge1xuICogICBkaWdpdGFsU2lnbmF0dXJlICAgICAgICAoMCksXG4gKiAgIG5vblJlcHVkaWF0aW9uICAgICAgICAgICgxKSxcbiAqICAga2V5RW5jaXBoZXJtZW50ICAgICAgICAgKDIpLFxuICogICBkYXRhRW5jaXBoZXJtZW50ICAgICAgICAoMyksXG4gKiAgIGtleUFncmVlbWVudCAgICAgICAgICAgICg0KSxcbiAqICAga2V5Q2VydFNpZ24gICAgICAgICAgICAgKDUpLFxuICogICBjUkxTaWduICAgICAgICAgICAgICAgICAoNiksXG4gKiAgIGVuY2lwaGVyT25seSAgICAgICAgICAgICg3KSxcbiAqICAgZGVjaXBoZXJPbmx5ICAgICAgICAgICAgKDgpXG4gKiB9XG4gKlxuICogaWQtY2UtYmFzaWNDb25zdHJhaW50cyBPQkpFQ1QgSURFTlRJRklFUiA6Oj0gIHsgaWQtY2UgMTkgfVxuICogQmFzaWNDb25zdHJhaW50cyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjQSAgICAgICAgICAgICAgICAgICAgICBCT09MRUFOIERFRkFVTFQgRkFMU0UsXG4gKiAgIHBhdGhMZW5Db25zdHJhaW50ICAgICAgIElOVEVHRVIgKDAuLk1BWCkgT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBzdWJqZWN0QWx0TmFtZSBFWFRFTlNJT04gOjo9IHtcbiAqICAgU1lOVEFYIEdlbmVyYWxOYW1lc1xuICogICBJREVOVElGSUVEIEJZIGlkLWNlLXN1YmplY3RBbHROYW1lXG4gKiB9XG4gKlxuICogR2VuZXJhbE5hbWVzIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEdlbmVyYWxOYW1lXG4gKlxuICogR2VuZXJhbE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIG90aGVyTmFtZSAgICAgIFswXSBJTlNUQU5DRSBPRiBPVEhFUi1OQU1FLFxuICogICByZmM4MjJOYW1lICAgICBbMV0gSUE1U3RyaW5nLFxuICogICBkTlNOYW1lICAgICAgICBbMl0gSUE1U3RyaW5nLFxuICogICB4NDAwQWRkcmVzcyAgICBbM10gT1JBZGRyZXNzLFxuICogICBkaXJlY3RvcnlOYW1lICBbNF0gTmFtZSxcbiAqICAgZWRpUGFydHlOYW1lICAgWzVdIEVESVBhcnR5TmFtZSxcbiAqICAgdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciBbNl0gSUE1U3RyaW5nLFxuICogICBJUEFkZHJlc3MgICAgICBbN10gT0NURVQgU1RSSU5HLFxuICogICByZWdpc3RlcmVkSUQgICBbOF0gT0JKRUNUIElERU5USUZJRVJcbiAqIH1cbiAqXG4gKiBPVEhFUi1OQU1FIDo6PSBUWVBFLUlERU5USUZJRVJcbiAqXG4gKiBFRElQYXJ0eU5hbWUgOjo9IFNFUVVFTkNFIHtcbiAqICAgbmFtZUFzc2lnbmVyIFswXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9IE9QVElPTkFMLFxuICogICBwYXJ0eU5hbWUgICAgWzFdIERpcmVjdG9yeVN0cmluZyB7dWItbmFtZX1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyBBU04uMSB3aXRoIGV4dGVuc2lvbiBzZXF1ZW5jZXMgdG8gcGFyc2UuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dHMpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGV4dHMudmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgZXh0ZW5zaW9uIHNlcXVlbmNlXG4gICAgdmFyIGV4dHNlcSA9IGV4dHMudmFsdWVbaV07XG4gICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgZXh0c2VxLnZhbHVlLmxlbmd0aDsgKytlaSkge1xuICAgICAgcnZhbC5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKGV4dHNlcS52YWx1ZVtlaV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2luZ2xlIGNlcnRpZmljYXRlIGV4dGVuc2lvbiBmcm9tIEFTTi4xLlxuICpcbiAqIEBwYXJhbSBleHQgdGhlIGV4dGVuc2lvbiBpbiBBU04uMSBmb3JtYXQuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIGV4dGVuc2lvbiBhcyBhbiBvYmplY3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGFuIGV4dGVuc2lvbiBoYXM6XG4gIC8vIFswXSBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUlxuICAvLyBbMV0gY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFXG4gIC8vIFsyXSBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAgdmFyIGUgPSB7fTtcbiAgZS5pZCA9IGFzbjEuZGVyVG9PaWQoZXh0LnZhbHVlWzBdLnZhbHVlKTtcbiAgZS5jcml0aWNhbCA9IGZhbHNlO1xuICBpZihleHQudmFsdWVbMV0udHlwZSA9PT0gYXNuMS5UeXBlLkJPT0xFQU4pIHtcbiAgICBlLmNyaXRpY2FsID0gKGV4dC52YWx1ZVsxXS52YWx1ZS5jaGFyQ29kZUF0KDApICE9PSAweDAwKTtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzJdLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGUudmFsdWUgPSBleHQudmFsdWVbMV0udmFsdWU7XG4gIH1cbiAgLy8gaWYgdGhlIG9pZCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lXG4gIGlmKGUuaWQgaW4gb2lkcykge1xuICAgIGUubmFtZSA9IG9pZHNbZS5pZF07XG5cbiAgICAvLyBoYW5kbGUga2V5IHVzYWdlXG4gICAgaWYoZS5uYW1lID09PSAna2V5VXNhZ2UnKSB7XG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIHZhciBiMyA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgYjMgPSBldi52YWx1ZS5sZW5ndGggPiAyID8gZXYudmFsdWUuY2hhckNvZGVBdCgyKSA6IDA7XG4gICAgICB9XG4gICAgICAvLyBzZXQgZmxhZ3NcbiAgICAgIGUuZGlnaXRhbFNpZ25hdHVyZSA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5ub25SZXB1ZGlhdGlvbiA9IChiMiAmIDB4NDApID09PSAweDQwO1xuICAgICAgZS5rZXlFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUuZGF0YUVuY2lwaGVybWVudCA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5rZXlBZ3JlZW1lbnQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUua2V5Q2VydFNpZ24gPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuY1JMU2lnbiA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5lbmNpcGhlck9ubHkgPSAoYjIgJiAweDAxKSA9PT0gMHgwMTtcbiAgICAgIGUuZGVjaXBoZXJPbmx5ID0gKGIzICYgMHg4MCkgPT09IDB4ODA7XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgICAvLyBoYW5kbGUgYmFzaWMgY29uc3RyYWludHNcbiAgICAgIC8vIGdldCB2YWx1ZSBhcyBTRVFVRU5DRVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgLy8gZ2V0IGNBIEJPT0xFQU4gZmxhZyAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgICAgIGUuY0EgPSAoZXYudmFsdWVbMF0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlLmNBID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBnZXQgcGF0aCBsZW5ndGggY29uc3RyYWludFxuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDAgJiYgZXYudmFsdWVbMF0udHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIpIHtcbiAgICAgICAgdmFsdWUgPSBldi52YWx1ZVswXS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMV0udmFsdWU7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlLnBhdGhMZW5Db25zdHJhaW50ID0gYXNuMS5kZXJUb0ludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdleHRLZXlVc2FnZScpIHtcbiAgICAgIC8vIGhhbmRsZSBleHRLZXlVc2FnZVxuICAgICAgLy8gdmFsdWUgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBldi52YWx1ZS5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoZXYudmFsdWVbdmldLnZhbHVlKTtcbiAgICAgICAgaWYob2lkIGluIG9pZHMpIHtcbiAgICAgICAgICBlW29pZHNbb2lkXV0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVbb2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnbnNDZXJ0VHlwZScpIHtcbiAgICAgIC8vIGhhbmRsZSBuc0NlcnRUeXBlXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgQklUIFNUUklOR1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgdmFyIGIyID0gMHgwMDtcbiAgICAgIGlmKGV2LnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gc2tpcCBmaXJzdCBieXRlLCBqdXN0IGluZGljYXRlcyB1bnVzZWQgYml0cyB3aGljaFxuICAgICAgICAvLyB3aWxsIGJlIHBhZGRlZCB3aXRoIDBzIGFueXdheVxuICAgICAgICAvLyBnZXQgYnl0ZXMgd2l0aCBmbGFnIGJpdHNcbiAgICAgICAgYjIgPSBldi52YWx1ZS5jaGFyQ29kZUF0KDEpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmNsaWVudCA9IChiMiAmIDB4ODApID09PSAweDgwO1xuICAgICAgZS5zZXJ2ZXIgPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUuZW1haWwgPSAoYjIgJiAweDIwKSA9PT0gMHgyMDtcbiAgICAgIGUub2Jqc2lnbiA9IChiMiAmIDB4MTApID09PSAweDEwO1xuICAgICAgZS5yZXNlcnZlZCA9IChiMiAmIDB4MDgpID09PSAweDA4O1xuICAgICAgZS5zc2xDQSA9IChiMiAmIDB4MDQpID09PSAweDA0O1xuICAgICAgZS5lbWFpbENBID0gKGIyICYgMHgwMikgPT09IDB4MDI7XG4gICAgICBlLm9iakNBID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgfSBlbHNlIGlmKFxuICAgICAgZS5uYW1lID09PSAnc3ViamVjdEFsdE5hbWUnIHx8XG4gICAgICBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgICAgLy8gaGFuZGxlIHN1YmplY3RBbHROYW1lL2lzc3VlckFsdE5hbWVcbiAgICAgIGUuYWx0TmFtZXMgPSBbXTtcblxuICAgICAgLy8gZXYgaXMgYSBTWU5UQVggU0VRVUVOQ0VcbiAgICAgIHZhciBnbjtcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIGZvcih2YXIgbiA9IDA7IG4gPCBldi52YWx1ZS5sZW5ndGg7ICsrbikge1xuICAgICAgICAvLyBnZXQgR2VuZXJhbE5hbWVcbiAgICAgICAgZ24gPSBldi52YWx1ZVtuXTtcblxuICAgICAgICB2YXIgYWx0TmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBnbi50eXBlLFxuICAgICAgICAgIHZhbHVlOiBnbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBlLmFsdE5hbWVzLnB1c2goYWx0TmFtZSk7XG5cbiAgICAgICAgLy8gTm90ZTogU3VwcG9ydCBmb3IgdHlwZXMgMSwyLDYsNyw4XG4gICAgICAgIHN3aXRjaChnbi50eXBlKSB7XG4gICAgICAgIC8vIHJmYzgyMk5hbWVcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAvLyBkTlNOYW1lXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gdW5pZm9ybVJlc291cmNlSWRlbnRpZmllciAoVVJJKVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElQQWRkcmVzc1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgLy8gY29udmVydCB0byBJUHY0L0lQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgYWx0TmFtZS5pcCA9IGZvcmdlLnV0aWwuYnl0ZXNUb0lQKGduLnZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gcmVnaXN0ZXJlZElEXG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBhbHROYW1lLm9pZCA9IGFzbjEuZGVyVG9PaWQoZ24udmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVuc3VwcG9ydGVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnc3ViamVjdEtleUlkZW50aWZpZXInKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBhbiBPQ1RFVFNUUklORyB3L3RoZSBoYXNoIG9mIHRoZSBrZXktdHlwZSBzcGVjaWZpY1xuICAgICAgLy8gcHVibGljIGtleSBzdHJ1Y3R1cmUgKGVnOiBSU0FQdWJsaWNLZXkpXG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGV2LnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaFxuICogc2hvdWxkIGJlIHNldCB0byB0cnVlLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gaW1wbGVtZW50YXRpb24gZm9yIGNvbnZlcnRpbmdcbiAqIGEgY2VydGlmaWNhdGUgYmFjayB0byBBU04uMSBzbyB0aGUgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHBhcnQgb2YgdGhlXG4gKiBBU04uMSBvYmplY3QgbmVlZHMgdG8gYmUgc2Nhbm5lZCBiZWZvcmUgdGhlIGNzciBvYmplY3QgaXMgY3JlYXRlZC5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaiwgY29tcHV0ZUhhc2gpIHtcbiAgLy8gdmFsaWRhdGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGFuZCBjYXB0dXJlIGRhdGFcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGNlcnRpZmljYXRpb25SZXF1ZXN0VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGdldCBvaWRcbiAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5wdWJsaWNLZXlPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLicpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdFxuICB2YXIgY3NyID0gcGtpLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7XG4gIGNzci52ZXJzaW9uID0gY2FwdHVyZS5jc3JWZXJzaW9uID8gY2FwdHVyZS5jc3JWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICBjc3Iuc2lnbmF0dXJlT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWduYXR1cmVPaWQsIGNhcHR1cmUuY3NyU2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gZm9yZ2UuYXNuMS5kZXJUb09pZChjYXB0dXJlLmNzclNpZ25hdHVyZU9pZCk7XG4gIGNzci5zaWdpbmZvLnBhcmFtZXRlcnMgPSBfcmVhZFNpZ25hdHVyZVBhcmFtZXRlcnMoXG4gICAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjc3Iuc2lnbmF0dXJlID0gY2FwdHVyZS5jc3JTaWduYXR1cmU7XG5cbiAgLy8ga2VlcCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gdG8gcHJlc2VydmUgc2lnbmF0dXJlIHdoZW4gZXhwb3J0aW5nXG4gIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBjYXB0dXJlLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbztcblxuICBpZihjb21wdXRlSGFzaCkge1xuICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICBjc3IubWQgPSBudWxsO1xuICAgIGlmKGNzci5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgdmFyIG9pZCA9IG9pZHNbY3NyLnNpZ25hdHVyZU9pZF07XG4gICAgICBzd2l0Y2gob2lkKSB7XG4gICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgY3NyLm1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihjc3IubWQgPT09IG51bGwpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIHNpZ25hdHVyZSBPSUQuJyk7XG4gICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmplY3QsIGJ1aWxkIHN1YmplY3QgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIHNtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0LCBzbWQpO1xuICBjc3Iuc3ViamVjdC5oYXNoID0gc21kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gY29udmVydCBSU0EgcHVibGljIGtleSBmcm9tIEFTTi4xXG4gIGNzci5wdWJsaWNLZXkgPSBwa2kucHVibGljS2V5RnJvbUFzbjEoY2FwdHVyZS5zdWJqZWN0UHVibGljS2V5SW5mbyk7XG5cbiAgLy8gY29udmVydCBhdHRyaWJ1dGVzIGZyb20gQVNOLjFcbiAgY3NyLmdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLCBzbik7XG4gIH07XG4gIGNzci5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY3NyLmF0dHJpYnV0ZXMgPSBwa2kuQ1JJQXR0cmlidXRlc0FzQXJyYXkoXG4gICAgY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9BdHRyaWJ1dGVzIHx8IFtdKTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IGNlcnRpZmljYXRpb24gcmVxdWVzdCAoYSBDU1Igb3IgY2VydGlmaWNhdGUgc2lnbmluZ1xuICogcmVxdWVzdCkuIE9uY2UgY3JlYXRlZCwgaXRzIHB1YmxpYyBrZXkgYW5kIGF0dHJpYnV0ZXMgY2FuIGJlIHNldCBhbmQgdGhlblxuICogaXQgY2FuIGJlIHNpZ25lZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3NyID0ge307XG4gIGNzci52ZXJzaW9uID0gMHgwMDtcbiAgY3NyLnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gIGNzci5zaWduYXR1cmUgPSBudWxsO1xuICBjc3Iuc2lnaW5mbyA9IHt9O1xuICBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuXG4gIGNzci5zdWJqZWN0ID0ge307XG4gIGNzci5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3Iuc3ViamVjdCwgc24pO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBbXTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG5cbiAgY3NyLnB1YmxpY0tleSA9IG51bGw7XG4gIGNzci5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5tZCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2Ygc3ViamVjdCBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRTdWJqZWN0ID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBhdHRycztcbiAgICBjc3Iuc3ViamVjdC5oYXNoID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIHRoZSBhcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICovXG4gIGNzci5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXNcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNzci5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgKGRlZmF1bHRzIHRvIGZvcmdlLm1kLnNoYTEpLlxuICAgKi9cbiAgY3NyLnNpZ24gPSBmdW5jdGlvbihrZXksIG1kKSB7XG4gICAgLy8gVE9ETzogZ2V0IHNpZ25hdHVyZSBPSUQgZnJvbSBwcml2YXRlIGtleVxuICAgIGNzci5tZCA9IG1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIGFsZ29yaXRobU9pZCA9IG9pZHNbY3NyLm1kLmFsZ29yaXRobSArICdXaXRoUlNBRW5jcnlwdGlvbiddO1xuICAgIGlmKCFhbGdvcml0aG1PaWQpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICdVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuJyk7XG4gICAgICBlcnJvci5hbGdvcml0aG0gPSBjc3IubWQuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNzci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBhbGdvcml0aG1PaWQ7XG5cbiAgICAvLyBnZXQgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLCBjb252ZXJ0IHRvIERFUlxuICAgIGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gPSBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0Rlcihjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKTtcblxuICAgIC8vIGRpZ2VzdCBhbmQgc2lnblxuICAgIGNzci5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgY3NyLnNpZ25hdHVyZSA9IGtleS5zaWduKGNzci5tZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIHRoZSBwYXNzZWQgY2VydGlmaWNhdGlvbiByZXF1ZXN0IHVzaW5nXG4gICAqIGl0cyBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBBIENTUiB0aGF0IGhhcyBiZWVuIGV4cG9ydGVkIHRvIGEgZmlsZSBpbiBQRU0gZm9ybWF0IGNhbiBiZSB2ZXJpZmllZCB1c2luZ1xuICAgKiBPcGVuU1NMIHVzaW5nIHRoaXMgY29tbWFuZDpcbiAgICpcbiAgICogb3BlbnNzbCByZXEgLWluIDx0aGUtY3NyLXBlbS1maWxlPiAtdmVyaWZ5IC1ub291dCAtdGV4dFxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNzci52ZXJpZnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgdmFyIG1kID0gY3NyLm1kO1xuICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgICBpZihjc3Iuc2lnbmF0dXJlT2lkIGluIG9pZHMpIHtcbiAgICAgICAgLy8gVE9ETzogY3JlYXRlIERSWSBgT0lEIHRvIG1kYCBmdW5jdGlvblxuICAgICAgICB2YXIgb2lkID0gb2lkc1tjc3Iuc2lnbmF0dXJlT2lkXTtcbiAgICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTM4NC5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhNTEyLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZGlnZXN0LiAnICtcbiAgICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjc3Iuc2lnbmF0dXJlT2lkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvZHVjZSBERVIgZm9ybWF0dGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBhbmQgZGlnZXN0IGl0XG4gICAgICB2YXIgY3JpID0gY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyB8fFxuICAgICAgICBwa2kuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGNzcik7XG4gICAgICB2YXIgYnl0ZXMgPSBhc24xLnRvRGVyKGNyaSk7XG4gICAgICBtZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gICAgfVxuXG4gICAgaWYobWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBzY2hlbWU7XG5cbiAgICAgIHN3aXRjaChjc3Iuc2lnbmF0dXJlT2lkKSB7XG4gICAgICBjYXNlIG9pZHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOlxuICAgICAgICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyBzY2hlbWUgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgICAgdmFyIGhhc2gsIG1nZjtcblxuICAgICAgICAvKiBpbml0aWFsaXplIG1nZiAqL1xuICAgICAgICBoYXNoID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICBpZihoYXNoID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uJyk7XG4gICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBoYXNoO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgbWdmID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYobWdmID09PSB1bmRlZmluZWQgfHwgZm9yZ2UubWdmW21nZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICAgIGVycm9yLm9pZCA9IGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IG1nZjtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1nZiA9IGZvcmdlLm1nZlttZ2ZdLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSk7XG5cbiAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgIGhhc2ggPSBvaWRzW2Nzci5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgaWYoaGFzaCA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1kW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICBlcnJvci5vaWQgPSBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtZSA9IGZvcmdlLnBzcy5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCksIG1nZixcbiAgICAgICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gY3NyIHVzaW5nIGl0cyBwdWJsaWMga2V5XG4gICAgICBydmFsID0gY3NyLnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCksIGNzci5zaWduYXR1cmUsIHNjaGVtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgc3ViamVjdCBvciBpc3N1ZXIgdG8gYW4gQVNOLjEgUkROU2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgc3ViamVjdCBvciBpc3N1ZXIgKGRpc3Rpbmd1aXNoZWQgbmFtZSkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUkROU2VxdWVuY2UuXG4gKi9cbmZ1bmN0aW9uIF9kblRvQXNuMShvYmopIHtcbiAgLy8gY3JlYXRlIGFuIGVtcHR5IFJETlNlcXVlbmNlXG4gIHZhciBydmFsID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhdHRyaWJ1dGVzXG4gIHZhciBhdHRyLCBzZXQ7XG4gIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICBhdHRyID0gYXR0cnNbaV07XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgIC8vIHJldXNlIHRhZyBjbGFzcyBmb3IgYXR0cmlidXRlIHZhbHVlIGlmIGF2YWlsYWJsZVxuICAgIHZhciB2YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORztcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcblxuICAgICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWUgc2V0XG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgc2V0IGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBmaXJzdFxuICAgIC8vIGNvbnRhaW5pbmcgdGhlIHR5cGUgKGFuIE9JRCkgYW5kIHNlY29uZCB0aGUgdmFsdWVcbiAgICBzZXQgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKGF0dHIudHlwZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCBmYWxzZSwgdmFsdWUpXG4gICAgICBdKVxuICAgIF0pO1xuICAgIHJ2YWwudmFsdWUucHVzaChzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogR2V0cyBhbGwgcHJpbnRhYmxlIGF0dHJpYnV0ZXMgKHR5cGljYWxseSBvZiBhbiBpc3N1ZXIgb3Igc3ViamVjdCkgaW4gYVxuICogc2ltcGxpZmllZCBKU09OIGZvcm1hdCBmb3IgZGlzcGxheS5cbiAqXG4gKiBAcGFyYW0gYXR0cnMgdGhlIGF0dHJpYnV0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgSlNPTiBmb3IgZGlzcGxheS5cbiAqL1xuZnVuY3Rpb24gX2dldEF0dHJpYnV0ZXNBc0pzb24oYXR0cnMpIHtcbiAgdmFyIHJ2YWwgPSB7fTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBpZihhdHRyLnNob3J0TmFtZSAmJiAoXG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4IHx8XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5QUklOVEFCTEVTVFJJTkcgfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLklBNVNUUklORykpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICBpZihhdHRyLnZhbHVlVGFnQ2xhc3MgPT09IGFzbjEuVHlwZS5VVEY4KSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KGF0dHIudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYoIShhdHRyLnNob3J0TmFtZSBpbiBydmFsKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmKGZvcmdlLnV0aWwuaXNBcnJheShydmFsW2F0dHIuc2hvcnROYW1lXSkpIHtcbiAgICAgICAgcnZhbFthdHRyLnNob3J0TmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXSA9IFtydmFsW2F0dHIuc2hvcnROYW1lXSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBhdHRyaWJ1dGVzLlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcyB0byBmaWxsIG1pc3NpbmcgZmllbGRzIGluLlxuICovXG5mdW5jdGlvbiBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpIHtcbiAgdmFyIGF0dHI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLnR5cGUgJiYgYXR0ci50eXBlIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIubmFtZSA9IHBraS5vaWRzW2F0dHIudHlwZV07XG4gICAgICB9IGVsc2UgaWYoYXR0ci5zaG9ydE5hbWUgJiYgYXR0ci5zaG9ydE5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbX3Nob3J0TmFtZXNbYXR0ci5zaG9ydE5hbWVdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHR5cGUgKE9JRClcbiAgICBpZih0eXBlb2YgYXR0ci50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBwa2kub2lkcykge1xuICAgICAgICBhdHRyLnR5cGUgPSBwa2kub2lkc1thdHRyLm5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdHlwZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgICBlcnJvci5hdHRyaWJ1dGUgPSBhdHRyO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3B1bGF0ZSBtaXNzaW5nIHNob3J0bmFtZVxuICAgIGlmKHR5cGVvZiBhdHRyLnNob3J0TmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIubmFtZSAmJiBhdHRyLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgYXR0ci5zaG9ydE5hbWUgPSBfc2hvcnROYW1lc1thdHRyLm5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZXh0ZW5zaW9ucyB0byB2YWx1ZVxuICAgIGlmKGF0dHIudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICBhdHRyLnZhbHVlQ29uc3RydWN0ZWQgPSB0cnVlO1xuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID0gYXNuMS5UeXBlLlNFUVVFTkNFO1xuICAgICAgaWYoIWF0dHIudmFsdWUgJiYgYXR0ci5leHRlbnNpb25zKSB7XG4gICAgICAgIGF0dHIudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yKHZhciBlaSA9IDA7IGVpIDwgYXR0ci5leHRlbnNpb25zLmxlbmd0aDsgKytlaSkge1xuICAgICAgICAgIGF0dHIudmFsdWUucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEoXG4gICAgICAgICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoYXR0ci5leHRlbnNpb25zW2VpXSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHR5cGVvZiBhdHRyLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdBdHRyaWJ1dGUgdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGaWxscyBpbiBtaXNzaW5nIGZpZWxkcyBpbiBjZXJ0aWZpY2F0ZSBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSBlIHRoZSBleHRlbnNpb24uXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFtjZXJ0XSB0aGUgY2VydGlmaWNhdGUgdGhlIGV4dGVuc2lvbnMgYXJlIGZvci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHRlbnNpb24uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHBvcHVsYXRlIG1pc3NpbmcgbmFtZVxuICBpZih0eXBlb2YgZS5uYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUuaWQgJiYgZS5pZCBpbiBwa2kub2lkcykge1xuICAgICAgZS5uYW1lID0gcGtpLm9pZHNbZS5pZF07XG4gICAgfVxuICB9XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBpZFxuICBpZih0eXBlb2YgZS5pZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZihlLm5hbWUgJiYgZS5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICBlLmlkID0gcGtpLm9pZHNbZS5uYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gSUQgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBpZih0eXBlb2YgZS52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBtaXNzaW5nIHZhbHVlOlxuXG4gIC8vIHZhbHVlIGlzIGEgQklUIFNUUklOR1xuICBpZihlLm5hbWUgPT09ICdrZXlVc2FnZScpIHtcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG4gICAgdmFyIGIzID0gMHgwMDtcbiAgICBpZihlLmRpZ2l0YWxTaWduYXR1cmUpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLm5vblJlcHVkaWF0aW9uKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5rZXlFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLmRhdGFFbmNpcGhlcm1lbnQpIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLmtleUFncmVlbWVudCkge1xuICAgICAgYjIgfD0gMHgwODtcbiAgICAgIHVudXNlZCA9IDM7XG4gICAgfVxuICAgIGlmKGUua2V5Q2VydFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDQ7XG4gICAgICB1bnVzZWQgPSAyO1xuICAgIH1cbiAgICBpZihlLmNSTFNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MDI7XG4gICAgICB1bnVzZWQgPSAxO1xuICAgIH1cbiAgICBpZihlLmVuY2lwaGVyT25seSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuICAgIGlmKGUuZGVjaXBoZXJPbmx5KSB7XG4gICAgICBiMyB8PSAweDgwO1xuICAgICAgdW51c2VkID0gNztcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYml0IHN0cmluZ1xuICAgIHZhciB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodW51c2VkKTtcbiAgICBpZihiMyAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGIzKTtcbiAgICB9IGVsc2UgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2Jhc2ljQ29uc3RyYWludHMnKSB7XG4gICAgLy8gYmFzaWNDb25zdHJhaW50cyBpcyBhIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIC8vIGNBIEJPT0xFQU4gZmxhZyBkZWZhdWx0cyB0byBmYWxzZVxuICAgIGlmKGUuY0EpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CT09MRUFOLCBmYWxzZSxcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGKSkpO1xuICAgIH1cbiAgICBpZigncGF0aExlbkNvbnN0cmFpbnQnIGluIGUpIHtcbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoZS5wYXRoTGVuQ29uc3RyYWludCkuZ2V0Qnl0ZXMoKSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2V4dEtleVVzYWdlJykge1xuICAgIC8vIGV4dEtleVVzYWdlIGlzIGEgU0VRVUVOQ0Ugb2YgT0lEc1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcbiAgICBmb3IodmFyIGtleSBpbiBlKSB7XG4gICAgICBpZihlW2tleV0gIT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBrZXkgaXMgbmFtZSBpbiBPSUQgbWFwXG4gICAgICBpZihrZXkgaW4gb2lkcykge1xuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihvaWRzW2tleV0pLmdldEJ5dGVzKCkpKTtcbiAgICAgIH0gZWxzZSBpZihrZXkuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAvLyBhc3N1bWUga2V5IGlzIGFuIE9JRFxuICAgICAgICBzZXEucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBmYWxzZSwgYXNuMS5vaWRUb0RlcihrZXkpLmdldEJ5dGVzKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICduc0NlcnRUeXBlJykge1xuICAgIC8vIG5zQ2VydFR5cGUgaXMgYSBCSVQgU1RSSU5HXG4gICAgLy8gYnVpbGQgZmxhZ3NcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICB2YXIgYjIgPSAweDAwO1xuXG4gICAgaWYoZS5jbGllbnQpIHtcbiAgICAgIGIyIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cbiAgICBpZihlLnNlcnZlcikge1xuICAgICAgYjIgfD0gMHg0MDtcbiAgICAgIHVudXNlZCA9IDY7XG4gICAgfVxuICAgIGlmKGUuZW1haWwpIHtcbiAgICAgIGIyIHw9IDB4MjA7XG4gICAgICB1bnVzZWQgPSA1O1xuICAgIH1cbiAgICBpZihlLm9ianNpZ24pIHtcbiAgICAgIGIyIHw9IDB4MTA7XG4gICAgICB1bnVzZWQgPSA0O1xuICAgIH1cbiAgICBpZihlLnJlc2VydmVkKSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5zc2xDQSkge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuZW1haWxDQSkge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUub2JqQ0EpIHtcbiAgICAgIGIyIHw9IDB4MDE7XG4gICAgICB1bnVzZWQgPSAwO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIyICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKTtcbiAgICB9XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0QWx0TmFtZScgfHwgZS5uYW1lID09PSAnaXNzdWVyQWx0TmFtZScpIHtcbiAgICAvLyBTWU5UQVggU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gICAgdmFyIGFsdE5hbWU7XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IGUuYWx0TmFtZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGFsdE5hbWUgPSBlLmFsdE5hbWVzW25dO1xuICAgICAgdmFyIHZhbHVlID0gYWx0TmFtZS52YWx1ZTtcbiAgICAgIC8vIGhhbmRsZSBJUFxuICAgICAgaWYoYWx0TmFtZS50eXBlID09PSA3ICYmIGFsdE5hbWUuaXApIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmJ5dGVzRnJvbUlQKGFsdE5hbWUuaXApO1xuICAgICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdFeHRlbnNpb24gXCJpcFwiIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQdjQgb3IgSVB2NiBhZGRyZXNzLicpO1xuICAgICAgICAgIGVycm9yLmV4dGVuc2lvbiA9IGU7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihhbHROYW1lLnR5cGUgPT09IDgpIHtcbiAgICAgICAgLy8gaGFuZGxlIE9JRFxuICAgICAgICBpZihhbHROYW1lLm9pZCkge1xuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcihhc24xLm9pZFRvRGVyKGFsdE5hbWUub2lkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVwcmVjYXRlZCAuLi4gY29udmVydCB2YWx1ZSB0byBPSURcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlLnZhbHVlLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZihlLm5hbWUgPT09ICdzdWJqZWN0S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgdmFyIHNraSA9IG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCk7XG4gICAgZS5zdWJqZWN0S2V5SWRlbnRpZmllciA9IHNraS50b0hleCgpO1xuICAgIC8vIE9DVEVUU1RSSU5HIHcvZGlnZXN0XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNraS5nZXRCeXRlcygpKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ2F1dGhvcml0eUtleUlkZW50aWZpZXInICYmIG9wdGlvbnMuY2VydCkge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICBpZihlLmtleUlkZW50aWZpZXIpIHtcbiAgICAgIHZhciBrZXlJZGVudGlmaWVyID0gKGUua2V5SWRlbnRpZmllciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyKCkuZ2V0Qnl0ZXMoKSA6XG4gICAgICAgIGUua2V5SWRlbnRpZmllcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCBmYWxzZSwga2V5SWRlbnRpZmllcikpO1xuICAgIH1cblxuICAgIGlmKGUuYXV0aG9yaXR5Q2VydElzc3Vlcikge1xuICAgICAgdmFyIGF1dGhvcml0eUNlcnRJc3N1ZXIgPSBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgNCwgdHJ1ZSwgW1xuICAgICAgICAgIF9kblRvQXNuMShlLmF1dGhvcml0eUNlcnRJc3N1ZXIgPT09IHRydWUgP1xuICAgICAgICAgICAgb3B0aW9ucy5jZXJ0Lmlzc3VlciA6IGUuYXV0aG9yaXR5Q2VydElzc3VlcilcbiAgICAgICAgXSlcbiAgICAgIF07XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBhdXRob3JpdHlDZXJ0SXNzdWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5zZXJpYWxOdW1iZXIpIHtcbiAgICAgIHZhciBzZXJpYWxOdW1iZXIgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoZS5zZXJpYWxOdW1iZXIgPT09IHRydWUgP1xuICAgICAgICBvcHRpb25zLmNlcnQuc2VyaWFsTnVtYmVyIDogZS5zZXJpYWxOdW1iZXIpO1xuICAgICAgc2VxLnB1c2goXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgZmFsc2UsIHNlcmlhbE51bWJlcikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdjUkxEaXN0cmlidXRpb25Qb2ludHMnKSB7XG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIC8vIENyZWF0ZSBzdWIgU0VRVUVOQ0Ugb2YgRGlzdHJpYnV0aW9uUG9pbnROYW1lXG4gICAgdmFyIHN1YlNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bGxOYW1lR2VuZXJhbE5hbWVzLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgYWx0TmFtZS50eXBlLCBmYWxzZSxcbiAgICAgICAgdmFsdWUpKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gdGhlIHBhcmVudCBTRVFVRU5DRVxuICAgIHN1YlNlcS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW2Z1bGxOYW1lR2VuZXJhbE5hbWVzXSkpO1xuICAgIHNlcS5wdXNoKHN1YlNlcSk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsdWUgaGFzIGJlZW4gZGVmaW5lZCBieSBub3dcbiAgaWYodHlwZW9mIGUudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdFeHRlbnNpb24gdmFsdWUgbm90IHNwZWNpZmllZC4nKTtcbiAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBvYmplY3QgdG8gQVNOLjFcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2lkIFNpZ25hdHVyZSBhbGdvcml0aG0gT0lEXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBzaWduYXR1cmUgcGFyYW1ldHJzIG9iamVjdFxuICogQHJldHVybiBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIF9zaWduYXR1cmVQYXJhbWV0ZXJzVG9Bc24xKG9pZCwgcGFyYW1zKSB7XG4gIHN3aXRjaChvaWQpIHtcbiAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBpZihwYXJhbXMuaGFzaC5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pKTtcbiAgICB9XG5cbiAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMiwgdHJ1ZSwgW1xuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5OVUxMLCBmYWxzZSwgJycpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QncyBhdHRyaWJ1dGVzIHRvIGFuIEFTTi4xIHNldCBvZlxuICogQ1JJQXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0gY3NyIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBzZXQgb2YgQ1JJQXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX0NSSUF0dHJpYnV0ZXNUb0FzbjEoY3NyKSB7XG4gIC8vIGNyZWF0ZSBhbiBlbXB0eSBjb250ZXh0LXNwZWNpZmljIGNvbnRhaW5lclxuICB2YXIgcnZhbCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuXG4gIC8vIG5vIGF0dHJpYnV0ZXMsIHJldHVybiBlbXB0eSBjb250YWluZXJcbiAgaWYoY3NyLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyBlYWNoIGF0dHJpYnV0ZSBoYXMgYSBzZXF1ZW5jZSB3aXRoIGEgdHlwZSBhbmQgYSBzZXQgb2YgdmFsdWVzXG4gIHZhciBhdHRycyA9IGNzci5hdHRyaWJ1dGVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG5cbiAgICAvLyByZXVzZSB0YWcgY2xhc3MgZm9yIGF0dHJpYnV0ZSB2YWx1ZSBpZiBhdmFpbGFibGVcbiAgICB2YXIgdmFsdWVUYWdDbGFzcyA9IGFzbjEuVHlwZS5VVEY4O1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuICAgIH1cbiAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgodmFsdWUpO1xuICAgIH1cbiAgICB2YXIgdmFsdWVDb25zdHJ1Y3RlZCA9IGZhbHNlO1xuICAgIGlmKCd2YWx1ZUNvbnN0cnVjdGVkJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZUNvbnN0cnVjdGVkID0gYXR0ci52YWx1ZUNvbnN0cnVjdGVkO1xuICAgIH1cbiAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG5cbiAgICAvLyBjcmVhdGUgYSBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIHNldFxuICAgIC8vIGVhY2ggdmFsdWUgaW4gdGhlIHNldCBpcyBhbiBBdHRyaWJ1dGVUeXBlQW5kVmFsdWUgZmlyc3RcbiAgICAvLyBjb250YWluaW5nIHRoZSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgdGhlIHZhbHVlXG4gICAgdmFyIHNlcSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihhdHRyLnR5cGUpLmdldEJ5dGVzKCkpLFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVQsIHRydWUsIFtcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIHZhbHVlQ29uc3RydWN0ZWQsIHZhbHVlKVxuICAgICAgXSlcbiAgICBdKTtcbiAgICBydmFsLnZhbHVlLnB1c2goc2VxKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5jb25zdCBqYW5fMV8xOTUwID0gbmV3IERhdGUoJzE5NTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5jb25zdCBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG4gZnVuY3Rpb24gX2RhdGVUb0FzbjEoZGF0ZSl7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAgLy8gYXZvaWQgZHVwbGljYXRlIGNlcnRpZmljYXRlcyBpbiBzdG9yZVxuICAgICAgaWYoY2VydC5zdWJqZWN0Lmhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgICAvLyBzdWJqZWN0IGhhc2ggYWxyZWFkeSBleGlzdHMsIGFwcGVuZCB0byBhcnJheVxuICAgICAgICB2YXIgdG1wID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodG1wKSkge1xuICAgICAgICAgIHRtcCA9IFt0bXBdO1xuICAgICAgICB9XG4gICAgICAgIHRtcC5wdXNoKGNlcnQpO1xuICAgICAgICBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXSA9IHRtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gY2VydDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrIChlaXRoZXIgYSBwa2kuY2VydGlmaWNhdGUgb3IgYVxuICAgKiAgICAgICAgICBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBpbiB0aGUgc3RvcmUsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNhU3RvcmUuaGFzQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuICAgIGlmKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgbWF0Y2ggPSBbbWF0Y2hdO1xuICAgIH1cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBvZiB0aGUgY2VydGlmaWNhdGVzIGtlcHQgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgcGtpLmNlcnRpZmljYXRlIG9iamVjdHMgaW4gdGhlIHN0b3JlLlxuICAgKi9cbiAgY2FTdG9yZS5saXN0QWxsQ2VydGlmaWNhdGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlcnRMaXN0ID0gW107XG5cbiAgICBmb3IodmFyIGhhc2ggaW4gY2FTdG9yZS5jZXJ0cykge1xuICAgICAgaWYoY2FTdG9yZS5jZXJ0cy5oYXNPd25Qcm9wZXJ0eShoYXNoKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjYVN0b3JlLmNlcnRzW2hhc2hdO1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGNlcnRMaXN0LnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlcnRMaXN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2VydGlmaWNhdGUgZnJvbSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byByZW1vdmUgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0ZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwgaWYgdGhlIGNlcnRpZmljYXRlXG4gICAqICAgICAgICAgICB3YXNuJ3QgaW4gc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLnJlbW92ZUNlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IGdldEJ5U3ViamVjdChjZXJ0LnN1YmplY3QpO1xuXG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShtYXRjaCkpIHtcbiAgICAgIHJlc3VsdCA9IGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIERFUi1lbmNvZGluZyBvZiBjZXJ0aWZpY2F0ZXNcbiAgICB2YXIgZGVyMSA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKGNlcnQpKS5nZXRCeXRlcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGRlcjIgPSBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShtYXRjaFtpXSkpLmdldEJ5dGVzKCk7XG4gICAgICBpZihkZXIxID09PSBkZXIyKSB7XG4gICAgICAgIHJlc3VsdCA9IG1hdGNoW2ldO1xuICAgICAgICBtYXRjaC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG1hdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0QnlTdWJqZWN0KHN1YmplY3QpIHtcbiAgICBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KTtcbiAgICByZXR1cm4gY2FTdG9yZS5jZXJ0c1tzdWJqZWN0Lmhhc2hdIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdWJqZWN0SGFzSGFzaChzdWJqZWN0KSB7XG4gICAgLy8gcHJvZHVjZSBzdWJqZWN0IGhhc2ggaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmKCFzdWJqZWN0Lmhhc2gpIHtcbiAgICAgIHZhciBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBzdWJqZWN0LmF0dHJpYnV0ZXMgPSAgcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KF9kblRvQXNuMShzdWJqZWN0KSwgbWQpO1xuICAgICAgc3ViamVjdC5oYXNoID0gbWQuZGlnZXN0KCkudG9IZXgoKTtcbiAgICB9XG4gIH1cblxuICAvLyBhdXRvLWFkZCBwYXNzZWQgaW4gY2VydHNcbiAgaWYoY2VydHMpIHtcbiAgICAvLyBwYXJzZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlcyBhcyBuZWNlc3NhcnlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2VydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjZXJ0ID0gY2VydHNbaV07XG4gICAgICBjYVN0b3JlLmFkZENlcnRpZmljYXRlKGNlcnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYVN0b3JlO1xufTtcblxuLyoqXG4gKiBDZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24gZXJyb3JzLCBiYXNlZCBvbiBUTFMuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUVycm9yID0ge1xuICBiYWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuQmFkQ2VydGlmaWNhdGUnLFxuICB1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTogJ2ZvcmdlLnBraS5VbnN1cHBvcnRlZENlcnRpZmljYXRlJyxcbiAgY2VydGlmaWNhdGVfcmV2b2tlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZVJldm9rZWQnLFxuICBjZXJ0aWZpY2F0ZV9leHBpcmVkOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlRXhwaXJlZCcsXG4gIGNlcnRpZmljYXRlX3Vua25vd246ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVVbmtub3duJyxcbiAgdW5rbm93bl9jYTogJ2ZvcmdlLnBraS5Vbmtub3duQ2VydGlmaWNhdGVBdXRob3JpdHknXG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgY2VydGlmaWNhdGUgY2hhaW4gYWdhaW5zdCB0aGUgZ2l2ZW4gQ2VydGlmaWNhdGUgQXV0aG9yaXR5IHN0b3JlXG4gKiB3aXRoIGFuIG9wdGlvbmFsIGN1c3RvbSB2ZXJpZnkgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIGNhU3RvcmUgYSBjZXJ0aWZpY2F0ZSBzdG9yZSB0byB2ZXJpZnkgYWdhaW5zdC5cbiAqIEBwYXJhbSBjaGFpbiB0aGUgY2VydGlmaWNhdGUgY2hhaW4gdG8gdmVyaWZ5LCB3aXRoIHRoZSByb290IG9yIGhpZ2hlc3RcbiAqICAgICAgICAgIGF1dGhvcml0eSBhdCB0aGUgZW5kIChhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMpLlxuICogQHBhcmFtIHZlcmlmeSBjYWxsZWQgZm9yIGV2ZXJ5IGNlcnRpZmljYXRlIGluIHRoZSBjaGFpbi5cbiAqXG4gKiBUaGUgdmVyaWZ5IGNhbGxiYWNrIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiB2ZXJpZmllZCAtIFNldCB0byB0cnVlIGlmIGNlcnRpZmljYXRlIHdhcyB2ZXJpZmllZCwgb3RoZXJ3aXNlIHRoZVxuICogICBwa2kuY2VydGlmaWNhdGVFcnJvciBmb3Igd2h5IHRoZSBjZXJ0aWZpY2F0ZSBmYWlsZWQuXG4gKiBkZXB0aCAtIFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBjaGFpbiwgd2hlcmUgMCBpcyB0aGUgZW5kIHBvaW50J3MgY2VydC5cbiAqIGNlcnRzIC0gVGhlIGNlcnRpZmljYXRlIGNoYWluLCAqTk9URSogYW4gZW1wdHkgY2hhaW4gaW5kaWNhdGVzIGFuIGFub255bW91c1xuICogICBlbmQgcG9pbnQuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzIGFuZCBvbiBmYWlsdXJlIGVpdGhlciB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIG9yIGFuIG9iamVjdCB3aXRoICdlcnJvcicgc2V0IHRvIHRoZSBhcHByb3ByaWF0ZVxuICogcGtpLmNlcnRpZmljYXRlRXJyb3IgYW5kICdtZXNzYWdlJyBzZXQgdG8gYSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZXJyb3IgdGhyb3duIGlmIG5vdC5cbiAqL1xucGtpLnZlcmlmeUNlcnRpZmljYXRlQ2hhaW4gPSBmdW5jdGlvbihjYVN0b3JlLCBjaGFpbiwgdmVyaWZ5KSB7XG4gIC8qIEZyb206IFJGQzMyODAgLSBJbnRlcm5ldCBYLjUwOSBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIENlcnRpZmljYXRlXG4gICAgU2VjdGlvbiA2OiBDZXJ0aWZpY2F0aW9uIFBhdGggVmFsaWRhdGlvblxuICAgIFNlZSBpbmxpbmUgcGFyZW50aGV0aWNhbHMgcmVsYXRlZCB0byB0aGlzIHBhcnRpY3VsYXIgaW1wbGVtZW50YXRpb24uXG5cbiAgICBUaGUgcHJpbWFyeSBnb2FsIG9mIHBhdGggdmFsaWRhdGlvbiBpcyB0byB2ZXJpZnkgdGhlIGJpbmRpbmcgYmV0d2VlblxuICAgIGEgc3ViamVjdCBkaXN0aW5ndWlzaGVkIG5hbWUgb3IgYSBzdWJqZWN0IGFsdGVybmF0aXZlIG5hbWUgYW5kIHN1YmplY3RcbiAgICBwdWJsaWMga2V5LCBhcyByZXByZXNlbnRlZCBpbiB0aGUgZW5kIGVudGl0eSBjZXJ0aWZpY2F0ZSwgYmFzZWQgb24gdGhlXG4gICAgcHVibGljIGtleSBvZiB0aGUgdHJ1c3QgYW5jaG9yLiBUaGlzIHJlcXVpcmVzIG9idGFpbmluZyBhIHNlcXVlbmNlIG9mXG4gICAgY2VydGlmaWNhdGVzIHRoYXQgc3VwcG9ydCB0aGF0IGJpbmRpbmcuIFRoYXQgc2VxdWVuY2Ugc2hvdWxkIGJlIHByb3ZpZGVkXG4gICAgaW4gdGhlIHBhc3NlZCAnY2hhaW4nLiBUaGUgdHJ1c3QgYW5jaG9yIHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gQ0FcbiAgICBzdG9yZS4gVGhlICdlbmQgZW50aXR5JyBjZXJ0aWZpY2F0ZSBpcyB0aGUgY2VydGlmaWNhdGUgcHJvdmlkZWQgYnkgdGhlXG4gICAgZW5kIHBvaW50ICh0eXBpY2FsbHkgYSBzZXJ2ZXIpIGFuZCBpcyB0aGUgZmlyc3QgaW4gdGhlIGNoYWluLlxuXG4gICAgVG8gbWVldCB0aGlzIGdvYWwsIHRoZSBwYXRoIHZhbGlkYXRpb24gcHJvY2VzcyB2ZXJpZmllcywgYW1vbmcgb3RoZXJcbiAgICB0aGluZ3MsIHRoYXQgYSBwcm9zcGVjdGl2ZSBjZXJ0aWZpY2F0aW9uIHBhdGggKGEgc2VxdWVuY2Ugb2YgblxuICAgIGNlcnRpZmljYXRlcyBvciBhICdjaGFpbicpIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICAoYSkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG4tMX0sIHRoZSBzdWJqZWN0IG9mIGNlcnRpZmljYXRlIHggaXNcbiAgICAgICAgICB0aGUgaXNzdWVyIG9mIGNlcnRpZmljYXRlIHgrMTtcblxuICAgIChiKSBjZXJ0aWZpY2F0ZSAxIGlzIGlzc3VlZCBieSB0aGUgdHJ1c3QgYW5jaG9yO1xuXG4gICAgKGMpIGNlcnRpZmljYXRlIG4gaXMgdGhlIGNlcnRpZmljYXRlIHRvIGJlIHZhbGlkYXRlZDsgYW5kXG5cbiAgICAoZCkgZm9yIGFsbCB4IGluIHsxLCAuLi4sIG59LCB0aGUgY2VydGlmaWNhdGUgd2FzIHZhbGlkIGF0IHRoZVxuICAgICAgICAgIHRpbWUgaW4gcXVlc3Rpb24uXG5cbiAgICBOb3RlIHRoYXQgaGVyZSAnbicgaXMgaW5kZXggMCBpbiB0aGUgY2hhaW4gYW5kIDEgaXMgdGhlIGxhc3QgY2VydGlmaWNhdGVcbiAgICBpbiB0aGUgY2hhaW4gYW5kIGl0IG11c3QgYmUgc2lnbmVkIGJ5IGEgY2VydGlmaWNhdGUgaW4gdGhlIGNvbm5lY3Rpb24nc1xuICAgIENBIHN0b3JlLlxuXG4gICAgVGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIGFsc28gZGV0ZXJtaW5lcyB0aGUgc2V0IG9mIGNlcnRpZmljYXRlXG4gICAgcG9saWNpZXMgdGhhdCBhcmUgdmFsaWQgZm9yIHRoaXMgcGF0aCwgYmFzZWQgb24gdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzXG4gICAgZXh0ZW5zaW9uLCBwb2xpY3kgbWFwcGluZyBleHRlbnNpb24sIHBvbGljeSBjb25zdHJhaW50cyBleHRlbnNpb24sIGFuZFxuICAgIGluaGliaXQgYW55LXBvbGljeSBleHRlbnNpb24uXG5cbiAgICBOb3RlOiBQb2xpY3kgbWFwcGluZyBleHRlbnNpb24gbm90IHN1cHBvcnRlZCAoTm90IFJlcXVpcmVkKS5cblxuICAgIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0ZSBoYXMgYW4gdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uLCB0aGVuIGl0XG4gICAgbXVzdCBiZSByZWplY3RlZC5cblxuICAgIE5vdGU6IEEgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgaWYgdGhlIEROcyB0aGF0IGFwcGVhciBpbiB0aGUgc3ViamVjdFxuICAgIGFuZCBpc3N1ZXIgZmllbGRzIGFyZSBpZGVudGljYWwgYW5kIGFyZSBub3QgZW1wdHkuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIGFsZ29yaXRobSBhc3N1bWVzIHRoZSBmb2xsb3dpbmcgc2V2ZW4gaW5wdXRzIGFyZVxuICAgIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmcgbG9naWMuIFdoYXQgdGhpcyBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuICAgIHdpbGwgdXNlIGlzIHByb3ZpZGVkIHBhcmVudGhldGljYWxseTpcblxuICAgIChhKSBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCBvZiBsZW5ndGggbiAodGhlICdjaGFpbicpXG4gICAgKGIpIHRoZSBjdXJyZW50IGRhdGUvdGltZTogKCdub3cnKS5cbiAgICAoYykgdXNlci1pbml0aWFsLXBvbGljeS1zZXQ6IEEgc2V0IG9mIGNlcnRpZmljYXRlIHBvbGljeSBpZGVudGlmaWVyc1xuICAgICAgICAgIG5hbWluZyB0aGUgcG9saWNpZXMgdGhhdCBhcmUgYWNjZXB0YWJsZSB0byB0aGUgY2VydGlmaWNhdGUgdXNlci5cbiAgICAgICAgICBUaGUgdXNlci1pbml0aWFsLXBvbGljeS1zZXQgY29udGFpbnMgdGhlIHNwZWNpYWwgdmFsdWUgYW55LXBvbGljeVxuICAgICAgICAgIGlmIHRoZSB1c2VyIGlzIG5vdCBjb25jZXJuZWQgYWJvdXQgY2VydGlmaWNhdGUgcG9saWN5XG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZC4gQW55IHBvbGljeSBpcyBhY2NlcHRlZCkuXG4gICAgKGQpIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiwgZGVzY3JpYmluZyBhIENBIHRoYXQgc2VydmVzIGFzIGEgdHJ1c3RcbiAgICAgICAgICBhbmNob3IgZm9yIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb25cbiAgICAgICAgICBpbmNsdWRlczpcblxuICAgICAgKDEpICB0aGUgdHJ1c3RlZCBpc3N1ZXIgbmFtZSxcbiAgICAgICgyKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSBhbGdvcml0aG0sXG4gICAgICAoMykgIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXksIGFuZFxuICAgICAgKDQpICBvcHRpb25hbGx5LCB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IHBhcmFtZXRlcnMgYXNzb2NpYXRlZFxuICAgICAgICAgICAgIHdpdGggdGhlIHB1YmxpYyBrZXkuXG5cbiAgICAgIChUcnVzdCBhbmNob3JzIGFyZSBwcm92aWRlZCB2aWEgY2VydGlmaWNhdGVzIGluIHRoZSBDQSBzdG9yZSkuXG5cbiAgICAgIFRoZSB0cnVzdCBhbmNob3IgaW5mb3JtYXRpb24gbWF5IGJlIHByb3ZpZGVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBpbiB0aGUgZm9ybSBvZiBhIHNlbGYtc2lnbmVkIGNlcnRpZmljYXRlLiBUaGUgdHJ1c3RlZCBhbmNob3JcbiAgICAgIGluZm9ybWF0aW9uIGlzIHRydXN0ZWQgYmVjYXVzZSBpdCB3YXMgZGVsaXZlcmVkIHRvIHRoZSBwYXRoIHByb2Nlc3NpbmdcbiAgICAgIHByb2NlZHVyZSBieSBzb21lIHRydXN0d29ydGh5IG91dC1vZi1iYW5kIHByb2NlZHVyZS4gSWYgdGhlIHRydXN0ZWRcbiAgICAgIHB1YmxpYyBrZXkgYWxnb3JpdGhtIHJlcXVpcmVzIHBhcmFtZXRlcnMsIHRoZW4gdGhlIHBhcmFtZXRlcnMgYXJlXG4gICAgICBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgKE5vIHBhcmFtZXRlcnMgdXNlZCBpbiB0aGlzXG4gICAgICBpbXBsZW1lbnRhdGlvbikuXG5cbiAgICAoZSkgaW5pdGlhbC1wb2xpY3ktbWFwcGluZy1pbmhpYml0LCB3aGljaCBpbmRpY2F0ZXMgaWYgcG9saWN5IG1hcHBpbmcgaXNcbiAgICAgICAgICBhbGxvd2VkIGluIHRoZSBjZXJ0aWZpY2F0aW9uIHBhdGguXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgbm8gcG9saWN5IGNoZWNraW5nKVxuXG4gICAgKGYpIGluaXRpYWwtZXhwbGljaXQtcG9saWN5LCB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIHBhdGggbXVzdCBiZSB2YWxpZFxuICAgICAgICAgIGZvciBhdCBsZWFzdCBvbmUgb2YgdGhlIGNlcnRpZmljYXRlIHBvbGljaWVzIGluIHRoZSB1c2VyLWluaXRpYWwtXG4gICAgICAgICAgcG9saWN5LXNldC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZykgaW5pdGlhbC1hbnktcG9saWN5LWluaGliaXQsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZVxuICAgICAgICAgIGFueVBvbGljeSBPSUQgc2hvdWxkIGJlIHByb2Nlc3NlZCBpZiBpdCBpcyBpbmNsdWRlZCBpbiBhXG4gICAgICAgICAgY2VydGlmaWNhdGUuXG4gICAgICAgICAgKE5vdCBpbXBsZW1lbnRlZCwgc28gYW55IHBvbGljeSBpcyB2YWxpZCBwcm92aWRlZCB0aGF0IGl0IGlzXG4gICAgICAgICAgbm90IG1hcmtlZCBhcyBjcml0aWNhbCkgKi9cblxuICAvKiBCYXNpYyBQYXRoIFByb2Nlc3Npbmc6XG5cbiAgICBGb3IgZWFjaCBjZXJ0aWZpY2F0ZSBpbiB0aGUgJ2NoYWluJywgdGhlIGZvbGxvd2luZyBpcyBjaGVja2VkOlxuXG4gICAgMS4gVGhlIGNlcnRpZmljYXRlIHZhbGlkaXR5IHBlcmlvZCBpbmNsdWRlcyB0aGUgY3VycmVudCB0aW1lLlxuICAgIDIuIFRoZSBjZXJ0aWZpY2F0ZSB3YXMgc2lnbmVkIGJ5IGl0cyBwYXJlbnQgKHdoZXJlIHRoZSBwYXJlbnQgaXMgZWl0aGVyXG4gICAgICAgdGhlIG5leHQgaW4gdGhlIGNoYWluIG9yIGZyb20gdGhlIENBIHN0b3JlKS4gQWxsb3cgcHJvY2Vzc2luZyB0b1xuICAgICAgIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHN0ZXAgaWYgbm8gcGFyZW50IGlzIGZvdW5kIGJ1dCB0aGUgY2VydGlmaWNhdGUgaXNcbiAgICAgICBpbiB0aGUgQ0Egc3RvcmUuXG4gICAgMy4gVE9ETzogVGhlIGNlcnRpZmljYXRlIGhhcyBub3QgYmVlbiByZXZva2VkLlxuICAgIDQuIFRoZSBjZXJ0aWZpY2F0ZSBpc3N1ZXIgbmFtZSBtYXRjaGVzIHRoZSBwYXJlbnQncyBzdWJqZWN0IG5hbWUuXG4gICAgNS4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgb2YgWC41MDAgZGlzdGluZ3Vpc2hlZCBuYW1lc1xuICAgICAgIGFuZCB0aGF0IGVhY2ggb2YgdGhlIGFsdGVybmF0aXZlIG5hbWVzIGluIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb25cbiAgICAgICAoY3JpdGljYWwgb3Igbm9uLWNyaXRpY2FsKSBpcyB3aXRoaW4gb25lIG9mIHRoZSBwZXJtaXR0ZWQgc3VidHJlZXMgZm9yXG4gICAgICAgdGhhdCBuYW1lIHR5cGUuXG4gICAgNi4gVE9ETzogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHNlbGYtaXNzdWVkIGFuZCBub3QgdGhlIGZpbmFsIGNlcnRpZmljYXRlXG4gICAgICAgaW4gdGhlIGNoYWluLCBza2lwIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIHZlcmlmeSB0aGF0IHRoZSBzdWJqZWN0IG5hbWVcbiAgICAgICBpcyBub3Qgd2l0aGluIG9uZSBvZiB0aGUgZXhjbHVkZWQgc3VidHJlZXMgZm9yIFguNTAwIGRpc3Rpbmd1aXNoZWRcbiAgICAgICBuYW1lcyBhbmQgbm9uZSBvZiB0aGUgc3ViamVjdEFsdE5hbWUgZXh0ZW5zaW9uIG5hbWVzIGFyZSBleGNsdWRlZCBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA3LiBUaGUgb3RoZXIgc3RlcHMgaW4gdGhlIGFsZ29yaXRobSBmb3IgYmFzaWMgcGF0aCBwcm9jZXNzaW5nIGludm9sdmVcbiAgICAgICBoYW5kbGluZyB0aGUgcG9saWN5IGV4dGVuc2lvbiB3aGljaCBpcyBub3QgcHJlc2VudGx5IHN1cHBvcnRlZCBpbiB0aGlzXG4gICAgICAgaW1wbGVtZW50YXRpb24uIEluc3RlYWQsIGlmIGEgY3JpdGljYWwgcG9saWN5IGV4dGVuc2lvbiBpcyBmb3VuZCwgdGhlXG4gICAgICAgY2VydGlmaWNhdGUgaXMgcmVqZWN0ZWQgYXMgbm90IHN1cHBvcnRlZC5cbiAgICA4LiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgbm90IHRoZSBmaXJzdCBvciBpZiBpdHMgdGhlIG9ubHkgY2VydGlmaWNhdGUgaW5cbiAgICAgICB0aGUgY2hhaW4gKGhhdmluZyBubyBwYXJlbnQgZnJvbSB0aGUgQ0Egc3RvcmUgb3IgaXMgc2VsZi1zaWduZWQpIGFuZCBpdFxuICAgICAgIGhhcyBhIGNyaXRpY2FsIGtleSB1c2FnZSBleHRlbnNpb24sIHZlcmlmeSB0aGF0IHRoZSBrZXlDZXJ0U2lnbiBiaXQgaXNcbiAgICAgICBzZXQuIElmIHRoZSBrZXkgdXNhZ2UgZXh0ZW5zaW9uIGV4aXN0cywgdmVyaWZ5IHRoYXQgdGhlIGJhc2ljXG4gICAgICAgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cy4gSWYgdGhlIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiBleGlzdHMsXG4gICAgICAgdmVyaWZ5IHRoYXQgdGhlIGNBIGZsYWcgaXMgc2V0LiBJZiBwYXRoTGVuQ29uc3RyYWludCBpcyBzZXQsIGVuc3VyZSB0aGF0XG4gICAgICAgdGhlIG51bWJlciBvZiBjZXJ0aWZpY2F0ZXMgdGhhdCBwcmVjZWRlIGluIHRoZSBjaGFpbiAoY29tZSBlYXJsaWVyXG4gICAgICAgaW4gdGhlIGNoYWluIGFzIGltcGxlbWVudGVkIGJlbG93KSwgZXhjbHVkaW5nIHRoZSB2ZXJ5IGZpcnN0IGluIHRoZVxuICAgICAgIGNoYWluICh0eXBpY2FsbHkgdGhlIGVuZC1lbnRpdHkgb25lKSwgaXNuJ3QgZ3JlYXRlciB0aGFuIHRoZVxuICAgICAgIHBhdGhMZW5Db25zdHJhaW50LiBUaGlzIGNvbnN0cmFpbnQgbGltaXRzIHRoZSBudW1iZXIgb2YgaW50ZXJtZWRpYXRlXG4gICAgICAgQ0FzIHRoYXQgbWF5IGFwcGVhciBiZWxvdyBhIENBIGJlZm9yZSBvbmx5IGVuZC1lbnRpdHkgY2VydGlmaWNhdGVzXG4gICAgICAgbWF5IGJlIGlzc3VlZC4gKi9cblxuICAvLyBjb3B5IGNlcnQgY2hhaW4gcmVmZXJlbmNlcyB0byBhbm90aGVyIGFycmF5IHRvIHByb3RlY3QgYWdhaW5zdCBjaGFuZ2VzXG4gIC8vIGluIHZlcmlmeSBjYWxsYmFja1xuICBjaGFpbiA9IGNoYWluLnNsaWNlKDApO1xuICB2YXIgY2VydHMgPSBjaGFpbi5zbGljZSgwKTtcblxuICAvLyBnZXQgY3VycmVudCBkYXRlXG4gIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyAxLiBjaGVjayB2YWxpZCB0aW1lXG4gICAgaWYobm93IDwgY2VydC52YWxpZGl0eS5ub3RCZWZvcmUgfHwgbm93ID4gY2VydC52YWxpZGl0eS5ub3RBZnRlcikge1xuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5jZXJ0aWZpY2F0ZV9leHBpcmVkLFxuICAgICAgICBub3RCZWZvcmU6IGNlcnQudmFsaWRpdHkubm90QmVmb3JlLFxuICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgbm93OiBub3dcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gMi4gdmVyaWZ5IHdpdGggcGFyZW50IGZyb20gY2hhaW4gb3IgQ0Egc3RvcmVcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgcGFyZW50ID0gY2hhaW5bMF0gfHwgY2FTdG9yZS5nZXRJc3N1ZXIoY2VydCk7XG4gICAgICBpZihwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNlbGYtc2lnbmVkIGNlcnRcbiAgICAgICAgaWYoY2VydC5pc0lzc3VlcihjZXJ0KSkge1xuICAgICAgICAgIHNlbGZTaWduZWQgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudCA9IGNlcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYocGFyZW50KSB7XG4gICAgICAgIC8vIEZJWE1FOiBjdXJyZW50IENBIHN0b3JlIGltcGxlbWVudGF0aW9uIG1pZ2h0IGhhdmUgbXVsdGlwbGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGVzIHdoZXJlIHRoZSBpc3N1ZXIgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIHRoZVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZSAoaGFwcGVucyByYXJlbHkgd2l0aCwgZWc6IG9sZCBjZXJ0aWZpY2F0ZXMpIHNvIG5vcm1hbGl6ZVxuICAgICAgICAvLyBieSBhbHdheXMgcHV0dGluZyBwYXJlbnRzIGludG8gYW4gYXJyYXlcbiAgICAgICAgLy8gVE9ETzogdGhlcmUncyBtYXkgYmUgYW4gZXh0cmVtZSBkZWdlbmVyYXRlIGNhc2UgY3VycmVudGx5IHVuY292ZXJlZFxuICAgICAgICAvLyB3aGVyZSBhbiBvbGQgaW50ZXJtZWRpYXRlIGNlcnRpZmljYXRlIHNlZW1zIHRvIGhhdmUgYSBtYXRjaGluZyBwYXJlbnRcbiAgICAgICAgLy8gYnV0IG5vbmUgb2YgdGhlIHBhcmVudHMgYWN0dWFsbHkgdmVyaWZ5IC4uLiBidXQgdGhlIGludGVybWVkaWF0ZVxuICAgICAgICAvLyBpcyBpbiB0aGUgQ0EgYW5kIGl0IHNob3VsZCBwYXNzIHRoaXMgY2hlY2s7IG5lZWRzIGludmVzdGlnYXRpb25cbiAgICAgICAgdmFyIHBhcmVudHMgPSBwYXJlbnQ7XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkocGFyZW50cykpIHtcbiAgICAgICAgICBwYXJlbnRzID0gW3BhcmVudHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIHZlcmlmeSB3aXRoIGVhY2ggcG9zc2libGUgcGFyZW50ICh0eXBpY2FsbHkgb25seSBvbmUpXG4gICAgICAgIHZhciB2ZXJpZmllZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSghdmVyaWZpZWQgJiYgcGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50cy5zaGlmdCgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2ZXJpZmllZCA9IHBhcmVudC52ZXJpZnkoY2VydCk7XG4gICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgLy8gZmFpbHVyZSB0byB2ZXJpZnksIGRvbid0IGNhcmUgd2h5LCB0cnkgbmV4dCBvbmVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZighdmVyaWZpZWQpIHtcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBzaWduYXR1cmUgaXMgaW52YWxpZC4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkgJiZcbiAgICAgICAgIWNhU3RvcmUuaGFzQ2VydGlmaWNhdGUoY2VydCkpIHtcbiAgICAgICAgLy8gbm8gcGFyZW50IGlzc3VlciBhbmQgY2VydGlmaWNhdGUgaXRzZWxmIGlzIG5vdCB0cnVzdGVkXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdHJ1c3RlZC4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bmtub3duX2NhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogMy4gY2hlY2sgcmV2b2tlZFxuXG4gICAgLy8gNC4gY2hlY2sgZm9yIG1hdGNoaW5nIGlzc3Vlci9zdWJqZWN0XG4gICAgaWYoZXJyb3IgPT09IG51bGwgJiYgcGFyZW50ICYmICFjZXJ0LmlzSXNzdWVyKHBhcmVudCkpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgaXNzdWVyXG4gICAgICBlcnJvciA9IHtcbiAgICAgICAgbWVzc2FnZTogJ0NlcnRpZmljYXRlIGlzc3VlciBpcyBpbnZhbGlkLicsXG4gICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gNS4gVE9ETzogY2hlY2sgbmFtZXMgd2l0aCBwZXJtaXR0ZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNi4gVE9ETzogY2hlY2sgbmFtZXMgYWdhaW5zdCBleGNsdWRlZCBuYW1lcyB0cmVlXG5cbiAgICAvLyA3LiBjaGVjayBmb3IgdW5zdXBwb3J0ZWQgY3JpdGljYWwgZXh0ZW5zaW9uc1xuICAgIGlmKGVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgICAgdmFyIHNlID0ge1xuICAgICAgICBrZXlVc2FnZTogdHJ1ZSxcbiAgICAgICAgYmFzaWNDb25zdHJhaW50czogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGVycm9yID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgaWYoZXh0LmNyaXRpY2FsICYmICEoZXh0Lm5hbWUgaW4gc2UpKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUgaGFzIGFuIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbi4nLFxuICAgICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguIGNoZWNrIGZvciBDQSBpZiBjZXJ0IGlzIG5vdCBmaXJzdCBvciBpcyB0aGUgb25seSBjZXJ0aWZpY2F0ZVxuICAgIC8vIHJlbWFpbmluZyBpbiBjaGFpbiB3aXRoIG5vIHBhcmVudCBvciBpcyBzZWxmLXNpZ25lZFxuICAgIGlmKGVycm9yID09PSBudWxsICYmXG4gICAgICAoIWZpcnN0IHx8IChjaGFpbi5sZW5ndGggPT09IDAgJiYgKCFwYXJlbnQgfHwgc2VsZlNpZ25lZCkpKSkge1xuICAgICAgLy8gZmlyc3QgY2hlY2sga2V5VXNhZ2UgZXh0ZW5zaW9uIGFuZCB0aGVuIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICB2YXIgYmNFeHQgPSBjZXJ0LmdldEV4dGVuc2lvbignYmFzaWNDb25zdHJhaW50cycpO1xuICAgICAgdmFyIGtleVVzYWdlRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2tleVVzYWdlJyk7XG4gICAgICBpZihrZXlVc2FnZUV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBrZXlDZXJ0U2lnbiBtdXN0IGJlIHRydWUgYW5kIHRoZXJlIG11c3QgYmUgYSBiYXNpY1xuICAgICAgICAvLyBjb25zdHJhaW50cyBleHRlbnNpb25cbiAgICAgICAgaWYoIWtleVVzYWdlRXh0LmtleUNlcnRTaWduIHx8IGJjRXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAnQ2VydGlmaWNhdGUga2V5VXNhZ2Ugb3IgYmFzaWNDb25zdHJhaW50cyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICAgJ29yIGluZGljYXRlIHRoYXQgdGhlIGNlcnRpZmljYXRlIGlzIG5vdCBhIENBLiAnICtcbiAgICAgICAgICAgICAgJ0lmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0aGUgb25seSBvbmUgaW4gdGhlIGNoYWluIG9yICcgK1xuICAgICAgICAgICAgICAnaXNuXFwndCB0aGUgZmlyc3QgdGhlbiB0aGUgY2VydGlmaWNhdGUgbXVzdCBiZSBhICcgK1xuICAgICAgICAgICAgICAndmFsaWQgQ0EuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBiYXNpYyBjb25zdHJhaW50cyBjQSBmbGFnIG11c3QgYmUgc2V0XG4gICAgICBpZihlcnJvciA9PT0gbnVsbCAmJiBiY0V4dCAhPT0gbnVsbCAmJiAhYmNFeHQuY0EpIHtcbiAgICAgICAgLy8gYmFkIGNlcnRpZmljYXRlXG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBpbmRpY2F0ZXMgdGhlIGNlcnRpZmljYXRlICcgK1xuICAgICAgICAgICAgJ2lzIG5vdCBhIENBLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gaWYgZXJyb3IgaXMgbm90IG51bGwgYW5kIGtleVVzYWdlIGlzIGF2YWlsYWJsZSwgdGhlbiB3ZSBrbm93IGl0XG4gICAgICAvLyBoYXMga2V5Q2VydFNpZ24gYW5kIHRoZXJlIGlzIGEgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIHRvbyxcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHdlIGNhbiBjaGVjayBwYXRoTGVuQ29uc3RyYWludCAoaWYgaXQgZXhpc3RzKVxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYga2V5VXNhZ2VFeHQgIT09IG51bGwgJiZcbiAgICAgICAgJ3BhdGhMZW5Db25zdHJhaW50JyBpbiBiY0V4dCkge1xuICAgICAgICAvLyBwYXRoTGVuIGlzIHRoZSBtYXhpbXVtICMgb2YgaW50ZXJtZWRpYXRlIENBIGNlcnRzIHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGZvdW5kIGJldHdlZW4gdGhlIGN1cnJlbnQgY2VydGlmaWNhdGUgYW5kIHRoZSBlbmQtZW50aXR5IChkZXB0aCAwKVxuICAgICAgICAvLyBjZXJ0aWZpY2F0ZTsgdGhpcyBudW1iZXIgZG9lcyBub3QgaW5jbHVkZSB0aGUgZW5kLWVudGl0eSAoZGVwdGggMCxcbiAgICAgICAgLy8gbGFzdCBpbiB0aGUgY2hhaW4pIGV2ZW4gaWYgaXQgaGFwcGVucyB0byBiZSBhIENBIGNlcnRpZmljYXRlIGl0c2VsZlxuICAgICAgICB2YXIgcGF0aExlbiA9IGRlcHRoIC0gMTtcbiAgICAgICAgaWYocGF0aExlbiA+IGJjRXh0LnBhdGhMZW5Db25zdHJhaW50KSB7XG4gICAgICAgICAgLy8gcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQsIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgcGF0aExlbkNvbnN0cmFpbnQgdmlvbGF0ZWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbCBhcHBsaWNhdGlvbiBjYWxsYmFja1xuICAgIHZhciB2ZmQgPSAoZXJyb3IgPT09IG51bGwpID8gdHJ1ZSA6IGVycm9yLmVycm9yO1xuICAgIHZhciByZXQgPSB2ZXJpZnkgPyB2ZXJpZnkodmZkLCBkZXB0aCwgY2VydHMpIDogdmZkO1xuICAgIGlmKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gY2xlYXIgYW55IHNldCBlcnJvclxuICAgICAgZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBwYXNzZWQgYmFzaWMgdGVzdHMsIHNldCBkZWZhdWx0IG1lc3NhZ2UgYW5kIGFsZXJ0XG4gICAgICBpZih2ZmQgPT09IHRydWUpIHtcbiAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgbWVzc2FnZTogJ1RoZSBhcHBsaWNhdGlvbiByZWplY3RlZCB0aGUgY2VydGlmaWNhdGUuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBjdXN0b20gZXJyb3IgaW5mb1xuICAgICAgaWYocmV0IHx8IHJldCA9PT0gMCkge1xuICAgICAgICAvLyBzZXQgY3VzdG9tIG1lc3NhZ2UgYW5kIGVycm9yXG4gICAgICAgIGlmKHR5cGVvZiByZXQgPT09ICdvYmplY3QnICYmICFmb3JnZS51dGlsLmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgIGlmKHJldC5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IHJldC5tZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gc2V0IGN1c3RvbSBlcnJvclxuICAgICAgICAgIGVycm9yLmVycm9yID0gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRocm93IGVycm9yXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBubyBsb25nZXIgZmlyc3QgY2VydCBpbiBjaGFpblxuICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgKytkZXB0aDtcbiAgfSB3aGlsZShjaGFpbi5sZW5ndGggPiAwKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgUEtDUyMxIFBTUyBzaWduYXR1cmUgcGFkZGluZy5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIHNob3J0Y3V0IGZvciBQU1MgQVBJXG52YXIgcHNzID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wc3MgPSBmb3JnZS5wc3MgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIFBTUyBzaWduYXR1cmUgc2NoZW1lIG9iamVjdC5cbiAqXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCB3YXlzIHRvIHByb3ZpZGUgYSBzYWx0IGZvciBlbmNvZGluZzpcbiAqXG4gKiAxLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIG9ubHkgYW5kIHRoZSBidWlsdC1pbiBQUk5HIHdpbGwgZ2VuZXJhdGUgaXQuXG4gKiAyLiBTcGVjaWZ5IHRoZSBzYWx0TGVuZ3RoIGFuZCBhIGN1c3RvbSBQUk5HIHdpdGggJ2dldEJ5dGVzU3luYycgZGVmaW5lZCB0aGF0XG4gKiAgIHdpbGwgYmUgdXNlZC5cbiAqIDMuIFNwZWNpZnkgdGhlIHNhbHQgaXRzZWxmIGFzIGEgZm9yZ2UudXRpbC5CeXRlQnVmZmVyLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCBhIGZvcmdlIG1kIGluc3RhbmNlLlxuICogICAgICAgICAgbWdmIHRoZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gdG8gdXNlLCBhIGZvcmdlIG1nZiBpbnN0YW5jZS5cbiAqICAgICAgICAgIFtzYWx0TGVuZ3RoXSB0aGUgbGVuZ3RoIG9mIHRoZSBzYWx0IGluIG9jdGV0cy5cbiAqICAgICAgICAgIFtwcm5nXSB0aGUgcHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZSB0byBwcm9kdWNlIGEgc2FsdC5cbiAqICAgICAgICAgIFtzYWx0XSB0aGUgc2FsdCB0byB1c2Ugd2hlbiBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJuIGEgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKi9cbnBzcy5jcmVhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHcvbGVnYWN5IGFyZ3M6IGhhc2gsIG1nZiwgc0xlblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIG1kOiBhcmd1bWVudHNbMF0sXG4gICAgICBtZ2Y6IGFyZ3VtZW50c1sxXSxcbiAgICAgIHNhbHRMZW5ndGg6IGFyZ3VtZW50c1syXVxuICAgIH07XG4gIH1cblxuICB2YXIgaGFzaCA9IG9wdGlvbnMubWQ7XG4gIHZhciBtZ2YgPSBvcHRpb25zLm1nZjtcbiAgdmFyIGhMZW4gPSBoYXNoLmRpZ2VzdExlbmd0aDtcblxuICB2YXIgc2FsdF8gPSBvcHRpb25zLnNhbHQgfHwgbnVsbDtcbiAgaWYodHlwZW9mIHNhbHRfID09PSAnc3RyaW5nJykge1xuICAgIC8vIGFzc3VtZSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICBzYWx0XyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNhbHRfKTtcbiAgfVxuXG4gIHZhciBzTGVuO1xuICBpZignc2FsdExlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgIHNMZW4gPSBvcHRpb25zLnNhbHRMZW5ndGg7XG4gIH0gZWxzZSBpZihzYWx0XyAhPT0gbnVsbCkge1xuICAgIHNMZW4gPSBzYWx0Xy5sZW5ndGgoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uJyk7XG4gIH1cblxuICBpZihzYWx0XyAhPT0gbnVsbCAmJiBzYWx0Xy5sZW5ndGgoKSAhPT0gc0xlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2l2ZW4gc2FsdCBsZW5ndGggZG9lcyBub3QgbWF0Y2ggbGVuZ3RoIG9mIGdpdmVuIHNhbHQuJyk7XG4gIH1cblxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG5cbiAgdmFyIHBzc29iaiA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGEgUFNTIHNpZ25hdHVyZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUFNTLUVOQ09ERSBhcyBwZXIgUkZDIDM0NDcsIHNlY3Rpb24gOS4xLjEuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIG1vZHNCaXRzIHRoZSBsZW5ndGggb2YgdGhlIFJTQSBtb2R1bHVzIGluIGJpdHMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBsZW5ndGhcbiAgICogICAgICAgICAgIGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpLlxuICAgKi9cbiAgcHNzb2JqLmVuY29kZSA9IGZ1bmN0aW9uKG1kLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIDIuIExldCBtSGFzaCA9IEhhc2goTSksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICB2YXIgbUhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImVuY29kaW5nIGVycm9yXCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBpcyB0b28gbG9uZyB0byBlbmNyeXB0LicpO1xuICAgIH1cblxuICAgIC8qIDQuIEdlbmVyYXRlIGEgcmFuZG9tIG9jdGV0IHN0cmluZyBzYWx0IG9mIGxlbmd0aCBzTGVuOyBpZiBzTGVuID0gMCxcbiAgICAgKiAgICB0aGVuIHNhbHQgaXMgdGhlIGVtcHR5IHN0cmluZy4gKi9cbiAgICB2YXIgc2FsdDtcbiAgICBpZihzYWx0XyA9PT0gbnVsbCkge1xuICAgICAgc2FsdCA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHNMZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzYWx0ID0gc2FsdF8uYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgTScgPSAoMHgpMDAgMDAgMDAgMDAgMDAgMDAgMDAgMDAgfHwgbUhhc2ggfHwgc2FsdDsgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDYuIExldCBIID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGggPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiA3LiBHZW5lcmF0ZSBhbiBvY3RldCBzdHJpbmcgUFMgY29uc2lzdGluZyBvZiBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMlxuICAgICAqICAgIHplcm8gb2N0ZXRzLiAgVGhlIGxlbmd0aCBvZiBQUyBtYXkgYmUgMC4gKi9cbiAgICB2YXIgcHMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgcHMuZmlsbFdpdGhCeXRlKDAsIGVtTGVuIC0gc0xlbiAtIGhMZW4gLSAyKTtcblxuICAgIC8qIDguIExldCBEQiA9IFBTIHx8IDB4MDEgfHwgc2FsdDsgREIgaXMgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aFxuICAgICAqICAgIGVtTGVuIC0gaExlbiAtIDEuICovXG4gICAgcHMucHV0Qnl0ZSgweDAxKTtcbiAgICBwcy5wdXRCeXRlcyhzYWx0KTtcbiAgICB2YXIgZGIgPSBwcy5nZXRCeXRlcygpO1xuXG4gICAgLyogOS4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIGRiTWFzayA9IG1nZi5nZW5lcmF0ZShoLCBtYXNrTGVuKTtcblxuICAgIC8qIDEwLiBMZXQgbWFza2VkREIgPSBEQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIG1hc2tlZERCID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBtYXNrZWREQiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRiLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogMTEuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0IGluXG4gICAgICogICAgIG1hc2tlZERCIHRvIHplcm8uICovXG4gICAgdmFyIG1hc2sgPSAoMHhGRjAwID4+ICg4ICogZW1MZW4gLSBlbUJpdHMpKSAmIDB4RkY7XG4gICAgbWFza2VkREIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoMCkgJiB+bWFzaykgK1xuICAgICAgbWFza2VkREIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTIuIExldCBFTSA9IG1hc2tlZERCIHx8IEggfHwgMHhiYy5cbiAgICAgKiAxMy4gT3V0cHV0IEVNLiAqL1xuICAgIHJldHVybiBtYXNrZWREQiArIGggKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1WRVJJRlkgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4yLlxuICAgKlxuICAgKiBAcGFyYW0gbUhhc2ggdGhlIG1lc3NhZ2UgZGlnZXN0IGhhc2gsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nLCB0b1xuICAgKiAgICAgICAgIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLlxuICAgKiBAcGFyYW0gZW0gdGhlIGVuY29kZWQgbWVzc2FnZSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmdcbiAgICogICAgICAgICAgKFJTQSBkZWNyeXB0aW9uIHJlc3VsdCkuXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSB3YXMgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIHBzc29iai52ZXJpZnkgPSBmdW5jdGlvbihtSGFzaCwgZW0sIG1vZEJpdHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgZW1CaXRzID0gbW9kQml0cyAtIDE7XG4gICAgdmFyIGVtTGVuID0gTWF0aC5jZWlsKGVtQml0cyAvIDgpO1xuXG4gICAgLyogYy4gQ29udmVydCB0aGUgbWVzc2FnZSByZXByZXNlbnRhdGl2ZSBtIHRvIGFuIGVuY29kZWQgbWVzc2FnZSBFTVxuICAgICAqICAgIG9mIGxlbmd0aCBlbUxlbiA9IGNlaWwoKG1vZEJpdHMgLSAxKSAvIDgpIG9jdGV0cywgd2hlcmUgbW9kQml0c1xuICAgICAqICAgIGlzIHRoZSBsZW5ndGggaW4gYml0cyBvZiB0aGUgUlNBIG1vZHVsdXMgbiAqL1xuICAgIGVtID0gZW0uc3Vic3RyKC1lbUxlbik7XG5cbiAgICAvKiAzLiBJZiBlbUxlbiA8IGhMZW4gKyBzTGVuICsgMiwgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW1MZW4gPCBoTGVuICsgc0xlbiArIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IHBhcmFtZXRlcnMgdG8gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uJyk7XG4gICAgfVxuXG4gICAgLyogNC4gSWYgdGhlIHJpZ2h0bW9zdCBvY3RldCBvZiBFTSBkb2VzIG5vdCBoYXZlIGhleGFkZWNpbWFsIHZhbHVlXG4gICAgICogICAgMHhiYywgb3V0cHV0IFwiaW5jb25zaXN0ZW50XCIgYW5kIHN0b3AuICovXG4gICAgaWYoZW0uY2hhckNvZGVBdChlbUxlbiAtIDEpICE9PSAweGJjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kZWQgbWVzc2FnZSBkb2VzIG5vdCBlbmQgaW4gMHhCQy4nKTtcbiAgICB9XG5cbiAgICAvKiA1LiBMZXQgbWFza2VkREIgYmUgdGhlIGxlZnRtb3N0IGVtTGVuIC0gaExlbiAtIDEgb2N0ZXRzIG9mIEVNLCBhbmRcbiAgICAgKiAgICBsZXQgSCBiZSB0aGUgbmV4dCBoTGVuIG9jdGV0cy4gKi9cbiAgICB2YXIgbWFza0xlbiA9IGVtTGVuIC0gaExlbiAtIDE7XG4gICAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyKDAsIG1hc2tMZW4pO1xuICAgIHZhciBoID0gZW0uc3Vic3RyKG1hc2tMZW4sIGhMZW4pO1xuXG4gICAgLyogNi4gSWYgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgIG1hc2tlZERCIGFyZSBub3QgYWxsIGVxdWFsIHRvIHplcm8sIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIGlmKChtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgbWFzaykgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQml0cyBiZXlvbmQga2V5c2l6ZSBub3QgemVybyBhcyBleHBlY3RlZC4nKTtcbiAgICB9XG5cbiAgICAvKiA3LiBMZXQgZGJNYXNrID0gTUdGKEgsIGVtTGVuIC0gaExlbiAtIDEpLiAqL1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBtYXNrZWREQiBcXHhvciBkYk1hc2suICovXG4gICAgdmFyIGRiID0gJyc7XG4gICAgZm9yKGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XG4gICAgICBkYiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hc2tlZERCLmNoYXJDb2RlQXQoaSkgXiBkYk1hc2suY2hhckNvZGVBdChpKSk7XG4gICAgfVxuXG4gICAgLyogOS4gU2V0IHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXRcbiAgICAgKiBpbiBEQiB0byB6ZXJvLiAqL1xuICAgIGRiID0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KDApICYgfm1hc2spICsgZGIuc3Vic3RyKDEpO1xuXG4gICAgLyogMTAuIElmIHRoZSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMiBsZWZ0bW9zdCBvY3RldHMgb2YgREIgYXJlIG5vdCB6ZXJvXG4gICAgICogb3IgaWYgdGhlIG9jdGV0IGF0IHBvc2l0aW9uIGVtTGVuIC0gaExlbiAtIHNMZW4gLSAxICh0aGUgbGVmdG1vc3RcbiAgICAgKiBwb3NpdGlvbiBpcyBcInBvc2l0aW9uIDFcIikgZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZSAweDAxLFxuICAgICAqIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIHZhciBjaGVja0xlbiA9IGVtTGVuIC0gaExlbiAtIHNMZW4gLSAyO1xuICAgIGZvcihpID0gMDsgaSA8IGNoZWNrTGVuOyBpKyspIHtcbiAgICAgIGlmKGRiLmNoYXJDb2RlQXQoaSkgIT09IDB4MDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWZ0bW9zdCBvY3RldHMgbm90IHplcm8gYXMgZXhwZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihkYi5jaGFyQ29kZUF0KGNoZWNrTGVuKSAhPT0gMHgwMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbnNpc3RlbnQgUFNTIHNpZ25hdHVyZSwgMHgwMSBtYXJrZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgLyogMTEuIExldCBzYWx0IGJlIHRoZSBsYXN0IHNMZW4gb2N0ZXRzIG9mIERCLiAqL1xuICAgIHZhciBzYWx0ID0gZGIuc3Vic3RyKC1zTGVuKTtcblxuICAgIC8qIDEyLiAgTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQgKi9cbiAgICB2YXIgbV8gPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgbV8uZmlsbFdpdGhCeXRlKDAsIDgpO1xuICAgIG1fLnB1dEJ5dGVzKG1IYXNoKTtcbiAgICBtXy5wdXRCeXRlcyhzYWx0KTtcblxuICAgIC8qIDEzLiBMZXQgSCcgPSBIYXNoKE0nKSwgYW4gb2N0ZXQgc3RyaW5nIG9mIGxlbmd0aCBoTGVuLiAqL1xuICAgIGhhc2guc3RhcnQoKTtcbiAgICBoYXNoLnVwZGF0ZShtXy5nZXRCeXRlcygpKTtcbiAgICB2YXIgaF8gPSBoYXNoLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvKiAxNC4gSWYgSCA9IEgnLCBvdXRwdXQgXCJjb25zaXN0ZW50LlwiIE90aGVyd2lzZSwgb3V0cHV0IFwiaW5jb25zaXN0ZW50LlwiICovXG4gICAgcmV0dXJuIGggPT09IGhfO1xuICB9O1xuXG4gIHJldHVybiBwc3NvYmo7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBiYXNpYyBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAqIHN1cHBvcnQgZm9yIFJTQSBwdWJsaWMgYW5kIHByaXZhdGUga2V5cy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbl9fd2VicGFja19yZXF1aXJlX18oOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbl9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQuIFVzZSBwZW0uZGVjb2RlKCkgaW5zdGVhZC5cbiAqXG4gKiBDb252ZXJ0cyBQRU0tZm9ybWF0dGVkIGRhdGEgdG8gREVSLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBERVItZm9ybWF0dGVkIGRhdGEuXG4gKi9cbnBraS5wZW1Ub0RlciA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQRU0gdG8gREVSOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG4gIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwcml2YXRlIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiYgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBSSVZBVEUgS0VZXCIgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wcml2YXRlS2V5RnJvbUFzbjEob2JqKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHByaXZhdGUga2V5IHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wcml2YXRlS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBraSB0aGUgUHJpdmF0ZUtleUluZm8uXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUluZm9Ub1BlbSA9IGZ1bmN0aW9uKHBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBCYXNlLU4vQmFzZS1YIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBPcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBmcm9tIGJhc2UteDpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYmFzZS14XG4gKlxuICogV2hpY2ggaXMgTUlUIGxpY2Vuc2VkOlxuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xudmFyIGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGJhc2VOIGFscGhhYmV0IGluZGV4ZXNcbnZhciBfcmV2ZXJzZUFscGhhYmV0cyA9IHt9O1xuXG4vKipcbiAqIEJhc2VOLWVuY29kZXMgYSBVaW50OEFycmF5IHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFVpbnQ4QXJyYXkgdG8gZW5jb2RlLlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVuY29kZWQgY2hhcmFjdGVycyBwZXIgbGluZSB0byB1c2UsXG4gKiAgICAgICAgICBkZWZhdWx0cyB0byBub25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGJhc2VOLWVuY29kZWQgb3V0cHV0IHN0cmluZy5cbiAqL1xuYXBpLmVuY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCwgbWF4bGluZSkge1xuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYobWF4bGluZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBtYXhsaW5lICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibWF4bGluZVwiIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgaWYoIShpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgLy8gYXNzdW1lIGZvcmdlIGJ5dGUgYnVmZmVyXG4gICAgb3V0cHV0ID0gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgICB2YXIgZGlnaXRzID0gWzBdO1xuICAgIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0W2ldOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBiYXNlKSB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICBmb3IoaSA9IDA7IGlucHV0W2ldID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG91dHB1dCArPSBmaXJzdDtcbiAgICB9XG4gICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgb3V0cHV0ICs9IGFscGhhYmV0W2RpZ2l0c1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYobWF4bGluZSkge1xuICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJy57MSwnICsgbWF4bGluZSArICd9JywgJ2cnKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQubWF0Y2gocmVnZXgpLmpvaW4oJ1xcclxcbicpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2VOLWVuY29kZWQgKHVzaW5nIHRoZSBnaXZlbiBhbHBoYWJldCkgc3RyaW5nIHRvIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiYXNlTi1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5LlxuICovXG5hcGkuZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIGFscGhhYmV0KSB7XG4gIGlmKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgfVxuICBpZih0eXBlb2YgYWxwaGFiZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJhbHBoYWJldFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgdGFibGUgPSBfcmV2ZXJzZUFscGhhYmV0c1thbHBoYWJldF07XG4gIGlmKCF0YWJsZSkge1xuICAgIC8vIGNvbXB1dGUgcmV2ZXJzZSBhbHBoYWJldFxuICAgIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB0YWJsZVthbHBoYWJldC5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgdmFyIGJhc2UgPSBhbHBoYWJldC5sZW5ndGg7XG4gIHZhciBmaXJzdCA9IGFscGhhYmV0LmNoYXJBdCgwKTtcbiAgdmFyIGJ5dGVzID0gWzBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB0YWJsZVtpbnB1dC5jaGFyQ29kZUF0KGkpXTtcbiAgICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSB2YWx1ZTsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBieXRlc1tqXSAqIGJhc2U7XG4gICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgY2FycnkgPj49IDg7XG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKHZhciBrID0gMDsgaW5wdXRba10gPT09IGZpcnN0ICYmIGsgPCBpbnB1dC5sZW5ndGggLSAxOyArK2spIHtcbiAgICBieXRlcy5wdXNoKDApO1xuICB9XG5cbiAgaWYodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZXMucmV2ZXJzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpO1xufTtcblxuZnVuY3Rpb24gX2VuY29kZVdpdGhCeXRlQnVmZmVyKGlucHV0LCBhbHBoYWJldCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBkaWdpdHMgPSBbMF07XG4gIGZvcihpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCgpOyArK2kpIHtcbiAgICBmb3IodmFyIGogPSAwLCBjYXJyeSA9IGlucHV0LmF0KGkpOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgYmFzZTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cblxuICAgIHdoaWxlKGNhcnJ5ID4gMCkge1xuICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSBiYXNlKTtcbiAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXQgPSAnJztcblxuICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICBmb3IoaSA9IDA7IGlucHV0LmF0KGkpID09PSAwICYmIGkgPCBpbnB1dC5sZW5ndGgoKSAtIDE7ICsraSkge1xuICAgIG91dHB1dCArPSBmaXJzdDtcbiAgfVxuICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICBmb3IoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogU2VjdXJlIEhhc2ggQWxnb3JpdGhtIHdpdGggMjU2LWJpdCBkaWdlc3QgKFNIQS0yNTYpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFNlZSBGSVBTIDE4MC0yIGZvciBkZXRhaWxzLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTUgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9jcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcbiAgICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgZ2V0UmFuZG9tVmFsdWVzID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0ICYgMHhGRikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBSQzIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBJbmZvcm1hdGlvbiBvbiB0aGUgUkMyIGNpcGhlciBpcyBhdmFpbGFibGUgZnJvbSBSRkMgIzIyNjgsXG4gKiBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjY4LnR4dFxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIHBpVGFibGUgPSBbXG4gIDB4ZDksIDB4NzgsIDB4ZjksIDB4YzQsIDB4MTksIDB4ZGQsIDB4YjUsIDB4ZWQsIDB4MjgsIDB4ZTksIDB4ZmQsIDB4NzksIDB4NGEsIDB4YTAsIDB4ZDgsIDB4OWQsXG4gIDB4YzYsIDB4N2UsIDB4MzcsIDB4ODMsIDB4MmIsIDB4NzYsIDB4NTMsIDB4OGUsIDB4NjIsIDB4NGMsIDB4NjQsIDB4ODgsIDB4NDQsIDB4OGIsIDB4ZmIsIDB4YTIsXG4gIDB4MTcsIDB4OWEsIDB4NTksIDB4ZjUsIDB4ODcsIDB4YjMsIDB4NGYsIDB4MTMsIDB4NjEsIDB4NDUsIDB4NmQsIDB4OGQsIDB4MDksIDB4ODEsIDB4N2QsIDB4MzIsXG4gIDB4YmQsIDB4OGYsIDB4NDAsIDB4ZWIsIDB4ODYsIDB4YjcsIDB4N2IsIDB4MGIsIDB4ZjAsIDB4OTUsIDB4MjEsIDB4MjIsIDB4NWMsIDB4NmIsIDB4NGUsIDB4ODIsXG4gIDB4NTQsIDB4ZDYsIDB4NjUsIDB4OTMsIDB4Y2UsIDB4NjAsIDB4YjIsIDB4MWMsIDB4NzMsIDB4NTYsIDB4YzAsIDB4MTQsIDB4YTcsIDB4OGMsIDB4ZjEsIDB4ZGMsXG4gIDB4MTIsIDB4NzUsIDB4Y2EsIDB4MWYsIDB4M2IsIDB4YmUsIDB4ZTQsIDB4ZDEsIDB4NDIsIDB4M2QsIDB4ZDQsIDB4MzAsIDB4YTMsIDB4M2MsIDB4YjYsIDB4MjYsXG4gIDB4NmYsIDB4YmYsIDB4MGUsIDB4ZGEsIDB4NDYsIDB4NjksIDB4MDcsIDB4NTcsIDB4MjcsIDB4ZjIsIDB4MWQsIDB4OWIsIDB4YmMsIDB4OTQsIDB4NDMsIDB4MDMsXG4gIDB4ZjgsIDB4MTEsIDB4YzcsIDB4ZjYsIDB4OTAsIDB4ZWYsIDB4M2UsIDB4ZTcsIDB4MDYsIDB4YzMsIDB4ZDUsIDB4MmYsIDB4YzgsIDB4NjYsIDB4MWUsIDB4ZDcsXG4gIDB4MDgsIDB4ZTgsIDB4ZWEsIDB4ZGUsIDB4ODAsIDB4NTIsIDB4ZWUsIDB4ZjcsIDB4ODQsIDB4YWEsIDB4NzIsIDB4YWMsIDB4MzUsIDB4NGQsIDB4NmEsIDB4MmEsXG4gIDB4OTYsIDB4MWEsIDB4ZDIsIDB4NzEsIDB4NWEsIDB4MTUsIDB4NDksIDB4NzQsIDB4NGIsIDB4OWYsIDB4ZDAsIDB4NWUsIDB4MDQsIDB4MTgsIDB4YTQsIDB4ZWMsXG4gIDB4YzIsIDB4ZTAsIDB4NDEsIDB4NmUsIDB4MGYsIDB4NTEsIDB4Y2IsIDB4Y2MsIDB4MjQsIDB4OTEsIDB4YWYsIDB4NTAsIDB4YTEsIDB4ZjQsIDB4NzAsIDB4MzksXG4gIDB4OTksIDB4N2MsIDB4M2EsIDB4ODUsIDB4MjMsIDB4YjgsIDB4YjQsIDB4N2EsIDB4ZmMsIDB4MDIsIDB4MzYsIDB4NWIsIDB4MjUsIDB4NTUsIDB4OTcsIDB4MzEsXG4gIDB4MmQsIDB4NWQsIDB4ZmEsIDB4OTgsIDB4ZTMsIDB4OGEsIDB4OTIsIDB4YWUsIDB4MDUsIDB4ZGYsIDB4MjksIDB4MTAsIDB4NjcsIDB4NmMsIDB4YmEsIDB4YzksXG4gIDB4ZDMsIDB4MDAsIDB4ZTYsIDB4Y2YsIDB4ZTEsIDB4OWUsIDB4YTgsIDB4MmMsIDB4NjMsIDB4MTYsIDB4MDEsIDB4M2YsIDB4NTgsIDB4ZTIsIDB4ODksIDB4YTksXG4gIDB4MGQsIDB4MzgsIDB4MzQsIDB4MWIsIDB4YWIsIDB4MzMsIDB4ZmYsIDB4YjAsIDB4YmIsIDB4NDgsIDB4MGMsIDB4NWYsIDB4YjksIDB4YjEsIDB4Y2QsIDB4MmUsXG4gIDB4YzUsIDB4ZjMsIDB4ZGIsIDB4NDcsIDB4ZTUsIDB4YTUsIDB4OWMsIDB4NzcsIDB4MGEsIDB4YTYsIDB4MjAsIDB4NjgsIDB4ZmUsIDB4N2YsIDB4YzEsIDB4YWRcbl07XG5cbnZhciBzID0gWzEsIDIsIDMsIDVdO1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgbGVmdCBieSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBCaXRzIHRoYXQgYXJlIHNoaWZ0ZWQgb3V0IG9uIHRoZSBsZWZ0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgcmlnaHRcbiAqIGhhbmQgc2lkZS5cbiAqXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0byBzaGlmdCBsZWZ0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9sID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkIDw8IGJpdHMpICYgMHhmZmZmKSB8ICgod29yZCAmIDB4ZmZmZikgPj4gKDE2IC0gYml0cykpO1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSB3b3JkIHJpZ2h0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIHJpZ2h0IGFyZSBwdXQgYmFjayBpbiBvbiB0aGUgbGVmdFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IHJpZ2h0LlxuICogQHBhcmFtIGJpdHMgVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0IGJ5LlxuICogQHJldHVybiBUaGUgcm90YXRlZCB3b3JkLlxuICovXG52YXIgcm9yID0gZnVuY3Rpb24od29yZCwgYml0cykge1xuICByZXR1cm4gKCh3b3JkICYgMHhmZmZmKSA+PiBiaXRzKSB8ICgod29yZCA8PCAoMTYgLSBiaXRzKSkgJiAweGZmZmYpO1xufTtcblxuLyogUkMyIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5yYzIgPSBmb3JnZS5yYzIgfHwge307XG5cbi8qKlxuICogUGVyZm9ybSBSQzIga2V5IGV4cGFuc2lvbiBhcyBwZXIgUkZDICMyMjY4LCBzZWN0aW9uIDIuXG4gKlxuICogQHBhcmFtIGtleSB2YXJpYWJsZS1sZW5ndGggdXNlciBrZXkgKGJldHdlZW4gMSBhbmQgMTI4IGJ5dGVzKVxuICogQHBhcmFtIGVmZktleUJpdHMgbnVtYmVyIG9mIGVmZmVjdGl2ZSBrZXkgYml0cyAoZGVmYXVsdDogMTI4KVxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgUkMyIGtleSAoQnl0ZUJ1ZmZlciBvZiAxMjggYnl0ZXMpXG4gKi9cbmZvcmdlLnJjMi5leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGVmZktleUJpdHMpIHtcbiAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICB9XG4gIGVmZktleUJpdHMgPSBlZmZLZXlCaXRzIHx8IDEyODtcblxuICAvKiBpbnRyb2R1Y2UgdmFyaWFibGVzIHRoYXQgbWF0Y2ggdGhlIG5hbWVzIHVzZWQgaW4gUkZDICMyMjY4ICovXG4gIHZhciBMID0ga2V5O1xuICB2YXIgVCA9IGtleS5sZW5ndGgoKTtcbiAgdmFyIFQxID0gZWZmS2V5Qml0cztcbiAgdmFyIFQ4ID0gTWF0aC5jZWlsKFQxIC8gOCk7XG4gIHZhciBUTSA9IDB4ZmYgPj4gKFQxICYgMHgwNyk7XG4gIHZhciBpO1xuXG4gIGZvcihpID0gVDsgaSA8IDEyODsgaSsrKSB7XG4gICAgTC5wdXRCeXRlKHBpVGFibGVbKEwuYXQoaSAtIDEpICsgTC5hdChpIC0gVCkpICYgMHhmZl0pO1xuICB9XG5cbiAgTC5zZXRBdCgxMjggLSBUOCwgcGlUYWJsZVtMLmF0KDEyOCAtIFQ4KSAmIFRNXSk7XG5cbiAgZm9yKGkgPSAxMjcgLSBUODsgaSA+PSAwOyBpLS0pIHtcbiAgICBMLnNldEF0KGksIHBpVGFibGVbTC5hdChpICsgMSkgXiBMLmF0KGkgKyBUOCldKTtcbiAgfVxuXG4gIHJldHVybiBMO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUkMyIGNpcGhlciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKGFzIGJhc2UgZm9yIGtleSBnZW5lcmF0aW9uKS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzLlxuICogQHBhcmFtIGVuY3J5cHQgZmFsc2UgZm9yIGRlY3J5cHRpb24sIHRydWUgZm9yIGVuY3J5cHRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG52YXIgY3JlYXRlQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzLCBlbmNyeXB0KSB7XG4gIHZhciBfZmluaXNoID0gZmFsc2UsIF9pbnB1dCA9IG51bGwsIF9vdXRwdXQgPSBudWxsLCBfaXYgPSBudWxsO1xuICB2YXIgbWl4Um91bmQsIG1hc2hSb3VuZDtcbiAgdmFyIGksIGosIEsgPSBbXTtcblxuICAvKiBFeHBhbmQga2V5IGFuZCBmaWxsIGludG8gS1tdIEFycmF5ICovXG4gIGtleSA9IGZvcmdlLnJjMi5leHBhbmRLZXkoa2V5LCBiaXRzKTtcbiAgZm9yKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgIEsucHVzaChrZXkuZ2V0SW50MTZMZSgpKTtcbiAgfVxuXG4gIGlmKGVuY3J5cHQpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtaXhpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1peGluZyBvbi5cbiAgICAgKi9cbiAgICBtaXhSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgUltpXSA9IHJvbChSW2ldLCBzW2ldKTtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSBtYXNoaW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtYXNoaW5nIG9uLlxuICAgICAqL1xuICAgIG1hc2hSb3VuZCA9IGZ1bmN0aW9uKFIpIHtcbiAgICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBSW2ldICs9IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldID0gcm9yKFJbaV0sIHNbaV0pO1xuICAgICAgICBSW2ldIC09IEtbal0gKyAoUlsoaSArIDMpICUgNF0gJiBSWyhpICsgMikgJSA0XSkgK1xuICAgICAgICAgICgoflJbKGkgKyAzKSAlIDRdKSAmIFJbKGkgKyAxKSAlIDRdKTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIG9uZSByLW1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICBSW2ldIC09IEtbUlsoaSArIDMpICUgNF0gJiA2M107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gdGhlIHNwZWNpZmllZCBjaXBoZXIgZXhlY3V0aW9uIHBsYW4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgZm91ciB3b3JkcyBmcm9tIHRoZSBpbnB1dCBidWZmZXIsIGFwcGxpZXMgdGhlIElWIG9uXG4gICAqIGl0IChpZiByZXF1ZXN0ZWQpIGFuZCBydW5zIHRoZSBwcm92aWRlZCBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhlIHBsYW4gbXVzdCBiZSBwdXQgdG9nZXRoZXIgaW4gZm9ybSBvZiBhIGFycmF5IG9mIGFycmF5cy4gIFdoZXJlIHRoZVxuICAgKiBvdXRlciBvbmUgaXMgc2ltcGx5IGEgbGlzdCBvZiBzdGVwcyB0byBwZXJmb3JtIGFuZCB0aGUgaW5uZXIgb25lIG5lZWRzXG4gICAqIHRvIGhhdmUgdHdvIGVsZW1lbnRzOiB0aGUgZmlyc3Qgb25lIHRlbGxpbmcgaG93IG1hbnkgcm91bmRzIHRvIHBlcmZvcm0sXG4gICAqIHRoZSBzZWNvbmQgb25lIHRlbGxpbmcgd2hhdCB0byBkbyAoaS5lLiB0aGUgZnVuY3Rpb24gdG8gY2FsbCkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBsYW4gVGhlIHBsYW4gdG8gZXhlY3V0ZS5cbiAgICovXG4gIHZhciBydW5QbGFuID0gZnVuY3Rpb24ocGxhbikge1xuICAgIHZhciBSID0gW107XG5cbiAgICAvKiBHZXQgZGF0YSBmcm9tIGlucHV0IGJ1ZmZlciBhbmQgZmlsbCB0aGUgZm91ciB3b3JkcyBpbnRvIFIgKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBfaW5wdXQuZ2V0SW50MTZMZSgpO1xuXG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcsIGFwcGx5IHRoZSBJViBmaXJzdC4gKi9cbiAgICAgICAgICB2YWwgXj0gX2l2LmdldEludDE2TGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBXZSdyZSBkZWNyeXB0aW9uLCBrZWVwIGNpcGhlciB0ZXh0IGZvciBuZXh0IGJsb2NrLiAqL1xuICAgICAgICAgIF9pdi5wdXRJbnQxNkxlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUi5wdXNoKHZhbCAmIDB4ZmZmZik7XG4gICAgfVxuXG4gICAgLyogUmVzZXQgZ2xvYmFsIFwialwiIHZhcmlhYmxlIGFzIHBlciBzcGVjLiAqL1xuICAgIGogPSBlbmNyeXB0ID8gMCA6IDYzO1xuXG4gICAgLyogUnVuIGV4ZWN1dGlvbiBwbGFuLiAqL1xuICAgIGZvcih2YXIgcHRyID0gMDsgcHRyIDwgcGxhbi5sZW5ndGg7IHB0cisrKSB7XG4gICAgICBmb3IodmFyIGN0ciA9IDA7IGN0ciA8IHBsYW5bcHRyXVswXTsgY3RyKyspIHtcbiAgICAgICAgcGxhbltwdHJdWzFdKFIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIFdyaXRlIGJhY2sgcmVzdWx0IHRvIG91dHB1dCBidWZmZXIuICovXG4gICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBpZihfaXYgIT09IG51bGwpIHtcbiAgICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICAgIC8qIFdlJ3JlIGVuY3J5cHRpbmcgaW4gQ0JDLW1vZGUsIGZlZWQgYmFjayBlbmNyeXB0ZWQgYnl0ZXMgaW50b1xuICAgICAgICAgICAgIElWIGJ1ZmZlciB0byBjYXJyeSBpdCBmb3J3YXJkIHRvIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUoUltpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUltpXSBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9vdXRwdXQucHV0SW50MTZMZShSW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyogQ3JlYXRlIGNpcGhlciBvYmplY3QgKi9cbiAgdmFyIGNpcGhlciA9IG51bGw7XG4gIGNpcGhlciA9IHtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgb3IgcmVzdGFydHMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLCB3aGljaGV2ZXJcbiAgICAgKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSBjaXBoZXIgaW4gQ0JDIG1vZGUsIGl2IG1heSBiZSBnaXZlbiBlaXRoZXIgYXMgYSBzdHJpbmdcbiAgICAgKiBvZiBieXRlcywgb3IgYXMgYSBieXRlIGJ1ZmZlci4gIEZvciBFQ0IgbW9kZSwgZ2l2ZSBudWxsIGFzIGl2LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLCBudWxsIGZvciBFQ0IgbW9kZS5cbiAgICAgKiBAcGFyYW0gb3V0cHV0IHRoZSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbihpdiwgb3V0cHV0KSB7XG4gICAgICBpZihpdikge1xuICAgICAgICAvKiBDQkMgbW9kZSAqL1xuICAgICAgICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2ZpbmlzaCA9IGZhbHNlO1xuICAgICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vdXRwdXQgPSBvdXRwdXQgfHwgbmV3IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBfaXYgPSBpdjtcblxuICAgICAgY2lwaGVyLm91dHB1dCA9IF9vdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gICAgICovXG4gICAgdXBkYXRlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIV9maW5pc2gpIHtcbiAgICAgICAgLy8gbm90IGZpbmlzaGluZywgc28gZmlsbCB0aGUgaW5wdXQgYnVmZmVyIHdpdGggbW9yZSBpbnB1dFxuICAgICAgICBfaW5wdXQucHV0QnVmZmVyKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoX2lucHV0Lmxlbmd0aCgpID49IDgpIHtcbiAgICAgICAgcnVuUGxhbihbXG4gICAgICAgICAgICBbIDUsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA2LCBtaXhSb3VuZCBdLFxuICAgICAgICAgICAgWyAxLCBtYXNoUm91bmQgXSxcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXVxuICAgICAgICAgIF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyBlbmNyeXB0aW5nIG9yIGRlY3J5cHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFkIGEgcGFkZGluZyBmdW5jdGlvbiB0byB1c2UsIG51bGwgZm9yIFBLQ1MjNyBwYWRkaW5nLFxuICAgICAqICAgICAgICAgICBzaWduYXR1cmUoYmxvY2tTaXplLCBidWZmZXIsIGRlY3J5cHQpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICAgICAqL1xuICAgIGZpbmlzaDogZnVuY3Rpb24ocGFkKSB7XG4gICAgICB2YXIgcnZhbCA9IHRydWU7XG5cbiAgICAgIGlmKGVuY3J5cHQpIHtcbiAgICAgICAgaWYocGFkKSB7XG4gICAgICAgICAgcnZhbCA9IHBhZCg4LCBfaW5wdXQsICFlbmNyeXB0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gICAgICAgICAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAoX2lucHV0Lmxlbmd0aCgpID09PSA4KSA/IDggOiAoOCAtIF9pbnB1dC5sZW5ndGgoKSk7XG4gICAgICAgICAgX2lucHV0LmZpbGxXaXRoQnl0ZShwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsKSB7XG4gICAgICAgIC8vIGRvIGZpbmFsIHVwZGF0ZVxuICAgICAgICBfZmluaXNoID0gdHJ1ZTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZighZW5jcnlwdCkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2sgc2l6ZVxuICAgICAgICBydmFsID0gKF9pbnB1dC5sZW5ndGgoKSA9PT0gMCk7XG4gICAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICAgIHJ2YWwgPSBwYWQoOCwgX291dHB1dCwgIWVuY3J5cHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgcGFkZGluZyBieXRlIGNvdW50IGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgbGVuID0gX291dHB1dC5sZW5ndGgoKTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IF9vdXRwdXQuYXQobGVuIC0gMSk7XG5cbiAgICAgICAgICAgIGlmKGNvdW50ID4gbGVuKSB7XG4gICAgICAgICAgICAgIHJ2YWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgICAgICAgICAgICAgX291dHB1dC50cnVuY2F0ZShjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXJcbiAqIG9mIHRoZSByZXR1cm5lZCBjaXBoZXIuXG4gKlxuICogVGhlIGtleSBhbmQgaXYgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKiBUaGUgY2lwaGVyIGlzIGluaXRpYWxpemVkIHRvIHVzZSAxMjggZWZmZWN0aXZlIGtleSBiaXRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0KSB7XG4gIHZhciBjaXBoZXIgPSBmb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcihrZXksIDEyOCk7XG4gIGNpcGhlci5zdGFydChpdiwgb3V0cHV0KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqXG4gKiBUaGUga2V5IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRvIHN0YXJ0IGVuY3J5cHRpbmcgY2FsbCBzdGFydCgpIG9uIHRoZSBjaXBoZXIgd2l0aCBhbiBpdiBhbmQgb3B0aW9uYWxcbiAqIG91dHB1dCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlciA9IGZ1bmN0aW9uKGtleSwgYml0cykge1xuICByZXR1cm4gY3JlYXRlQ2lwaGVyKGtleSwgYml0cywgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZGVjcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCBmYWxzZSk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBQYXJ0aWFsIGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSB2Mi4yOiBSU0EtT0VBUFxuICpcbiAqIE1vZGlmaWVkIGJ1dCBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIE1JVCBhbmQgQlNEIGxpY2Vuc2VkIGNvZGU6XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2tqdXIvanNqd3MvYmxvYi9tYXN0ZXIvcnNhLmpzOlxuICpcbiAqIFRoZSAnanNqd3MnKEpTT04gV2ViIFNpZ25hdHVyZSBKYXZhU2NyaXB0IExpYnJhcnkpIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgS2VuamkgVXJ1c2hpbWFcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIGh0dHA6Ly93ZWJyc2EuY3ZzLnNvdXJjZWZvcmdlLm5ldC92aWV3dmMvd2VicnNhL0NsaWVudC9SU0FFUy1PQUVQLmpzP2NvbnRlbnQtdHlwZT10ZXh0JTJGcGxhaW46XG4gKlxuICogUlNBRVMtT0FFUC5qc1xuICogJElkOiBSU0FFUy1PQUVQLmpzLHYgMS4xLjEuMSAyMDAzLzAzLzE5IDE1OjM3OjIwIGVsbGlzcHJpdGNoYXJkIEV4cCAkXG4gKiBKYXZhU2NyaXB0IEltcGxlbWVudGF0aW9uIG9mIFBLQ1MgIzEgdjIuMSBSU0EgQ1JZUFRPR1JBUEhZIFNUQU5EQVJEIChSU0EgTGFib3JhdG9yaWVzLCBKdW5lIDE0LCAyMDAyKVxuICogQ29weXJpZ2h0IChDKSBFbGxpcyBQcml0Y2hhcmQsIEd1YXJkaWFuIFVubGltaXRlZCAyMDAzLlxuICogQ29udGFjdDogZWxsaXNAbnVraW5ldGljcy5jb21cbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqXG4gKiBPZmZpY2lhbCBkb2N1bWVudGF0aW9uOiBodHRwOi8vd3d3LnJzYS5jb20vcnNhbGFicy9ub2RlLmFzcD9pZD0yMTI1XG4gKlxuICogQGF1dGhvciBFdmFuIEpvbmVzIChodHRwOi8vZXZhbmpvbmVzLmNhLylcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbi8vIHNob3J0Y3V0IGZvciBQS0NTIzEgQVBJXG52YXIgcGtjczEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3MxID0gZm9yZ2UucGtjczEgfHwge307XG5cbi8qKlxuICogRW5jb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIG1lc3NhZ2UgKE0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbCBsYWJlbCAoTClcbiAqIGFuZCBzZWVkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGVuY3J5cHRpb24sIGl0IG9ubHkgZW5jb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIHNlZWQgdGhlIHNlZWQgdG8gdXNlLlxuICogICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UsIHVuZGVmaW5lZCBmb3IgU0hBLTEuXG4gKiAgICAgICAgICBtZ2YxIG9wdGlvbmFsIG1nZjEgcGFyYW1ldGVyczpcbiAqICAgICAgICAgICAgbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB0byB1c2UgZm9yIE1HRjEuXG4gKlxuICogQHJldHVybiB0aGUgZW5jb2RlZCBtZXNzYWdlIGJ5dGVzLlxuICovXG5wa2NzMS5lbmNvZGVfcnNhX29hZXAgPSBmdW5jdGlvbihrZXksIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgLy8gcGFyc2UgYXJndW1lbnRzXG4gIHZhciBsYWJlbDtcbiAgdmFyIHNlZWQ7XG4gIHZhciBtZDtcbiAgdmFyIG1nZjFNZDtcbiAgLy8gbGVnYWN5IGFyZ3MgKGxhYmVsLCBzZWVkLCBtZClcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zO1xuICAgIHNlZWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gYXJndW1lbnRzWzRdIHx8IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgdW5kZWZpbmVkO1xuICAgIHNlZWQgPSBvcHRpb25zLnNlZWQgfHwgdW5kZWZpbmVkO1xuICAgIG1kID0gb3B0aW9ucy5tZCB8fCB1bmRlZmluZWQ7XG4gICAgaWYob3B0aW9ucy5tZ2YxICYmIG9wdGlvbnMubWdmMS5tZCkge1xuICAgICAgbWdmMU1kID0gb3B0aW9ucy5tZ2YxLm1kO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlZmF1bHQgT0FFUCB0byBTSEEtMSBtZXNzYWdlIGRpZ2VzdFxuICBpZighbWQpIHtcbiAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgbWQuc3RhcnQoKTtcbiAgfVxuXG4gIC8vIGRlZmF1bHQgTUdGLTEgdG8gc2FtZSBhcyBPQUVQXG4gIGlmKCFtZ2YxTWQpIHtcbiAgICBtZ2YxTWQgPSBtZDtcbiAgfVxuXG4gIC8vIGNvbXB1dGUgbGVuZ3RoIGluIGJ5dGVzIGFuZCBjaGVjayBvdXRwdXRcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuICB2YXIgbWF4TGVuZ3RoID0ga2V5TGVuZ3RoIC0gMiAqIG1kLmRpZ2VzdExlbmd0aCAtIDI7XG4gIGlmKG1lc3NhZ2UubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoO1xuICAgIGVycm9yLm1heExlbmd0aCA9IG1heExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGlmKCFsYWJlbCkge1xuICAgIGxhYmVsID0gJyc7XG4gIH1cbiAgbWQudXBkYXRlKGxhYmVsLCAncmF3Jyk7XG4gIHZhciBsSGFzaCA9IG1kLmRpZ2VzdCgpO1xuXG4gIHZhciBQUyA9ICcnO1xuICB2YXIgUFNfbGVuZ3RoID0gbWF4TGVuZ3RoIC0gbWVzc2FnZS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICBQUyArPSAnXFx4MDAnO1xuICB9XG5cbiAgdmFyIERCID0gbEhhc2guZ2V0Qnl0ZXMoKSArIFBTICsgJ1xceDAxJyArIG1lc3NhZ2U7XG5cbiAgaWYoIXNlZWQpIHtcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG1kLmRpZ2VzdExlbmd0aCk7XG4gIH0gZWxzZSBpZihzZWVkLmxlbmd0aCAhPT0gbWQuZGlnZXN0TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgJyArXG4gICAgICAnbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguJyk7XG4gICAgZXJyb3Iuc2VlZExlbmd0aCA9IHNlZWQubGVuZ3RoO1xuICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkREIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKERCLCBkYk1hc2ssIERCLmxlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHNlZWQsIHNlZWRNYXNrLCBzZWVkLmxlbmd0aCk7XG5cbiAgLy8gcmV0dXJuIGVuY29kZWQgbWVzc2FnZVxuICByZXR1cm4gJ1xceDAwJyArIG1hc2tlZFNlZWQgKyBtYXNrZWREQjtcbn07XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSAoRU0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbFxuICogbGFiZWwgKEwpLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGRlY3J5cHRpb24sIGl0IG9ubHkgZGVjb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBlbSB0aGUgZW5jb2RlZCBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBPQUVQLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmdzXG4gIHZhciBsYWJlbDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJnc1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgbWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXNcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlbS5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWRMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYobWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgaWYoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAga2V5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGhhc2ggZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIC8vIHNwbGl0IHRoZSBtZXNzYWdlIGludG8gaXRzIHBhcnRzXG4gIHZhciB5ID0gZW0uY2hhckF0KDApO1xuICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyaW5nKDEgKyBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBzZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWRTZWVkLCBzZWVkTWFzaywgbWFza2VkU2VlZC5sZW5ndGgpO1xuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgZGIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZERCLCBkYk1hc2ssIG1hc2tlZERCLmxlbmd0aCk7XG5cbiAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIHRoYXQgYWxsIHZhbHVlcyBtYXRjaCB3aGF0IGlzIGV4cGVjdGVkXG4gIHZhciBlcnJvciA9ICh5ICE9PSAnXFx4MDAnKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIGxIYXNoIHZzIGxIYXNoUHJpbWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgZXJyb3IgfD0gKGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSkpO1xuICB9XG5cbiAgLy8gXCJjb25zdGFudCB0aW1lXCIgZmluZCB0aGUgMHgxIGJ5dGUgc2VwYXJhdGluZyB0aGUgcGFkZGluZyAoemVyb3MpIGZyb20gdGhlXG4gIC8vIG1lc3NhZ2VcbiAgLy8gVE9ETzogSXQgbXVzdCBiZSBwb3NzaWJsZSB0byBkbyB0aGlzIGluIGEgYmV0dGVyL3NtYXJ0ZXIgd2F5P1xuICB2YXIgaW5fcHMgPSAxO1xuICB2YXIgaW5kZXggPSBtZC5kaWdlc3RMZW5ndGg7XG4gIGZvcih2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGNvZGUgPSBkYi5jaGFyQ29kZUF0KGopO1xuXG4gICAgdmFyIGlzXzAgPSAoY29kZSAmIDB4MSkgXiAweDE7XG5cbiAgICAvLyBub24temVybyBpZiBub3QgMCBvciAxIGluIHRoZSBwcyBzZWN0aW9uXG4gICAgdmFyIGVycm9yX21hc2sgPSBpbl9wcyA/IDB4ZmZmZSA6IDB4MDAwMDtcbiAgICBlcnJvciB8PSAoY29kZSAmIGVycm9yX21hc2spO1xuXG4gICAgLy8gbGF0Y2ggaW5fcHMgdG8gemVybyBhZnRlciB3ZSBmaW5kIDB4MVxuICAgIGluX3BzID0gaW5fcHMgJiBpc18wO1xuICAgIGluZGV4ICs9IGluX3BzO1xuICB9XG5cbiAgaWYoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuJyk7XG4gIH1cblxuICByZXR1cm4gZGIuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG5mdW5jdGlvbiByc2FfbWdmMShzZWVkLCBtYXNrTGVuZ3RoLCBoYXNoKSB7XG4gIC8vIGRlZmF1bHQgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIWhhc2gpIHtcbiAgICBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuICB2YXIgdCA9ICcnO1xuICB2YXIgY291bnQgPSBNYXRoLmNlaWwobWFza0xlbmd0aCAvIGhhc2guZGlnZXN0TGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaSA+PiAyNCkgJiAweEZGLCAoaSA+PiAxNikgJiAweEZGLCAoaSA+PiA4KSAmIDB4RkYsIGkgJiAweEZGKTtcbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUoc2VlZCArIGMpO1xuICAgIHQgKz0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiB0LnN1YnN0cmluZygwLCBtYXNrTGVuZ3RoKTtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogUHJpbWUgbnVtYmVyIGdlbmVyYXRpb24gQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4oZnVuY3Rpb24oKSB7XG5cbi8vIGZvcmdlLnByaW1lIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucHJpbWUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZTtcbiAgcmV0dXJuO1xufVxuXG4vKiBQUklNRSBBUEkgKi9cbnZhciBwcmltZSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJpbWUgPSBmb3JnZS5wcmltZSB8fCB7fTtcblxudmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIHByaW1lcyBhcmUgMzBrK2kgZm9yIGkgPSAxLCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5XG52YXIgR0NEXzMwX0RFTFRBID0gWzYsIDQsIDIsIDQsIDIsIDQsIDYsIDJdO1xudmFyIFRISVJUWSA9IG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xuVEhJUlRZLmZyb21JbnQoMzApO1xudmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4fHk7fTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcHJvYmFibGUgcHJpbWUgd2l0aCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQWx0ZXJuYXRpdmUgYWxnb3JpdGhtcyBjYW4gYmUgc3BlY2lmaWVkIGJ5IG5hbWUgYXMgYSBzdHJpbmcgb3IgYXMgYW5cbiAqIG9iamVjdCB3aXRoIGN1c3RvbSBvcHRpb25zIGxpa2Ugc286XG4gKlxuICoge1xuICogICBuYW1lOiAnUFJJTUVJTkMnLFxuICogICBvcHRpb25zOiB7XG4gKiAgICAgbWF4QmxvY2tUaW1lOiA8dGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gYmxvY2sgdGhlIG1haW5cbiAqICAgICAgIHRocmVhZCBiZWZvcmUgYWxsb3dpbmcgSS9PIG90aGVyIEpTIHRvIHJ1bj4sXG4gKiAgICAgbWlsbGVyUmFiaW5UZXN0czogPHRoZSBudW1iZXIgb2YgbWlsbGVyLXJhYmluIHRlc3RzIHRvIHJ1bj4sXG4gKiAgICAgd29ya2VyU2NyaXB0OiA8dGhlIHdvcmtlciBzY3JpcHQgVVJMPixcbiAqICAgICB3b3JrZXJzOiA8dGhlIG51bWJlciBvZiB3ZWIgd29ya2VycyAoaWYgc3VwcG9ydGVkKSB0byB1c2UsXG4gKiAgICAgICAtMSB0byB1c2UgZXN0aW1hdGVkIGNvcmVzIG1pbnVzIG9uZT4uXG4gKiAgICAgd29ya0xvYWQ6IHRoZSBzaXplIG9mIHRoZSB3b3JrIGxvYWQsIGllOiBudW1iZXIgb2YgcG9zc2libGUgcHJpbWVcbiAqICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgbnVtYmVyIG9mIGJpdHMgZm9yIHRoZSBwcmltZSBudW1iZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBbYWxnb3JpdGhtXSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiAgICAgICAgICBbcHJuZ10gYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuXG4gKlxuICogQHJldHVybiBjYWxsYmFjayhlcnIsIG51bSkgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZSA9IGZ1bmN0aW9uKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBkZWZhdWx0IHRvIFBSSU1FSU5DIGFsZ29yaXRobVxuICB2YXIgYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJztcbiAgaWYodHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycpIHtcbiAgICBhbGdvcml0aG0gPSB7bmFtZTogYWxnb3JpdGhtfTtcbiAgfVxuICBhbGdvcml0aG0ub3B0aW9ucyA9IGFsZ29yaXRobS5vcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNyZWF0ZSBwcm5nIHdpdGggYXBpIHRoYXQgbWF0Y2hlcyBCaWdJbnRlZ2VyIHNlY3VyZSByYW5kb21cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuICB2YXIgcm5nID0ge1xuICAgIC8vIHggaXMgYW4gYXJyYXkgdG8gZmlsbCB3aXRoIGJ5dGVzXG4gICAgbmV4dEJ5dGVzOiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgYiA9IHBybmcuZ2V0Qnl0ZXNTeW5jKHgubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmKGFsZ29yaXRobS5uYW1lID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgYWxnb3JpdGhtLm9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmltZSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobS5uYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoJ3dvcmtlcnMnIGluIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRob3V0V29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIGluaXRpYWxpemUgcmFuZG9tIG51bWJlclxuICB2YXIgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcblxuICAvKiBOb3RlOiBBbGwgcHJpbWVzIGFyZSBvZiB0aGUgZm9ybSAzMGsraSBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEuIFRoZVxuICBudW1iZXIgd2UgYXJlIGdpdmVuIGlzIGFsd2F5cyBhbGlnbmVkIGF0IDMwayArIDEuIEVhY2ggdGltZSB0aGUgbnVtYmVyIGlzXG4gIGRldGVybWluZWQgbm90IHRvIGJlIHByaW1lIHdlIGFkZCB0byBnZXQgdG8gdGhlIG5leHQgJ2knLCBlZzogaWYgdGhlIG51bWJlclxuICB3YXMgYXQgMzBrICsgMSB3ZSBhZGQgNi4gKi9cbiAgdmFyIGRlbHRhSWR4ID0gMDtcblxuICAvLyBnZXQgcmVxdWlyZWQgbnVtYmVyIG9mIE1SIHRlc3RzXG4gIHZhciBtclRlc3RzID0gZ2V0TWlsbGVyUmFiaW5UZXN0cyhudW0uYml0TGVuZ3RoKCkpO1xuICBpZignbWlsbGVyUmFiaW5UZXN0cycgaW4gb3B0aW9ucykge1xuICAgIG1yVGVzdHMgPSBvcHRpb25zLm1pbGxlclJhYmluVGVzdHM7XG4gIH1cblxuICAvLyBmaW5kIHByaW1lIG5lYXJlc3QgdG8gJ251bScgZm9yIG1heEJsb2NrVGltZSBtc1xuICAvLyAxMCBtcyBnaXZlcyA1bXMgb2YgbGVld2F5IGZvciBvdGhlciBjYWxjdWxhdGlvbnMgYmVmb3JlIGRyb3BwaW5nXG4gIC8vIGJlbG93IDYwZnBzICgxMDAwLzYwID09IDE2LjY3KSwgYnV0IGluIHJlYWxpdHksIHRoZSBudW1iZXIgd2lsbFxuICAvLyBsaWtlbHkgYmUgaGlnaGVyIGR1ZSB0byBhbiAnYXRvbWljJyBiaWcgaW50IG1vZFBvd1xuICB2YXIgbWF4QmxvY2tUaW1lID0gMTA7XG4gIGlmKCdtYXhCbG9ja1RpbWUnIGluIG9wdGlvbnMpIHtcbiAgICBtYXhCbG9ja1RpbWUgPSBvcHRpb25zLm1heEJsb2NrVGltZTtcbiAgfVxuXG4gIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBzdGFydCA9ICtuZXcgRGF0ZSgpO1xuICBkbyB7XG4gICAgLy8gb3ZlcmZsb3csIHJlZ2VuZXJhdGUgcmFuZG9tIG51bWJlclxuICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgfVxuICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgaWYobnVtLmlzUHJvYmFibGVQcmltZShtclRlc3RzKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bSk7XG4gICAgfVxuICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgIG51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICB9IHdoaWxlKG1heEJsb2NrVGltZSA8IDAgfHwgKCtuZXcgRGF0ZSgpIC0gc3RhcnQgPCBtYXhCbG9ja1RpbWUpKTtcblxuICAvLyBrZWVwIHRyeWluZyBsYXRlclxuICBmb3JnZS51dGlsLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfcHJpbWVpbmMobnVtLCBiaXRzLCBybmcsIGRlbHRhSWR4LCBtclRlc3RzLCBtYXhCbG9ja1RpbWUsIGNhbGxiYWNrKTtcbiAgfSk7XG59XG5cbi8vIE5PVEU6IFRoaXMgYWxnb3JpdGhtIGlzIGluZGV0ZXJtaW5hdGUgaW4gbmF0dXJlIGJlY2F1c2Ugd29ya2Vyc1xuLy8gcnVuIGluIHBhcmFsbGVsIGxvb2tpbmcgYXQgZGlmZmVyZW50IHNlZ21lbnRzIG9mIG51bWJlcnMuIEV2ZW4gaWYgdGhpc1xuLy8gYWxnb3JpdGhtIGlzIHJ1biB0d2ljZSB3aXRoIHRoZSBzYW1lIGlucHV0IGZyb20gYSBwcmVkaWN0YWJsZSBSTkcsIGl0XG4vLyBtYXkgcHJvZHVjZSBkaWZmZXJlbnQgb3V0cHV0cy5cbmZ1bmN0aW9uIHByaW1laW5jRmluZFByaW1lV2l0aFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyB3ZWIgd29ya2VycyB1bmF2YWlsYWJsZVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8vIHVzZSB3ZWIgd29ya2VycyB0byBnZW5lcmF0ZSBrZXlzXG4gIHZhciBudW1Xb3JrZXJzID0gb3B0aW9ucy53b3JrZXJzO1xuICB2YXIgd29ya0xvYWQgPSBvcHRpb25zLndvcmtMb2FkIHx8IDEwMDtcbiAgdmFyIHJhbmdlID0gd29ya0xvYWQgKiAzMCAvIDg7XG4gIHZhciB3b3JrZXJTY3JpcHQgPSBvcHRpb25zLndvcmtlclNjcmlwdCB8fCAnZm9yZ2UvcHJpbWUud29ya2VyLmpzJztcbiAgaWYobnVtV29ya2VycyA9PT0gLTEpIHtcbiAgICByZXR1cm4gZm9yZ2UudXRpbC5lc3RpbWF0ZUNvcmVzKGZ1bmN0aW9uKGVyciwgY29yZXMpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICAvLyBkZWZhdWx0IHRvIDJcbiAgICAgICAgY29yZXMgPSAyO1xuICAgICAgfVxuICAgICAgbnVtV29ya2VycyA9IGNvcmVzIC0gMTtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGUoKTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEgd29ya2VyXG4gICAgbnVtV29ya2VycyA9IE1hdGgubWF4KDEsIG51bVdvcmtlcnMpO1xuXG4gICAgLy8gVE9ETzogY29uc2lkZXIgb3B0aW1pemluZyBieSBzdGFydGluZyB3b3JrZXJzIG91dHNpZGUgZ2V0UHJpbWUoKSAuLi5cbiAgICAvLyBub3RlIHRoYXQgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhleSB3aWxsIGhhdmUgdG8gYmUgbWFkZSBpbnRlcm5hbGx5XG4gICAgLy8gYXN5bmNocm9ub3VzIHdoaWNoIG1heSBhY3R1YWxseSBiZSBzbG93ZXJcblxuICAgIC8vIHN0YXJ0IHdvcmtlcnMgaW1tZWRpYXRlbHlcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIC8vIEZJWE1FOiBmaXggcGF0aCBvciB1c2UgYmxvYiBVUkxzXG4gICAgICB3b3JrZXJzW2ldID0gbmV3IFdvcmtlcih3b3JrZXJTY3JpcHQpO1xuICAgIH1cbiAgICB2YXIgcnVubmluZyA9IG51bVdvcmtlcnM7XG5cbiAgICAvLyBsaXN0ZW4gZm9yIHJlcXVlc3RzIGZyb20gd29ya2VycyBhbmQgYXNzaWduIHJhbmdlcyB0byBmaW5kIHByaW1lXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgd29ya2Vyc1tpXS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyogTm90ZTogVGhlIGRpc3RyaWJ1dGlvbiBvZiByYW5kb20gbnVtYmVycyBpcyB1bmtub3duLiBUaGVyZWZvcmUsIGVhY2hcbiAgICB3ZWIgd29ya2VyIGlzIGNvbnRpbnVvdXNseSBhbGxvY2F0ZWQgYSByYW5nZSBvZiBudW1iZXJzIHRvIGNoZWNrIGZvciBhXG4gICAgcmFuZG9tIG51bWJlciB1bnRpbCBvbmUgaXMgZm91bmQuXG5cbiAgICBFdmVyeSAzMCBudW1iZXJzIHdpbGwgYmUgY2hlY2tlZCBqdXN0IDggdGltZXMsIGJlY2F1c2UgcHJpbWUgbnVtYmVyc1xuICAgIGhhdmUgdGhlIGZvcm06XG5cbiAgICAzMGsraSwgZm9yIGkgPCAzMCBhbmQgZ2NkKDMwLCBpKT0xICh0aGVyZSBhcmUgOCB2YWx1ZXMgb2YgaSBmb3IgdGhpcylcblxuICAgIFRoZXJlZm9yZSwgaWYgd2Ugd2FudCBhIHdlYiB3b3JrZXIgdG8gcnVuIE4gY2hlY2tzIGJlZm9yZSBhc2tpbmcgZm9yXG4gICAgYSBuZXcgcmFuZ2Ugb2YgbnVtYmVycywgZWFjaCByYW5nZSBtdXN0IGNvbnRhaW4gTiozMC84IG51bWJlcnMuXG5cbiAgICBGb3IgMTAwIGNoZWNrcyAod29ya0xvYWQpLCB0aGlzIGlzIGEgcmFuZ2Ugb2YgMzc1LiAqL1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gd29ya2VyTWVzc2FnZShlKSB7XG4gICAgICAvLyBpZ25vcmUgbWVzc2FnZSwgcHJpbWUgYWxyZWFkeSBmb3VuZFxuICAgICAgaWYoZm91bmQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAtLXJ1bm5pbmc7XG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgIGlmKGRhdGEuZm91bmQpIHtcbiAgICAgICAgLy8gdGVybWluYXRlIGFsbCB3b3JrZXJzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB3b3JrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQmlnSW50ZWdlcihkYXRhLnByaW1lLCAxNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgICBpZihudW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFzc2lnbiBuZXcgcmFuZ2UgdG8gY2hlY2tcbiAgICAgIHZhciBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuXG4gICAgICAvLyBzdGFydCBwcmltZSBzZWFyY2hcbiAgICAgIGUudGFyZ2V0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaGV4OiBoZXgsXG4gICAgICAgIHdvcmtMb2FkOiB3b3JrTG9hZFxuICAgICAgfSk7XG5cbiAgICAgIG51bS5kQWRkT2Zmc2V0KHJhbmdlLCAwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIHVzaW5nIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cyBhbmQgUk5HLlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIG51bWJlci5cbiAqIEBwYXJhbSBybmcgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpIHtcbiAgdmFyIG51bSA9IG5ldyBCaWdJbnRlZ2VyKGJpdHMsIHJuZyk7XG4gIC8vIGZvcmNlIE1TQiBzZXRcbiAgdmFyIGJpdHMxID0gYml0cyAtIDE7XG4gIGlmKCFudW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICBudW0uYml0d2lzZVRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChiaXRzMSksIG9wX29yLCBudW0pO1xuICB9XG4gIC8vIGFsaWduIG51bWJlciBvbiAzMGsrMSBib3VuZGFyeVxuICBudW0uZEFkZE9mZnNldCgzMSAtIG51bS5tb2QoVEhJUlRZKS5ieXRlVmFsdWUoKSwgMCk7XG4gIHJldHVybiBudW07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIE1pbGxlci1SYWJpbiB0ZXN0cyB0byBnZW5lcmF0ZSBhXG4gKiBwcmltZSB3aXRoIGFuIGVycm9yIHByb2JhYmlsaXR5IG9mICgxLzIpXjgwLlxuICpcbiAqIFNlZSBIYW5kYm9vayBvZiBBcHBsaWVkIENyeXB0b2dyYXBoeSBDaGFwdGVyIDQsIFRhYmxlIDQuNC5cbiAqXG4gKiBAcGFyYW0gYml0cyB0aGUgYml0IHNpemUuXG4gKlxuICogQHJldHVybiB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGdldE1pbGxlclJhYmluVGVzdHMoYml0cykge1xuICBpZihiaXRzIDw9IDEwMCkgcmV0dXJuIDI3O1xuICBpZihiaXRzIDw9IDE1MCkgcmV0dXJuIDE4O1xuICBpZihiaXRzIDw9IDIwMCkgcmV0dXJuIDE1O1xuICBpZihiaXRzIDw9IDI1MCkgcmV0dXJuIDEyO1xuICBpZihiaXRzIDw9IDMwMCkgcmV0dXJuIDk7XG4gIGlmKGJpdHMgPD0gMzUwKSByZXR1cm4gODtcbiAgaWYoYml0cyA8PSA0MDApIHJldHVybiA3O1xuICBpZihiaXRzIDw9IDUwMCkgcmV0dXJuIDY7XG4gIGlmKGJpdHMgPD0gNjAwKSByZXR1cm4gNTtcbiAgaWYoYml0cyA8PSA4MDApIHJldHVybiA0O1xuICBpZihiaXRzIDw9IDEyNTApIHJldHVybiAzO1xuICByZXR1cm4gMjtcbn1cblxufSkoKTtcblxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEyLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBQS0NTIzEyIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgZnRwOi8vZnRwLnJzYXNlY3VyaXR5LmNvbS9wdWIvcGtjcy9wa2NzLTEyL3BrY3MtMTItdGMxLnBkZiBmb3IgZGV0YWlscylcbiAqXG4gKiBQRlggOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgSU5URUdFUiB7djMoMyl9KHYzLC4uLiksXG4gKiAgIGF1dGhTYWZlIENvbnRlbnRJbmZvLFxuICogICBtYWNEYXRhICBNYWNEYXRhIE9QVElPTkFMXG4gKiB9XG4gKlxuICogTWFjRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICBtYWMgRGlnZXN0SW5mbyxcbiAqICAgbWFjU2FsdCBPQ1RFVCBTVFJJTkcsXG4gKiAgIGl0ZXJhdGlvbnMgSU5URUdFUiBERUZBVUxUIDFcbiAqIH1cbiAqIE5vdGU6IFRoZSBpdGVyYXRpb25zIGRlZmF1bHQgaXMgZm9yIGhpc3RvcmljYWwgcmVhc29ucyBhbmQgaXRzIHVzZSBpc1xuICogZGVwcmVjYXRlZC4gQSBoaWdoZXIgdmFsdWUsIGxpa2UgMTAyNCwgaXMgcmVjb21tZW5kZWQuXG4gKlxuICogRGlnZXN0SW5mbyBpcyBkZWZpbmVkIGluIFBLQ1MjNyBhcyBmb2xsb3dzOlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIFNIQTEgdGhlcmUgaXMgbm9uZS5cbiAqXG4gKiBBbGdvcml0aG1JZGVudGlmZXIgOjo9IFNFUVVFTkNFIHtcbiAqICAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAqXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgIFswXSBFWFBMSUNJVCBBTlkgREVGSU5FRCBCWSBjb250ZW50VHlwZSBPUFRJT05BTFxuICogfVxuICpcbiAqIENvbnRlbnRUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICpcbiAqIEF1dGhlbnRpY2F0ZWRTYWZlIDo6PSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1xuICogLS0gRGF0YSBpZiB1bmVuY3J5cHRlZFxuICogLS0gRW5jcnlwdGVkRGF0YSBpZiBwYXNzd29yZC1lbmNyeXB0ZWRcbiAqIC0tIEVudmVsb3BlZERhdGEgaWYgcHVibGljIGtleS1lbmNyeXB0ZWRcbiAqXG4gKlxuICogU2FmZUNvbnRlbnRzIDo6PSBTRVFVRU5DRSBPRiBTYWZlQmFnXG4gKlxuICogU2FmZUJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBiYWdJZCAgICAgQkFHLVRZUEUuJmlkICh7UEtDUzEyQmFnU2V0fSlcbiAqICAgYmFnVmFsdWUgIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSh7UEtDUzEyQmFnU2V0fXtAYmFnSWR9KSxcbiAqICAgYmFnQXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogUEtDUzEyQXR0cmlidXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGF0dHJJZCBBVFRSSUJVVEUuJmlkICh7UEtDUzEyQXR0clNldH0pLFxuICogICBhdHRyVmFsdWVzIFNFVCBPRiBBVFRSSUJVVEUuJlR5cGUgKHtQS0NTMTJBdHRyU2V0fXtAYXR0cklkfSlcbiAqIH0gLS0gVGhpcyB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgWC41MDAgdHlwZSDigJlBdHRyaWJ1dGXigJlcbiAqXG4gKiBQS0NTMTJBdHRyU2V0IEFUVFJJQlVURSA6Oj0ge1xuICogICBmcmllbmRseU5hbWUgfCAtLSBmcm9tIFBLQ1MgIzlcbiAqICAgbG9jYWxLZXlJZCwgLS0gZnJvbSBQS0NTICM5XG4gKiAgIC4uLiAtLSBPdGhlciBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkXG4gKiB9XG4gKlxuICogQ2VydEJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjZXJ0SWQgICAgQkFHLVRZUEUuJmlkICAgKHtDZXJ0VHlwZXN9KSxcbiAqICAgY2VydFZhbHVlIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSAoe0NlcnRUeXBlc317QGNlcnRJZH0pXG4gKiB9XG4gKlxuICogeDUwOUNlcnRpZmljYXRlIEJBRy1UWVBFIDo6PSB7T0NURVQgU1RSSU5HIElERU5USUZJRUQgQlkge2NlcnRUeXBlcyAxfX1cbiAqICAgLS0gREVSLWVuY29kZWQgWC41MDkgY2VydGlmaWNhdGUgc3RvcmVkIGluIE9DVEVUIFNUUklOR1xuICpcbiAqIHNkc2lDZXJ0aWZpY2F0ZSBCQUctVFlQRSA6Oj0ge0lBNVN0cmluZyBJREVOVElGSUVEIEJZIHtjZXJ0VHlwZXMgMn19XG4gKiAtLSBCYXNlNjQtZW5jb2RlZCBTRFNJIGNlcnRpZmljYXRlIHN0b3JlZCBpbiBJQTVTdHJpbmdcbiAqXG4gKiBDZXJ0VHlwZXMgQkFHLVRZUEUgOjo9IHtcbiAqICAgeDUwOUNlcnRpZmljYXRlIHxcbiAqICAgc2RzaUNlcnRpZmljYXRlLFxuICogICAuLi4gLS0gRm9yIGZ1dHVyZSBleHRlbnNpb25zXG4gKiB9XG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbl9fd2VicGFja19yZXF1aXJlX18oNik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xICYgUEtJIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjMTIgQVBJXG52YXIgcDEyID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMTIgPSBmb3JnZS5wa2NzMTIgfHwge307XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsICAvLyBhIENvbnRlbnRJbmZvXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xuXG52YXIgcGZ4VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEZYJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEZYLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLCB7XG4gICAgbmFtZTogJ1BGWC5tYWNEYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnbWFjJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLCAgLy8gRGlnZXN0SW5mb1xuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSwgIC8vIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYWNBbGdvcml0aG0nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6ICdtYWNBbGdvcml0aG1QYXJhbWV0ZXJzJ1xuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYWNEaWdlc3QnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWNTYWx0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdtYWNTYWx0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5pdGVyYXRpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlOiAnbWFjSXRlcmF0aW9ucydcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHNhZmVCYWdWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTYWZlQmFnJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdiYWdJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdTYWZlQmFnLmJhZ1ZhbHVlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnYmFnVmFsdWUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYmFnQXR0cmlidXRlcydcbiAgfV1cbn07XG5cbnZhciBhdHRyaWJ1dGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdBdHRyaWJ1dGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0cklkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ29pZCdcbiAgfSwge1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0clZhbHVlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZTogJ3ZhbHVlcydcbiAgfV1cbn07XG5cbnZhciBjZXJ0QmFnVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydEJhZycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRCYWcuY2VydElkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAvKiBTbyBmYXIgd2Ugb25seSBzdXBwb3J0IFguNTA5IGNlcnRpZmljYXRlcyAod2hpY2ggYXJlIHdyYXBwZWQgaW5cbiAgICAgICBhbiBPQ1RFVCBTVFJJTkcsIGhlbmNlIGhhcmQgY29kZSB0aGF0IGhlcmUpLiAqL1xuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRCYWcuY2VydFZhbHVlWzBdJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydCdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBTZWFyY2ggU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSBmb3IgYmFncyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhlIHNlYXJjaCBjYW4gb3B0aW9uYWxseSBiZSBuYXJyb3dlZCBieSBhIGNlcnRhaW4gYmFnIHR5cGUuXG4gKlxuICogQHBhcmFtIHNhZmVDb250ZW50cyB0aGUgU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0gYXR0ck5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0gYXR0clZhbHVlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAqXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhZ3MuXG4gKi9cbmZ1bmN0aW9uIF9nZXRCYWdzQnlBdHRyaWJ1dGUoc2FmZUNvbnRlbnRzLCBhdHRyTmFtZSwgYXR0clZhbHVlLCBiYWdUeXBlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNhZmVDb250ZW50c1tpXS5zYWZlQmFncy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGJhZyA9IHNhZmVDb250ZW50c1tpXS5zYWZlQmFnc1tqXTtcbiAgICAgIGlmKGJhZ1R5cGUgIT09IHVuZGVmaW5lZCAmJiBiYWcudHlwZSAhPT0gYmFnVHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGJ5IGJhZyB0eXBlLCBubyBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgICBpZihhdHRyTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXS5pbmRleE9mKGF0dHJWYWx1ZSkgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbiBpbnRvIGEgUEZYIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byB1c2Ugc3RyaWN0IERFUiBkZWNvZGluZywgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIFBLQ1MjMTIgUEZYIG9iamVjdC5cbiAqL1xucDEyLnBrY3MxMkZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGhhbmRsZSBhcmdzXG4gIGlmKHR5cGVvZiBzdHJpY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBzdHJpY3Q7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHN0cmljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIFBGWCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwZnhWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHBmeCA9IHtcbiAgICB2ZXJzaW9uOiBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSxcbiAgICBzYWZlQ29udGVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBiYWdzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgdGhlIGF0dHJpYnV0ZXMgdG8gZmlsdGVyIGJ5OlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkXSB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkSGV4XSB0aGUgbG9jYWxLZXlJZCBpbiBoZXggdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbZnJpZW5kbHlOYW1lXSB0aGUgZnJpZW5kbHkgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtiYWdUeXBlXSBiYWcgdHlwZSB0byBuYXJyb3cgZWFjaCBhdHRyaWJ1dGUgc2VhcmNoIGJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgdHlwZSB0byBhbiBhcnJheSBvZiBtYXRjaGluZyBiYWdzIG9yLCBpZiBub1xuICAgICAqICAgICAgICAgICBhdHRyaWJ1dGUgd2FzIGdpdmVuIGJ1dCBhIGJhZyB0eXBlLCB0aGUgbWFwIGtleSB3aWxsIGJlIHRoZVxuICAgICAqICAgICAgICAgICBiYWcgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHZhciBydmFsID0ge307XG5cbiAgICAgIHZhciBsb2NhbEtleUlkO1xuICAgICAgaWYoJ2xvY2FsS2V5SWQnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZmlsdGVyLmxvY2FsS2V5SWQ7XG4gICAgICB9IGVsc2UgaWYoJ2xvY2FsS2V5SWRIZXgnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGZpbHRlci5sb2NhbEtleUlkSGV4KTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG9uIGJhZ1R5cGUgb25seVxuICAgICAgaWYobG9jYWxLZXlJZCA9PT0gdW5kZWZpbmVkICYmICEoJ2ZyaWVuZGx5TmFtZScgaW4gZmlsdGVyKSAmJlxuICAgICAgICAnYmFnVHlwZScgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJ2YWxbZmlsdGVyLmJhZ1R5cGVdID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCBudWxsLCBudWxsLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGxvY2FsS2V5SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydmFsLmxvY2FsS2V5SWQgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdsb2NhbEtleUlkJyxcbiAgICAgICAgICBsb2NhbEtleUlkLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG4gICAgICBpZignZnJpZW5kbHlOYW1lJyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgcnZhbC5mcmllbmRseU5hbWUgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdmcmllbmRseU5hbWUnLFxuICAgICAgICAgIGZpbHRlci5mcmllbmRseU5hbWUsIGZpbHRlci5iYWdUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmllbmRseU5hbWUgdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGJhZ3Mgd2l0aCBtYXRjaGluZyBmcmllbmRseU5hbWUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUZyaWVuZGx5TmFtZTogZnVuY3Rpb24oZnJpZW5kbHlOYW1lLCBiYWdUeXBlKSB7XG4gICAgICByZXR1cm4gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgJ2ZyaWVuZGx5TmFtZScsIGZyaWVuZGx5TmFtZSwgYmFnVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgbG9jYWxLZXlJZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxLZXlJZCB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUxvY2FsS2V5SWQ6IGZ1bmN0aW9uKGxvY2FsS2V5SWQsIGJhZ1R5cGUpIHtcbiAgICAgIHJldHVybiBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnbG9jYWxLZXlJZCcsIGxvY2FsS2V5SWQsIGJhZ1R5cGUpO1xuICAgIH1cbiAgfTtcblxuICBpZihjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSAhPT0gMykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUEtDUyMxMiBQRlggb2YgdmVyc2lvbiBvdGhlciB0aGFuIDMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpICE9PSBwa2kub2lkcy5kYXRhKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdPbmx5IFBLQ1MjMTIgUEZYIGluIHBhc3N3b3JkIGludGVncml0eSBtb2RlIHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci5vaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gIGlmKGRhdGEudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGRhdGEudHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIGF1dGhTYWZlIGNvbnRlbnQgZGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLicpO1xuICB9XG4gIGRhdGEgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpO1xuXG4gIC8vIGNoZWNrIGZvciBNQUNcbiAgaWYoY2FwdHVyZS5tYWMpIHtcbiAgICB2YXIgbWQgPSBudWxsO1xuICAgIHZhciBtYWNLZXlCeXRlcyA9IDA7XG4gICAgdmFyIG1hY0FsZ29yaXRobSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5tYWNBbGdvcml0aG0pO1xuICAgIHN3aXRjaChtYWNBbGdvcml0aG0pIHtcbiAgICBjYXNlIHBraS5vaWRzLnNoYTE6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDIwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5zaGEyNTY6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHBraS5vaWRzLnNoYTM4NDpcbiAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuc2hhNTEyOlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5tZDU6XG4gICAgICBtZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMTY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiB1c2VzIHVuc3VwcG9ydGVkIE1BQyBhbGdvcml0aG06ICcgKyBtYWNBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSBNQUMgKGl0ZXJhdGlvbnMgZGVmYXVsdCB0byAxKVxuICAgIHZhciBtYWNTYWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihjYXB0dXJlLm1hY1NhbHQpO1xuICAgIHZhciBtYWNJdGVyYXRpb25zID0gKCgnbWFjSXRlcmF0aW9ucycgaW4gY2FwdHVyZSkgP1xuICAgICAgcGFyc2VJbnQoZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGNhcHR1cmUubWFjSXRlcmF0aW9ucyksIDE2KSA6IDEpO1xuICAgIHZhciBtYWNLZXkgPSBwMTIuZ2VuZXJhdGVLZXkoXG4gICAgICBwYXNzd29yZCwgbWFjU2FsdCwgMywgbWFjSXRlcmF0aW9ucywgbWFjS2V5Qnl0ZXMsIG1kKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQobWQsIG1hY0tleSk7XG4gICAgbWFjLnVwZGF0ZShkYXRhLnZhbHVlKTtcbiAgICB2YXIgbWFjVmFsdWUgPSBtYWMuZ2V0TWFjKCk7XG4gICAgaWYobWFjVmFsdWUuZ2V0Qnl0ZXMoKSAhPT0gY2FwdHVyZS5tYWNEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkPycpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGRhdGEudmFsdWUsIHN0cmljdCwgcGFzc3dvcmQpO1xuICByZXR1cm4gcGZ4O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIFBLQ1MjNyBEYXRhLiBQS0NTIzcgKFJGQyAyMzE1KSBkZWZpbmVzIFwiRGF0YVwiIGFzIGFuIE9DVEVUIFNUUklORyxcbiAqIGJ1dCBpdCBpcyBzb21ldGltZXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaXMgY29tcG9zZWQvY29uc3RydWN0ZWQgb2YgY2h1bmtzLFxuICogZWFjaCBpdHMgb3duIE9DVEVUIFNUUklORy4gVGhpcyBpcyBCRVItZW5jb2RpbmcgdnMuIERFUi1lbmNvZGluZy4gVGhpc1xuICogZnVuY3Rpb24gdHJhbnNmb3JtcyB0aGlzIGNvcm5lci1jYXNlIGludG8gdGhlIHVzdWFsIHNpbXBsZSxcbiAqIG5vbi1jb21wb3NlZC9jb25zdHJ1Y3RlZCBPQ1RFVCBTVFJJTkcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgbW92ZWQgdG8gQVNOLjEgYXQgc29tZSBwb2ludCB0byBiZXR0ZXIgZGVhbCB3aXRoXG4gKiBtb3JlIEJFUi1lbmNvZGluZyBpc3N1ZXMsIHNob3VsZCB0aGV5IGFyaXNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIHRoZSBBU04uMSBEYXRhIG9iamVjdCB0byB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVQa2NzN0RhdGEoZGF0YSkge1xuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIFwiY2h1bmtlZFwiIGRhdGEgY29udGVudDogYW4gb2N0ZXQgc3RyaW5nIGNvbXBvc2VkXG4gIC8vIG9mIG90aGVyIG9jdGV0IHN0cmluZ3NcbiAgaWYoZGF0YS5jb21wb3NlZCB8fCBkYXRhLmNvbnN0cnVjdGVkKSB7XG4gICAgdmFyIHZhbHVlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUucHV0Qnl0ZXMoZGF0YS52YWx1ZVtpXS52YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEuY29tcG9zZWQgPSBkYXRhLmNvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgZGF0YS52YWx1ZSA9IHZhbHVlLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIFBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgKEJFUiBlbmNvZGVkKSBpbnRvIFBGWCBvYmplY3QuXG4gKlxuICogVGhlIEF1dGhlbnRpY2F0ZWRTYWZlIGlzIGEgQkVSLWVuY29kZWQgU0VRVUVOQ0UgT0YgQ29udGVudEluZm8uXG4gKlxuICogQHBhcmFtIHBmeCBUaGUgUEtDUyMxMiBQRlggb2JqZWN0IHRvIGZpbGwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aFNhZmUgQkVSLWVuY29kZWQgQXV0aGVudGljYXRlZFNhZmUuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlKHBmeCwgYXV0aFNhZmUsIHN0cmljdCwgcGFzc3dvcmQpIHtcbiAgYXV0aFNhZmUgPSBhc24xLmZyb21EZXIoYXV0aFNhZmUsIHN0cmljdCk7ICAvKiBhY3R1YWxseSBpdCdzIEJFUiBlbmNvZGVkICovXG5cbiAgaWYoYXV0aFNhZmUudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGF1dGhTYWZlLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgICBhdXRoU2FmZS5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBBdXRoZW50aWNhdGVkU2FmZSBleHBlY3RlZCB0byBiZSBhICcgK1xuICAgICAgJ1NFUVVFTkNFIE9GIENvbnRlbnRJbmZvJyk7XG4gIH1cblxuICBmb3IodmFyIGkgPSAwOyBpIDwgYXV0aFNhZmUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGVudEluZm8gPSBhdXRoU2FmZS52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIGNvbnRlbnRJbmZvIGFuZCBjYXB0dXJlIGRhdGFcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZighYXNuMS52YWxpZGF0ZShjb250ZW50SW5mbywgY29udGVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgQ29udGVudEluZm8uJyk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge1xuICAgICAgZW5jcnlwdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHNhZmVDb250ZW50cyA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gICAgc3dpdGNoKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSkpIHtcbiAgICBjYXNlIHBraS5vaWRzLmRhdGE6XG4gICAgICBpZihkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICAgICAgZGF0YS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIFNhZmVDb250ZW50cyBEYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuJyk7XG4gICAgICB9XG4gICAgICBzYWZlQ29udGVudHMgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5lbmNyeXB0ZWREYXRhOlxuICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgb2JqLmVuY3J5cHRlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzEyIGNvbnRlbnRUeXBlLicpO1xuICAgICAgZXJyb3IuY29udGVudFR5cGUgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgb2JqLnNhZmVCYWdzID0gX2RlY29kZVNhZmVDb250ZW50cyhzYWZlQ29udGVudHMsIHN0cmljdCwgcGFzc3dvcmQpO1xuICAgIHBmeC5zYWZlQ29udGVudHMucHVzaChvYmopO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCBQS0NTIzcgRW5jcnlwdGVkRGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIGRhdGEgQVNOLjEgZW5jb2RlZCBFbmNyeXB0ZWRDb250ZW50SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHVzZXItcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHJldHVybiBUaGUgZGVjcnlwdGVkIFNhZmVDb250ZW50cyAoQVNOLjEgb2JqZWN0KS5cbiAqL1xuZnVuY3Rpb24gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShcbiAgICBkYXRhLCBmb3JnZS5wa2NzNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEVuY3J5cHRlZENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLmRhdGEpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAnUEtDUyMxMiBFbmNyeXB0ZWRDb250ZW50SW5mbyBDb250ZW50VHlwZSBpcyBub3QgRGF0YS4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pO1xuICB2YXIgY2lwaGVyID0gcGtpLnBiZS5nZXRDaXBoZXIob2lkLCBjYXB0dXJlLmVuY1BhcmFtZXRlciwgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkQ29udGVudEFzbjEgPSBfZGVjb2RlUGtjczdEYXRhKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudEFzbjEpO1xuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW5jcnlwdGVkQ29udGVudEFzbjEudmFsdWUpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoIWNpcGhlci5maW5pc2goKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgUEtDUyMxMiBTYWZlQ29udGVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNhZmVDb250ZW50cyAoQkVSLWVuY29kZWQpIGludG8gYXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKlxuICogVGhlIHNhZmVDb250ZW50cyBpcyBhIEJFUi1lbmNvZGVkIFNFUVVFTkNFIE9GIFNhZmVCYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNhZmVDb250ZW50cyBCRVItZW5jb2RlZCBzYWZlQ29udGVudHMuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGlmIHN0cmljdCBhbmQgbm8gc2FmZSBjb250ZW50cywgcmV0dXJuIGVtcHR5IHNhZmVzXG4gIGlmKCFzdHJpY3QgJiYgc2FmZUNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGFjdHVhbGx5IGl0J3MgQkVSLWVuY29kZWRcbiAgc2FmZUNvbnRlbnRzID0gYXNuMS5mcm9tRGVyKHNhZmVDb250ZW50cywgc3RyaWN0KTtcblxuICBpZihzYWZlQ29udGVudHMudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgc2FmZUNvbnRlbnRzLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgIHNhZmVDb250ZW50cy5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdQS0NTIzEyIFNhZmVDb250ZW50cyBleHBlY3RlZCB0byBiZSBhIFNFUVVFTkNFIE9GIFNhZmVCYWcuJyk7XG4gIH1cblxuICB2YXIgcmVzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzYWZlQ29udGVudHMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2FmZUJhZyA9IHNhZmVDb250ZW50cy52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIFNhZmVCYWcgYW5kIGNhcHR1cmUgZGF0YVxuICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGlmKCFhc24xLnZhbGlkYXRlKHNhZmVCYWcsIHNhZmVCYWdWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgU2FmZUJhZy4nKTtcbiAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8qIENyZWF0ZSBiYWcgb2JqZWN0IGFuZCBwdXNoIHRvIHJlc3VsdCBhcnJheS4gKi9cbiAgICB2YXIgYmFnID0ge1xuICAgICAgdHlwZTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmJhZ0lkKSxcbiAgICAgIGF0dHJpYnV0ZXM6IF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGNhcHR1cmUuYmFnQXR0cmlidXRlcylcbiAgICB9O1xuICAgIHJlcy5wdXNoKGJhZyk7XG5cbiAgICB2YXIgdmFsaWRhdG9yLCBkZWNvZGVyO1xuICAgIHZhciBiYWdBc24xID0gY2FwdHVyZS5iYWdWYWx1ZS52YWx1ZVswXTtcbiAgICBzd2l0Y2goYmFnLnR5cGUpIHtcbiAgICAgIGNhc2UgcGtpLm9pZHMucGtjczhTaHJvdWRlZEtleUJhZzpcbiAgICAgICAgLyogYmFnQXNuMSBoYXMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbywgd2hpY2ggd2UgbmVlZCB0byBkZWNyeXB0LlxuICAgICAgICAgICBBZnRlcndhcmRzIHdlIGNhbiBoYW5kbGUgaXQgbGlrZSBhIGtleUJhZyxcbiAgICAgICAgICAgd2hpY2ggaXMgYSBQcml2YXRlS2V5SW5mby4gKi9cbiAgICAgICAgYmFnQXNuMSA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYmFnQXNuMSwgcGFzc3dvcmQpO1xuICAgICAgICBpZihiYWdBc24xID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1VuYWJsZSB0byBkZWNyeXB0IFBLQ1MjOCBTaHJvdWRlZEtleUJhZywgd3JvbmcgcGFzc3dvcmQ/Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgcGtpLm9pZHMua2V5QmFnOlxuICAgICAgICAvKiBBIFBLQ1MjMTIga2V5QmFnIGlzIGEgc2ltcGxlIFByaXZhdGVLZXlJbmZvIGFzIHVuZGVyc3Rvb2QgYnkgb3VyXG4gICAgICAgICAgIFBLSSBtb2R1bGUsIGhlbmNlIHdlIGRvbid0IGhhdmUgdG8gZG8gdmFsaWRhdGlvbi9jYXB0dXJpbmcgaGVyZSxcbiAgICAgICAgICAganVzdCBwYXNzIHdoYXQgd2UgYWxyZWFkeSBnb3QuICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmFnLmtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoYmFnQXNuMSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB1bmtub3duIGtleSB0eXBlLCBwYXNzIGFzbjEgdmFsdWVcbiAgICAgICAgICBiYWcua2V5ID0gbnVsbDtcbiAgICAgICAgICBiYWcuYXNuMSA9IGJhZ0FzbjE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7ICAvKiBOb3RoaW5nIG1vcmUgdG8gZG8uICovXG5cbiAgICAgIGNhc2UgcGtpLm9pZHMuY2VydEJhZzpcbiAgICAgICAgLyogQSBQS0NTIzEyIGNlcnRCYWcgY2FuIHdyYXAgYm90aCBYLjUwOSBhbmQgc2RzaSBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgICAgIFRoZXJlZm9yZSBwdXQgdGhlIFNhZmVCYWcgY29udGVudCB0aHJvdWdoIGFub3RoZXIgdmFsaWRhdG9yIHRvXG4gICAgICAgICAgIGNhcHR1cmUgdGhlIGZpZWxkcy4gIEFmdGVyd2FyZHMgY2hlY2sgJiBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICAgICAgdmFsaWRhdG9yID0gY2VydEJhZ1ZhbGlkYXRvcjtcbiAgICAgICAgZGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpICE9PSBwa2kub2lkcy54NTA5Q2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIGNlcnRpZmljYXRlIHR5cGUsIG9ubHkgWC41MDkgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRJZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cnVlPXByb2R1Y2UgY2VydCBoYXNoXG4gICAgICAgICAgdmFyIGNlcnRBc24xID0gYXNuMS5mcm9tRGVyKGNhcHR1cmUuY2VydCwgc3RyaWN0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFnLmNlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShjZXJ0QXNuMSwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBjZXJ0IHR5cGUsIHBhc3MgYXNuMSB2YWx1ZVxuICAgICAgICAgICAgYmFnLmNlcnQgPSBudWxsO1xuICAgICAgICAgICAgYmFnLmFzbjEgPSBjZXJ0QXNuMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBLQ1MjMTIgU2FmZUJhZyB0eXBlLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBiYWcudHlwZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgU2FmZUJhZyB2YWx1ZSAoaS5lLiBDZXJ0QmFnLCBldGMuKSBhbmQgY2FwdHVyZSBkYXRhIGlmIG5lZWRlZC4gKi9cbiAgICBpZih2YWxpZGF0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICFhc24xLnZhbGlkYXRlKGJhZ0FzbjEsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyICcgKyB2YWxpZGF0b3IubmFtZSk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvKiBDYWxsIGRlY29kZXIgZnVuY3Rpb24gZnJvbSBhYm92ZSB0byBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICBkZWNvZGVyKCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNFVCBPRiBQS0NTMTJBdHRyaWJ1dGUgaW50byBKYXZhU2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIChBU04uMSBvYmplY3QpLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUJhZ0F0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZGVjb2RlZEF0dHJzID0ge307XG5cbiAgaWYoYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZighYXNuMS52YWxpZGF0ZShhdHRyaWJ1dGVzW2ldLCBhdHRyaWJ1dGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyIEJhZ0F0dHJpYnV0ZS4nKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5vaWQpO1xuICAgICAgaWYocGtpLm9pZHNbb2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlLCBpZ25vcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0gPSBbXTtcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjYXB0dXJlLnZhbHVlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0ucHVzaChjYXB0dXJlLnZhbHVlc1tqXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZWRBdHRycztcbn1cblxuLyoqXG4gKiBXcmFwcyBhIHByaXZhdGUga2V5IGFuZCBjZXJ0aWZpY2F0ZSBpbiBhIFBLQ1MjMTIgUEZYIHdyYXBwZXIuIElmIGFcbiAqIHBhc3N3b3JkIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHByaXZhdGUga2V5IHdpbGwgYmUgZW5jcnlwdGVkLlxuICpcbiAqIEFuIGVudGlyZSBjZXJ0aWZpY2F0ZSBjaGFpbiBtYXkgYWxzbyBiZSBpbmNsdWRlZC4gVG8gZG8gdGhpcywgcGFzc1xuICogYW4gYXJyYXkgZm9yIHRoZSBcImNlcnRcIiBwYXJhbWV0ZXIgd2hlcmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlIGlzXG4gKiB0aGUgb25lIHRoYXQgaXMgcGFpcmVkIHdpdGggdGhlIHByaXZhdGUga2V5IGFuZCBlYWNoIHN1YnNlcXVlbnQgb25lXG4gKiB2ZXJpZmllcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgY2VydGlmaWNhdGVzIG1heSBiZSBpbiBQRU0gZm9ybWF0IG9yXG4gKiBoYXZlIGJlZW4gYWxyZWFkeSBwYXJzZWQgYnkgRm9yZ2UuXG4gKlxuICogQHRvZG8gaW1wbGVtZW50IHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHRoZSB3aG9sZSBwYWNrYWdlXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgKG1heSBiZSBhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMgaW4gb3JkZXJcbiAqICAgICAgICAgIHRvIHNwZWNpZnkgYSBjZXJ0aWZpY2F0ZSBjaGFpbikuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHVzZU1hYyB0cnVlIHRvIGluY2x1ZGUgYSBNQUMsIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICAgICAgIGxvY2FsS2V5SWQgdGhlIGxvY2FsIGtleSBJRCB0byB1c2UsIGluIGhleC5cbiAqICAgICAgICAgIGZyaWVuZGx5TmFtZSB0aGUgZnJpZW5kbHkgbmFtZSB0byB1c2UuXG4gKiAgICAgICAgICBnZW5lcmF0ZUxvY2FsS2V5SWQgdHJ1ZSB0byBnZW5lcmF0ZSBhIHJhbmRvbSBsb2NhbCBrZXkgSUQsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzEyIFBGWCBBU04uMSBvYmplY3QuXG4gKi9cbnAxMi50b1BrY3MxMkFzbjEgPSBmdW5jdGlvbihrZXksIGNlcnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgb3B0aW9ucy5lbmNBbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIGlmKCEoJ3VzZU1hYycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnVzZU1hYyA9IHRydWU7XG4gIH1cbiAgaWYoISgnbG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmxvY2FsS2V5SWQgPSBudWxsO1xuICB9XG4gIGlmKCEoJ2dlbmVyYXRlTG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmdlbmVyYXRlTG9jYWxLZXlJZCA9IHRydWU7XG4gIH1cblxuICB2YXIgbG9jYWxLZXlJZCA9IG9wdGlvbnMubG9jYWxLZXlJZDtcbiAgdmFyIGJhZ0F0dHJzO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhsb2NhbEtleUlkKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZ2VuZXJhdGVMb2NhbEtleUlkKSB7XG4gICAgLy8gdXNlIFNIQS0xIG9mIHBhaXJlZCBjZXJ0LCBpZiBhdmFpbGFibGVcbiAgICBpZihjZXJ0KSB7XG4gICAgICB2YXIgcGFpcmVkQ2VydCA9IGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSA/IGNlcnRbMF0gOiBjZXJ0O1xuICAgICAgaWYodHlwZW9mIHBhaXJlZENlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhaXJlZENlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tUGVtKHBhaXJlZENlcnQpO1xuICAgICAgfVxuICAgICAgdmFyIHNoYTEgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgc2hhMS51cGRhdGUoYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEocGFpcmVkQ2VydCkpLmdldEJ5dGVzKCkpO1xuICAgICAgbG9jYWxLZXlJZCA9IHNoYTEuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIHVzaW5nIFNIQS0xIG9mIHB1YmxpYyBrZXkgKHdoaWNoIGNhbiBiZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGZyb20gcHJpdmF0ZSBrZXkgY29tcG9uZW50cyksIHNlZTogY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyXG4gICAgICAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXNcbiAgICAgIGxvY2FsS2V5SWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRycyA9IFtdO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgYXR0cnMucHVzaChcbiAgICAgIC8vIGxvY2FsS2V5SURcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYXR0cklkXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmxvY2FsS2V5SWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICBsb2NhbEtleUlkKVxuICAgICAgICBdKVxuICAgICAgXSkpO1xuICB9XG4gIGlmKCdmcmllbmRseU5hbWUnIGluIG9wdGlvbnMpIHtcbiAgICBhdHRycy5wdXNoKFxuICAgICAgLy8gZnJpZW5kbHlOYW1lXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGF0dHJJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5mcmllbmRseU5hbWUpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CTVBTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9ucy5mcmllbmRseU5hbWUpXG4gICAgICAgIF0pXG4gICAgICBdKSk7XG4gIH1cblxuICBpZihhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgYmFnQXR0cnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgYXR0cnMpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBjb250ZW50cyBmb3IgQXV0aGVudGljYXRlZFNhZmVcbiAgdmFyIGNvbnRlbnRzID0gW107XG5cbiAgLy8gY3JlYXRlIHNhZmUgYmFnKHMpIGZvciBjZXJ0aWZpY2F0ZSBjaGFpblxuICB2YXIgY2hhaW4gPSBbXTtcbiAgaWYoY2VydCAhPT0gbnVsbCkge1xuICAgIGlmKGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSkge1xuICAgICAgY2hhaW4gPSBjZXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFpbiA9IFtjZXJ0XTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2VydFNhZmVCYWdzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7ICsraSkge1xuICAgIC8vIGNvbnZlcnQgY2VydCBmcm9tIFBFTSBhcyBuZWNlc3NhcnlcbiAgICBjZXJ0ID0gY2hhaW5baV07XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBTYWZlQmFnXG4gICAgdmFyIGNlcnRCYWdBdHRycyA9IChpID09PSAwKSA/IGJhZ0F0dHJzIDogdW5kZWZpbmVkO1xuICAgIHZhciBjZXJ0QXNuMSA9IHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KTtcbiAgICB2YXIgY2VydFNhZmVCYWcgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5jZXJ0QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gQ2VydEJhZ1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGNlcnRJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLng1MDlDZXJ0aWZpY2F0ZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICAvLyBjZXJ0VmFsdWUgKHg1MDlDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRBc24xKS5nZXRCeXRlcygpKVxuICAgICAgICAgICAgXSldKV0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgY2VydEJhZ0F0dHJzXG4gICAgICBdKTtcbiAgICBjZXJ0U2FmZUJhZ3MucHVzaChjZXJ0U2FmZUJhZyk7XG4gIH1cblxuICBpZihjZXJ0U2FmZUJhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBjZXJ0U2FmZUNvbnRlbnRzID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBjZXJ0U2FmZUJhZ3MpO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIgY2VydENJID1cbiAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEudG9EZXIoY2VydFNhZmVDb250ZW50cykuZ2V0Qnl0ZXMoKSlcbiAgICAgICAgXSlcbiAgICAgIF0pO1xuICAgIGNvbnRlbnRzLnB1c2goY2VydENJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBzYWZlIGNvbnRlbnRzIGZvciBwcml2YXRlIGtleVxuICB2YXIga2V5QmFnID0gbnVsbDtcbiAgaWYoa2V5ICE9PSBudWxsKSB7XG4gICAgLy8gU2FmZUJhZ1xuICAgIHZhciBwa0FzbjEgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEoa2V5KSk7XG4gICAgaWYocGFzc3dvcmQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vIGVuY3J5cHRpb25cbiAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMua2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa0FzbjFcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGJhZ0F0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICAgICAgICBiYWdBdHRyc1xuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuY3J5cHRlZCBQcml2YXRlS2V5SW5mb1xuICAgICAga2V5QmFnID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa2kuZW5jcnlwdFByaXZhdGVLZXlJbmZvKHBrQXNuMSwgcGFzc3dvcmQsIG9wdGlvbnMpXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgYmFnQXR0cnNcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBrZXlTYWZlQ29udGVudHMgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW2tleUJhZ10pO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIga2V5Q0kgPVxuICAgICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAvLyBPSUQgZm9yIHRoZSBjb250ZW50IHR5cGUgaXMgJ2RhdGEnXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS50b0RlcihrZXlTYWZlQ29udGVudHMpLmdldEJ5dGVzKCkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICBjb250ZW50cy5wdXNoKGtleUNJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBBdXRoZW50aWNhdGVkU2FmZSBieSBzdHJpbmdpbmcgdG9nZXRoZXIgdGhlIGNvbnRlbnRzXG4gIHZhciBzYWZlID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgY29udGVudHMpO1xuXG4gIHZhciBtYWNEYXRhO1xuICBpZihvcHRpb25zLnVzZU1hYykge1xuICAgIC8vIE1hY0RhdGFcbiAgICB2YXIgc2hhMSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKFxuICAgICAgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG9wdGlvbnMuc2FsdFNpemUpKTtcbiAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIC8vIDE2MC1iaXQga2V5XG4gICAgdmFyIGtleSA9IHAxMi5nZW5lcmF0ZUtleShwYXNzd29yZCwgbWFjU2FsdCwgMywgY291bnQsIDIwKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQoc2hhMSwga2V5KTtcbiAgICBtYWMudXBkYXRlKGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgIG1hY0RhdGEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBtYWMgRGlnZXN0SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBkaWdlc3RBbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIGFsZ29yaXRobSA9IFNIQS0xXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5zaGExKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzID0gTnVsbFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gZGlnZXN0XG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsIG1hY1ZhbHVlLmdldEJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIC8vIG1hY1NhbHQgT0NURVQgU1RSSU5HXG4gICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIG1hY1NhbHQuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBpdGVyYXRpb25zIElOVEVHRVIgKFhYWDogT25seSBzdXBwb3J0IGNvdW50IDwgNjU1MzYpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0Rlcihjb3VudCkuZ2V0Qnl0ZXMoKVxuICAgICAgKVxuICAgIF0pO1xuICB9XG5cbiAgLy8gUEZYXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMykuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gY29udGVudFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgIGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSlcbiAgICAgIF0pXG4gICAgXSksXG4gICAgbWFjRGF0YVxuICBdKTtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucDEyLmdlbmVyYXRlS2V5ID0gZm9yZ2UucGJlLmdlbmVyYXRlUGtjczEyS2V5O1xuXG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gc2hvcnRjdXQgZm9yIEFTTi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgUEtDUyM3IEFQSVxudmFyIHA3diA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtjczdhc24xID0gZm9yZ2UucGtjczdhc24xIHx8IHt9O1xuZm9yZ2UucGtjczcgPSBmb3JnZS5wa2NzNyB8fCB7fTtcbmZvcmdlLnBrY3M3LmFzbjEgPSBwN3Y7XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uQ29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY29udGVudCdcbiAgfV1cbn07XG5wN3YuY29udGVudEluZm9WYWxpZGF0b3IgPSBjb250ZW50SW5mb1ZhbGlkYXRvcjtcblxudmFyIGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50VHlwZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdjb250ZW50VHlwZSdcbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtLnBhcmFtZXRlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY1BhcmFtZXRlcidcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvLmVuY3J5cHRlZENvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICAvKiBUaGUgUEtDUyM3IHN0cnVjdHVyZSBvdXRwdXQgYnkgT3BlblNTTCBzb21ld2hhdCBkaWZmZXJzIGZyb20gd2hhdFxuICAgICAqIG90aGVyIGltcGxlbWVudGF0aW9ucyBkbyBnZW5lcmF0ZS5cbiAgICAgKlxuICAgICAqIE9wZW5TU0wgZ2VuZXJhdGVzIGEgc3RydWN0dXJlIGxpa2UgdGhpczpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdXG4gICAgICogICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFdoZXJlYXMgb3RoZXIgaW1wbGVtZW50YXRpb25zIChhbmQgdGhpcyBQS0NTIzcgbW9kdWxlKSBnZW5lcmF0ZTpcbiAgICAgKiBTRVFVRU5DRSB7XG4gICAgICogICAgLi4uXG4gICAgICogICAgWzBdIHtcbiAgICAgKiAgICAgICBPQ1RFVCBTVFJJTkdcbiAgICAgKiAgICAgICAgICAyNiBEQSA2NyBEMiAxNyA5QyA0NSAzQyBCMSAyQSBBOCA1OSAyRiAyOSAzMyAzOFxuICAgICAqICAgICAgICAgIEMzIEMzIERGIDg2IDcxIDc0IDdBIDE5IDlGIDQwIEQwIDI5IEJFIDg1IDkwIDQ1XG4gICAgICogICAgICAgICAgLi4uXG4gICAgICogICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIHN1cHBvcnQgYm90aCwgd2UganVzdCBjYXB0dXJlIHRoZSBjb250ZXh0IHNwZWNpZmljXG4gICAgICogZmllbGQgaGVyZS4gIFRoZSBPQ1RFVCBTVFJJTkcgYml0IGlzIHJlbW92ZWQgYmVsb3cuXG4gICAgICovXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZENvbnRlbnQnLFxuICAgIGNhcHR1cmVBc24xOiAnZW5jcnlwdGVkQ29udGVudEFzbjEnXG4gIH1dXG59O1xuXG5wN3YuZW52ZWxvcGVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VudmVsb3BlZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdFbnZlbG9wZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5SZWNpcGllbnRJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdyZWNpcGllbnRJbmZvcydcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxucDd2LmVuY3J5cHRlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9XS5jb25jYXQoZW5jcnlwdGVkQ29udGVudEluZm9WYWxpZGF0b3IpXG59O1xuXG52YXIgc2lnbmVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU2lnbmVySW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZGlnZXN0QWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RQYXJhbWV0ZXInLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmVBbGdvcml0aG0nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby5lbmNyeXB0ZWREaWdlc3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdzaWduYXR1cmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVySW5mby51bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ3VuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXMnXG4gIH1dXG59O1xuXG5wN3Yuc2lnbmVkRGF0YVZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lZERhdGEnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5EaWdlc3RBbGdvcml0aG1zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2RpZ2VzdEFsZ29yaXRobXMnXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLFxuICB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0ZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5DZXJ0aWZpY2F0ZVJldm9jYXRpb25MaXN0cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY3JscydcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLlNpZ25lckluZm9zJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjYXB0dXJlOiAnc2lnbmVySW5mb3MnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbc2lnbmVyVmFsaWRhdG9yXVxuICB9XVxufTtcblxucDd2LnJlY2lwaWVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdSZWNpcGllbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnaXNzdWVyJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnc2VyaWFsJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNBbGdvcml0aG0nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY0tleSdcbiAgfV1cbn07XG5cblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKlxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbl9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZiA9IGZvcmdlLm1nZiB8fCB7fTtcbmZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMTtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gTUdGMS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZm9yZ2UubWdmID0gZm9yZ2UubWdmIHx8IHt9O1xudmFyIG1nZjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMSA9IGZvcmdlLm1nZjEgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1HRjEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IEFQSSB0byB1c2UgKGVnOiBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpKS5cbiAqXG4gKiBAcmV0dXJuIGEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqL1xubWdmMS5jcmVhdGUgPSBmdW5jdGlvbihtZCkge1xuICB2YXIgbWdmID0ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG1hc2sgb2Ygc3BlY2lmaWVkIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIFRoZSBzZWVkIGZvciBtYXNrIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIG1hc2tMZW4gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBtYXNrLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihzZWVkLCBtYXNrTGVuKSB7XG4gICAgICAvKiAyLiBMZXQgVCBiZSB0aGUgZW1wdHkgb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgdmFyIHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgICAgIC8qIDMuIEZvciBjb3VudGVyIGZyb20gMCB0byBjZWlsKG1hc2tMZW4gLyBoTGVuKSwgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwobWFza0xlbiAvIG1kLmRpZ2VzdExlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLyogYS4gQ29udmVydCBjb3VudGVyIHRvIGFuIG9jdGV0IHN0cmluZyBDIG9mIGxlbmd0aCA0IG9jdGV0cyAqL1xuICAgICAgICB2YXIgYyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgYy5wdXRJbnQzMihpKTtcblxuICAgICAgICAvKiBiLiBDb25jYXRlbmF0ZSB0aGUgaGFzaCBvZiB0aGUgc2VlZCBtZ2ZTZWVkIGFuZCBDIHRvIHRoZSBvY3RldFxuICAgICAgICAgKiBzdHJpbmcgVDogKi9cbiAgICAgICAgbWQuc3RhcnQoKTtcbiAgICAgICAgbWQudXBkYXRlKHNlZWQgKyBjLmdldEJ5dGVzKCkpO1xuICAgICAgICB0LnB1dEJ1ZmZlcihtZC5kaWdlc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIE91dHB1dCB0aGUgbGVhZGluZyBtYXNrTGVuIG9jdGV0cyBvZiBUIGFzIHRoZSBvY3RldCBzdHJpbmcgbWFzay4gKi9cbiAgICAgIHQudHJ1bmNhdGUodC5sZW5ndGgoKSAtIG1hc2tMZW4pO1xuICAgICAgcmV0dXJuIHQuZ2V0Qnl0ZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG1nZjtcbn07XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9